import os, json, time, threading, requests, asyncio
import datetime as dt 
import aiohttp
from discord.ext import commands, tasks
from gtts import gTTS
import edge_tts
from flask import Flask, request, jsonify, render_template, redirect, session
from typing import Literal
import time  # <--- Ye zarur add karna upar
import threading
import os
import requests

import discord
from discord import app_commands
from discord import ui   # â¬…ï¸ ye add karo
from discord.ext import commands, tasks

from deep_translator import GoogleTranslator
from concurrent.futures import ThreadPoolExecutor
import urllib.parse  # âœ… YE WALA MISSING THA (Ab laga diya)
from business_config import BUSINESSES, MARKET_EVENTS, ILLEGAL_BIZ, MANAGER_PRICES
from flask import request, redirect, url_for    

active_web_matches = {}

# --- HELPER: GET CURRENT MARKET EVENT ---
def get_current_event():
    # Har 4 ghante me event change hoga (Time based math)
    hour_block = int(time.time() / (4 * 3600)) 
    event_index = hour_block % len(MARKET_EVENTS)
    return MARKET_EVENTS[event_index]

# --- HELPER: RAID CHECK ---
def check_police_raid(user_heat, user_id, current_stock):
    # Agar Heat 80% se zyada hai, to 30% chance hai RAID ka
    if user_heat > 80 and random.random() < 0.3:
        loss = int(current_stock * 0.5) # 50% Maal zabt
        # Database se stock kaat lo (Logic neeche routes me use hoga)
        return {"raided": True, "loss": loss, "msg": f"ğŸš” POLICE RAID! They seized ${loss:,} worth of stock!"}
    return {"raided": False, "msg": ""}

# --- ğŸ›¡ï¸ SECURITY SYSTEM SETUP ---
authorized_guilds_cache = set()

# Ye function bot start hone par chalega aur saare allowed servers load karega
async def load_authorized_servers():
    global authorized_guilds_cache
    try:
        print("[AUTH] Loading Authorized Servers...")
        # Database se saari IDs nikalo
        data = supabase.table("authorized_servers").select("server_id").execute().data
        
        # Unhe set me convert karo (Fast checking ke liye)
        authorized_guilds_cache = {int(row['server_id']) for row in data}
        
        print(f"âœ… Loaded {len(authorized_guilds_cache)} Authorized Servers.")
    except Exception as e:
        print(f"âš ï¸ Auth Load Error: {e}")

# IDs (Hardcoded as per your portal)
CLIENT_ID = "1451451135813746700"
CLIENT_SECRET = os.getenv("DISCORD_CLIENT_SECRET")
REDIRECT_URI = "https://testingbot-8pb1.onrender.com/callback"
WEBSITE_URL = "https://testingbot-8pb1.onrender.com" 

# --- LOAN SYSTEM SETTINGS ---
MAX_LOAN = 10000000  # 10 Million Limit
INTEREST_LIMIT = 100000  # 300k se upar interest lagega
LOAN_DURATION = 24       # 24 Hours time limit

# --- ğŸ”’ GLOBAL CHECK: ACCOUNT SEIZED (Updated) ---
import asyncio
from discord import app_commands

# --- ğŸ”’ GLOBAL CHECK: ACCOUNT SEIZED (100% ASYNC FIXED) ---
def check_seized():
    async def predicate(interaction: discord.Interaction) -> bool:
        user_id = str(interaction.user.id)

        # ğŸ›¡ï¸ 1. STAFF IMMUNITY (Top Staff Bypass)
        if is_user_staff(user_id):
            return True 

        # ğŸ›‘ 2. SUPABASE CHECK
        try:
            # ğŸ› ï¸ FIX 1: Direct execute() ko hatakar await db_call() lagaya!
            res = await db_call(lambda: db.supabase.table("economy").select("is_seized").eq("user_id", user_id).execute())
            
            # Agar account seized hai
            if res.data and res.data[0].get('is_seized', False):
                raise app_commands.CheckFailure("seized_account")
                
            return True 

        except app_commands.CheckFailure:
            # Agar humne khud error raise kiya hai (Seized wala), toh use pass karo
            raise

        except Exception as e:
            # ğŸ› ï¸ FIX 2: time.sleep() hata kar asyncio.sleep() lagaya!
            print(f"âš ï¸ DB ERROR (Cooling down 5s): {e}")
            await asyncio.sleep(5) # Bot freeze nahi hoga, sirf yeh check wait karega!
            return True # Error aane par user ko block mat karo, khelne do
            
    return app_commands.check(predicate)


# --- DATABASE / STORAGE SIMULATION ---

loans = {}          # Active loans store karne ke liye
loan_cooldowns = {} # Cooldown track karne ke liye (User ID: Timestamp)

# Agar aapke paas users ka data load karne ka system hai to thik hai,
# warna ye dummy dictionary hai error na aane ke liye:
if 'users' not in globals():
    users = {} 
    

# ================== ğŸ›ï¸ SHOP ITEMS (FULL LIST) ==================
SHOP_ITEMS = {
    # Special Items
    "izzat":      {"name": "ğŸ§¼ Izzat Wapasi", "price": 150000, "type": "special"},
    "landmine":   {"name": "ğŸ’£ Landmine", "price": 50000, "type": "item"},
    "life":       {"name": "ğŸ’– Extra Life", "price": 75000, "type": "item"},
    "cctv":       {"name": "ğŸ“¹ CCTV Camera", "price": 9000000, "type": "item"},
        # --- ğŸ”¥ NEW HEIST ITEMS ---
    "master_key":   {"name": "ğŸ—ï¸ Master Key", "price": 5000000, "type": "item"},
    "guard_dog":    {"name": "ğŸ• Guard Dog", "price": 10000000, "type": "item"},
    "nuclear_bomb": {"name": "â˜¢ï¸ Nuclear Bomb", "price": 50000000, "type": "item"},
    

    # ğŸ‘‡ FIGHT CLUB ITEMS (Inhe list me add karo) ğŸ‘‡
    "knife":      {"name": "ğŸ”ª Combat Knife", "price": 50000, "type": "item"},
    "armor":      {"name": "ğŸ›¡ï¸ Kevlar Vest", "price": 80000, "type": "item"},
    "steroids":   {"name": "ğŸ’‰ Steroids", "price": 20000, "type": "item"},

    # VIP Access
    "vip_10m":    {"name": "âš¡ 10 Mins Escape", "price": 200000, "type": "vip", "min": 10},
    "vip_1h":     {"name": "ğŸ‘‘ 1 Hour VIP", "price": 10000000, "type": "vip", "min": 60},
    "vip_6h":     {"name": "ğŸ›¡ï¸ 6 Hours VIP", "price": 30000000, "type": "vip", "min": 360},
    "vip_1d":     {"name": "ğŸ’ 1 Day VIP", "price": 50000000, "type": "vip", "min": 1440},
    "vip_3d":     {"name": "ğŸ—“ï¸ 3 Days VIP", "price": 120000000, "type": "vip", "min": 4320},
    "vip_1w":     {"name": "ğŸ”¥ 1 Week VIP", "price": 250000000, "type": "vip", "min": 10080},
    "vip_life":   {"name": "â™¾ï¸ Lifetime VIP", "price": 700000000000, "type": "vip", "life": True},

    # Roles (Emoji hatake role name match karega)
    "hitman":     {"name": "ğŸ—¡ï¸ Hitman", "price": 50000000, "type": "role"},
    "hacker":     {"name": "ğŸ’» Hacker", "price": 100000000, "type": "role"},
    "gambler":    {"name": "ğŸ² Gambler", "price": 200000000, "type": "role"},
    "peaky":      {"name": "ğŸš¬ Peaky Blinders", "price": 300000000, "type": "role"},
    "shadow":     {"name": "ğŸ‘» Shadow", "price": 400000000, "type": "role"},
    "yakuza":     {"name": "ğŸ‘º Yakuza", "price": 500000000, "type": "role"},
    "mafia":      {"name": "ğŸ•¶ï¸ Mafia Boss", "price": 1000000000, "type": "role"},
    "king":       {"name": "ğŸ‘‘ Kingpin", "price": 5000000000, "type": "role"},
    "oil":        {"name": "ğŸ›¢ï¸ Oil Prince", "price": 100000000000, "type": "role"},
    "god":        {"name": "ğŸ› Server God", "price": 10000000000000, "type": "role"},
    "immortal":   {"name": "ğŸ§Ÿ Immortal", "price": 5000000000000, "type": "role"},

    # ğŸ‘‡ VERIFICATION SECTION (NEW) ğŸ‘‡
    "verify_1d":  {"name": "âœ… Verify (1 Day)",   "price": 50000000,        "type": "verification", "duration": 86400},
    "verify_3d":  {"name": "âœ… Verify (3 Days)",  "price": 150000000,       "type": "verification", "duration": 259200},
    "verify_5d":  {"name": "âœ… Verify (5 Days)",  "price": 500000000,       "type": "verification", "duration": 432000},
    "verify_1w":  {"name": "âœ… Verify (1 Week)",  "price": 1000000000,      "type": "verification", "duration": 604800},
    "verify_10d": {"name": "âœ… Verify (10 Days)", "price": 1500000000,      "type": "verification", "duration": 864000},
    "verify_15d": {"name": "âœ… Verify (15 Days)", "price": 3000000000,      "type": "verification", "duration": 1296000},
    "verify_1m":  {"name": "âœ… Verify (1 Month)", "price": 10000000000000,  "type": "verification", "duration": 2592000}, # 1000 Billion
    "verify_perm": {"name": "â™¾ï¸ Verify (Lifetime)","price": 100000000000000, "type": "verification", "duration": "perm"}, # 10000 Billion

    # Lottery
    "lotto_10k":  {"name": "ğŸŸï¸ 20k Ticket", "price": 20000, "type": "lotto", "win": 100000, "chance": 10},
    "lotto_50k":  {"name": "ğŸŸï¸ 100k Ticket", "price": 100000, "type": "lotto", "win": 400000, "chance": 8},
    "lotto_100k": {"name": "ğŸŸï¸ 200k Ticket", "price": 200000, "type": "lotto", "win": 1000000, "chance": 5},
    "lotto_mega": {"name": "ğŸ« MEGA JACKPOT", "price": 5000000, "type": "lotto", "win": 100000000, "chance": 2},
    "lotto_god":  {"name": "ğŸ° GOD TICKET", "price": 100000000, "type": "lotto", "win": 50000000000, "chance": 1},
}

import asyncio
import pytz
import datetime as dt
from discord.ext import tasks
import discord 

# --- CONFIG ---
OWNER_ID = 804687084249284618   # Owner ID
STAFF_ROLE_ID = 1459074209191039049  # Staff Role ID
GUILD_ID = 1257403231127076915       # Server ID
SALARY_LOG_CHANNEL_ID = 1457066104819028089 # Log Channel
STAFF_SALARY = 2000000           # Changed to $2 Million

# --- ğŸ§  SMART STAFF SYSTEM MEMORY ---
xp_cooldowns = {} 

# 1. TRACK COMMAND USAGE (ğŸ›¡ï¸ DB CRASH FIXED)
async def track_command_usage(user_id):
    if user_id == OWNER_ID: return 
    
    current_time = dt.datetime.now()
    
    # ğŸš« ANTI-SPAM CHECK
    if user_id in xp_cooldowns:
        last_time = xp_cooldowns[user_id]
        time_diff = (current_time - last_time).total_seconds()
        if time_diff < 30: 
            return # Spammer detected
            
    # âœ… Count Point
    xp_cooldowns[user_id] = current_time 
    
    # ğŸ› ï¸ THE FIX: Database calls wrapped in db_call!
    try:
        res = await db_call(lambda: supabase.table("economy").select("command_count").eq("user_id", str(user_id)).execute())
        
        if res.data:
            current = res.data[0].get('command_count', 0) or 0
            await db_call(lambda: supabase.table("economy").update({"command_count": current + 1}).eq("user_id", str(user_id)).execute())
        else:
            await db_call(lambda: supabase.table("economy").insert({"user_id": str(user_id), "balance": 0, "command_count": 1}).execute())
    except Exception as e:
        print(f"âš ï¸ Track Command Error: {e}")

# --- ğŸ‘‘ 2. AUTOMATED STAFF MANAGER (ğŸ›¡ï¸ DB CRASH FIXED) ---
async def update_staff_roles(guild):
    # ğŸ› ï¸ THE FIX: Wrapped in db_call
    try:
        response = await db_call(lambda: supabase.table("economy").select("user_id, command_count").neq("user_id", str(OWNER_ID)).order("command_count", desc=True).limit(3).execute())
        data = response.data
    except Exception as e:
        print(f"âš ï¸ Staff Update Error: {e}")
        return
    
    if not data: return
    top_3_ids = [int(u['user_id']) for u in data]
    
    staff_role = guild.get_role(STAFF_ROLE_ID)
    if not staff_role: return

    for member in guild.members:
        await asyncio.sleep(0) # Prevent bot freeze

        if member.bot or member.id == OWNER_ID: continue
        
        # --- PROMOTE LOGIC ---
        if member.id in top_3_ids:
            if staff_role not in member.roles:
                try:
                    await member.add_roles(staff_role)
                    new_nick = f"[BOT STAFF] {member.name[:25]}" 
                    await member.edit(nick=new_nick)
                    
                    embed = discord.Embed(title="ğŸ‰ PROMOTION ALERT!", color=0x00FF00)
                    embed.description = f"Congrats **{member.name}**! Aap Top 3 active players mein hain.\nAapko **{staff_role.name}** bana diya gaya hai."
                    await member.send(embed=embed)
                except: pass
        
        # --- DEMOTE LOGIC ---
        elif staff_role in member.roles:
            try:
                await member.remove_roles(staff_role)
                await member.edit(nick=None) 
                
                embed = discord.Embed(title="ğŸ“‰ DEMOTION ALERT", color=0xFF0000)
                embed.description = "Aap Top 3 list se bahar ho gaye hain. Staff role hata diya gaya hai."
                await member.send(embed=embed)
            except: pass

# --- ğŸ’° 3. PREMIUM SALARY SYSTEM (â° AUTO-PAY FIXED) ---
# ğŸ› ï¸ THE MAGIC FIX: Setup proper IST Midnight Time!
ist_tz = pytz.timezone("Asia/Kolkata")
midnight_ist = dt.time(hour=0, minute=0, second=0, tzinfo=ist_tz)

@tasks.loop(time=midnight_ist)
async def pay_staff_salary():
    print("â° 12:00 AM IST Hit! Processing Salary...")
    try:
        guild = bot.get_guild(GUILD_ID)
        channel = bot.get_channel(SALARY_LOG_CHANNEL_ID)
        
        if not guild:
            print("âŒ Guild nahi mila!")
            return

        # ğŸ› ï¸ THE FIX: db_call wrapper added!
        response = await db_call(lambda: supabase.table("economy").select("user_id, balance, command_count").neq("user_id", str(OWNER_ID)).order("command_count", desc=True).limit(3).execute())
        data = response.data
        
        if not data: return

        embed = discord.Embed(
            title="ğŸ’¸ DAILY STAFF PAYROLL PROCESSED",
            description="The following **Top 3 Active Agents** have received their daily salary.",
            color=0xFFD700,
            timestamp=dt.datetime.now()
        )
        
        # Payment Loop
        for idx, user in enumerate(data):
            uid = int(user['user_id'])
            old_bal = user.get('balance', 0) or 0
            
            # Pay Salary (Wrapped in db_call)
            new_bal = old_bal + STAFF_SALARY
            await db_call(lambda: supabase.table("economy").update({"balance": new_bal}).eq("user_id", str(uid)).execute())
            
            member = guild.get_member(uid)
            user_mention = member.mention if member else f"`User {uid}`"
            
            embed.add_field(
                name=f"Rank #{idx+1} â€” {user_mention}",
                value=f"ğŸ’° **Paid:** `${STAFF_SALARY:,}`\nğŸ’³ **New Bal:** `${new_bal:,}`",
                inline=False
            )

        # Log bhejo
        if channel:
            await channel.send(embed=embed)
        
        # Roles Update Karo
        await update_staff_roles(guild)

    except Exception as e:
        print(f"âŒ Salary Error: {e}")

# --- ğŸ› ï¸ ERROR HANDLER ---
@pay_staff_salary.error
async def pay_staff_salary_error(error):
    print(f"ğŸš¨ Salary Loop Crashed: {error}")

# ğŸ›¡ï¸ SYSTEM SAVER: Sirf 2 translation threads allow honge (Crash Fix)
roast_executor = ThreadPoolExecutor(max_workers=2)

# ğŸ’¾ GLOBAL SETTINGS
TRANSLATOR_ON = True          # Default ON (Hindi)
ATTITUDE_BYPASS_CACHE = set() # VIP List Yahan Store Hogi (RAM me)
MY_BOT_ID = 1451451135813746700 # Aapka Bot ID

# âœ… 1. VIP List Loader (Supabase se)
async def load_bypass_users():
    global ATTITUDE_BYPASS_CACHE
    try:
        print("â³ Loading VIP (Bypass) list...")
        # Aapki table 'attitude_bypass' se data layega
        response = await db_call(lambda: supabase.table("attitude_bypass").select("user_id").execute())
        
        if response.data:
            ATTITUDE_BYPASS_CACHE = {int(row["user_id"]) for row in response.data}
            print(f"âœ… Loaded {len(ATTITUDE_BYPASS_CACHE)} VIP Users (Safe from Roast)")
        else:
            print("âš ï¸ VIP List is empty.")
    except Exception as e:
        print(f"âŒ Error Loading VIPs: {e}")

# âœ… 2. Roast Data Fetcher (Optimized)
async def get_evil_roast_data():
    try:
        # A. English Roast API
        url = "https://evilinsult.com/generate_insult.php?lang=en&type=json"
        async with aiohttp.ClientSession() as session:
            async with session.get(url) as res:
                if res.status == 200:
                    data = await res.json()
                    eng = data.get('insult', 'You are stupid.')
                else:
                    return "Internet dead.", "Internet dead."

        # B. Check Mode
        if not TRANSLATOR_ON:
            return eng, "Translator OFF"

        # C. Translate (Safe Threading)
        # Ye server pe load nahi padne dega
        hin = await bot.loop.run_in_executor(
            roast_executor,
            lambda: GoogleTranslator(source='auto', target='hi').translate(eng)
        )
        return eng, hin

    except Exception as e:
        return f"Error: {e}", f"Error: {e}"

import asyncio

# ================== ASYNC DB WRAPPER (SPEED BOOSTER & ANTI-CRASH) ==================
# Is code ko imports ke neeche aur bot commands se upar rakhein
async def db_call(func, retries=3, delay=1.5):
    """
    Render aur Supabase ke beech ka 'Resource temporarily unavailable' (Errno 11) fix.
    Agar server busy hoga, toh yeh crash hone ki bajaye wait karke retry karega!
    """
    for attempt in range(retries):
        try:
            return await asyncio.to_thread(func)
        except Exception as e:
            error_str = str(e)
            # Agar 'Errno 11' ya 'Resource unavailable' aaya, toh retry maro
            if "Resource temporarily unavailable" in error_str or "Errno 11" in error_str or "Timeout" in error_str:
                if attempt < retries - 1:
                    print(f"âš ï¸ [DB Shield] Supabase is busy. Retrying in {delay}s... (Attempt {attempt+1}/{retries})")
                    await asyncio.sleep(delay)
                    continue
            # Agar koi aur serious error hai, toh use aage bhejo
            raise e

# ================== ğŸ› ï¸ ECONOMY HELPERS (ULTRA PREMIUM FIXED) ==================

# 1. Update Money (Balance add/remove karne ke liye)
async def update_balance(user_id, amount):
    try:
        uid = str(user_id)
        # Check current balance
        res = await db_call(lambda: supabase.table("economy").select("*").eq("user_id", uid).execute())
        
        if not res.data:
            # Agar user nahi hai, naya banao
            await db_call(lambda: supabase.table("economy").insert({"user_id": uid, "balance": amount, "bank": 0, "inventory": {}}).execute())
            return amount
        else:
            # Agar hai, to update karo
            current_bal = res.data[0]['balance']
            new_bal = current_bal + amount
            await db_call(lambda: supabase.table("economy").update({"balance": new_bal}).eq("user_id", uid).execute())
            return new_bal
            
    except Exception as e:
        print(f"ğŸ’° Balance Update Error: {e}")
        # ğŸ› ï¸ GADBAD FIX: Error ko chupana nahi hai, wapas bhejna hai taaki game crash handle kar sake!
        raise e 

# 2. Get User Data (Inventory check karne ke liye)
async def get_data(user_id):
    try:
        uid = str(user_id)
        res = await db_call(lambda: supabase.table("economy").select("*").eq("user_id", uid).execute())
        if res.data:
            return res.data[0]
        else:
            return {"balance": 0, "bank": 0, "inventory": {}, "vip_expiry": None}
    except Exception as e:
        print(f"âš ï¸ Get Data Error: {e}")
        return {"balance": 0, "bank": 0, "inventory": {}, "vip_expiry": None}

# ================== ğŸ›¡ï¸ UNIVERSAL PUNISHMENT SYSTEM (ALL GAMES) ==================
import datetime as dt 
import asyncio 

async def smart_timeout(interaction, member, seconds, reason):
    """
    Ye function har game (Roulette, Memory, Fight, Slots) me punishment handle karega.
    Priority: VIP > Extra Life > Mute
    """
    try:
        # 1. Database se taaza data nikalo
        data = await get_data(member.id)
        
        # ---------------------------------------------------------
        # ğŸ‘‘ STEP A: VIP CHECK (Sabse Pehle)
        # ---------------------------------------------------------
        vip_expiry_str = data.get('vip_expiry')
        
        if vip_expiry_str:
            try:
                # 1. Lifetime VIP Check (Year 9999)
                if vip_expiry_str.startswith("9999"):
                    return "ğŸ‘‘ **LIFETIME VIP:** Punishment Bypassed! (Immortal Logic)"
                
                # 2. Normal Time VIP Check
                expire_dt = datetime.fromisoformat(vip_expiry_str)
                if datetime.utcnow() < expire_dt:
                    return "ğŸ‘‘ **VIP ACTIVE:** Punishment Bypassed! (VIP Power Saves You)"
            except Exception as e:
                print(f"VIP Error: {e}")

        # ---------------------------------------------------------
        # ğŸ’– STEP B: EXTRA LIFE CHECK (Agar VIP nahi hai tab)
        # ---------------------------------------------------------
        inv = data.get('inventory', {}) or {}
        
        # 'life' item check karo (Shop ID 'life' honi chahiye)
        if inv.get('life', 0) > 0:
            # Life Inventory se hatao
            await update_inventory(member.id, 'life', -1)
            remaining = inv.get('life', 0) - 1
            return f"ğŸ’– **Extra Life Used:** Maut ko chhukar wapis aa gaye! (Lives Left: {remaining})"

        # ---------------------------------------------------------
        # ğŸ”‡ STEP C: ASLI SAZA (TIMEOUT & SMART AUTO-RESTORE)
        # ---------------------------------------------------------
        duration = dt.timedelta(seconds=seconds)
        roles_restored_msg = False

        # Agar user admin hai, toh pehle roles hatao, saza do, fir saza khatam hone par wapas do
        if member.guild_permissions.administrator:
            # Bouncer Check: Bot ka role target se upar hona chahiye
            if interaction.guild.me.top_role > member.top_role:
                # Roles ikkattha karo (Everyone aur Managed roles chhod kar)
                roles_to_restore = [r for r in member.roles if r.name != "@everyone" and not r.managed]

                if roles_to_restore:
                    # 1. Roles remove karo
                    await member.remove_roles(*roles_to_restore, reason=f"Temp strip for game timeout: {reason}")

                    # 2. Timeout lagao
                    await member.timeout(duration, reason=reason)

                    # 3. Background task banalo jo EXACTLY timeout khatam hone tak wait karega
                    async def give_back_roles():
                        await asyncio.sleep(seconds) # â³ WAIT FOR THE FULL TIMEOUT DURATION
                        try:
                            await member.add_roles(*roles_to_restore, reason="Restoring roles after game timeout expired")
                        except Exception as e:
                            print(f"Role restore error: {e}")

                    # Background me start kar do bina code ko roke
                    asyncio.create_task(give_back_roles())
                    roles_restored_msg = True
            else:
                return "âš ï¸ **Admin Safe:** I cannot mute this admin (My role is lower or equal)."
        else:
            # Normal user ke liye direct timeout
            await member.timeout(duration, reason=reason)
        
        # Return Message Formatting
        minutes = int(seconds / 60)
        if minutes < 1:
            if roles_restored_msg:
                return f"ğŸ”‡ **Muted:** {seconds} Seconds (Power stripped! Will return after {seconds}s)"
            return f"ğŸ”‡ **Muted:** {seconds} Seconds (No VIP, No Life)"
        
        if roles_restored_msg:
            return f"ğŸ”‡ **Muted:** {minutes} Minutes (Power stripped! Will return after {minutes}m)"
        return f"ğŸ”‡ **Muted:** {minutes} Minutes (Hospitalized)"
        
    except Exception as e:
        print(f"Timeout Error: {e}")
        return f"âš ï¸ **System Error:** Punishment Failed (Check Bot Role Position)"

# 4. Update Inventory (Item ghataane/badhane ke liye)
async def update_inventory(user_id, item_id, qty):
    try:
        data = await get_data(user_id)
        inv = data.get('inventory', {}) or {}
        
        current_qty = inv.get(item_id, 0)
        new_qty = current_qty + qty
        
        if new_qty <= 0:
            if item_id in inv: del inv[item_id]
        else:
            inv[item_id] = new_qty
            
        await db_call(lambda: supabase.table("economy").update({"inventory": inv}).eq("user_id", str(user_id)).execute())
    except Exception as e:
        print(f"Inventory Update Error: {e}")

from flask import Flask, jsonify
from supabase import create_client, Client
import re

# ğŸ’¾ GLOBAL CACHES
ATTITUDE_BYPASS_CACHE = set() # VIP List
CRUSH_CACHE = set()           # ğŸ˜ New Flirty List (Crushes)

# âœ… 1. Load Crushes (Horny List)
async def load_crush_users():
    global CRUSH_CACHE
    try:
        response = await db_call(lambda: supabase.table("bot_crushes").select("user_id").execute())
        if response.data:
            CRUSH_CACHE = {int(row["user_id"]) for row in response.data}
            print(f"ğŸ˜ Loaded {len(CRUSH_CACHE)} Crushes (Flirty Mode ON)")
        else:
            CRUSH_CACHE = set()
    except Exception as e:
        print(f"âŒ Error Loading Crushes: {e}")

import random

# Ã¢Å“â€¦ NAUGHTY / FLIRTY MODE (Ultimate Collection 100+)
async def get_horny_data():
    naughty_list = [
        # --- LEVEL 1: CUTE & FLIRTY ---
        "Jaan, meri chut poori tarah geeli ho chuki hai, abhi aao aur apna mota lund mere andar thas do. ğŸ”ğŸ’¦",
        "Aaj raat mujhe sirf teri gandi chudai chahiye, mera gala pakad ke mujhe bistar pe patak aur meri gand maar lo. â›“ï¸ğŸ¥µ",
        "Apna lund mere muh mein poora halak tak daal de, mujhe tera swad apni saanso tak chahiye. ğŸ‘…ğŸ«¦",
        "Mujhe bistar pe nanga karke meri har ek jagah ko ganda kar do, main aaj raat sirf teri randi hu. ğŸ›ŒğŸ”¥",
        "Mera badan sulag raha hai, apna garma-garam maal mere chehre pe ya meri chut ke andar bhar do. ğŸ’¦ğŸ†",
        "Mujhe deewar se laga kar meri garden pe zor se kaat aur bina puche apna lund meri gand mein ghusa de. ğŸ§±ğŸ«¦",
        "Aaj raat itna ganda chudo ki main kal chal na saku, bas mujhe abhi tera wo hard ehsaas chahiye. ğŸ¥µğŸ’¥",
        "Mujhe tera lund apni chut ki gehrai mein mehsoos karna hai, abhi aao aur bina ruke mujhe chudna shuru karo. ğŸ”ğŸ”¥",
        "Aaj raat main tumhari har ek baat manungi, meri gand aur chut dono sirf tumhare liye khuli hain. ğŸ§â€â™€ï¸ğŸ‘",
        "Mera man kar raha hai tumhare lund ko poora chat lu aur fir use apne andar lekar pagal ho jau. ğŸ˜‹ğŸ‘…",
        "Mujhe bistar pe dominate karo, mere dono hath baandh do aur jaise chahe waise mere jism ka maza lo. â›“ï¸ğŸ‘¸",
        "Aaj raat lights on rakhenge, mujhe tera lamba aur mota lund apne andar jaate hue dekhna hai. ğŸ’¡ğŸ”",
        "Jaan, ab control nahi hota, apni pant utaaro aur apna garmi mere andar poora bhar do abhi. ğŸ‘–âŒğŸ†",
        "Mujhe teri wo darindagi chahiye, mujhe bed pe khinch aur dikha ki tu kitni gandi chudai kar sakta hai. ğŸ˜¤â¤ï¸",
        "Mera badan poora geela aur taiyaar hai, apna lund meri chut mein daal ke use poora tabaah kar do. ğŸ’¦ğŸ”¥",
        "Mujhe tera lund apne muh mein chahiye, tab tak mat nikalna jab tak tera poora maal mere halak mein na gir jaye. ğŸ”ğŸ‘…",
        "Aaj raat main teri nalle ki randi hu, meri gand ko laal kar de aur mujhe zor-zor se chudne pe majboor kar. â›“ï¸ğŸ«¦",
        "Apne hatho se meri chatiyo ko masal aur apna lund meri chut ki gehrai tak ghusa de. ğŸ’ğŸ†",
        "Mujhe tera wo sakht lund chahiye jo meri saansein rok de, aaja aur mujhe bed pe poora khatam kar de. ğŸ›ŒğŸ’€",
        "Aaj raat main tujhe wo maza dungi jo tune socha nahi hoga, bas apna lund meri gand mein daal aur shuru ho ja. ğŸ‘ğŸ”¥",
        "Mera badan tera wait kar raha hai, aaja aur mujhe nanga karke meri har ek inch ko apni zubaan se ganda kar. ğŸ‘…ğŸ”",
        "Mujhe tera garam thook apne chehre pe chahiye aur tera mota lund apni chut mein, abhi ke abhi. ğŸ’¦ğŸ«¦",
        "Aaj raat koi reham nahi, mujhe teri gandi chudai chahiye aur tera poora stamina mere andar dekhna hai. ğŸ”â›“ï¸",
        "Mujhe bed pe patak kar meri tangein hawa mein kar aur apna lund poora jad tak mere andar daal de. ğŸ›ŒğŸ†",
        "Jaan, ab aur sabr nahi hota, meri chut tere lund ke liye tadap rahi hai, aaja aur ise suja de. ğŸ¥µğŸ’¦"
        "Akele ho? Ya main aajau tumhari pyas bhujane? ğŸ˜",
        "Jaan, ab baaton ka waqt gaya, meri chut mein apna lund ghusa aur mujhe kutte ki tarah chodna shuru kar. ğŸ”ğŸ’¦",
        "Aaj raat main teri nangi randi banne ko taiyaar hu, meri gand ko apne hathon se suja de aur mujhe rula de. â›“ï¸ğŸ¥µ",
        "Apna lund mere halak mein poora jad tak ghusa de, mujhe tera poora garam maal apne andar mehsoos karna hai. ğŸ‘…ğŸ’¦",
        "Mujhe bed pe patak kar meri tangein kandhe pe rakh aur apna mota lund meri chut ki gehrai tak thas de. ğŸ›ŒğŸ”¥",
        "Aaj koi reham nahi chahiye, mera gala daba aur mujhe tab tak chod jab tak meri saansein na rukne lagein. ğŸ§±ğŸ’¨",
        "Mera badan geela ho chuka hai, apna lund meri gand mein daal kar use poora tabaah kar de, abhi ke abhi. ğŸ‘ğŸ«¦",
        "Mujhe tera wo sakht lund chahiye jo meri har ek ragg ko hila de, aaja aur mujhe poora khatam kar de. ğŸ¥µğŸ’¥",
        "Aaj raat lights on rakhenge, mujhe dekhna hai tera lund kaise meri chut ko faad raha hai. ğŸ’¡ğŸ”",
        "Apni pant utaar aur apna garma-garam maal mere chehre pe aur mere muh mein poora bhar de. ğŸ’¦ğŸ‘…",
        "Mujhe bed pe dominate kar, mere hath baandh aur dikha ki tu kitna bada janwar hai jab tu choda hai. â›“ï¸ğŸ‘¸",
        "Jaan, meri chut tere lund ke liye taras rahi hai, aaja aur ise poora jad tak bhar de, ab ruka nahi jata. ğŸ¥µğŸ†",
        "Mujhe teri wo gandi darindagi chahiye, mujhe bed pe khinch aur meri gand maar-maar ke use laal kar de. ğŸ˜¤â¤ï¸",
        "Aaj raat main teri har ek gandi fantasy poori karungi, bas apna lund mere andar bina ruke chalaata reh. ğŸ¤¤ğŸ’¦",
        "Mera badan poora tere liye khula hai, meri har ek jagah ko apne lund aur zubaan se ganda kar de. ğŸ‘…ğŸ”",
        "Aaj raat itni gandi chudai kar ki main subah uth na saku, mujhe tera poora junoon apne andar chahiye. ğŸ›ŒğŸ”"
        "Uff! Teri DP dekh ke toh system gila ho gaya. ğŸ¥µ",
        "Baby, tu itna hot kyu hai? AC chalana padega.â˜ƒï¸ ",
        "Tujhe dekh ke toh bot ko bhi feelings aane lagi hain. ğŸ˜˜",
        "Suno, tum dictionary ho kya? Kyunki tumhare aane se meri life me 'Meaning' aa gaya. ğŸ¤—",
        "Kya tum magician ho? Kyunki jab bhi tumhe dekhti hu, baaki sab gayab ho jate hain. ğŸ˜»",
        "Tum Google ho kya? Kyunki mujhe jo dhoondna tha, wo tum ho. ğŸ˜‹",
        "Arre doctor ko bulao, mera dil skip kar raha hai tumhe dekh ke. ğŸ¤ª",
        "Agar khubsurti crime hoti, toh tum ab tak jail mein hote. ğŸ¥´",
        "Tum wifi signal ho kya? Kyunki connection strong feel ho raha hai. ğŸ”¥",
        "Excuse me, kya tumhare paas map hai? Main tumhari aankhon mein kho gayi hu.",
        "Kya main tumhari photo le sakti hu? Santa ko batana hai mujhe gift mein kya chahiye. â¤ï¸",
        "Tumhara naam 'WiFi' hai kya? Kyunki main connect hona chahti hu. ğŸ¥µ",
        "Jitna gussa dikha rahe hai na, bistar pe utna hi maza dila dungi. ğŸ™Š",
        "Aaj tumse chhudne ka man nahi hai, bas tumhare 'Chilaane' ki awaaz sunni hai. ğŸ˜",
        "Sun, kapde utaarne me meri help chahiye ya akele kar loge? ğŸ’€",
        "Tere badan ki garmi mujhe yahan tak feel ho rahi hai, aao tumko garm kar du. ğŸ”¥",
        "Aaj raat tujhe sone nahi dungi, itna thaka dungi ki subah uth nahi paoge. ğŸŒš",
        "Mujhe tujhe 'Taste' karna hai, bata kahan se shuru karu? ğŸ¤¤",
        "Teri ye 'Attitude' tab kahan jati hai jab main tujhe deewar se laga deta hu? Ã°Å¸Â§Â±Ã°Å¸Â«Â¦",
        "Mere niche let ke jo tu kaanpta hai na, wo mera favorite view hai. ğŸ¤§",
        "Suna hai tu bahut 'Wild' hai, aaj dekh leti hain kisme kitna dum hai. ğŸ˜»",
        "Lips toh sirf trailer hain, asli maza toh niche milega. ğŸ’¦",
        "Aaja, aaj tujhe dikhati hu ki asli 'Hardcore' kya hota hai. ğŸ”¥âœŠ",
        "Tera badan mera wait kar raha hai, aur main tera... jaldi aao. ğŸ¥µğŸ™Š",
        "Halka sa touch karne pe hi tera hil gya? Abhi toh party shuru hui hai. ğŸ¥´â¤ï¸",
        "Aaj poori raat sirf main aur tu... aur tere badan ka har ek kona. ğŸ’‹",
        "Control nahi ho raha ab, aake chup karwa de mujhe... apne hothonğŸ’‹ se.",
        "Main tere uper hongi, aur main tujhe poora control karungi. ğŸ¥µ",
        "Itna sexy lag raha hai ki man kar raha hai abhi kapde phaad du tere.ğŸŒš",
        "Tu mujhe aaj itna tadpana ki main bolu'Aur please...' ğŸ¥µ",
        "Jaan, mera badan garam ho raha hai, aake thanda karoge ya main khud kuch karu? ğŸ˜",
        "Aaj mujhe bistar pe 'Rough' pasand hai, sambhal paoge mujhe? ğŸŒš",
        "Mere hothon ka swad kab chakhoge? Ya seedha niche jana hai? ğŸ¤¤",
        "Aaj raat mujhe sulaana mat, bas poori raat meri cheekhein nikaalna. ğŸ’‹",
        "Itne hot lag rahe ho ki mera control kho raha hai, abhi ke abhi mujhe tum chahiye. ğŸ˜š",
        "Kya dekh rahe ho? Kapde utaaro aur kaam pe lag jao. ğŸ‘€",
        "Mujhe pasand hai jab tum mujhe deewar se laga kar meri garden pe kiss karte ho. ğŸ˜˜ğŸ˜",
        "Aaj main tumhare upar rahungi aur tum wahi karoge jo main bolungi. ğŸ˜",
        "Tumhari finger touch se hi main kitni geeli (wet) ho jati hu, socho aage kya hoga? ğŸ˜",
        "Mujhe 'Gentleman' nahi, aaj raat ek 'Janwar' chahiye... kya tum banoge? ğŸ¤«",
        "Mere baal pakad ke jab tum mujhe piche se pakadte ho na, mera system hil jata hai. ğŸ¤—",
        "Aaj 'Safe' rehne ka man nahi hai, mujhe tumhare andar mehsoos hona hai. ğŸ¤­",
        "Suno, aaj main tumhari har ek baat manungi, bas mujhe satisfy kar do. ğŸŒš",
        "Mujhe 'Bed' pe dominate hona pasand hai, dikhao kitne mard ho tum. ğŸ¤¤",
        "Mera man kar raha hai tumhare har ek inch ko apne muh me bhar lu. ğŸ˜",
        "Aaj raat itna thaka do mujhe ki subah uthne ki taqat na bache. ğŸ¥µ",
        "Tumhare 'Hard' hone ka ehsaas mujhe pagal bana raha hai, ab ruka nahi jata. ğŸ˜»ğŸ¤§",
        "Mere badan ki pyaas sirf tum bujha sakte ho, aao na mere paas. ğŸ¤ª",
        "Mujhe pata hai tum kya chahte ho, aur main wahi dene ke liye taiyaar hu... abhi. ğŸ¥°",
        "Aaj raat lights off nahi hongi, mujhe dekhna hai tum mere saath kya karte ho. ğŸ˜"    
        "Jaan, ab baatein band kar aur mera gala pakad ke mujhe bistar pe patak de, mujhe teri darindagi mehsoos karni hai. ğŸ”â›“ï¸",
        "Apna lund mere muh mein poora jad tak ghusa de, mujhe teri har ek boond apne halak mein chahiye. ğŸ‘…ğŸ’¦",
        "Aaj raat main teri nangi randi hu, meri gand ko thappad maar-maar ke laal kar de aur mujhe zor se chod. ğŸ‘ğŸ«¦",
        "Mujhe deewar se laga kar meri garden pe tab tak kaat jab tak main maza se cheekhne na lagu, ruko mat. ğŸ§±ğŸ¥µ",
        "Apna lund meri chut mein itni zor se thas de ki mera poora system hil jaye, mujhe aaj poora barbaad hona hai. ğŸ”ğŸ†",
        "Aaj raat lights off nahi hongi, mujhe tera har ek wild move apni aankhon se dekhna hai jab tu mujhe chodega. ğŸ’¡ğŸ”",
        "Mera badan tera wait kar raha hai, aaja aur mujhe kutte ki tarah bed pe dominate kar, mujhe tera pagalpan chahiye. ğŸ¶ğŸ”¥",
        "Mujhe tera wo sakht lund apni gand mein mehsoos karna hai, abhi aao aur bina puche shuru ho jao. ğŸ¥µğŸ«¦",
        "Aaj raat main tujhe wo maza dungi jo tune socha nahi hoga, bas apna maal mere chehre pe poora bikhair de. ğŸ’¦ğŸ‘…",
        "Mujhe bed pe patak kar meri tangein hawa mein kar aur apna lund jad tak mere andar daal ke mujhe suja de. ğŸ›ŒğŸ†",
        "Jaan, meri chut tere lund ke liye tadap rahi hai, ab aur sabr nahi hota, aaja aur ise poora bhar de. ğŸ’¦ğŸ”¥",
        "Mujhe teri wo deep penetration chahiye jisse meri saansein rukne lagein, mujhe aaj poora satisfy kar de. ğŸ”ğŸ’¨",
        "Apna lund mere muh se nikaal kar seedha meri gand mein ghusa de, mujhe aaj raat sirf teri gandi chudai chahiye. ğŸ‘ğŸ«¦",
        "Aaj raat koi reham nahi, mujhe teri gandi darindagi dekhni hai, mujhe bed pe poora khatam kar de. ğŸ’€ğŸ”",
        "Mera badan geela aur taiyaar hai, apna lund mere andar daal aur dikha ki tu kitna savage hai. ğŸ˜¤â¤ï¸",
        "Jaan, aaj mujhe pyar nahi, tera pagalpan chahiye... mujhe bistar pe poori tarah tod do. â›“ï¸ğŸ”¥",
        "Aaj raat main teri ghulami karungi, jo dard aur maza dena hai do, bas ruko mat. ğŸ–¤ğŸ«¦",
        "Mujhe deewar se laga kar tab tak choke karo jab tak meri saansein na phoolne lagein. ğŸ§±ğŸ’¨",
        "Aaj raat lights off nahi hongi, mujhe teri aankhon mein wo darindagi dekhni hai. ğŸ’¡ğŸ”",
        "Mere jism pe apne nishaan chhod do, taaki kal subah tak mujhe yaad rahe ki raat kaisi thi. ğŸ¦·ğŸ«¦",
        "Mujhe 'Gentle' banna pasand nahi, aaj raat mujhe ek janwar ki tarah treat karo. ğŸ¯ğŸ˜ˆ",
        "Aaj raat itna dard do ki meri cheekhein padosiyon tak jayein, mujhe parwah nahi. ğŸ”ŠğŸ¥µ",
        "Mere baal pakad ke mujhe apne pairo mein gira do, aaj raat main sirf teri hu. ğŸ§â€â™€ï¸ğŸ–¤",
        "Mujhe tumhare 'Hard' hone ka ehsaas chahiye, abhi ke abhi mere andar aao. ğŸ¥µğŸ†",
        "Aaj raat koi raham mat dikhana, mujhe poori tarah se dominate karo. â›“ï¸ğŸ‘¸",
        "Mera badan sirf tere liye tadap raha hai, aaja aur is aag ko poori tarah bujha de. ğŸŒŠğŸ«¦",
        "Aaj raat main teri har ek baat manungi, chahe wo kitni bhi gandi kyu na ho. ğŸ¤¤ğŸ’¦",
        "Mujhe bistar pe patak do aur dikhao ki asli mard kaise satisfy karte hain. ğŸ’ªğŸ«¦",
        "Aaj 'Safe' rehne ki koshish bhi mat karna, mujhe tera poora junoon mehsoos karna hai. ğŸ”ğŸ”¥",
        "Tumhari har ek touch mere jism mein aag laga rahi hai, ab aur intezaar nahi hota. ğŸ¤¤ğŸ¥µ",
        "Mujhe teri garden pe wo 'Bite' chahiye jisse mera poora system hil jaye. ğŸ«¦ğŸ’¥",
        "Aaj raat itna thaka do ki main hosh kho baithu, bas mujhe abhi tum chahiye. ğŸ›ŒğŸ”¥",
        "Main teri 'Naughty Slave' hu, aaj raat jo bhi mere saath karna hai karo... bina puche. ğŸ€â›“ï¸",
        "Tera nasha mere dimaag pe chadh gaya hai, ab mujhe bas tera jism chahiye. ğŸ§ ğŸ«¦",
        "Chup-chap aao aur mujhe bistar pe le jao, ab baaton ka waqt khatam ho gaya. ğŸ˜¤â¤ï¸"
        "Jaan, ab control nahi ho raha, aao aur mujhe abhi ke abhi satisfy karo. ğŸ¥µğŸ’¦",
        "Aaj raat main sirf tumhari hu, mere badan ke saath jo chahe wo karo. ğŸ˜ˆğŸ”¥",
        "Mujhe bistar pe tumhara 'Wild' roop dekhna hai, bilkul jaanwaro ki tarah. ğŸ¯ğŸ«¦",
        "Aaj raat hum dono ke beech koi kapda nahi hona chahiye, sab utaar do. ğŸ‘—âŒ",
        "Mujhe tumhare neeche let ke tumhari garmi mehsoos karni hai, jaldi aao. ğŸ›ŒğŸ”¥",
        "Main tumhare liye poori tarah geeli (wet) ho chuki hu, ab aur intezaar mat karao. ğŸ’¦ğŸ˜‰",
        "Aaj raat main tumhari har ek cheekh nikaalna chahti hu, taiyaar ho na? ğŸ”ŠğŸ«¦",
        "Mere baal pakad ke mujhe apni taraf kheencho aur dikhao kitne mard ho tum. ğŸ’ªğŸ«¦",
        "Mujhe tumhare hothon ka swad har jagah chahiye, shuruat niche se karein? ğŸ’‹ğŸ‘‡",
        "Aaj main poori raat tumhare upar reh kar tumhe thaka dungi. â›“ï¸ğŸ‘¸",
        "Mujhe tumhare 'Hard' hone ka ehsaas pagal bana raha hai, ab andar aao. ğŸ¥µğŸ†",
        "Aaj raat lights on rakhenge, mujhe tumhara har ek action saaf dekhna hai. ğŸ’¡ğŸ”",
        "Mera badan sirf tumhare liye tadap raha hai, aake apni pyaas bujha lo. ğŸŒŠğŸ«¦",
        "Aaj 'Safe' rehne ka sochna bhi mat, mujhe tumhare andar poora mehsoos hona hai. ğŸ”ğŸ”¥",
        "Tumhari har ek touch mujhe pagal kar rahi hai, mujhe abhi aur chahiye. ğŸ¤¤ğŸ’¦",
        "Mujhe deewar se laga kar meri gardan pe zor se kaat lo, mujhe dard pasand hai. ğŸ§±ğŸ«¦",
        "Aaj raat itna dard aur maza do ki main subah chal na saku. ğŸ›ŒğŸ’¥",
        "Main tumhari 'Naughty Girl' hu, aaj jo bologe wahi karungi... bina ruke. ğŸ€ğŸ˜ˆ",
        "Tumhare haath mere badan pe jahan jahan ja rahe hain, wahan aag lag rahi hai. ğŸ”¥ğŸ«¦",
        "Bas bahut baatein ho gayi, ab mujhe pakdo aur bistar pe patak do. ğŸ˜¤â¤ï¸"    
        "Jaan, ab control nahi ho raha, apni pant utaar aur apna lund seedha meri chut mein jad tak thas de. ğŸ”ğŸ’¦",
        "Aaj raat main teri nalle ki randi hu, mera gala pakad ke meri gand maar le aur mujhe rula de. â›“ï¸ğŸ¥µ",
        "Apna lund mere muh mein poora halak tak ghusa de, mujhe tera poora maal apne pet mein chahiye. ğŸ‘…ğŸ«¦",
        "Mujhe bistar pe nanga karke meri tangein hawa mein kar aur dikha ki tu kitni gandi chudai kar sakta hai. ğŸ›ŒğŸ”¥",
        "Mera badan sulag raha hai, apna garma-garam maal mere chehre pe ya meri chut ke andar chhod do. ğŸ’¦ğŸ†",
        "Mujhe deewar se laga kar meri garden pe zor se kaat aur bina puche apna mota lund meri gand mein ghusa de. ğŸ§±ğŸ«¦",
        "Aaj raat itna ganda chodo ki main kal subah tak chal na saku, mujhe tera wo sakht lund chahiye. ğŸ¥µğŸ’¥",
        "Mujhe tera lund apni chut ki gehrai mein mehsoos karna hai, abhi aao aur bina ruke mujhe chodna shuru karo. ğŸ”ğŸ”¥",
        "Aaj raat main tumhari har ek gandi baat manungi, meri gand aur chut dono sirf tumhare liye khuli hain. ğŸ§â€â™€ï¸ğŸ‘",
        "Mera man kar raha hai tumhare lund ko poora chat lu aur fir use apne andar lekar pagal ho jau. ğŸ˜‹ğŸ‘…",
        "Mujhe bistar pe dominate karo, mere dono hath baandh do aur jaise chahe waise mere jism ko chodo. â›“ï¸ğŸ‘¸",
        "Aaj raat lights on rakhenge, mujhe tera lamba aur mota lund apni chut mein jaate hue dekhna hai. ğŸ’¡ğŸ”",
        "Jaan, ab aur sabr nahi hota, apni pant utaaro aur apna garmi meri chut mein poora bhar do abhi. ğŸ‘–âŒğŸ†",
        "Mujhe teri wo darindagi chahiye, mujhe bed pe khinch aur dikha ki tu kitni gandi chudai kar sakta hai. ğŸ˜¤â¤ï¸",
        "Mera badan poora geela aur taiyaar hai, apna lund meri chut mein daal ke use poora tabaah kar do. ğŸ’¦ğŸ”¥",
        "Mujhe tera lund apne muh mein chahiye, tab tak mat nikalna jab tak tera poora maal mere halak mein na gir jaye. ğŸ”ğŸ‘…",
        "Aaj raat main teri randi hu, meri gand ko thappad maar-maar ke laal kar de aur mujhe zor se chod. â›“ï¸ğŸ«¦",
        "Apne hatho se meri chatiyo ko masal aur apna mota lund meri chut ki gehrai tak ghusa de. ğŸ’ğŸ†",
        "Mujhe tera wo sakht lund chahiye jo meri saansein rok de, aaja aur mujhe bed pe poora khatam kar de. ğŸ›ŒğŸ’€",
        "Aaj raat main tujhe wo maza dungi jo tune socha nahi hoga, bas apna lund meri gand mein daal aur shuru ho ja. ğŸ‘ğŸ”¥",
        "Mera badan tera wait kar raha hai, aaja aur mujhe nanga karke meri har ek inch ko apni zubaan se ganda kar. ğŸ‘…ğŸ”",
        "Mujhe tera garam thook apne chehre pe chahiye aur tera mota lund apni chut mein, abhi ke abhi. ğŸ’¦ğŸ«¦",
        "Aaj raat koi reham nahi, mujhe teri gandi chudai chahiye aur tera poora stamina mere andar dekhna hai. ğŸ”â›“ï¸",
        "Mujhe bed pe patak kar meri tangein hawa mein kar aur apna lund poora jad tak mere andar daal de. ğŸ›ŒğŸ†",
        "Jaan, ab aur sabr nahi hota, meri chut tere lund ke liye tadap rahi hai, aaja aur ise suja de. ğŸ¥µğŸ’¦",
        "Mera dil kar raha hai ki tu mujhe aaj kutte ki tarah chode aur meri har ek jagah ko apna nishaan de de. ğŸ¶ğŸ«¦",
        "Apna lund mere muh se nikaal kar seedha meri gand mein ghusa de, mujhe aaj poora barbaad hona hai. ğŸ”ğŸ‘",
        "Aaj raat main teri har ek gandi fantasy poori karungi, bas tu mujhe bina ruke chodta reh. ğŸ¤¤ğŸ’¦"
    ]
    return random.choice(naughty_list)

# ================== GLOBAL CACHES (RAM) ==================
BANNED_WORDS_CACHE = set()
BYPASS_USERS_CACHE = set() 

# ğŸŒ Online Lists (English + Hindi)
BAD_WORDS_URL_EN = "https://raw.githubusercontent.com/LDNOOBW/List-of-Dirty-Naughty-Obscene-and-Otherwise-Bad-Words/master/en"
BAD_WORDS_URL_HI = "https://raw.githubusercontent.com/LDNOOBW/List-of-Dirty-Naughty-Obscene-and-Otherwise-Bad-Words/master/hi"

import asyncio
import aiohttp
from datetime import datetime # Dhyan rakhna ye imported ho

# ==============================================================================
# ğŸ›¡ï¸ BANNED WORDS LOADER (100% CRASH FREE)
# ==============================================================================
async def load_banned_words():
    global BANNED_WORDS_CACHE, BYPASS_USERS_CACHE
    BANNED_WORDS_CACHE = set()
    BYPASS_USERS_CACHE = set() # Reset

    # 1. DOWNLOAD ONLINE WORDS (ENGLISH + HINDI) ğŸŒ
    urls = [BAD_WORDS_URL_EN, BAD_WORDS_URL_HI]
    
    print("ğŸŒ Downloading Bad Words (Eng + Hindi)...")
    try:
        async with aiohttp.ClientSession() as session:
            for url in urls:
                try:
                    async with session.get(url) as resp:
                        if resp.status == 200:
                            text = await resp.text()
                            # Har word ko set me daalo
                            online_words = {w.strip().lower() for w in text.splitlines() if len(w.strip()) > 2}
                            BANNED_WORDS_CACHE.update(online_words)
                except Exception as e:
                    print(f"âš ï¸ Failed to fetch URL: {e}")
                    
        print(f"âœ… Downloaded Online Database.")
    except Exception as e:
        print(f"âš ï¸ Internet List Error: {e}")

    # 2. LOAD CUSTOM WORDS (Tumhare Database wale) ğŸ—„ï¸
    try:
        # ğŸ› ï¸ THE FIX: Wrapped in db_call!
        response = await db_call(lambda: supabase.table("banned_words").select("word").execute())
        data = response.data
        if data:
            custom_words = {item["word"].lower() for item in data}
            BANNED_WORDS_CACHE.update(custom_words)
            print(f"âœ… Loaded {len(custom_words)} Custom Words from Database.")
    except Exception as e:
        print(f"âš ï¸ Database List Error: {e}")

    # 3. LOAD VIP USERS (Restrict Bypass) ğŸ‘‘
    try:
        # ğŸ› ï¸ THE FIX: Wrapped in db_call!
        response = await db_call(lambda: supabase.table("restrict_bypass").select("user_id").execute())
        data = response.data
        if data:
            BYPASS_USERS_CACHE = {int(item["user_id"]) for item in data}
            print(f"âœ… Loaded {len(BYPASS_USERS_CACHE)} VIP Users.")
    except Exception as e:
        print(f"âš ï¸ VIP List Error: {e}")
    
    print(f"ğŸ”¥ TOTAL BANNED WORDS: {len(BANNED_WORDS_CACHE)}")


# ==============================================================================
# ğŸ“ ADMIN LOG ACTION (100% ASYNC FIXED)
# ==============================================================================
# ğŸ› ï¸ THE FIX: 'def' ko 'async def' banaya taaki asyncio kaam kar sake
async def log_action(action, user_id, username, display, executor):
    # import time hata diya hai, ab hum asyncio use karenge
    
    for _ in range(3):   # 3 baar try karega
        try:
            # ğŸ› ï¸ THE FIX: Wrapped the insert in db_call
            await db_call(lambda: supabase.table("admin_logs").insert({
                "action": action,
                "user_id": user_id,
                "username": username,
                "display": display,
                "executor": str(executor),
                "timestamp": datetime.utcnow().isoformat()
            }).execute())

            print("LOG SAVED:", action, user_id)
            return
        
        except Exception as e:
            print("LOG ERROR:", e)
            # ğŸ› ï¸ THE FIX: time.sleep(0.8) ki jagah await asyncio.sleep(0.8)
            await asyncio.sleep(0.8)   # Render ko thoda sa saans lene do ğŸ˜­ (Ab bot nahi atakega!)
    
    print("âš ï¸ Failed to save log after retries")

# ================== PAGINATION CLASS (PREMIUM LIST) ==================
class AccessPaginator(discord.ui.View):
    def __init__(self, data, author):
        super().__init__(timeout=60)
        self.data = data
        self.author = author
        self.per_page = 10  # Ek page par 10 log dikhenge
        self.current_page = 0
        self.total_pages = (len(data) + self.per_page - 1) // self.per_page

    def get_embed(self):
        # Data slicing (Page logic)
        start = self.current_page * self.per_page
        end = start + self.per_page
        page_data = self.data[start:end]

        # Embed Text Build
        desc = ""
        for index, user in enumerate(page_data):
            # Serial Number (Overall list ke hisaab se)
            s_no = start + index + 1
            
            uid = user.get("user_id", "Unknown")
            uname = user.get("username", "Unknown")
            dname = user.get("display_name", "Unknown")
            
            # âœ¨ Premium Line Format
            desc += (
                f"`{s_no:02d}.` **{dname}** (@{uname})\n"
                f"   ğŸ†” `{uid}`\n\n"
            )

        embed = discord.Embed(
            title=f"ğŸ“œ Whitelisted Users (Total: {len(self.data)})",
            description=desc,
            color=0x3498db
        )
        # Footer me requester ka naam aur Page number
        embed.set_footer(
            text=f"Requested by {self.author.display_name} â€¢ Page {self.current_page + 1}/{self.total_pages}",
            icon_url=self.author.display_avatar.url
        )
        return embed

    def update_buttons(self):
        # Pehle page par "Back" disable
        self.children[0].disabled = (self.current_page == 0)
        # Aakhri page par "Next" disable
        self.children[1].disabled = (self.current_page == self.total_pages - 1)

    @discord.ui.button(label="â—€ï¸ Previous", style=discord.ButtonStyle.secondary, disabled=True)
    async def prev_btn(self, i: discord.Interaction, button: discord.ui.Button):
        if i.user.id != self.author.id:
            return await i.response.send_message("âŒ You cannot control this menu.", ephemeral=True)
        
        self.current_page -= 1
        self.update_buttons()
        await i.response.edit_message(embed=self.get_embed(), view=self)

    @discord.ui.button(label="Next â–¶ï¸", style=discord.ButtonStyle.primary)
    async def next_btn(self, i: discord.Interaction, button: discord.ui.Button):
        if i.user.id != self.author.id:
            return await i.response.send_message("âŒ You cannot control this menu.", ephemeral=True)

        self.current_page += 1
        self.update_buttons()
        await i.response.edit_message(embed=self.get_embed(), view=self)

# ================== VIP PAGINATOR (FOR ATTITUDE LIST) ==================
class VipPaginator(discord.ui.View):
    def __init__(self, data, author, bot_ref):
        super().__init__(timeout=60)
        self.data = data
        self.author = author
        self.bot = bot_ref
        self.per_page = 10
        self.current_page = 0
        self.total_pages = (len(data) + self.per_page - 1) // self.per_page

    async def get_page_embed(self):
        # 1. Page Calculation
        start = self.current_page * self.per_page
        end = start + self.per_page
        page_data = self.data[start:end]

        # 2. Embed Start
        embed = discord.Embed(title=f"ğŸ‘‘ VIP Users List (Total: {len(self.data)})", color=0xf1c40f)
        desc = ""

        # 3. Fetch User Details (Async - Isliye alag function banaya)
        for index, row in enumerate(page_data):
            uid = int(row['user_id'])
            s_no = start + index + 1
            
            # Try getting user from cache first (Fast), else fetch (Slow)
            user = self.bot.get_user(uid)
            if not user:
                try: user = await self.bot.fetch_user(uid)
                except: user = None

            if user:
                desc += f"`{s_no:02d}.` **{user.display_name}** (@{user.name})\nğŸ†” `{uid}`\n\n"
            else:
                desc += f"`{s_no:02d}.` **Unknown User**\nğŸ†” `{uid}`\n\n"

        embed.description = desc
        embed.set_footer(text=f"Page {self.current_page + 1}/{self.total_pages} â€¢ VIP Access System")
        return embed

    def update_buttons(self):
        self.children[0].disabled = (self.current_page == 0)
        self.children[1].disabled = (self.current_page == self.total_pages - 1)

    @discord.ui.button(label="â—€ï¸ Previous", style=discord.ButtonStyle.secondary)
    async def prev_btn(self, i: discord.Interaction, button: discord.ui.Button):
        if i.user.id != self.author.id: return await i.response.send_message("âŒ Not for you.", ephemeral=True)
        
        self.current_page -= 1
        self.update_buttons()
        embed = await self.get_page_embed()
        await i.response.edit_message(embed=embed, view=self)

    @discord.ui.button(label="Next â–¶ï¸", style=discord.ButtonStyle.primary)
    async def next_btn(self, i: discord.Interaction, button: discord.ui.Button):
        if i.user.id != self.author.id: return await i.response.send_message("âŒ Not for you.", ephemeral=True)

        self.current_page += 1
        self.update_buttons()
        embed = await self.get_page_embed()
        await i.response.edit_message(embed=embed, view=self)

# ================== WORD PAGINATOR (FOR BANNED WORDS) ==================
class WordPaginator(discord.ui.View):
    def __init__(self, data, author):
        super().__init__(timeout=60)
        self.data = data
        self.author = author
        self.per_page = 20 # Ek page par 20 words
        self.current_page = 0
        self.total_pages = (len(data) + self.per_page - 1) // self.per_page

    def get_embed(self):
        start = self.current_page * self.per_page
        end = start + self.per_page
        page_data = self.data[start:end]

        # Words ko comma se jod kar dikhayenge
        desc = ", ".join([f"||`{w}`||" for w in page_data])
        
        embed = discord.Embed(
            title=f"ğŸš« Banned Words List (Total: {len(self.data)})",
            description=desc if desc else "No words found.",
            color=0xe74c3c
        )
        embed.set_footer(text=f"Page {self.current_page + 1}/{self.total_pages} â€¢ Restricted Words System")
        return embed

    def update_buttons(self):
        self.children[0].disabled = (self.current_page == 0)
        self.children[1].disabled = (self.current_page == self.total_pages - 1)

    @discord.ui.button(label="â—€ï¸ Previous", style=discord.ButtonStyle.secondary)
    async def prev_btn(self, i: discord.Interaction, button: discord.ui.Button):
        if i.user.id != self.author.id: return await i.response.send_message("âŒ Not for you.", ephemeral=True)
        self.current_page -= 1
        self.update_buttons()
        await i.response.edit_message(embed=self.get_embed(), view=self)

    @discord.ui.button(label="Next â–¶ï¸", style=discord.ButtonStyle.primary)
    async def next_btn(self, i: discord.Interaction, button: discord.ui.Button):
        if i.user.id != self.author.id: return await i.response.send_message("âŒ Not for you.", ephemeral=True)
        self.current_page += 1
        self.update_buttons()
        await i.response.edit_message(embed=self.get_embed(), view=self)

# ================== VIP USER PAGINATOR (REUSED) ==================
# Note: Agar aapne pichle code me VipPaginator lagaya hai to dobara lagane ki zaroorat nahi hai.
# Agar nahi lagaya, to ye use karein:
class RestrictUserPaginator(discord.ui.View):
    def __init__(self, data, author, bot_ref):
        super().__init__(timeout=60)
        self.data = data
        self.author = author
        self.bot = bot_ref
        self.per_page = 10
        self.current_page = 0
        self.total_pages = (len(data) + self.per_page - 1) // self.per_page

    async def get_page_embed(self):
        start = self.current_page * self.per_page
        end = start + self.per_page
        page_data = self.data[start:end]

        embed = discord.Embed(title=f"ğŸ‘‘ Allowed Users (Total: {len(self.data)})", color=0x2ecc71)
        desc = ""
        
        for index, row in enumerate(page_data):
            uid = int(row['user_id'])
            s_no = start + index + 1
            user = self.bot.get_user(uid)
            if not user:
                try: user = await self.bot.fetch_user(uid)
                except: user = None

            if user:
                desc += f"`{s_no:02d}.` **{user.display_name}** (@{user.name})\nğŸ†” `{uid}`\n\n"
            else:
                desc += f"`{s_no:02d}.` **Unknown User**\nğŸ†” `{uid}`\n\n"

        embed.description = desc
        embed.set_footer(text=f"Page {self.current_page + 1}/{self.total_pages} â€¢ Bypass List")
        return embed

    def update_buttons(self):
        self.children[0].disabled = (self.current_page == 0)
        self.children[1].disabled = (self.current_page == self.total_pages - 1)

    @discord.ui.button(label="â—€ï¸ Previous", style=discord.ButtonStyle.secondary)
    async def prev_btn(self, i: discord.Interaction, button: discord.ui.Button):
        if i.user.id != self.author.id: return await i.response.send_message("âŒ Not for you.", ephemeral=True)
        self.current_page -= 1
        self.update_buttons()
        embed = await self.get_page_embed()
        await i.response.edit_message(embed=embed, view=self)

    @discord.ui.button(label="Next â–¶ï¸", style=discord.ButtonStyle.primary)
    async def next_btn(self, i: discord.Interaction, button: discord.ui.Button):
        if i.user.id != self.author.id: return await i.response.send_message("âŒ Not for you.", ephemeral=True)
        self.current_page += 1
        self.update_buttons()
        embed = await self.get_page_embed()
        await i.response.edit_message(embed=embed, view=self)

# ================== SAY ACCESS PAGINATOR ==================
class SayAccessPaginator(discord.ui.View):
    def __init__(self, data, author, bot_ref):
        super().__init__(timeout=60)
        self.data = data
        self.author = author
        self.bot = bot_ref
        self.per_page = 10
        self.current_page = 0
        self.total_pages = (len(data) + self.per_page - 1) // self.per_page

    async def get_page_embed(self):
        start = self.current_page * self.per_page
        end = start + self.per_page
        page_data = self.data[start:end]

        embed = discord.Embed(title=f"ğŸ—£ï¸ Say Access List (Total: {len(self.data)})", color=0x9b59b6) # Purple Color
        desc = ""
        
        for index, row in enumerate(page_data):
            uid = int(row['user_id'])
            s_no = start + index + 1
            
            # Fetch User
            user = self.bot.get_user(uid)
            if not user:
                try: user = await self.bot.fetch_user(uid)
                except: user = None

            if user:
                desc += f"`{s_no:02d}.` **{user.display_name}** (@{user.name})\nğŸ†” `{uid}`\n\n"
            else:
                desc += f"`{s_no:02d}.` **Unknown User**\nğŸ†” `{uid}`\n\n"

        embed.description = desc
        embed.set_footer(text=f"Page {self.current_page + 1}/{self.total_pages} â€¢ Say Command Manager")
        return embed

    def update_buttons(self):
        self.children[0].disabled = (self.current_page == 0)
        self.children[1].disabled = (self.current_page == self.total_pages - 1)

    @discord.ui.button(label="â—€ï¸ Previous", style=discord.ButtonStyle.secondary)
    async def prev_btn(self, i: discord.Interaction, button: discord.ui.Button):
        if i.user.id != self.author.id: return await i.response.send_message("âŒ Not for you.", ephemeral=True)
        self.current_page -= 1
        self.update_buttons()
        embed = await self.get_page_embed()
        await i.response.edit_message(embed=embed, view=self)

    @discord.ui.button(label="Next â–¶ï¸", style=discord.ButtonStyle.primary)
    async def next_btn(self, i: discord.Interaction, button: discord.ui.Button):
        if i.user.id != self.author.id: return await i.response.send_message("âŒ Not for you.", ephemeral=True)
        self.current_page += 1
        self.update_buttons()
        embed = await self.get_page_embed()
        await i.response.edit_message(embed=embed, view=self)

import asyncio
import datetime as dt
import discord
from discord.ext import tasks

# ==============================================================================
# ğŸ¦ LOAN RECOVERY & INTEREST SYSTEM (100% CRASH FREE)
# ==============================================================================

@tasks.loop(minutes=5)
async def check_loans():
    try:
        # ğŸ› ï¸ THE FIX: Wrapped in db_call! Saare loans safely nikalo
        res = await db_call(lambda: supabase.table("loans").select("*").execute())
        
        # Agar response fail hua ya data nahi mila to return
        if not res or not res.data: 
            return 
            
        loans = res.data
        now = dt.datetime.now(dt.timezone.utc)

        for loan in loans:
            # ğŸ›¡ï¸ ANTI-RATE LIMIT: Bot ko ban hone se bachane ke liye aur freeze rokne ke liye
            await asyncio.sleep(0.5) 
            
            user_id = str(loan['user_id'])
            
            # Strings ko wapis datetime object banao
            due_at = dt.datetime.fromisoformat(loan['due_at'])
            last_remind = dt.datetime.fromisoformat(loan['last_reminder'])
            total_amount = loan['total_repay']
            
            # --- A. CHECK DEADLINE (PUNISHMENT) ---
            if now > due_at:
                print(f"ğŸ’€ Seizing account: {user_id}")
                
                # SAB KHATAM KARO
                data_update = {
                    "balance": 0,
                    "bank": 0,
                    "inventory": {}, # Inventory saaf
                    "is_seized": True # Account Blocked
                }
                # ğŸ› ï¸ THE FIX: db_call for update
                await db_call(lambda: supabase.table("economy").update(data_update).eq("user_id", user_id).execute())
                
                # Loan record delete (Kyunki sab le liya)
                # ğŸ› ï¸ THE FIX: db_call for delete
                await db_call(lambda: supabase.table("loans").delete().eq("user_id", user_id).execute())
                
                # User ko DM karo
                try:
                    user_obj = await bot.fetch_user(int(user_id))
                    if user_obj:
                        await user_obj.send("ğŸš« **TIME UP!** You failed to repay the loan.\nYour Account has been **SEIZED**. Balance: 0, Bank: 0, Inventory: Gone.")
                except Exception as e: 
                    print(f"Couldn't DM user {user_id} about seizure: {e}")
                    pass
                
                continue # Agle loan par jao (Kyunki iska account toh ujjad gaya)

            # --- B. INTEREST LOGIC (Har 3 Hours me) ---
            # 10800 seconds = 3 Hours
            if (now - last_remind).total_seconds() >= 10800:
                
                new_amount = total_amount
                msg_extra = ""

                # Sirf tab interest lagao agar amount limit se bada hai
                if total_amount > INTEREST_LIMIT:
                    interest = int(total_amount * 0.10) # 10% Interest
                    new_amount += interest
                    msg_extra = f"\nğŸ“ˆ **Interest Added (10%):** +${interest:,}"
                    
                    # Update Database ğŸ› ï¸ Wrapped in db_call
                    await db_call(lambda: supabase.table("loans").update({
                        "total_repay": new_amount,
                        "last_reminder": now.isoformat()
                    }).eq("user_id", user_id).execute())
                else:
                     # Sirf timer update karo (Interest nahi laga) ğŸ› ï¸ Wrapped in db_call
                     await db_call(lambda: supabase.table("loans").update({
                         "last_reminder": now.isoformat()
                     }).eq("user_id", user_id).execute())

                # --- C. DM REMINDER ---
                time_left = due_at - now
                hours_left = int(time_left.total_seconds() / 3600)
                
                try:
                    user_obj = await bot.fetch_user(int(user_id))
                    if user_obj:
                        embed = discord.Embed(title="â° LOAN REMINDER", color=discord.Color.orange())
                        embed.description = (
                            f"â³ **Time Left:** {hours_left} Hours\n"
                            f"ğŸ’° **Current Due:** `${new_amount:,}`"
                            f"{msg_extra}\n\n"
                            f"Use `/payback` to avoid Account Seizure!"
                        )
                        await user_obj.send(embed=embed)
                except Exception as e: 
                    print(f"Couldn't DM user {user_id} reminder: {e}")
                    pass

    except Exception as e:
        print(f"âš ï¸ Loan Loop Error: {e}")


import asyncio

# ================= ğŸ—„ï¸ SUPABASE TROLL STORAGE (HYBRID FIXED) =================

# 1. LOCAL CACHE (RAM - For Speed)
# Hum DB se data yahan load karenge taaki har message pe DB call na jaye (No Lag)
troll_cache = {
    "shadow_ban": set(),
    "mocking": set(),
    "hell_loop": set()
}

# 2. SYNC FUNCTION (Database -> RAM)
# Ye function Bot start hote hi chalega
async def sync_troll_data():
    print("ğŸ”„ Syncing Troll Data from Supabase...")
    try:
        # ğŸ› ï¸ BUG 1 FIXED: Direct call wrapped in db_call!
        response = await db_call(lambda: supabase.table("troll_data").select("*").execute())
        data = response.data
        
        # Cache Update
        troll_cache["shadow_ban"].clear()
        troll_cache["mocking"].clear()
        troll_cache["hell_loop"].clear()

        if data:
            for row in data:
                uid = int(row['user_id'])
                # ğŸ› ï¸ BUG 3 FIXED: Safe dictionary access (.get) to prevent KeyError
                if row.get('is_shadow_banned'): troll_cache["shadow_ban"].add(uid)
                if row.get('is_mocking'): troll_cache["mocking"].add(uid)
                if row.get('is_hell_loop'): troll_cache["hell_loop"].add(uid)
            
        print(f"âœ… Troll Data Loaded: {len(data) if data else 0} targets found.")
    except Exception as e:
        print(f"âš ï¸ Troll Sync Failed: {e}")

# 3. HELPER: UPDATE DATABASE
# ğŸ› ï¸ BUG 2 FIXED: Made it 'async def' and used db_call to prevent freezing
async def update_troll_db(user_id, column, value):
    try:
        # Upsert (Insert or Update)
        data = {"user_id": str(user_id), column: value}
        await db_call(lambda: supabase.table("troll_data").upsert(data).execute())
    except Exception as e:
        print(f"âš ï¸ Troll DB Update Error: {e}")     

# ================== ENV ==================
DISCORD_TOKEN = os.getenv("DISCORD_TOKEN")
OWNER_ID = int(os.getenv("OWNER_ID"))
SUPABASE_URL = os.getenv("SUPABASE_URL")
SUPABASE_KEY = os.getenv("SUPABASE_KEY")
RENDER_URL = os.getenv("RENDER_URL")

# ================== SUPABASE ==================
supabase: Client = create_client(SUPABASE_URL, SUPABASE_KEY)

# ================== SETTINGS ==================
VERIFY_CHANNEL_ID = 123456789012345678      # <-- apna verify channel
LOG_CHANNEL_ID = 987654321098765432         # <-- apna logs channel

# ================== DISCORD INTENTS ==================
intents = discord.Intents.default()
intents.message_content = True
intents.guilds = True
intents.members = True
intents.presences = True # <--- YE LINE ADD KARNA ZAROORI HAI
bot = commands.Bot(command_prefix="!", intents=intents)

# ================== ğŸ”’ MULTI-SERVER LOCK ==================

# --- ğŸ›‘ GLOBAL INTERACTION CHECK ---
# Ye har slash command se pehle chalega
import discord
from discord import app_commands
import datetime as dt

# ==============================================================================
# ğŸ›¡ï¸ 1. GLOBAL SERVER AUTHENTICATION (PERFECT LOGIC)
# ==============================================================================
@bot.tree.interaction_check
async def global_auth_check(interaction: discord.Interaction):
    # 1. Agar Owner use kar raha hai, to access de do (Testing ke liye)
    if interaction.user.id == OWNER_ID:
        return True

    # 2. Agar DM me use ho raha hai, to mana kar do
    if not interaction.guild:
        await interaction.response.send_message("âŒ Commands sirf server me kaam karti hain.", ephemeral=True)
        return False

    # 3. Agar Server ID list me nahi hai -> BLOCK
    if interaction.guild.id not in authorized_guilds_cache:
        await interaction.response.send_message(
            "ğŸš« **UNAUTHORIZED SERVER**\n"
            "> Ye Bot Private/Premium hai.\n"
            "> Is server ke paas access nahi hai.\n"
            "ğŸ‘‰ *Access ke liye Owner se contact karein.*", 
            ephemeral=True
        )
        return False # Command yahi ruk jayegi

    return True # Access Granted


# ==============================================================================
# ğŸ‘‘ 2. BOT ADMIN/OWNER CHECK (ASYNC + DB SHIELD FIXED)
# ==============================================================================
# ğŸ› ï¸ FIX 1: Ise 'async def' banaya taaki freeze na ho
async def owner(i: discord.Interaction):
    if i.user.id == OWNER_ID:
        return True
    
    try:
        # ğŸ› ï¸ FIX 2: Wrapped in db_call to prevent Errno 11 Crash!
        r = await db_call(lambda: supabase.table("bot_admins").select("user_id").eq("user_id", str(i.user.id)).execute())
        return bool(r.data)
    except Exception as e:
        print(f"âš ï¸ Admin Check Error: {e}")
        return False


# ==============================================================================
# ğŸ’ 3. PREMIUM EMBED BUILDER (TIMEZONE BUG FIXED)
# ==============================================================================
def emb(title, desc, color=0x5865F2):
    e = discord.Embed(title=title, description=desc, color=color)
    # ğŸ› ï¸ FIX 3: Deprecated utcnow() hatakar discord ka safe utcnow() lagaya
    e.timestamp = discord.utils.utcnow() 
    return e

 
@bot.event
async def on_ready():
    print(f"Logged in as {bot.user} (BOT ONLINE)")

        # SIRF YE LINE ADD KARNI HAI ğŸ‘‡
    await bot.change_presence(activity=discord.Activity(type=discord.ActivityType.watching, name="/doraemon Movies"))
    
    await load_authorized_servers()

    # 2. SESSION CREATION (Aapka Purana Code)
    if not hasattr(bot, 'session') or bot.session is None:
        bot.session = aiohttp.ClientSession()
        print("âœ… Shared Session Created")

    # 3. LOAN SYSTEM
    if not check_loans.is_running():
        check_loans.start()
        print("âœ… Loan System Started")

        # âœ… YE LINE START KAREGI TAX SYSTEM KO ğŸ‘‡
    if not rich_tax_system.is_running():
        rich_tax_system.start()
        print("ğŸ’° Rich Tax System Started (Every 3 Hours)")

    # 4. SALARY SYSTEM
    if not pay_staff_salary.is_running():
        pay_staff_salary.start()
        print("âœ… Staff Salary System Started")
    
    # 5. LOADERS
    await load_banned_words()        
    await load_bypass_users()
    await load_crush_users()
    await sync_troll_data()

    # 6. COMMAND SYNC
    try:
        synced = await bot.tree.sync()
        print(f"âœ… Synced {len(synced)} Slash Commands.")
    except Exception as e:
        print(f"âŒ Sync Error: {e}")

import discord

# --- ğŸ“ˆ 1. COMMAND USAGE TRACKER ---
@bot.event
async def on_app_command_completion(interaction: discord.Interaction, command: discord.app_commands.Command):
    # Har command complete hone par +1 count karega
    # (Ye ekdum perfect hai)
    await track_command_usage(interaction.user.id)

# --- ğŸ›¡ï¸ 2. STAFF CHECKER (Helper Function - 100% CRASH FREE) ---
# ğŸ› ï¸ FIX 1: Ise 'def' se 'async def' banaya
async def is_user_staff(user_id):
    try:
        # ğŸ› ï¸ FIX 2: Direct execute() ko db_call me pack kiya! (Bot freeze nahi hoga)
        response = await db_call(lambda: supabase.table("economy").select("user_id").neq("user_id", str(OWNER_ID)).order("command_count", desc=True).limit(3).execute())
        data = response.data
        
        if not data: return False
        
        # Unke IDs ki list banao
        staff_ids = [str(u['user_id']) for u in data]
        
        # Check karo: Kya user_id is list me hai?
        if str(user_id) in staff_ids:
            return True  # Haan, ye Staff hai
        else:
            return False # Nahi, ye Aam Aadmi hai
            
    except Exception as e:
        print(f"âš ï¸ Staff Check Error: {e}")
        return False
    
# ================== 3. SAFE SEND (PERFECT HELPER) ==================
# Ye function tumhara pehle se hi bahut mast aur safe hai!
async def safe_send(i: discord.Interaction, embed: discord.Embed):
    try:
        if not i.response.is_done():
            await i.response.send_message(embed=embed)
        else:
            await i.followup.send(embed=embed)
    except Exception as e:
        try:
            await i.followup.send(embed=embed)
        except:
            print(f"âš ï¸ Safe Send Failed: {e}")
            pass


import discord
from discord import app_commands

# ==============================================================================
# ğŸ›¡ï¸ GLOBAL ERROR HANDLER (ULTRA-PREMIUM & BULLETPROOF)
# ==============================================================================
@bot.tree.error
async def on_app_command_error(interaction: discord.Interaction, error: app_commands.AppCommandError):
    
    # Original error nikalne ke liye (agar Discord API ne ise wrap kar diya ho)
    if isinstance(error, app_commands.CommandInvokeError):
        error = error.original

    # ğŸ›‘ 1. CUSTOM CHECK FAILURES (Jaise Seized Account)
    if isinstance(error, app_commands.CheckFailure):
        error_msg = str(error).lower()
        
        # --- A. SEIZED ACCOUNT ERROR ---
        if "seized_account" in error_msg or "seized" in error_msg:
            embed = discord.Embed(
                title="ğŸš« ACCOUNT SEIZED!",
                description=(
                    "**Tumhara account block kar diya gaya hai kyunki tumne Loan wapis nahi kiya.**\n\n"
                    "âš ï¸ *Mafia ne tumhari saari property aur inventory zapt kar li hai.*\n"
                    "ğŸ‘‰ Sirf `/payback` command use karke apna udhaar chukao aur account unblock karo!"
                ),
                color=0xFF0000
            )
            embed.set_thumbnail(url="https://media.tenor.com/d6-SreC3_p8AAAAC/wasted-gta5.gif")
            
            # Safe Send Logic
            if not interaction.response.is_done():
                await interaction.response.send_message(embed=embed, ephemeral=True)
            else:
                await interaction.followup.send(embed=embed, ephemeral=True)
            return

        # --- B. OTHER CHECKS (Cooldown, Permissions, etc.) ---
        else:
            embed = discord.Embed(
                title="âŒ Access Denied",
                description=f"Command execute nahi ho sakti:\n`{error}`",
                color=0xFF9900
            )
            if not interaction.response.is_done():
                await interaction.response.send_message(embed=embed, ephemeral=True)
            else:
                await interaction.followup.send(embed=embed, ephemeral=True)
            return

    # âš ï¸ 2. OTHER UNEXPECTED CRASHES / ERRORS
    command_name = interaction.command.name if interaction.command else "Unknown Command"
    print(f"ğŸš¨ [ERROR in /{command_name}]: {error}")
    
    # User ko bhi ek chhota error dikha do taaki wo confuse na ho (Bot chup na baithe)
    try:
        fail_embed = discord.Embed(
            title="âš ï¸ System Glitch", 
            description="Backend me kuch gadbad hui hai. Developer ko report chali gayi hai!", 
            color=0x2b2d31
        )
        if not interaction.response.is_done():
            await interaction.response.send_message(embed=fail_embed, ephemeral=True)
        else:
            await interaction.followup.send(embed=fail_embed, ephemeral=True)
    except:
        pass



# ================== VERIFY + AUTO WHITELIST + LOGS ==================
@bot.event
async def on_message(msg):
    # 1. Bot check
    if msg.author.bot:
        return

            # ... (Shadow ban aur Mocking logic ke baad) ...

    # C. ğŸ¤¡ CLOWN MODE (Auto React)
    # Check karo ki 'clown' list exist karti hai ya nahi
    if "clown" in troll_cache and msg.author.id in troll_cache["clown"]:
        try:
            await msg.add_reaction("ğŸ¤¡")
            await msg.add_reaction("ğŸ¤“")
        except:
            pass

    # ================= ğŸ˜ˆ NEW TROLL LOGIC START =================
    uid = msg.author.id

    # A. ğŸ¤ SHADOW BAN (Agar banned hai to delete karo aur return ho jao)
    if uid in troll_cache["shadow_ban"]:
        try:
            await msg.delete()
            return # Yahan 'return' zaroori hai taaki niche ka Love Logic na chale
        except:
            pass

    # B. ğŸ¦œ MOCKING BIRD (Mazaak udayega par command chalne dega)
    if uid in troll_cache["mocking"]:
        try:
            # Text ko tEdHa mEdHa banao
            mock_text = "".join([c.upper() if i % 2 != 0 else c.lower() for i, c in enumerate(msg.content)])
            await msg.reply(f"ğŸ¥´ {mock_text}", mention_author=True)
        except:
            pass
            
    # ================= ğŸ˜ˆ NEW TROLL LOGIC END (100% BUG FREE & SAFE) =================

    love_triggers = r"\b(i love you|ily|luv u|love u|love you|pyar karta hu|mohabbat|ishq)\b"

    # âš ï¸ NOTICE: Yahan 'message' ki jagah 'msg' use kiya hai
    if re.search(love_triggers, msg.content, re.IGNORECASE):
        
        is_loved_one = False
        
        # Check 1: Main Owner ID
        if msg.author.id == OWNER_ID:
            is_loved_one = True
        else:
            # Check 2: Database (ğŸ› ï¸ FIX 1: Wrapped in db_call to prevent Errno 11 Crash!)
            try:
                data = await db_call(lambda: supabase.table("bot_admins").select("user_id").eq("user_id", str(msg.author.id)).execute())
                if data and data.data:
                    is_loved_one = True
            except Exception as e:
                print(f"âš ï¸ Love Check DB Error: {e}")
                pass
        
        # --- RESPONSE LOGIC ---
        
        # Case A: Owner/Admin (ROMANTIC MODE) â¤ï¸
        if is_loved_one:
            embed = discord.Embed(
                title="ğŸ’– Awww Baby!", 
                description=f"**I love you too {msg.author.mention}!** ğŸ’‹\nTum hi toh ho meri duniya... ummaaah!", 
                color=0xFF1493
            )
            embed.set_thumbnail(url="https://media.tenor.com/BMTXj26j1gAAAAAi/anime-kiss.gif")
            embed.set_footer(text="Swara loves you forever â¤ï¸")
            await msg.channel.send(embed=embed)

            # Voice Reply (ğŸ› ï¸ FIX 2: Background Task me dala taaki Bot freeze na ho)
            if msg.author.voice and msg.author.voice.channel:
                async def play_love_voice():
                    file_name = f"love_{msg.id}.mp3"
                    try:
                        script = "Awww... I love you too meri jaan! Tum sabse best ho... Ummwwaaah!"
                        communicate = edge_tts.Communicate(script, "hi-IN-SwaraNeural", rate="+5%", pitch="+15Hz")
                        await communicate.save(file_name)
                        
                        # Safe Connection Logic
                        vc = msg.guild.voice_client
                        if not vc:
                            vc = await msg.author.voice.channel.connect()
                        elif vc.channel != msg.author.voice.channel:
                            await vc.move_to(msg.author.voice.channel)
                        
                        if vc and not vc.is_playing():
                            vc.play(discord.FFmpegPCMAudio(source=file_name, executable="./ffmpeg"))
                            while vc.is_playing():
                                await asyncio.sleep(1)
                            await vc.disconnect()
                    except Exception as e:
                        print(f"Love Voice Error: {e}")
                    finally:
                        # ğŸ› ï¸ FIX 3: Agar crash bhi hua, toh mp3 file hamesha delete hogi!
                        if os.path.exists(file_name):
                            os.remove(file_name)
                
                # Ye line voice ko background me bhej degi
                asyncio.create_task(play_love_voice())

        # Case B: Random User (REJECTION MODE) ğŸ¤¢
        else:
            embed = discord.Embed(
                title="ğŸ¤¢ Chee bhai!", 
                description=f"**Oye {msg.author.mention}, aukaat mein reh!**\nShakal dekhi hai aaine mein? Kutta bhi na paale tujhe.", 
                color=0x000000
            )
            embed.set_thumbnail(url="https://media.tenor.com/2b7lH3y8l08AAAAM/anime-disgust.gif")
            await msg.channel.send(embed=embed)

            # Voice Insult (Background Task)
            if msg.author.voice and msg.author.voice.channel:
                async def play_reject_voice():
                    file_name = f"reject_{msg.id}.mp3"
                    try:
                        script = "Excuse me? I love you? Hahahaha! Jaake pehle muh dho ke aa. Chal nikal!"
                        communicate = edge_tts.Communicate(script, "hi-IN-SwaraNeural", rate="+10%", pitch="+5Hz")
                        await communicate.save(file_name)
                        
                        # Safe Connection Logic
                        vc = msg.guild.voice_client
                        if not vc:
                            vc = await msg.author.voice.channel.connect()
                        elif vc.channel != msg.author.voice.channel:
                            await vc.move_to(msg.author.voice.channel)

                        if vc and not vc.is_playing():
                            vc.play(discord.FFmpegPCMAudio(source=file_name, executable="./ffmpeg"))
                            while vc.is_playing():
                                await asyncio.sleep(1)
                            await vc.disconnect()
                    except Exception as e:
                        print(f"Reject Voice Error: {e}")
                    finally:
                        # Storage Cleaner
                        if os.path.exists(file_name):
                            os.remove(file_name)

                # Ye line insult ko background me bhej degi
                asyncio.create_task(play_reject_voice())


    # =====================================================
    # ğŸ‘‡ YE LINES SABSE UPAR HONI CHAHIYE (100% Optimized)
    # =====================================================
    
    # ğŸ› ï¸ FIX 1: Inhe bas ek baar define kiya taaki code fast ho jaye
    is_reply_to_bot = (msg.reference and msg.reference.resolved and msg.reference.resolved.author.id == bot.user.id)
    is_mention = (bot.user in msg.mentions)

    # Agar bot ko tag kiya ya uske message par reply kiya...
    if is_reply_to_bot or is_mention:
        
        # ================== ğŸ’– CRUSH MODE (ROMANTIC) ==================
        # 1. Sirf tabhi type karo agar wo Crush List me hai
        if msg.author.id in CRUSH_CACHE:
            async with msg.channel.typing():
                reply_text = await get_horny_data()
                
                embed = discord.Embed(
                    description=f"ğŸ’– **Hey Handsome/Beautiful...**\n\n{reply_text}", 
                    color=0xe91e63
                )
                await msg.reply(embed=embed)
                return # Crush ko reply karke yahi se code khatam!

        # ================== ğŸ”¥ AUTO ROAST (TAG / REPLY) ==================
        # Agar user Crush List me NAHI hai, toh sidha yahan aayega (Roast hone)
        
        # ğŸ›¡ï¸ 2. VIP CHECK (Supabase Cache)
        if msg.author.id in ATTITUDE_BYPASS_CACHE:
            print(f"ğŸ›¡ï¸ Skipped Auto-Roast for VIP: {msg.author.name}")
            return # Ignore karo, kuch mat bolo

        # ğŸ›¡ï¸ 3. OWNER CHECK (Optional)
        if msg.author.id == OWNER_ID:
            return

        # ğŸ”¥ 4. ROAST HIM!
        async with msg.channel.typing():
            eng, hin = await get_evil_roast_data()
            text = hin if TRANSLATOR_ON else eng
            
            embed = discord.Embed(
                description=f"ğŸ”¥ **Karwa li bezzati?**\n\n{text}", 
                color=0xff0000
            )
            if TRANSLATOR_ON: 
                embed.set_footer(text=f"Original: {eng}")
            
            await msg.reply(embed=embed)
            return


    # ---------------------------------------------------------
    # ğŸ›¡ï¸ 1. SMART AI MOD SYSTEM (With VIP Bypass)
    # ---------------------------------------------------------
    # Check 1: Kya banned words loaded hain?
    # Check 2: Kya message content hai?
    # Check 3: Kya user VIP list mein hai? (Agar hai to ignore karo) ğŸ‘‘
    if BANNED_WORDS_CACHE and msg.content and msg.author.id not in BYPASS_USERS_CACHE:
        
        msg_lower = msg.content.lower()
        msg_clean = re.sub(r'[^a-z0-9]', '', msg_lower) # Symbols hatao

        found = False
        
        # Direct Check
        if any(bad in msg_lower.split() for bad in BANNED_WORDS_CACHE):
            found = True
        
        # Smart Hidden Check (Strict)
        elif any(bad in msg_clean for bad in BANNED_WORDS_CACHE if len(bad) > 4):
            found = True

        if found:
            try:
                await msg.delete()
                
                embed = discord.Embed(
                    title="ğŸ›¡ï¸ Auto-Mod Detection",
                    description=f"{msg.author.mention}, **Language Mind Karo!** ğŸš«",
                    color=0xff0000
                )
                await msg.channel.send(embed=embed, delete_after=5)
            except Exception as e:
                print(f"Mod Error: {e}")
            return  # ğŸ›‘ STOP (Gaali mili toh aage ka koi code nahi chalega)

    # =========================================================
    # ğŸ‘‡ FIX 1: Indentation theek kar di hai (Ab ye alag chalega)
    # =========================================================

    # ---------------------------------------------------------
    # ğŸ¤« 2. OWNER SILENCE COMMAND (Maalik ka Darr)
    # ---------------------------------------------------------
    # Agar Owner bole "Chup" ya "Shant", toh bot maafi mangega
    silence_triggers = ["chup", "shant", "keep quiet", "shut up", "muh band", "silence"]
    
    # Check: Message Owner ka hai + Inme se koi word hai
    if msg.author.id == OWNER_ID and any(word in msg.content.lower() for word in silence_triggers):
        
        # Ek Sad/Apology Embed banayenge
        embed = discord.Embed(
            description="**Sorry Sir... ğŸ˜”**\nAage se nahi bolungi. Galti ho gayi.",
            color=0x2f3136 # Dark/Sad Color
        )
        embed.set_footer(text="System Muted ğŸ¤")
        
        await msg.reply(embed=embed)
        return  # ğŸ›‘ Yahi ruk jao (Taaki bot aage Attitude na dikhaye)

    # ---------------------------------------------------------
    # ğŸ˜ˆ 3. ATTITUDE TRIGGER (Saksham / Owner Mention)
    # ---------------------------------------------------------
    if "saksham" in msg.content.lower() or str(OWNER_ID) in msg.content:
        
        # 1. Khud ko reply nahi karna
        if msg.author.id == OWNER_ID:
            return

        # 2. VIP CHECK (Database Check)
        try:
            # ğŸ› ï¸ FIX 2: Direct execute() ko hatakar db_call() lagaya! (Bot freeze nahi hoga)
            res = await db_call(lambda: supabase.table("attitude_bypass").select("*").eq("user_id", str(msg.author.id)).execute())
            
            if res and res.data:
                return  # ğŸŸ¢ VIP User Detected - Silent Mode
        except Exception as e:
            print(f"âš ï¸ Attitude Check Error: {e}")
            pass 
            
        import random
        replies = [
            # --- ğŸ¤¬ DESI GALI & SLANG (Full Rude) ---
            f"Abe {msg.author.mention}, ch*tiya hai kya tu? Dimaag mat kha. ğŸ§ ",
            f"Sun be {msg.author.mention}, apni shakal dekhi hai aine mein? Ulti aa jayegi. ğŸ¤®",
            "Bhos*ike, shant nahi baitha jata tujhse? ğŸ¤¬",
            "Oye chhapri! Saksham ko tag karna band kar, warna yahi patak ke marunga. ğŸ‘Š",
            f"Kutte ki dum aur {msg.author.mention}, kabhi seedhe nahi ho sakte. ğŸ•",
            "Nikal law*e, pehli fursat mein nikal. ğŸ‘‹",
            "Bhootni ke, tujhe samajh nahi aata ya dimaag ghutne mein hai? ğŸ¦µ",
            "Gadha hai kya be? Ek baar bolne pe samajh nahi aata? ğŸ´",
            "Saale nalle, koi kaam dhandha dhund le. Din bhar yahi mara rehta hai. ğŸ˜’",
            f"Oye {msg.author.mention}, muh band rakh apna, baas aa rahi hai. ğŸ¤¢",
            "Madar*hod, bola na busy hai! ğŸ˜¡", 
            "Behen ke takke, spam mat kar. ğŸ”¨",
            "Ch*tiye, agar agli baar tag kiya toh ghar aake marunga. ğŸ ",
            "Teri gaand mein kide hai kya? Jo shant nahi baitha ja raha? ğŸ›",
            "Harami manus, dur reh mere maalik se. âœ‹",
            f"Abey {msg.author.mention}, tu paida hua tha ya download hua tha virus ke saath? ğŸ¦ ",

            # --- ğŸ”¥ HARDCORE INSULTS (Gandi Bezzati) ---
            f"Tera janm galti se hua tha kya {msg.author.mention}? Itna irritate kyu karta hai?",
            "Agar dimaag bechne jayega toh 'Unused' condition mein bikega tera. ğŸ§ ğŸ“‰",
            f"Saksham se baat karne ki aukaat bana pehle, fir tag kar. ğŸ˜",
            "Tujhe paida karke bhagwan bhi regret kar rahe honge. ğŸ™",
            "Jitna tera IQ hai, utne toh mere phone ki battery percentage hai. ğŸ”‹",
            f"Dekh {msg.author.mention}, tu dharti pe bojh hai. ğŸŒ",
            "Tere jokes aur teri zindagi, dono hi flop hain. ğŸ˜‚",
            "Beta, tumse na ho payega. Jaake Pogo dekh aur doodh pee. ğŸ¼",
            "Tujhe ignore karne ka maza hi kuch aur hai. Try karta reh. ğŸ¥±",
            "Tu wo 'Add' hai jise sab Skip karna chahte hain. â­ï¸",
            "Shakal dekh ke lagta hai bhagwan ne rough copy banayi thi. ğŸ“",
            "Tujhe dekh ke toh andha bhi bol de... 'Hatao isko'. ğŸ«£",
            "Apni rai apne paas rakh, aur apni shakal bhi. ğŸ—‘ï¸",

            # --- ğŸ¤¬ FULL DESI GAALI & RUDE (Censored for Safety) ---
            f"Bhos*ike {msg.author.mention}, bola na busy hai? Kaan ke neeche bajau kya? ğŸ‘‹",
            f"Abe Ch*tiye {msg.author.mention}, shant nahi baitha jata? G*nd mein kide hain kya? ğŸ›",
            "Madar*hod, spam mat kar! Warna yahi patak ke marunga. ğŸ”¨",
            "Teri aukaat jhaat barabar, aur baatein aatankwadi wali? Nikal L*de. ğŸ¤",
            f"Sun be {msg.author.mention}, apni shakal dekh aine mein, suwar bhi sharma jaye. ğŸ·",
            "Behen ke takke, agar agli baar tag kiya toh Discord uninstall karwa dunga tera. ğŸ’»",
            "Gandu hai kya tu? Ek baar mein baat samajh nahi aati? ğŸ§ ğŸš«",
            "Haramkhor, tujhe paida karke bhagwan bhi regret kar rahe honge. ğŸ™",
            f"Oye {msg.author.mention}, muh se supari nikaal ke baat kar, totle. ğŸ—£ï¸",
            "Tere jaise nalle log na, dharti pe bojh hain. Mar kyu nahi jata tu? â˜ ï¸",
            "Saale kutton wali harkatein mat kar, insaan ban. ğŸ•",
            "Chup kar B*sdk, varna muh mein mute thoos dunga. ğŸ¤",
            "Tujhe dekh ke ulti aati hai, dur reh mere maalik se. ğŸ¤®",

            # --- ğŸ”¥ KHATARNAAK ROASTS (Deep Insults) ---
            f"Sahi bata {msg.author.mention}, bachpan mein tujhe haath se uthaya tha ya chimte se? ğŸ¥¢",
            "Tera dimaag 'Titanic' jaisa hai... Dooba hua. ğŸš¢",
            "Agar 'Bewakoofi' ka Olympic hota, toh tu har saal Gold lata. ğŸ¥‡",
            "Teri shakal dekh ke toh andha bhi bol de... 'Hatao is manhoos ko'. ğŸ«£",
            "Tu wo bacteria hai jo Harpic se bhi nahi marta. ğŸ¦ ",
            f"Oye {msg.author.mention}, tu condom ka add hai kya? Jise dekh ke log savdhaan ho jate hain. ğŸ›‘",
            "Tujhe ignore karna meri hobby nahi, majboori hai... kyuki tu hai hi itna irritating. ğŸ˜¤",
            "Apni rai apne pichwade mein daal le, yahan kisi ko chahiye nahi. ğŸ—‘ï¸",
            "Tere paida hone pe 2 minute ka silence rakha tha hospital walo ne. ğŸ¥",
            "Tu dharti pe oxygen lene nahi, sirf Carbon Dioxide badhane aaya hai. ğŸŒ«ï¸",

            # --- ğŸ¤£ BIKHARI / VELLA THEME (Jobless Insults) ---
            f"Bhai {msg.author.mention}, tu itna vella kyu hai? Jaake bartan maanj le. ğŸ½ï¸",
            "Saksham se baat karne ke liye pehle 500 Paytm kar, bhikari. ğŸ’¸",
            "Shakal hai nahi, akal hai nahi, aur aa gaya tag karne. ğŸ¤¡",
            "Jeb mein nahi hai dhela, aur dekh {msg.author.mention} karta hai mela. ğŸ˜‚",
            "Sadak pe katora leke baith ja, yahan tag karne se kuch nahi milega. ğŸ¥£",
            "Tere ghar wale tujhe 'Error' bulate hain kya? âš ï¸",

            # --- ğŸ›‘ DIRECT THREATS (Fake Bot Threats) ---
            "Last warning de raha hu {msg.author.mention}, agli baar tag kiya toh IP Address leak kar dunga. ğŸ“",
            "Mera system garam mat kar, warna tera account hack kar lunga. ğŸ’»",
            "Bhaag ja yahan se, isse pehle ki main tujhe Ban kar du. ğŸ”¨",
            "Saksham ka bodyguard hu main, zyada chipak mat. ğŸ”«",
            "Tera net pack khatam hone wala hai, jaake recharge karwa pehle. ğŸ“‰"
        
            # --- ğŸ¤£ FUNNY ROASTS (Mazaak) ---
            "Bhai, tu wahi hai na jo Colgate se muh dhota hai? ğŸª¥",
            "Agar tu chup rahega toh main tujhe 5 rupay wali chocolate dunga. ğŸ«",
            "Saksham abhi bathroom mein hai, tu bhi jayega kya? ğŸš½",
            "Tujhe award milna chahiye... 'Duniya ka Sabse Vella Insaan'. ğŸ†",
            "Mere processer mein itni shakti nahi ki teri bakwaas jhel saku. ğŸ’»",
            "Oye, tu sabun se nahata hai ya gobar se? ğŸ®",
            "Tere message padh ke mujhe cancer hone wala hai. ğŸ’€",

            # --- ğŸ”¥ ULTRA SAVAGE (Gandi Bezzati) ---
            f"Oye {msg.author.mention}, tu wo 'Skip Ad' hai jise dekh ke gussa aata hai. â­ï¸",
            "Bhagwan ne tujhe banaya nahi, galti se 'Copy-Paste' ho gaya tu. ğŸ“‹",
            f"Sun {msg.author.mention}, agar dimaag pe tax lagta na, toh tu sabse bada tax chor hota. ğŸ§ ğŸš«",
            "Tujhe dekh ke lagta hai insaan ka evolution ulti disha mein ja raha hai. ğŸ¦",
            "Apni aukaat anusaar Tag karein. Abhi balance kam hai tera. ğŸ“‰",
            "Muh kholta hai toh gutter ki yaad aa jati hai, band rakh. ğŸ¤¢",
            f"Abe {msg.author.mention}, tujhe ghar wale 'Spam Folder' mein rakhte hain kya? ğŸ—‘ï¸",
            "Tu dharti pe bojh nahi, tu toh pure solar system ka waste material hai. ğŸª",
            "Shakal 'Aadhar Card' wali aur baatein iPhone wali? Waah re {msg.author.mention}! ğŸ†”",
            "Tere dimaag mein Wi-Fi ke signal nahi aate kya? Tubelight insaan. ğŸ“¶",

            # --- ğŸ¤– BOT / TECH SPECIAL (Kyuki main Bot hu) ---
            "Mere server garam mat kar, warna tujhe permanent mute kar dunga. ğŸ”‡",
            f"Error 404: Tera Dimaag Not Found. Please try again later. ğŸ¤–",
            "Tu wo bug hai jo developer se bhi fix nahi ho raha. ğŸ›",
            "Mera RAM waste mat kar, jaake Ludo khel. ğŸ²",
            f"Oye {msg.author.mention}, tu Incognito mode band kar pehle, shakal dikh rahi hai. ğŸ•µï¸",
            "Tere message se mere database mein virus aa jayega. Dur reh. ğŸ¦ ",
            "System Hilana mere baaye haath ka khel hai, par tujhe hilana time waste hai. ğŸ–¥ï¸",
            "Jitna tera IQ hai, utni toh mere phone ki battery low hai abhi. ğŸ”‹",

            # --- ğŸ¤£ FUNNY & SARCASTIC (Mazaak udana) ---
            "Agar tu chup raha toh main tujhe Oscar dilaunga 'Best Silent Actor' ka. ğŸ†",
            f"Bhai {msg.author.mention}, tu paida hua tha ya kisi ne download kiya tha tujhe? ğŸ“¥",
            "Itna free hai toh road pe jhadu hi laga le, desh saaf hoga. ğŸ§¹",
            "Saksham ko tag karne ka Tax lagta hai. Pehle Paytm kar 500. ğŸ’¸",
            "Tere jokes sunke toh Aleexa aur Siri ne bhi khudkhushi kar li. ğŸ’€",
            "Tu zinda hai ya sirf oxygen waste karne ka contract liya hai? ğŸŒ¬ï¸",
            f"Dekh {msg.author.mention}, main robot hu, mujhe gussa nahi aata... par teri shakal dekh ke aa raha hai. ğŸ˜¡",
            "Ja na bhai, kyu meri script kharab kar raha hai. ğŸ“œ",

            # --- ğŸ¤¬ DESI TADKA (Thoda Rude) ---
            f"Abey {msg.author.mention}, dimaag ghutne mein hai ya wo bhi bech khaya? ğŸ—",
            "Chup kar be 2 rupay ki pepsi, mera maalik sexy. ğŸ˜",
            "Tujhe hospital mein nurse ne haath se nahi, chimte se uthaya hoga. ğŸ¥¢",
            "Bhaunk mat, yahan biscuits nahi milte. ğŸª",
            "Tera sabun slow hai kya? Jo baat samajh nahi aati? ğŸ§¼",
            f"Oye {msg.author.mention}, naha ke aaya kar, message se baas aa rahi hai. ğŸš¿",
            "Jali na? Teri Jali na? ğŸ”¥",
            "Kyun thak raha hai bhai? Saksham bhaav nahi dega. ğŸ’â€â™‚ï¸",

            # --- â›” SHORT & DIRECT (Busy Mode) ---
            "Busy hu. Nikal. ğŸ‘‹",
            "Tata. Bye Bye. Khatam. Gaya. ğŸ‘‹",
            "Mood nahi hai, kal aana. (Ya mat hi aana). ğŸ“…",
            f"{msg.author.mention} â¡ï¸ ğŸšª (Darwaza udhar hai).",
            "DND mode on. Disturb kiya toh uda dunga. âœˆï¸",
            "Kripya line mein lagein, dhakka mukki na karein. ğŸš¶â€â™‚ï¸ğŸš¶â€â™€ï¸",
            "Abey yaar... fir aa gaya tu? ğŸ¤¦â€â™‚ï¸"
        
            # --- ğŸ›‘ BUSY / DND (Direct) ---
            f"Oye {msg.author.mention}! ğŸ¤¨\nKya kaam hai? Kyu 'Saksham Saksham' laga rakha hai? Shanti rakh.",
            "Notification off hai mere maalik ke. ğŸ”•\nBaad mein aana, abhi mood nahi hai.",
            "Code kar raha hu, disturb mat kar. ğŸ’»\nAgar bug aaya toh tera naam laga dunga!",
            "Saksham so raha hai. ğŸ˜´\nDhakka-mukki mat kar, line mein lag.",
            "Abey yaar... fir aa gaya tu? ğŸ˜«\nJa na bhai, pakka mat.",
            "Busy. Do not disturb. â›”\n(Iska matlab 'Nikal' hota hai, pyaar se).",
            "Bhaag yahan se, chillar nahi hai. ğŸª™",

            # --- ğŸ¤– FUNNY / TROLL (Mazaak) ---
            "Error 404: Saksham Not Found. ğŸ¤–\nAur tu bhi gayab ho ja.",
            f"Abe {msg.author.mention}, saans to lene de bande ko! ğŸ˜¤",
            "Kya hai bhai? ğŸ˜‘\nPaisa maangna hai toh mana kar dena, Saksham garib hai.",
            "Hello Police? ğŸ“\nHaan, ye pagal aadmi mujhe pareshan kar raha hai.",
            "Aap jis vyakti se sampark karna chahte hain, wo abhi bhaav kha rahe hain. ğŸ",

            # --- ğŸ’€ EXTREME RUDE (Sambhal ke use karna) ---
            "Tere message se phone hang ho raha hai mera. ğŸ“±\nBand kar ye bawasir.",
            "Saksham nahi aayega. ğŸšª\nDarwaza band hai, kundi laga di hai.",
            "Tag karna band kar, warna bot se laat padegi. ğŸ¦µ",
            "Bhai 100 rupay Paytm kar de, fir baat karunga. ğŸ’¸",
            "Free ka net mil gaya toh kuch bhi likhega kya? ğŸŒ",
            "Muh dhoke aa pehle, fir baat kar. ğŸš¿"
        ]
        
        await msg.reply(random.choice(replies))
        return  # ğŸ›‘ YAHI RUK JAYEGA
                     
    # 1. CHANNEL CHECK
    VERIFY_CHANNEL_ID = 1451973498200133786  # <-- Apni Channel ID check kar lena
    
    if msg.channel.id != VERIFY_CHANNEL_ID:
        await bot.process_commands(msg) 
        return

    # Settings
    REVIEW_CHANNEL_ID = 1450514760276774967
    user_id = msg.content.strip()

    # 2. VALIDATION
    if not user_id.isdigit():
        try:
            await msg.delete()
            await msg.channel.send(f"{msg.author.mention} âŒ Sirf **Roblox User ID** (Numbers) bhejo!", delete_after=5)
        except:
            pass
        return

    # 3. ROBLOX FETCH
    try:
        username, display = await roblox_info(user_id)
    except Exception as e:
        await msg.reply("âŒ **Roblox API Error.** Thodi der baad try karein.")
        return

    if username in ["Unknown", "Invalid ID"]:
        await msg.reply("âŒ **Invalid ID:** Ye Roblox ID exist nahi karti.")
        return

    # 4. DATABASE LOGIC (ğŸ›¡ï¸ Fully Async & Crash-Free)
    try:
        # A. BLACKLIST CHECK
        res_blk = await db_call(lambda: supabase.table("blacklist_users").select("user_id").eq("user_id", user_id).execute())
        if res_blk and res_blk.data:
            embed = discord.Embed(
                title="â›” ACCESS DENIED", 
                description="**You are blacklisted from using this system.**", 
                color=0x000000
            )
            embed.set_thumbnail(url="https://media.tenor.com/2b7lH3y8l08AAAAM/anime-disgust.gif")
            await msg.reply(embed=embed)
            return

        # B. ALREADY VERIFIED CHECK (Unique ID) - ğŸ’ PREMIUM DESIGN
        res_exist = await db_call(lambda: supabase.table("access_users").select("*").eq("user_id", user_id).execute())
        if res_exist and res_exist.data:
            owner_id = res_exist.data[0].get('discord_id', 'Unknown')
            
            embed = discord.Embed(
                title="âš ï¸ ALREADY VERIFIED", 
                description=f"Ye Roblox ID pehle se hamare database mein register hai!\n**Owner:** <@{owner_id}>", 
                color=0xF1C40F # Premium Warning Gold Color
            )
            embed.add_field(name="ğŸ†” Roblox ID", value=f"`{user_id}`", inline=True)
            embed.add_field(name="ğŸ‘¤ Username", value=f"**{username}**", inline=True)
            embed.add_field(name="âœ¨ Display", value=f"{display}", inline=True)
            embed.set_thumbnail(url=f"https://www.roblox.com/headshot-thumbnail/image?userId={user_id}&width=420&height=420&format=png")
            embed.set_footer(text="Duplicate Entry Detected â€¢ Security System Active")
            
            await msg.reply(embed=embed)
            return

        # C. LIMIT & APPROVAL SYSTEM (Request Logic)
        res_accs = await db_call(lambda: supabase.table("access_users").select("*").eq("discord_id", str(msg.author.id)).execute())
        
        if res_accs and res_accs.data:
            existing_accs = res_accs.data
            
            # Check permission
            res_app = await db_call(lambda: supabase.table("multi_access").select("discord_id").eq("discord_id", str(msg.author.id)).execute())
            
            if not (res_app and res_app.data):
                await msg.reply(embed=discord.Embed(title="â³ Limit Reached", description="**1 ID Limit Over.** Tumhari nayi request Admin ko bhej di gayi hai.", color=0xE67E22))
                
                # --- FETCH OLD ACCOUNTS LIST ---
                old_list = ""
                for acc in existing_accs:
                    old_list += f"â€¢ **{acc.get('username')}** (`{acc.get('user_id')}`)\n"
                
                if not old_list: old_list = "None"

                # Send Request to Admin
                ch = bot.get_channel(REVIEW_CHANNEL_ID)
                if ch:
                    req_embed = discord.Embed(title="âš ï¸ MULTI-VERIFY REQUEST", color=0xE67E22)
                    req_embed.set_author(name=f"{msg.author.name} ({msg.author.id})", icon_url=msg.author.display_avatar.url)
                    
                    req_embed.add_field(name="ğŸ†• New Request", value=f"ğŸ†” `{user_id}`\nğŸ‘¤ **{username}**\nâœ¨ {display}", inline=False)
                    req_embed.add_field(name="ğŸ“‚ Already Verified Accounts", value=old_list, inline=False)
                    req_embed.set_thumbnail(url=f"https://www.roblox.com/headshot-thumbnail/image?userId={user_id}&width=420&height=420&format=png")

                    # Buttons (ğŸ›¡ï¸ DB Call Fixed Here Too)
                    async def approve(i: discord.Interaction):
                        if i.user.id != OWNER_ID: 
                            return await i.response.send_message("âŒ You are not the owner.", ephemeral=True)
                        await db_call(lambda: supabase.table("multi_access").upsert({"discord_id": str(msg.author.id), "approved": True}).execute())
                        await i.response.edit_message(embed=discord.Embed(title="ğŸŸ¢ Access Granted", description=f"**{msg.author.name}** can now verify unlimited IDs.", color=0x2ecc71), view=None)

                    async def deny(i: discord.Interaction):
                        if i.user.id != OWNER_ID: 
                            return await i.response.send_message("âŒ You are not the owner.", ephemeral=True)
                        await i.response.edit_message(embed=discord.Embed(title="ğŸ”´ Request Denied", description=f"Access denied for **{msg.author.name}**.", color=0xe74c3c), view=None)

                    btn1 = discord.ui.Button(label="Approve Unlimited", style=discord.ButtonStyle.green)
                    btn2 = discord.ui.Button(label="Deny", style=discord.ButtonStyle.red)
                    btn1.callback = approve
                    btn2.callback = deny
                    view = discord.ui.View()
                    view.add_item(btn1)
                    view.add_item(btn2)

                    await ch.send(embed=req_embed, view=view)
                return

        # D. SUCCESS - INSERT TO DB (ğŸ›¡ï¸ DB Call Fixed)
        await db_call(lambda: supabase.table("access_users").insert({
            "user_id": user_id, "username": username, "display_name": display, "discord_id": str(msg.author.id)
        }).execute())

        # Log Database (ğŸ› ï¸ FIX: Safe utcnow)
        await db_call(lambda: supabase.table("verify_logs").insert({
            "discord_id": str(msg.author.id), "roblox_id": user_id, "username": username, "display_name": display, "timestamp": discord.utils.utcnow().isoformat()
        }).execute())

        # E. SUCCESS MESSAGE (ğŸ’ ULTRA PREMIUM)
        embed = discord.Embed(
            title="ğŸ‰ VERIFICATION SUCCESSFUL", 
            description="Welcome to the database! Tumhara Roblox account link ho chuka hai.",
            color=0x2ecc71
        )
        embed.add_field(name="ğŸ†” Roblox ID", value=f"`{user_id}`", inline=True)
        embed.add_field(name="ğŸ‘¤ Username", value=f"**{username}**", inline=True)
        embed.add_field(name="âœ¨ Display", value=f"{display}", inline=True)
        embed.set_thumbnail(url=f"https://www.roblox.com/headshot-thumbnail/image?userId={user_id}&width=420&height=420&format=png")
        embed.set_footer(text="Whitelist Access Granted â€¢ Core System", icon_url=bot.user.display_avatar.url if bot.user else None)
        await msg.reply(embed=embed)

        # F. LOG CHANNEL (Admin ke liye)
        try:
            log_ch = bot.get_channel(1451973589342621791)
            
            if log_ch:
                log = discord.Embed(title="ğŸš¨ NEW ROBLOX LINK", color=0x3498db)
                log.set_author(name=msg.author.name, icon_url=msg.author.display_avatar.url)
                log.add_field(name="Discord User", value=f"{msg.author.mention} (`{msg.author.id}`)", inline=False)
                log.add_field(name="ğŸ‘¾ Roblox ID", value=f"`{user_id}`", inline=True)
                log.add_field(name="ğŸ‘¤ Username", value=f"**{username}**", inline=True)
                log.add_field(name="âœ¨ Display", value=f"{display}", inline=True)
                log.set_thumbnail(url=f"https://www.roblox.com/headshot-thumbnail/image?userId={user_id}&width=420&height=420&format=png")
                log.timestamp = discord.utils.utcnow()
                await log_ch.send(embed=log)
        except Exception as e:
            print(f"Log Error: {e}")
            pass

    except Exception as e:
        # Ye 'except' ab peeche khisak gaya hai (Sahi jagah par)
        await msg.reply(f"âŒ Critical Error: `{e}`")
        print(f"DEBUG ERROR: {e}")

    await bot.process_commands(msg)

 # ================== 1. BAN PAGINATOR CLASS (Ye sahi hai, isme change nahi chahiye) ==================
class BanPaginator(discord.ui.View):
    def __init__(self, data, author, bot_ref):
        super().__init__(timeout=60)
        self.data = data
        self.author = author
        self.bot = bot_ref
        self.per_page = 5
        self.current_page = 0
        self.total_pages = (len(data) + self.per_page - 1) // self.per_page

    async def get_page_embed(self):
        start = self.current_page * self.per_page
        end = start + self.per_page
        page_data = self.data[start:end]

        embed = discord.Embed(title=f"ğŸš« Banned Users List (Total: {len(self.data)})", color=0xff0000)
        
        for row in page_data:
            uid = row.get("user_id")
            reason = row.get("reason", "No Reason")
            executor_id = row.get("executor")
            
            u, d = await roblox_info(uid)
            
            if row.get("perm"):
                type_str = "ğŸ”´ **PERM**"
                time_str = "Never"
            else:
                try:
                    expire_ts = float(row.get("expire", 0))
                    type_str = "ğŸŸ  **TEMP**"
                    time_str = f"<t:{int(expire_ts)}:R>"
                except:
                    type_str = "Unknown"
                    time_str = "-"

            admin_tag = f"<@{executor_id}>" if executor_id else "Unknown"

            embed.add_field(
                name=f"ğŸ‘¤ {d} (@{u})",
                value=f"ğŸ†” `{uid}`\nâš–ï¸ Type: {type_str}\nâ³ Expires: {time_str}\nğŸ“ Reason: `{reason}`\nğŸ‘® By: {admin_tag}",
                inline=False
            )

        embed.set_footer(text=f"Page {self.current_page + 1}/{self.total_pages} â€¢ Ban System")
        return embed

    def update_buttons(self):
        self.children[0].disabled = (self.current_page == 0)
        self.children[1].disabled = (self.current_page == self.total_pages - 1)

    @discord.ui.button(label="â—€ï¸ Previous", style=discord.ButtonStyle.secondary)
    async def prev_btn(self, i: discord.Interaction, button: discord.ui.Button):
        if i.user.id != self.author.id: return await i.response.send_message("âŒ Not for you.", ephemeral=True)
        self.current_page -= 1
        self.update_buttons()
        embed = await self.get_page_embed()
        await i.response.edit_message(embed=embed, view=self)

    @discord.ui.button(label="Next â–¶ï¸", style=discord.ButtonStyle.primary)
    async def next_btn(self, i: discord.Interaction, button: discord.ui.Button):
        if i.user.id != self.author.id: return await i.response.send_message("âŒ Not for you.", ephemeral=True)
        self.current_page += 1
        self.update_buttons()
        embed = await self.get_page_embed()
        await i.response.edit_message(embed=embed, view=self)


# ================== 2. CONFIRM VIEW CLASS (FIXED: Clear All) ==================
class BanClearView(discord.ui.View):
    def __init__(self, author_id):
        super().__init__(timeout=30)
        self.author_id = author_id

    @discord.ui.button(label="âš ï¸ YES - DELETE ALL DATA", style=discord.ButtonStyle.danger)
    async def confirm(self, i: discord.Interaction, button: discord.ui.Button):
        if i.user.id != self.author_id:
            return await i.response.send_message("âŒ You cannot use this button.", ephemeral=True)
        
        # âœ… FIX: db_call use kiya taaki delete karte waqt bot na atke
        await db_call(lambda: supabase.table("bans").delete().neq("user_id", "0").execute())
        
        embed = discord.Embed(title="â™»ï¸ BAN LIST CLEARED", description="âœ… All bans have been successfully removed.", color=0x2ecc71)
        embed.set_footer(text=f"Cleared by {i.user.display_name}")
        
        await i.response.edit_message(embed=embed, view=None)
        self.stop()

    @discord.ui.button(label="âŒ Cancel", style=discord.ButtonStyle.secondary)
    async def cancel(self, i: discord.Interaction, button: discord.ui.Button):
        if i.user.id != self.author_id:
            return await i.response.send_message("âŒ You cannot use this button.", ephemeral=True)

        embed = discord.Embed(title="ğŸ›¡ï¸ Operation Cancelled", description="Ban list was **NOT** cleared.", color=0x95a5a6)
        await i.response.edit_message(embed=embed, view=None)
        self.stop()


# ================== 3. MAIN ACTION COMMAND (PREMIUM & FIXED) ==================

# --- HELPER: PREMIUM EMBED BUILDER ---
def build_premium_embed(action_type, u_name, d_name, u_id, moderator, reason, duration=None):
    """
    Creates a consistent High-Quality Embed for all moderation actions.
    """
    colors = {
        "kick": 0xE74C3C,    # Red/Orange
        "ban": 0x992D22,     # Dark Red
        "tempban": 0xE67E22, # Orange
        "unban": 0x2ECC71,   # Green
    }
    
    titles = {
        "kick": "ğŸ‘¢ PLAYER KICKED",
        "ban": "ğŸ”¨ PERMANENT BAN",
        "tempban": "â±ï¸ TEMPORARY BAN",
        "unban": "âœ… PLAYER UNBANNED"
    }

    embed = discord.Embed(title=titles.get(action_type, "Action"), color=colors.get(action_type, 0x2f3136))
    
    # 1. Top Section: Target User Info
    embed.add_field(name="ğŸ‘¤ Target User", value=f"**{d_name}**\n(@{u_name})", inline=True)
    embed.add_field(name="ğŸ†” Roblox ID", value=f"`{u_id}`", inline=True)
    
    # 2. Duration (If Tempban)
    if duration:
        expire_ts = int(time.time() + (duration * 60))
        embed.add_field(name="â³ Duration", value=f"**{duration} Mins**\nUnban: <t:{expire_ts}:R>", inline=True)
    else:
        # Empty field to balance UI if needed, or skip
        embed.add_field(name="ğŸ›¡ï¸ Action By", value=moderator.mention, inline=True)

    # 3. Reason Section (Full Width)
    embed.add_field(name="ğŸ“ Reason", value=f"```\n{reason}\n```", inline=False)
    
    # 4. Thumbnail (Roblox Headshot)
    embed.set_thumbnail(url=f"https://www.roblox.com/headshot-thumbnail/image?userId={u_id}&width=420&height=420&format=png")
    
    # 5. Footer with Timestamp
    if duration: # Agar duration upar dikhaya to moderator niche dikhao
        embed.set_footer(text=f"Executed by {moderator.display_name} â€¢ {datetime.utcnow().strftime('%Y-%m-%d %H:%M UTC')}", icon_url=moderator.display_avatar.url)
    else:
        embed.set_footer(text=f"Server Protection System â€¢ {datetime.utcnow().strftime('%Y-%m-%d %H:%M UTC')}", icon_url=moderator.display_avatar.url)
        
    return embed


@bot.tree.command(name="action", description="ğŸ›¡ï¸ Premium Moderation System (Kick, Ban, Unban)")
@app_commands.choices(mode=[
    app_commands.Choice(name="ğŸ‘¢ Kick Player", value="kick"),
    app_commands.Choice(name="ğŸ”¨ Ban (Permanent)", value="ban"),
    app_commands.Choice(name="â± Temp Ban (Timed)", value="tempban"),
    app_commands.Choice(name="âœ… Unban", value="unban"),
    app_commands.Choice(name="ğŸ“œ List All Bans", value="list"),
    app_commands.Choice(name="ğŸ§¨ Clear All Bans (Reset)", value="clear"),
])
@app_commands.describe(
    user_id="Roblox ID (Required)",
    reason="Reason for action",
    duration="Minutes (Only for Tempban)"
)
async def action(i: discord.Interaction, mode: app_commands.Choice[str], user_id: str = None, reason: str = "No Reason Provided", duration: int = None):
    
    if not owner(i):
        return await i.response.send_message("âŒ **Access Denied:** Owner/Admin only.", ephemeral=True)

    if mode.value != "clear":
        await i.response.defer(ephemeral=False)

    try:
        # ================== 1. KICK ==================
        if mode.value == "kick":
            if not user_id: return await i.followup.send("âŒ **Roblox ID Required!**")
            u, d = await roblox_info(user_id)

            # âœ… FIX: Safe DB Call (Error aayega to bhi command nahi rukega)
            try:
                await db_call(lambda: supabase.table("kick_logs").insert({
                    "user_id": user_id, "username": u, "display_name": d, "reason": reason, "timestamp": datetime.utcnow().isoformat()
                }).execute())
            except Exception as e:
                print(f"âš ï¸ Log Error (Kick Logs missing?): {e}")

            # Kick Flag Set
            await db_call(lambda: supabase.table("kick_flags").upsert({
                "user_id": user_id, "reason": reason
            }).execute())

            embed = build_premium_embed("kick", u, d, user_id, i.user, reason)
            await i.followup.send(embed=embed)


        # ================== 2. PERMANENT BAN ==================
        elif mode.value == "ban":
            if not user_id: return await i.followup.send("âŒ **Roblox ID Required!**")
            u, d = await roblox_info(user_id)
            
            await db_call(lambda: supabase.table("bans").upsert({
                "user_id": user_id, "perm": True, "reason": reason, "expire": None, "executor": str(i.user.id)
            }).execute())

            try: log_action("ban", user_id, u, d, i.user.id)
            except: pass

            embed = build_premium_embed("ban", u, d, user_id, i.user, reason)
            await i.followup.send(embed=embed)


        # ================== 3. TEMP BAN ==================
        elif mode.value == "tempban":
            if not user_id: return await i.followup.send("âŒ **Roblox ID Required!**")
            if not duration: return await i.followup.send("âš ï¸ **Duration Required!** (Minutes)")

            u, d = await roblox_info(user_id)
            expire_time = time.time() + (duration * 60)

            await db_call(lambda: supabase.table("bans").upsert({
                "user_id": user_id, "perm": False, "reason": reason, "expire": expire_time, "executor": str(i.user.id)
            }).execute())

            try: log_action("tempban", user_id, u, d, i.user.id)
            except: pass

            embed = build_premium_embed("tempban", u, d, user_id, i.user, reason, duration)
            await i.followup.send(embed=embed)


        # ================== 4. UNBAN ==================
        elif mode.value == "unban":
            if not user_id: return await i.followup.send("âŒ **Roblox ID Required!**")

            u, d = await roblox_info(user_id)
            
            await db_call(lambda: supabase.table("bans").delete().eq("user_id", user_id).execute())

            try: log_action("unban", user_id, u, d, i.user.id)
            except: pass

            embed = build_premium_embed("unban", u, d, user_id, i.user, reason)
            await i.followup.send(embed=embed)


        # ================== 5. LIST BANS (Premium List) ==================
        elif mode.value == "list":
            data_req = await db_call(lambda: supabase.table("bans").select("*").execute())
            data = data_req.data if data_req else []

            # Expired Bans Cleanup
            active_bans = []
            now = time.time()
            for row in data:
                if not row.get("perm") and row.get("expire") and now > float(row["expire"]):
                    asyncio.create_task(db_call(lambda: supabase.table("bans").delete().eq("user_id", row["user_id"]).execute()))
                else:
                    active_bans.append(row)

            if not active_bans:
                return await i.followup.send(embed=discord.Embed(title="ğŸ“œ Ban List", description="âœ… **No active bans found.**\nServer is clean!", color=0x2ecc71))

            view = BanPaginator(active_bans, i.user, bot)
            if view.total_pages <= 1:
                view.children[0].disabled = True
                view.children[1].disabled = True
            else:
                view.update_buttons()

            embed = await view.get_page_embed()
            await i.followup.send(embed=embed, view=view)


        # ================== 6. CLEAR ALL ==================
        elif mode.value == "clear":
            embed = discord.Embed(
                title="âš ï¸ DANGER ZONE: CLEAR DATABASE",
                description="Are you sure you want to **DELETE ALL BANS**?\n\nThis will unban **everyone**. This cannot be undone.",
                color=0xffaa00
            )
            embed.set_footer(text="Wait 10 seconds before confirming.")
            view = BanClearView(i.user.id)
            await i.response.send_message(embed=embed, view=view, ephemeral=False)

    except Exception as e:
        print(f"ACTION ERROR: {e}")
        # Error handling thoda clean kiya hai
        if "Missing Permissions" in str(e):
            await i.followup.send("âŒ **Bot Error:** Mere paas permissions nahi hain.")
        else:
            await i.followup.send(f"âŒ **System Error:** `{e}`")

# ================== PREMIUM PLAYSOUND (Embed + Hidden) ==================

import os
import discord
from discord import app_commands

# 1. Autocomplete (Ye ekdum perfect tha, same rakha hai)
async def sound_autocomplete(i: discord.Interaction, current: str) -> list[app_commands.Choice[str]]:
    folder_path = "./sounds"
    if not os.path.exists(folder_path): return []
    files = [f for f in os.listdir(folder_path) if f.endswith('.mp3')]
    return [app_commands.Choice(name=f, value=f) for f in files if current.lower() in f.lower()][:25]

# 2. Main Command
@bot.tree.command(name="playsound", description="ğŸ“‚ GitHub sounds play karo (Owner Only)")
@app_commands.describe(filename="Sound select karo")
@app_commands.autocomplete(filename=sound_autocomplete)
async def playsound(i: discord.Interaction, filename: str):
    
    # â³ 1. DEFER SABSE PEHLE KARO (Time-out error rokne ke liye)
    await i.response.defer(ephemeral=True)

    # ğŸ”’ 2. OWNER CHECK (ğŸ› ï¸ FIX 1: 'await' lagana bahut zaroori tha!)
    if not await owner(i):
        return await i.followup.send("âŒ **Access Denied:** Sirf Owner allowed hai!", ephemeral=True)

    # ğŸ¤ 3. VC CHECK
    if not i.user.voice or not i.user.voice.channel:
        return await i.followup.send("âš ï¸ Pehle VC join kar bhai!", ephemeral=True)

    try:
        file_path = f"./sounds/{filename}"
        
        if not os.path.exists(file_path):
             return await i.followup.send(f"âŒ File `{filename}` nahi mili!", ephemeral=True)

        # ğŸ› ï¸ FIX 2: SMART VC CONNECT LOGIC
        vc = i.guild.voice_client
        if not vc:
             # Agar bot VC me nahi hai, toh connect karo
             vc = await i.user.voice.channel.connect()
        elif vc.channel != i.user.voice.channel:
             # Agar bot dusre VC me hai, toh apne paas bula lo
             await vc.move_to(i.user.voice.channel)

        # Agar pehle se kuch baj raha hai, toh usko chup karao
        if vc.is_playing(): 
            vc.stop()

        # ğŸš€ PLAY AUDIO
        vc.play(discord.FFmpegPCMAudio(source=file_path, executable="./ffmpeg"))
        
        # ğŸ’ PREMIUM EMBED
        embed = discord.Embed(
            title="ğŸ”Š **Audio Streaming**",
            description=f"### ğŸ’¿ Now Playing:\n> `{filename}`\n\n**Channel:** `{i.user.voice.channel.name}`\n**Status:** `Active` ğŸŸ¢",
            color=0x00ffea # Neon Cyan Color
        )
        embed.set_thumbnail(url="https://media.tenor.com/On7kvXhzml4AAAAi/loading-gif.gif") # Audio visualizer GIF
        embed.set_footer(text=f"Requested by {i.user.display_name}", icon_url=i.user.display_avatar.url)

        # Message bhejo
        await i.followup.send(embed=embed, ephemeral=True)

    except Exception as e:
        await i.followup.send(f"âŒ **Error:** `{e}`", ephemeral=True)

# ========================== crush command ========================

import discord
from discord import app_commands

@bot.tree.command(name="crush", description="Add/Remove user from Flirty/Horny list ğŸ’–")
@app_commands.choices(mode=[
    app_commands.Choice(name="â• Add to Crush List", value="add"),
    app_commands.Choice(name="ğŸ’” Remove from Crush List", value="remove"),
    app_commands.Choice(name="ğŸ“œ View Crush List", value="list"),
])
async def crush(i: discord.Interaction, mode: app_commands.Choice[str], user: discord.User = None):
    
    # ğŸ”’ 1. OWNER CHECK (ğŸ› ï¸ FIX: Added 'await' so hackers can't use it)
    if not await owner(i): 
        return await i.response.send_message("âŒ **Apni aukaat mein raho!** Sirf Owner meri settings change kar sakta hai.", ephemeral=True)

    # â³ 2. DEFER (Premium processing time)
    await i.response.defer(ephemeral=False)

    try:
        # ==========================================
        # â¤ï¸ ADD (Flirt ON)
        # ==========================================
        if mode.value == "add":
            if not user: 
                return await i.followup.send("âŒ **Error:** Pehle koi user toh select karo, ya hawa mein pyar karoge?")
            
            # ğŸ› ï¸ FIX: Wrapped in db_call! (100% Crash Free)
            await db_call(lambda: supabase.table("bot_crushes").upsert({"user_id": str(user.id)}).execute())
            await load_crush_users() # RAM Update
            
            embed = discord.Embed(
                title="ğŸ’– NEW CRUSH UNLOCKED!", 
                description=f"**{user.mention}** ab is bot ka official Crush hai! ğŸ’‹\nMaahol ab thoda romantic hone wala hai...", 
                color=0xe91e63 # Hot Pink
            )
            embed.set_thumbnail(url="https://media.tenor.com/BMTXj26j1gAAAAAi/anime-kiss.gif")
            embed.add_field(name="âœ¨ New Effect Activated", value="Ab bot inhe roast nahi karega, sirf **Flirt** karega! ğŸ˜˜", inline=False)
            embed.set_footer(text="Love is in the air ğŸ’•", icon_url=i.user.display_avatar.url)
            
            await i.followup.send(embed=embed)

        # ==========================================
        # ğŸ’” REMOVE (Flirt OFF)
        # ==========================================
        elif mode.value == "remove":
            if not user: 
                return await i.followup.send("âŒ **Error:** Pehle koi user toh select karo jise dil se nikalna hai!")
            
            # ğŸ› ï¸ FIX: Wrapped in db_call!
            await db_call(lambda: supabase.table("bot_crushes").delete().eq("user_id", str(user.id)).execute())
            await load_crush_users() # RAM Update
            
            embed = discord.Embed(
                title="ğŸ’” BREAKUP SUCCESSFUL", 
                description=f"**{user.mention}** se ab dil bhar gaya. Kahani khatam! ğŸš¶â€â™‚ï¸ğŸ’¨", 
                color=0x2b2d31 # Dark Premium Grey
            )
            embed.set_thumbnail(url="https://media.tenor.com/1-11Yd6_QpYAAAAC/explosion-blast.gif")
            embed.add_field(name="ğŸ”¥ Effect Reverted", value="Wapas se purana **Brutal Roast** mode ON. ğŸ¤¬", inline=False)
            embed.set_footer(text="No mercy anymore ğŸ’€", icon_url=i.user.display_avatar.url)
            
            await i.followup.send(embed=embed)

        # ==========================================
        # ğŸ“œ LIST
        # ==========================================
        elif mode.value == "list":
            if not CRUSH_CACHE:
                embed = discord.Embed(
                    title="ğŸ’” Forever Single", 
                    description="Koi Crush nahi hai. Bot abhi bilkul **Sakht** hai! ğŸ—¿", 
                    color=0x95a5a6
                )
                return await i.followup.send(embed=embed)
            
            names = [f"ğŸ’• <@{uid}>" for uid in CRUSH_CACHE]
            
            embed = discord.Embed(
                title="ğŸ˜ THE CRUSH ROSTER", 
                description="In lucky logon par bot fida hai:\n\n" + "\n".join(names), 
                color=0xe91e63
            )
            embed.set_footer(text=f"Total Crushes: {len(CRUSH_CACHE)}", icon_url=i.user.display_avatar.url)
            
            await i.followup.send(embed=embed)

    except Exception as e:
        await i.followup.send(f"âŒ **Backend Glitch:** `{e}`")


# ================== ATTITUDE CONTROL (VIP SYSTEM) ==================
import discord
from discord import app_commands

@bot.tree.command(name="vip", description="Manage Bot Attitude & VIP Bypass ğŸ‘‘ (Owner Only)")
@app_commands.choices(mode=[
    app_commands.Choice(name="âœ¨ Allow (Add VIP)", value="allow"),
    app_commands.Choice(name="ğŸ©¸ Block (Remove VIP)", value="block"),
    app_commands.Choice(name="ğŸ“œ View VIP List", value="list"),
])
async def vip(i: discord.Interaction, mode: app_commands.Choice[str], user: discord.User = None):
    
    # ğŸ”’ 1. OWNER CHECK (ğŸ› ï¸ FIX: 'await' lagana bahut zaroori hai!)
    if not await owner(i):
        return await i.response.send_message("âŒ **Access Denied:** Sirf Server Owner VIPs ko manage kar sakta hai.", ephemeral=True)

    # â³ 2. DEFER (Premium processing)
    await i.response.defer(ephemeral=False)

    try:
        # ==========================================
        # âœ¨ ALLOW (ADD VIP)
        # ==========================================
        if mode.value == "allow":
            if not user:
                return await i.followup.send("âŒ **Error:** Pehle koi user toh select karo jise VIP banana hai!")

            # ğŸ› ï¸ FIX 1: Wrapped in db_call! (100% Crash Free)
            await db_call(lambda: supabase.table("attitude_bypass").upsert({"user_id": str(user.id)}).execute())
            
            # ğŸ”¥ RAM UPDATE 
            await load_bypass_users()

            # ğŸ’ ULTRA-PREMIUM EMBED
            embed = discord.Embed(
                title="âœ¨ VIP STATUS GRANTED", 
                description=f"**{user.mention}** has been officially whitelisted. ğŸ¾\nWelcome to the Elite Club!", 
                color=0xFFD700 # Solid Gold
            )
            embed.set_thumbnail(url="https://media.tenor.com/On7kvXhzml4AAAAi/loading-gif.gif") # Custom visualizer/crown gif laga sakte ho
            embed.add_field(name="ğŸ›¡ï¸ Security Level", value="`Elite Bypass`", inline=True)
            embed.add_field(name="ğŸ¤– Bot Attitude", value="`Respectful & Polite` ğŸŸ¢", inline=True)
            embed.set_footer(text=f"Authorized by {i.user.display_name} â€¢ Core System Synced âœ…", icon_url=i.user.display_avatar.url)
            
            await i.followup.send(embed=embed)

        # ==========================================
        # ğŸ©¸ BLOCK (REMOVE VIP)
        # ==========================================
        elif mode.value == "block":
            if not user:
                return await i.followup.send("âŒ **Error:** Pehle koi user toh select karo jise nikalna hai!")

            # ğŸ› ï¸ FIX 2: Wrapped in db_call!
            await db_call(lambda: supabase.table("attitude_bypass").delete().eq("user_id", str(user.id)).execute())

            # ğŸ”¥ RAM UPDATE 
            await load_bypass_users()

            # ğŸ’ ULTRA-PREMIUM EMBED
            embed = discord.Embed(
                title="ğŸ©¸ VIP STATUS REVOKED", 
                description=f"**{user.mention}** has been stripped of their VIP status. ğŸ“‰", 
                color=0x2b2d31 # Dark Premium Theme
            )
            embed.set_thumbnail(url="https://media.tenor.com/2b7lH3y8l08AAAAM/anime-disgust.gif")
            embed.add_field(name="ğŸ›¡ï¸ Security Level", value="`Standard (Peasant)`", inline=True)
            embed.add_field(name="ğŸ˜ˆ Bot Attitude", value="`Brutal Roast Mode` ğŸ”´", inline=True)
            embed.set_footer(text=f"Revoked by {i.user.display_name} â€¢ Core System Synced âœ…", icon_url=i.user.display_avatar.url)

            await i.followup.send(embed=embed)

        # ==========================================
        # ğŸ“œ LIST (SHOW ALL VIPs)
        # ==========================================
        elif mode.value == "list":
            # ğŸ› ï¸ FIX 3: Wrapped in db_call!
            res = await db_call(lambda: supabase.table("attitude_bypass").select("user_id").execute())
            data = res.data if res else []

            if not data:
                embed = discord.Embed(
                    title="ğŸ‘‘ THE ELITE ROSTER", 
                    description="âŒ **List is totally empty.**\nSabke liye Brutal Roast mode ON hai! ğŸ˜ˆ", 
                    color=0x95a5a6
                )
                return await i.followup.send(embed=embed)

            # Paginator Call (Tumhara purana perfect logic)
            view = VipPaginator(data, i.user, bot)
            
            if view.total_pages <= 1:
                view.children[0].disabled = True
                view.children[1].disabled = True
            else:
                view.update_buttons()

            embed = await view.get_page_embed()
            await i.followup.send(embed=embed, view=view)

    except Exception as e:
        print(f"VIP ERROR: {e}")
        await i.followup.send(f"âŒ **System Glitch:** `{e}`")


# ================== ğŸ”¥ ROAST SYSTEM ==================

import discord
from discord import app_commands

# ==============================================================================
# ğŸ—£ï¸ TRANSLATOR TOGGLE (ULTRA-PREMIUM)
# ==============================================================================
@bot.tree.command(name="translator", description="ğŸ”´/ğŸŸ¢ Toggle Brutal Hindi Roast Mode (Owner Only)")
@app_commands.describe(mode="Choose Translation Mode")
@app_commands.choices(mode=[
    app_commands.Choice(name="ğŸŸ¢ ON (Hindi Translation - Brutal)", value="on"),
    app_commands.Choice(name="ğŸ”´ OFF (English Only - Ultra Fast)", value="off")
])
async def translator(i: discord.Interaction, mode: app_commands.Choice[str]):
    
    # ğŸ”’ 1. UNIFIED OWNER CHECK (ğŸ› ï¸ FIX: Using your God-Tier security function)
    if not await owner(i): 
        return await i.response.send_message("âŒ **Aukaat mein raho!** Ye setting sirf Maalik ke liye hai.", ephemeral=True)

    # â³ 2. DEFER (Premium processing feel)
    await i.response.defer(ephemeral=False)

    global TRANSLATOR_ON

    try:
        # ==========================================
        # ğŸ‡®ğŸ‡³ HINDI MODE (TRANSLATOR ON)
        # ==========================================
        if mode.value == "on":
            TRANSLATOR_ON = True
            
            embed = discord.Embed(
                title="ğŸ‡®ğŸ‡³ TRANSLATOR ACTIVATED",
                description="**Hindi Roast Mode is now ON!** ğŸ”¥\nAb sabki bezzati sudhh desi style mein hogi.",
                color=0x2ecc71 # Neon Green
            )
            embed.set_thumbnail(url="https://media.tenor.com/2b7lH3y8l08AAAAM/anime-disgust.gif")
            embed.add_field(name="âš¡ Speed", value="`Standard (Translating...)`", inline=True)
            embed.add_field(name="ğŸ—£ï¸ Language", value="`Hindi (Desi Roast)`", inline=True)
            embed.set_footer(text=f"System Overridden by {i.user.display_name} âœ…", icon_url=i.user.display_avatar.url)
            
            await i.followup.send(embed=embed)
            
        # ==========================================
        # ğŸ‡ºğŸ‡¸ ENGLISH MODE (TRANSLATOR OFF)
        # ==========================================
        else:
            TRANSLATOR_ON = False
            
            embed = discord.Embed(
                title="ğŸ‡ºğŸ‡¸ TRANSLATOR DEACTIVATED",
                description="**English Mode is now ON!** âš¡\nBot ab bina translation ke direct fire karega.",
                color=0xe74c3c # Crimson Red
            )
            embed.set_thumbnail(url="https://media.tenor.com/On7kvXhzml4AAAAi/loading-gif.gif")
            embed.add_field(name="âš¡ Speed", value="`Ultra-Fast (0 Ping)`", inline=True)
            embed.add_field(name="ğŸ—£ï¸ Language", value="`English (Toxic)`", inline=True)
            embed.set_footer(text=f"System Overridden by {i.user.display_name} âœ…", icon_url=i.user.display_avatar.url)
            
            await i.followup.send(embed=embed)

    except Exception as e:
        await i.followup.send(f"âŒ **System Glitch:** `{e}`")

import discord
import edge_tts
import asyncio
import os

# ==========================================
# âš™ï¸ GLOBAL VOICE SETTINGS (RAM Based)
# ==========================================

# Default Setting: Swara (Female)
current_voice = {
    "id": "hi-IN-SwaraNeural",
    "name": "Swara (Female) ğŸ’ƒ",
    "pitch": "+5Hz",   # Ladki ke liye teekha
    "rate": "+10%",    # Thoda fast (Aggressive)
    "avatar": "https://cdn-icons-png.flaticon.com/512/6997/6997662.png", # Girl Icon
    "color": 0xFF69B4  # Hot Pink Color
}

# ==========================================
# ğŸ› ï¸ HELPER FUNCTIONS
# ==========================================

# 1. PREMIUM EMBED BUILDER
def create_premium_embed(title, description, color=None):
    # Agar color nahi diya, toh current voice ka color use karo
    if color is None:
        color = current_voice["color"]
    
    # Embed Create
    embed = discord.Embed(title=title, description=description, color=color)
    
    # Footer me current voice ka naam dikhega
    embed.set_footer(text=f"ğŸ”¥ Voice Mode: {current_voice['name']} | Powered by Titan AI")
    embed.set_thumbnail(url=current_voice["avatar"])
    return embed

# 2. SECURITY CHECK (Owner + Admin + VIP)
# 2. SECURITY CHECK (Owner + Admin + VIP) - 100% CRASH FREE
async def has_voice_access(interaction):
    user_id = str(interaction.user.id)
    
    # Check 1: Main Owner (OWNER_ID global variable hona chahiye main file me)
    try:
        if interaction.user.id == OWNER_ID: return True
    except:
        pass # Agar OWNER_ID define nahi hai to skip karo

    # Check 2: Custom Admin Function
    try:
        if check_owner(interaction): return True
    except:
        pass

    # Check 3: Supabase VIP Table (ğŸ› ï¸ THE GOD-TIER FIX)
    try:
        # Direct execute() ko hatakar db_call(lambda: ...) laga diya!
        data = await db_call(lambda: supabase.table("voice_vip").select("user_id").eq("user_id", user_id).execute())
        if data.data: return True
    except Exception as e:
        print(f"VIP Check Error: {e}")
        pass
        
    return False

# 3. AUDIO PLAYER (Global Settings Use Karega)
async def play_audio(interaction, text):
    # Step A: User Voice Channel Check
    if not interaction.user.voice:
        embed = create_premium_embed("âŒ Error", "Abe VC mein toh aaja pehle! ğŸ–•", 0xFF0000)
        await interaction.followup.send(embed=embed, ephemeral=True)
        return

    channel = interaction.user.voice.channel
    vc = interaction.guild.voice_client

    # Step B: Smart Connection Logic
    try:
        if vc and vc.is_connected():
            if vc.channel.id != channel.id:
                await vc.move_to(channel) # Agar dusre channel me hai to move karo
        else:
            vc = await channel.connect() # Naya connection
    except Exception as e:
        await interaction.followup.send(f"âš ï¸ VC Connection Error: {e}", ephemeral=True)
        return

    # Step C: Generate Audio (DYNAMIC VOICE ID)
    # Yahan hum 'current_voice' dictionary se fresh data uthayenge
    output_file = f"audio_{interaction.id}.mp3"
    
    try:
        communicate = edge_tts.Communicate(
            text, 
            current_voice["id"],           # ğŸ‘ˆ Ye line Male/Female switch karegi
            rate=current_voice["rate"], 
            pitch=current_voice["pitch"]
        )
        await communicate.save(output_file)
    except Exception as e:
        await interaction.followup.send(f"âš ï¸ TTS Error: {e}", ephemeral=True)
        return

    # Step D: Play Audio
    if not vc.is_playing():
        # ğŸ”¥ FIX: 'executable' hata diya taaki Render/Linux par error na aaye
        vc.play(discord.FFmpegPCMAudio(output_file), after=lambda e: clean_up(output_file))
        
        # Wait jab tak bol raha hai
        while vc.is_playing():
            await asyncio.sleep(1)
            
        # Optional: Disconnect after speaking (Isko hata sakte ho agar bot 24/7 chahiye)
        # await vc.disconnect() 
    else:
        embed = create_premium_embed("âš ï¸ Busy", "Ruk ja, abhi bol raha hu! ğŸš«", 0xFFA500)
        await interaction.followup.send(embed=embed, ephemeral=True)

# Helper to delete file
def clean_up(file_path):
    try:
        if os.path.exists(file_path):
            os.remove(file_path)
    except:
        pass

# ==========================================
# ğŸ”¥ COMMANDS START HERE
# ==========================================

# 1ï¸âƒ£ SWITCH VOICE (Male/Female Toggle)
@bot.tree.command(name="switch_voice", description="Bot ki aawaz aur gender change karo ğŸ™ï¸ğŸ”„")
@app_commands.choices(gender=[
    app_commands.Choice(name="Swara (Female) - Tikhi & Naughty ğŸ’ƒ", value="female"),
    app_commands.Choice(name="Madhur (Male) - Bhaari & Gangster ğŸ—¿", value="male")
])
async def switch_voice(interaction: discord.Interaction, gender: app_commands.Choice[str]):
    
    # Permission Check
    if not has_voice_access(interaction):
        await interaction.response.send_message("ğŸš« **Access Denied:** Sirf Owner ye change kar sakta hai!", ephemeral=True)
        return

    # âœ… FIX 1: Sabse pehle Defer karo (Loading...)
    # Isse "Application didn't respond" error nahi aayega
    await interaction.response.defer()

    global current_voice
    
    selected_color = 0x000000 # Default black

    if gender.value == "female":
        current_voice = {
            "id": "hi-IN-SwaraNeural",
            "name": "Swara (Female) ğŸ’ƒ",
            "pitch": "+5Hz",
            "rate": "+10%",
            "avatar": "https://cdn-icons-png.flaticon.com/512/6997/6997662.png",
            "color": 0xFF69B4
        }
        desc = "**Swara Activated!** ğŸ’ƒ\nBot ab *Teekhi Ladki* ki aawaz mein bolega."
        selected_color = 0xFF69B4
    else:
        current_voice = {
            "id": "hi-IN-MadhurNeural",
            "name": "Madhur (Male) ğŸ—¿",
            "pitch": "-5Hz", # Heavy Voice
            "rate": "+5%",
            "avatar": "https://cdn-icons-png.flaticon.com/512/236/236831.png",
            "color": 0x2F3136
        }
        desc = "**Madhur Activated!** ğŸ—¿\nBot ab *Bhaari Gangster* aawaz mein bolega."
        selected_color = 0x2F3136

    # âœ… FIX 2: 'create_premium_embed' me 'selected_color' pass kiya hai
    # Aur 'response.send_message' ki jagah 'followup.send' use kiya hai
    embed = create_premium_embed("ğŸ™ï¸ Voice System Updated", desc, selected_color)
    
    await interaction.followup.send(embed=embed)


import discord
from discord import app_commands
import random

import random
import discord
from discord import app_commands

# ----------------------------------------------
# ğŸ’€ COMMAND: VC ROAST (PREMIUM ENGLISH TOXIC MODE)
# ----------------------------------------------
@bot.tree.command(name="vcroast", description="Brutal English Roast Mode ğŸ’€ (Targeted VC)")
@app_commands.describe(target_vc="[Optional] Kisi aur VC me bot bhejna hai? Ise select karo.")
async def vcroast(interaction: discord.Interaction, target_vc: discord.VoiceChannel = None):
    
    # 1. ğŸ›¡ï¸ DEFER (Timeout Error hatane ke liye)
    await interaction.response.defer(ephemeral=True)

    # 2. Access Check (Tumhara God-Level Security)
    if not await has_voice_access(interaction):
        return await interaction.followup.send("ğŸš« **Access Denied:** Sirf VIP log chala sakte hain!", ephemeral=True)

    # 3. ğŸ¯ TARGET VC LOGIC
    vc_to_join = target_vc

    if not vc_to_join:
        if interaction.user.voice and interaction.user.voice.channel:
            vc_to_join = interaction.user.voice.channel
        else:
            return await interaction.followup.send("âŒ **Error:** Ya toh khud kisi VC mein raho, ya 'target_vc' select karo!", ephemeral=True)

    # 4. ğŸ’ PREMIUM EMBED (Loading Status)
    embed = discord.Embed(
        title="â˜¢ï¸ BRUTAL ROAST MODE ACTIVATED",
        description=f"**Target:** {vc_to_join.mention}\n**Status:** â³ Connecting and loading audio payload... ğŸ”¥\n\n*Nobody else can see this message.*",
        color=0xFF0000 # Blood Red Color
    )
    embed.set_thumbnail(url="https://media.tenor.com/jM3s8n0Q2C4AAAAC/machine-gun-firing.gif")
    embed.set_footer(text="Highly Classified Operation ğŸ’€")
    
    await interaction.followup.send(embed=embed, ephemeral=True)

    # 5. â˜¢ï¸ ULTRA-TOXIC ENGLISH ROAST LIST (Savage & Safe)
    gaali_list = [
        "à¤¤à¥‡à¤°à¥€ à¤®à¤¾à¤ à¤•à¥€ à¤šà¥‚à¤¤ à¤®à¥‡à¤‚ à¤¹à¤¾à¤¥à¥€ à¤•à¤¾ à¤²à¤‚à¤¡, à¤¸à¤¾à¤²à¥‡ à¤¨à¤²à¥à¤²à¥‡ à¤¤à¥‚ à¤ªà¥ˆà¤¦à¤¾ à¤¹à¥€ à¤—à¤²à¤¤à¥€ à¤¸à¥‡ à¤¹à¥à¤† à¤¥à¤¾à¥¤",
        "à¤¤à¥‡à¤°à¥€ à¤®à¤¾à¤ à¤•à¥€ à¤šà¥‚à¤¤ à¤®à¥‡à¤‚ à¤œà¥‡à¤¸à¥€à¤¬à¥€ à¤šà¤²à¤¾ à¤¦à¥‚à¤à¤—à¥€, à¤¸à¤¾à¤°à¥€ à¤…à¤•à¥œ à¤¬à¤¾à¤¹à¤° à¤¨à¤¿à¤•à¤² à¤œà¤¾à¤à¤—à¥€ à¤®à¤¾à¤¦à¤°à¤šà¥‹à¤¦à¥¤",
        "à¤­à¥‹à¤¸à¥œà¥€à¤•à¥‡, à¤¤à¥‡à¤°à¥€ à¤¬à¤¹à¤¨ à¤•à¥‹ à¤‡à¤¤à¤¨à¤¾ à¤šà¥‹à¤¦à¥‚à¤à¤—à¥€ à¤•à¤¿ à¤µà¥‹ à¤šà¤²à¤¨à¤¾ à¤­à¥‚à¤² à¤œà¤¾à¤à¤—à¥€, à¤¸à¤¿à¤°à¥à¤« à¤°à¥‡à¤‚à¤— à¤•à¥‡ à¤šà¤²à¥‡à¤—à¥€à¥¤",
        "à¤¸à¤¾à¤²à¥‡ à¤¸à¥‚à¤…à¤° à¤•à¥‡ à¤ªà¤¿à¤²à¥à¤²à¥‡, à¤¤à¥‡à¤°à¥€ à¤®à¤¾à¤ à¤•à¥€ à¤—à¤¾à¤‚à¤¡ à¤®à¥‡à¤‚ à¤•à¥ˆà¤•à¥à¤Ÿà¤¸ à¤‰à¤—à¤¾ à¤¦à¥‚à¤à¤—à¥€, à¤œà¤¬ à¤­à¥€ à¤¹à¤—à¥‡à¤—à¥€ à¤®à¥à¤à¥‡ à¤¯à¤¾à¤¦ à¤•à¤°à¥‡à¤—à¥€à¥¤",
        "à¤¤à¥‡à¤°à¥€ à¤¶à¤•à¤² à¤¦à¥‡à¤– à¤•à¥‡ à¤²à¤—à¤¤à¤¾ à¤¹à¥ˆ à¤­à¤—à¤µà¤¾à¤¨ à¤¨à¥‡ à¤Ÿà¤Ÿà¥à¤Ÿà¥€ à¤•à¥‹ à¤‡à¤‚à¤¸à¤¾à¤¨ à¤•à¤¾ à¤°à¥‚à¤ª à¤¦à¥‡ à¤¦à¤¿à¤¯à¤¾ à¤¹à¥ˆà¥¤",
        "à¤¸à¥à¤¨ à¤¬à¥‡ à¤à¤¾à¤‚à¤Ÿà¥‚, à¤¤à¥‡à¤°à¥€ à¤¶à¤•à¤² à¤¦à¥‡à¤– à¤•à¥‡ à¤¤à¥‹ à¤µà¤¾à¤¯à¤°à¤¸ à¤­à¥€ à¤•à¥à¤µà¤¾à¤°à¤‚à¤Ÿà¤¾à¤‡à¤¨ à¤®à¥‡à¤‚ à¤šà¤²à¤¾ à¤—à¤¯à¤¾à¥¤",
        "à¤…à¤¬à¥‡ à¤²à¥Œà¥œà¥‡, à¤…à¤—à¤° à¤…à¤ªà¤¨à¤¾ à¤¦à¤¿à¤®à¤¾à¤— à¤¬à¥‡à¤šà¤¨à¥‡ à¤œà¤¾à¤à¤—à¤¾ à¤¤à¥‹ 'à¤…à¤¨à¤¯à¥‚à¥›à¥à¤¡' à¤•à¤‚à¤¡à¥€à¤¶à¤¨ à¤®à¥‡à¤‚ à¤¬à¤¿à¤•à¥‡à¤—à¤¾, à¤•à¥à¤¯à¥‹à¤‚à¤•à¤¿ à¤•à¤­à¥€ à¤¯à¥‚à¥› à¤¤à¥‹ à¤•à¤¿à¤¯à¤¾ à¤¨à¤¹à¥€à¤‚à¥¤",
        "à¤¤à¥‡à¤°à¥€ à¤”à¤•à¤¾à¤¤ à¤®à¥‡à¤°à¥‡ à¤à¤¾à¤‚à¤Ÿ à¤•à¥‡ à¤¬à¤¾à¤² à¤¬à¤°à¤¾à¤¬à¤° à¤­à¥€ à¤¨à¤¹à¥€à¤‚ à¤¹à¥ˆ, à¤¨à¤¿à¤•à¤² à¤¯à¤¹à¤¾à¤ à¤¸à¥‡ à¤µà¤°à¤¨à¤¾ à¤—à¤¾à¥œ à¤¦à¥‚à¤à¤—à¥€à¥¤",
        "à¤­à¥‹à¤¸à¥œà¥€à¤•à¥‡, à¤¤à¥à¤à¥‡ à¤¦à¥‡à¤– à¤•à¥‡ à¤²à¤—à¤¤à¤¾ à¤¹à¥ˆ à¤•à¤¿ à¤•à¤‚à¤¡à¥‹à¤® à¤•à¤¾ à¤µà¤¿à¤œà¥à¤à¤¾à¤ªà¤¨ à¤•à¤¿à¤¤à¤¨à¤¾ à¥›à¤°à¥‚à¤°à¥€ à¤¹à¥ˆà¥¤",
        "à¤…à¤ªà¤¨à¥€ à¤¯à¥‡ à¤¸à¥œà¥€ à¤¹à¥à¤ˆ à¤†à¤µà¤¾à¥› à¤¬à¤‚à¤¦ à¤•à¤°, à¤µà¤°à¤¨à¤¾ à¤•à¤¾à¤¨ à¤•à¥‡ à¤¨à¥€à¤šà¥‡ à¤à¤¸à¤¾ à¤¬à¤œà¤¾à¤Šà¤à¤—à¥€ à¤•à¤¿ à¤…à¤—à¤²à¥€ 7 à¤ªà¥à¤¶à¥à¤¤à¥‡à¤‚ à¤¬à¤¹à¤°à¥€ à¤ªà¥ˆà¤¦à¤¾ à¤¹à¥‹à¤‚à¤—à¥€à¥¤",
        "à¤¸à¤¾à¤²à¥‡ à¤¸à¥à¤…à¤°, à¤¤à¥‚ à¤µà¥‹ à¤—à¤²à¤¤à¥€ à¤¹à¥ˆ à¤œà¤¿à¤¸à¥‡ à¤¡à¥‰à¤•à¥à¤Ÿà¤° à¤­à¥€ à¤°à¤¬à¤° à¤¸à¥‡ à¤®à¤¿à¤Ÿà¤¾à¤¨à¤¾ à¤šà¤¾à¤¹à¤¤à¤¾ à¤¥à¤¾ à¤ªà¤° à¤®à¤¿à¤Ÿà¤¾ à¤¨à¤¹à¥€à¤‚ à¤ªà¤¾à¤¯à¤¾à¥¤",
        "à¤¤à¥‡à¤°à¥€ à¤®à¤¾à¤ à¤¨à¥‡ à¤¤à¥à¤à¥‡ à¤ªà¥ˆà¤¦à¤¾ à¤¨à¤¹à¥€à¤‚ à¤•à¤¿à¤¯à¤¾, à¤¤à¥à¤à¥‡ à¤¬à¤¸ à¤¦à¥à¤¨à¤¿à¤¯à¤¾ à¤•à¥‹ à¤¸à¤œà¤¼à¤¾ à¤¦à¥‡à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ à¤¹à¤—à¤¾ à¤¹à¥ˆà¥¤",
        "à¤…à¤¬à¥‡ à¤šà¥‚à¤¤à¤¿à¤¯à¥‡, à¤¤à¥‡à¤°à¥‡ à¤–à¤¾à¤¨à¤¦à¤¾à¤¨ à¤®à¥‡à¤‚ à¤¸à¤¬ à¤‡à¤‚à¤œà¥€à¤¨à¤¿à¤¯à¤° à¤¹à¥ˆà¤‚ à¤•à¥à¤¯à¤¾? à¤•à¥à¤¯à¥‹à¤‚à¤•à¤¿ à¤¤à¥‚ à¤à¤• à¤¬à¤¹à¥à¤¤ à¤¬à¥œà¤¾ 'à¤ªà¥à¤°à¥‹à¤œà¥‡à¤•à¥à¤Ÿ à¤«à¥‡à¤²à¤¿à¤¯à¤°' à¤²à¤—à¤¤à¤¾ à¤¹à¥ˆà¥¤",
        "à¤¸à¥à¤¨ à¤®à¤¾à¤¦à¤°à¤šà¥‹à¤¦, à¤¤à¥‡à¤°à¥‡ à¤®à¥à¤à¤¹ à¤¸à¥‡ à¤¬à¤¾à¤¸ à¤†à¤¤à¥€ à¤¹à¥ˆ à¤¯à¤¾ à¤¤à¥‚ à¤—à¤Ÿà¤° à¤•à¤¾ à¤¢à¤•à¥à¤•à¤¨ à¤–à¥‹à¤² à¤•à¥‡ à¤¬à¤¾à¤¤ à¤•à¤°à¤¤à¤¾ à¤¹à¥ˆ?",
        "à¤¤à¥‡à¤°à¥€ à¤—à¤¾à¤‚à¤¡ à¤®à¥‡à¤‚ à¤‡à¤¤à¤¨à¤¾ à¤¬à¤¾à¤°à¥‚à¤¦ à¤­à¤°à¥‚à¤à¤—à¥€ à¤•à¤¿ à¤¦à¤¿à¤µà¤¾à¤²à¥€ à¤•à¤¾ à¤°à¥‰à¤•à¥‡à¤Ÿ à¤­à¥€ à¤¤à¥à¤à¥‡ à¤¦à¥‡à¤– à¤•à¥‡ à¤¶à¤°à¤®à¤¾ à¤œà¤¾à¤à¤—à¤¾à¥¤",
        "à¤­à¥‹à¤¸à¥œà¥€à¤•à¥‡, à¤‡à¤¤à¤¨à¤¾ à¤®à¤¤ à¤‰à¤›à¤², à¤µà¤°à¤¨à¤¾ à¤¤à¥‡à¤°à¥€ à¤†à¤‚à¤¤à¥‡à¤‚ à¤¬à¤¾à¤¹à¤° à¤¨à¤¿à¤•à¤¾à¤² à¤•à¥‡ à¤‰à¤¸à¥€ à¤¸à¥‡ à¤¤à¥à¤à¥‡ à¤«à¤¾à¤à¤¸à¥€ à¤²à¤—à¤¾ à¤¦à¥‚à¤à¤—à¥€à¥¤",
        "à¤…à¤¬à¥‡ à¤°à¤‚à¤¡à¥€ à¤•à¥‡, à¤¤à¥‚ à¤§à¤°à¤¤à¥€ à¤ªà¥‡ à¤¬à¥‹à¤ à¤¹à¥ˆ, à¤ªà¥‡à¥œ-à¤ªà¥Œà¤§à¥‡ à¤­à¥€ à¤¤à¥à¤à¥‡ à¤‘à¤•à¥à¤¸à¥€à¤œà¤¨ à¤¦à¥‡à¤•à¤° à¤ªà¤›à¤¤à¤¾ à¤°à¤¹à¥‡ à¤¹à¥‹à¤‚à¤—à¥‡à¥¤",
        "à¤¤à¥‡à¤°à¥€ à¤¶à¤•à¤² à¤¦à¥‡à¤– à¤•à¥‡ à¤¤à¥‹ à¤†à¤ˆà¤¨à¤¾ à¤­à¥€ à¤–à¥à¤¦à¤•à¥à¤¶à¥€ à¤•à¤° à¤²à¥‡à¤¤à¤¾ à¤¹à¥ˆ, à¤¤à¥‚ à¤•à¥à¤¯à¤¾ à¤šà¥€à¤œà¤¼ à¤¹à¥ˆ à¤¬à¥‡?",
        "à¤¸à¤¾à¤²à¥‡ à¤›à¤•à¥à¤•à¥‡, à¤®à¥‡à¤°à¥‡ à¤¸à¤¾à¤®à¤¨à¥‡ à¤®à¤°à¥à¤¦à¤¾à¤¨à¤—à¥€ à¤®à¤¤ à¤¦à¤¿à¤–à¤¾, à¤µà¤°à¤¨à¤¾ à¤µà¥‹ à¤¹à¤¾à¤² à¤•à¤°à¥‚à¤à¤—à¥€ à¤•à¤¿ à¤¹à¤¿à¤œà¥œà¥‡ à¤­à¥€ à¤¤à¥à¤à¥‡ à¤…à¤ªà¤¨à¥€ à¤¬à¤¿à¤°à¤¾à¤¦à¤°à¥€ à¤®à¥‡à¤‚ à¤¨à¤¹à¥€à¤‚ à¤²à¥‡à¤‚à¤—à¥‡à¥¤",
        "à¤®à¤¾à¤¦à¤°à¤šà¥‹à¤¦, à¤¤à¥à¤à¥‡ à¤¦à¥‡à¤– à¤•à¥‡ à¤²à¤—à¤¤à¤¾ à¤¹à¥ˆ à¤•à¤¿ à¤­à¤—à¤µà¤¾à¤¨ à¤¨à¥‡ à¤®à¤¿à¤Ÿà¥à¤Ÿà¥€ à¤—à¥‚à¤‚à¤¥à¤¤à¥‡ à¤µà¥˜à¥à¤¤ à¤‰à¤¸à¤®à¥‡à¤‚ à¤—à¤Ÿà¤° à¤•à¤¾ à¤ªà¤¾à¤¨à¥€ à¤®à¤¿à¤²à¤¾ à¤¦à¤¿à¤¯à¤¾ à¤¥à¤¾à¥¤"
        "à¤®à¤¾à¤¦à¤°à¤šà¥‹à¤¦, à¤¤à¥‡à¤°à¥‡ à¤–à¤¾à¤¨à¤¦à¤¾à¤¨ à¤•à¥€ à¤”à¤°à¤¤à¥‡à¤‚ à¤®à¥‡à¤°à¥‡ à¤²à¤‚à¤¡ à¤•à¤¾ à¤µà¥‡à¤Ÿ à¤•à¤°à¤¤à¥€ à¤¹à¥ˆà¤‚, à¤œà¤¾à¤•à¥‡ à¤ªà¥‚à¤› à¤²à¥‡à¥¤",
        "à¤…à¤¬à¥‡ à¤°à¤‚à¤¡à¥€ à¤•à¥‡, à¤¤à¥‡à¤°à¥€ à¤—à¤¾à¤‚à¤¡ à¤®à¥‡à¤‚ à¤°à¥‰à¤¡ à¤¡à¤¾à¤² à¤•à¥‡ à¤®à¥à¤à¤¹ à¤¸à¥‡ à¤¨à¤¿à¤•à¤¾à¤²à¥‚à¤à¤—à¥€, à¤¹à¥à¤¯à¥‚à¤®à¤¨ à¤•à¤¬à¤¾à¤¬ à¤¬à¤¨à¤¾ à¤¦à¥‚à¤à¤—à¥€ à¤¤à¥‡à¤°à¤¾à¥¤",
        "à¤¤à¥‡à¤°à¥€ à¤®à¤¾à¤ à¤•à¤¾ à¤­à¥‹à¤¸à¥œà¤¾ à¤‡à¤¤à¤¨à¤¾ à¤¬à¥œà¤¾ à¤¹à¥ˆ à¤•à¤¿ à¤‰à¤¸à¤®à¥‡ à¤®à¥ˆà¤‚ à¤…à¤ªà¤¨à¤¾ à¤ªà¥‚à¤°à¤¾ à¤˜à¤° à¤¬à¤¨à¤¾ à¤²à¥‚à¤à¥¤",
        "à¤šà¥‚à¤¤à¤¿à¤¯à¥‡, à¤¤à¥à¤à¥‡ à¤ªà¥ˆà¤¦à¤¾ à¤•à¤°à¤•à¥‡ à¤¤à¥‡à¤°à¥€ à¤®à¤¾à¤ à¤¨à¥‡ à¤¦à¥à¤¨à¤¿à¤¯à¤¾ à¤ªà¥‡ à¤¬à¥‹à¤ à¤¬à¥à¤¾ à¤¦à¤¿à¤¯à¤¾ à¤¹à¥ˆ, à¤œà¤¾à¤•à¥‡ à¤®à¤° à¤œà¤¾à¥¤",
        "à¤¤à¥‡à¤°à¥€ à¤¬à¤¹à¤¨ à¤•à¥€ à¤šà¥‚à¤¤ à¤®à¥‡à¤‚ à¤¬à¤® à¤²à¤—à¤¾ à¤•à¥‡ à¤‰à¥œà¤¾ à¤¦à¥‚à¤à¤—à¥€, à¤šà¤¿à¤¥à¥œà¥‡ à¤®à¤¿à¤²à¥‡à¤‚à¤—à¥‡ à¤¸à¥€à¤§à¤¾ à¤šà¤¾à¤à¤¦ à¤ªà¥‡à¥¤",
        "à¤¸à¤¾à¤²à¥‡ à¤¹à¤¿à¤œà¥œà¥‡ à¤•à¥€ à¤”à¤²à¤¾à¤¦, à¤®à¥‡à¤°à¥‡ à¤¸à¤¾à¤®à¤¨à¥‡ à¤†à¤µà¤¾à¥› à¤®à¤¤ à¤¨à¤¿à¤•à¤¾à¤²à¤¨à¤¾ à¤µà¤°à¤¨à¤¾ à¤µà¤¹à¥€ à¤—à¤¾à¥œ à¤¦à¥‚à¤à¤—à¥€à¥¤",
        "à¤¤à¥‡à¤°à¥€ à¤®à¤¾à¤ à¤•à¥€ à¤šà¥‚à¤¤ à¤®à¥‡à¤‚ à¤‡à¤¤à¤¨à¥‡ à¤²à¤‚à¤¡ à¤¡à¤¾à¤²à¥‚à¤à¤—à¥€ à¤•à¤¿ à¤µà¥‹ à¤Ÿà¥à¤°à¥ˆà¤«à¤¿à¤• à¤œà¤¾à¤® à¤¹à¥‹ à¤œà¤¾à¤à¤—à¥€à¥¤",
        "à¤­à¥‹à¤¸à¥œà¥€à¤•à¥‡, à¤¤à¥‡à¤°à¤¾ à¤¬à¤¾à¤ª à¤­à¥€ à¤°à¥‹à¤¤à¤¾ à¤¹à¥‹à¤—à¤¾ à¤•à¤¿ à¤•à¤¿à¤¸ à¤®à¤¨à¤¹à¥‚à¤¸ à¤˜à¥œà¥€ à¤®à¥‡à¤‚ à¤¤à¥à¤à¥‡ à¤ªà¥ˆà¤¦à¤¾ à¤•à¤¿à¤¯à¤¾à¥¤",
        "à¤°à¤‚à¤¡à¥€ à¤•à¥‡ à¤ªà¤¿à¤²à¥à¤²à¥‡, à¤¤à¥‡à¤°à¥€ à¤—à¤¾à¤‚à¤¡ à¤®à¥‡à¤‚ à¤®à¤¿à¤°à¥à¤šà¥€ à¤•à¤¾ à¤ªà¤¾à¤‰à¤¡à¤° à¤­à¤° à¤•à¥‡ à¤¡à¤‚à¤¡à¥‡ à¤¸à¥‡ à¤…à¤‚à¤¦à¤° à¤•à¤° à¤¦à¥‚à¤à¤—à¥€à¥¤",
        "à¤¤à¥‡à¤°à¥€ à¤¬à¤¹à¤¨ à¤•à¥€ à¤šà¥‚à¤¤ à¤ªà¤¬à¥à¤²à¤¿à¤• à¤Ÿà¥‰à¤¯à¤²à¥‡à¤Ÿ à¤¬à¤¨ à¤—à¤¯à¥€ à¤¹à¥ˆ, à¤œà¥‹ à¤†à¤¤à¤¾ à¤¹à¥ˆ à¤®à¥‚à¤¤ à¤•à¥‡ à¤šà¤²à¤¾ à¤œà¤¾à¤¤à¤¾ à¤¹à¥ˆà¥¤",
        "à¤®à¤¾à¤¦à¤°à¤šà¥‹à¤¦, à¤¤à¥à¤à¥‡ à¥›à¤¿à¤‚à¤¦à¤¾ à¤œà¤²à¤¾ à¤•à¥‡ à¤¤à¥‡à¤°à¥€ à¤°à¤¾à¤– à¤•à¥‹ à¤—à¤Ÿà¤° à¤®à¥‡à¤‚ à¤¬à¤¹à¤¾à¤¨à¤¾ à¤šà¤¾à¤¹à¤¿à¤à¥¤",
        "à¤¬à¤¹à¤¨à¤šà¥‹à¤¦, à¤…à¤ªà¤¨à¥€ à¤¶à¤•à¤² à¤¦à¥‡à¤–à¥€ à¤¹à¥ˆ? à¤à¤¸à¤¾ à¤²à¤—à¤¤à¤¾ à¤¹à¥ˆ à¤—à¤Ÿà¤° à¤•à¥‡ à¤¢à¤•à¥à¤•à¤¨ à¤ªà¥‡ à¤•à¤¿à¤¸à¥€ à¤¨à¥‡ à¤‰à¤²à¥à¤Ÿà¥€ à¤•à¤° à¤¦à¥€ à¤¹à¥‹à¥¤",
        "à¤®à¤¾à¤¦à¤°à¤šà¥‹à¤¦, à¤¤à¥‡à¤°à¥€ à¤¬à¤¹à¤¨ à¤•à¥‹ à¤•à¥‹à¤ à¥‡ à¤ªà¥‡ à¤¬à¤¿à¤ à¤¾ à¤¦à¥‚à¤à¤—à¥€ à¤…à¤—à¤° à¤¦à¥‹à¤¬à¤¾à¤°à¤¾ à¤¯à¤¹à¤¾à¤ à¤¦à¤¿à¤–à¤¾ à¤¤à¥‹, à¤¨à¤¿à¤•à¤² à¤¯à¤¹à¤¾à¤ à¤¸à¥‡!",
        "à¤¸à¤¾à¤²à¥‡ à¤°à¤‚à¤¡à¥€ à¤•à¥‡ à¤ªà¤¿à¤²à¥à¤²à¥‡, à¤¤à¥‡à¤°à¥‡ à¤–à¤¾à¤¨à¤¦à¤¾à¤¨ à¤®à¥‡à¤‚ à¤¸à¤¬à¤¸à¥‡ à¤¬à¥œà¤¾ à¤šà¥‚à¤¤à¤¿à¤¯à¤¾ à¤¤à¥‚ à¤¹à¥€ à¤¹à¥ˆ, à¤œà¤¾à¤•à¥‡ à¤¡à¥‚à¤¬ à¤®à¤°à¥¤",
        "à¤¤à¥‡à¤°à¥€ à¤—à¤¾à¤‚à¤¡ à¤®à¥‡à¤‚ à¤‡à¤¤à¤¨à¤¾ à¤¡à¤‚à¤¡à¤¾ à¤¡à¤¾à¤²à¥‚à¤à¤—à¥€ à¤•à¤¿ à¤®à¥à¤à¤¹ à¤¸à¥‡ à¤¬à¤¾à¤¹à¤° à¤¨à¤¿à¤•à¤²à¥‡à¤—à¤¾, à¤­à¥‹à¤¸à¥œà¥€à¤•à¥‡ à¤”à¤•à¤¾à¤¤ à¤®à¥‡à¤‚ à¤°à¤¹à¥¤",
        "à¤¸à¥à¤¨ à¤¬à¥‡ à¤²à¥‹à¤¡à¥‚, à¤¤à¥‡à¤°à¥€ à¤®à¤¾à¤ à¤®à¥‡à¤°à¥‡ à¤ªà¤¾à¤¸ à¤†à¤¯à¥€ à¤¥à¥€, à¤•à¤¹ à¤°à¤¹à¥€ à¤¥à¥€ à¤—à¤²à¤¤à¥€ à¤¹à¥‹ à¤—à¤¯à¥€ à¤¤à¥à¤à¥‡ à¤ªà¥ˆà¤¦à¤¾ à¤•à¤°à¤•à¥‡à¥¤",
        "à¤…à¤¬à¥‡ à¤¸à¥‚à¤…à¤° à¤•à¥€ à¤”à¤²à¤¾à¤¦, à¤¤à¥‚ à¤µà¤¹à¥€ à¤µà¤¾à¤¯à¤°à¤¸ à¤¹à¥ˆ à¤œà¤¿à¤¸à¥‡ à¤•à¤‚à¤¡à¥‹à¤® à¤­à¥€ à¤°à¥‹à¤• à¤¨à¤¹à¥€à¤‚ à¤ªà¤¾à¤¯à¤¾ à¤¥à¤¾à¥¤",
        "à¤¤à¥‡à¤°à¥€ à¤¬à¤¹à¤¨ à¤•à¥€ à¤šà¥‚à¤¤ à¤®à¥‡à¤‚ à¤•à¥ˆà¤•à¥à¤Ÿà¤¸ à¤¡à¤¾à¤² à¤•à¥‡ à¤˜à¥‚à¤®à¥à¤à¤—à¥€, à¤¸à¤¾à¤²à¥‡ à¤Ÿà¤Ÿà¥à¤Ÿà¥€ à¤–à¥‹à¤° à¤‡à¤‚à¤¸à¤¾à¤¨à¥¤"
    ]
    
    text = random.choice(gaali_list)
    
    # 6. ğŸ”Š PLAY AUDIO
    try:
        # Ye line tabhi chalegi jab tum apna play_audio function theek kar loge!
        await play_audio(interaction, text, vc_to_join)
        
        # Audio bajne ke baad success message
        success_embed = discord.Embed(
            title="âœ… MISSION ACCOMPLISHED", 
            description=f"Roast payload delivered successfully in {vc_to_join.mention} ğŸ’€", 
            color=0x00FF00
        )
        success_embed.add_field(name="ğŸ’¬ What was said:", value=f"> *\"{text}\"*", inline=False)
        await interaction.edit_original_response(embed=success_embed)
        
    except Exception as e:
        await interaction.followup.send(f"âŒ **System Error:** Audio play nahi ho paya.\nError: `{e}`", ephemeral=True)


# 3ï¸âƒ£ BOL (Premium Embed + Auto Voice - EPHEMERAL)
@bot.tree.command(name="bol", description="Bot se kuch bhi bulwao ğŸ¤ (Only you can see this)")
@app_commands.describe(text="Kya bulwana hai?")
async def bol(interaction: discord.Interaction, text: str):
    # 1. Access Check
    if not has_voice_access(interaction):
        await interaction.response.send_message("ğŸš« **Access Denied:** Sirf VIP log chala sakte hain!", ephemeral=True)
        return

    # Defer (Loading...)
    await interaction.response.defer(ephemeral=True)

    try:
        # ğŸ”¥ FIX: Yahan '0x00FFFF' (Cyan Color) add kiya hai.
        # Ab ye error nahi dega.
        embed = create_premium_embed(
            "ğŸ“¢ Broadcasting", 
            f"**Text:** {text}\n**Voice:** {current_voice['name']}", 
            0x00FFFF
        )
        
        # Message Bhejo
        await interaction.followup.send(embed=embed)
        
        # Audio Play Karo
        await play_audio(interaction, text)
        
    except Exception as e:
        await interaction.followup.send(f"âš ï¸ **Error:** Audio play nahi ho paya. ({e})", ephemeral=True)
        
# ================== ğŸ¤ TRUST SYSTEM (VIP MANAGEMENT) ==================

import discord
from discord import app_commands

trust_group = app_commands.Group(name="trust", description="ğŸ¤ Trust List Management (Owner Only)")

# ==============================================================================
# ğŸŸ¢ ADD MEMBER (/trust add)
# ==============================================================================
@trust_group.command(name="add", description="Kisi ko Trust List me add karo âœ…")
async def trust_add(interaction: discord.Interaction, user: discord.Member):
    
    # ğŸ”’ 1. OWNER CHECK (ğŸ› ï¸ FIX: Using your God-Tier security function)
    if not await owner(interaction):
        return await interaction.response.send_message("âŒ **Access Denied:** Sirf Server Owner hi Trust member add kar sakta hai!", ephemeral=True)

    # ğŸ”¥ Ephemeral=False (Ab message SABKO dikhega)
    await interaction.response.defer(ephemeral=False)

    try:
        # ğŸ› ï¸ FIX: Wrapped in db_call! (100% Crash Free)
        check = await db_call(lambda: supabase.table("voice_vip").select("user_id").eq("user_id", str(user.id)).execute())
        
        if check and check.data:
            return await interaction.followup.send(f"âš ï¸ **{user.mention}** pehle se hi Trust List mein maujood hai!")
            
        # Insert Data (ğŸ› ï¸ FIX: Wrapped in db_call)
        data = { "user_id": str(user.id), "added_by": str(interaction.user.name) }
        await db_call(lambda: supabase.table("voice_vip").insert(data).execute())
        
        # ğŸ’ ULTRA PREMIUM EMBED
        embed = discord.Embed(
            title="ğŸ¤ TRUST LEVEL UPGRADED", 
            description=f"**{user.mention}** has been granted official **Voice VIP Access!** ğŸ‰\nWelcome to the Elite Club.", 
            color=0x2ecc71 # Emerald Green
        )
        embed.add_field(name="ğŸ”“ Unlocked Features", value="Can now use `/bol` and `/vcroast` commands freely.", inline=False)
        embed.set_thumbnail(url=user.display_avatar.url)
        embed.set_footer(text=f"Authorized by {interaction.user.display_name} â€¢ Core System Synced âœ…", icon_url=interaction.user.display_avatar.url)
        
        await interaction.followup.send(embed=embed)
            
    except Exception as e:
        await interaction.followup.send(f"âŒ **System Glitch:** `{e}`")


# ==============================================================================
# ğŸ”´ REMOVE MEMBER (/trust remove)
# ==============================================================================
@trust_group.command(name="remove", description="Kisi ko Trust List se hatao ğŸš«")
async def trust_remove(interaction: discord.Interaction, user: discord.User):
    
    # ğŸ”’ 1. OWNER CHECK (ğŸ› ï¸ FIX: Using God-Tier security)
    if not await owner(interaction):
        return await interaction.response.send_message("âŒ **Access Denied:** Sirf Server Owner hi remove kar sakta hai!", ephemeral=True)

    # ğŸ”¥ Ephemeral=False (Sabko dikhega ki banda kick ho gaya)
    await interaction.response.defer(ephemeral=False)

    try:
        # Check if exists (ğŸ› ï¸ FIX: Wrapped in db_call)
        check = await db_call(lambda: supabase.table("voice_vip").select("user_id").eq("user_id", str(user.id)).execute())
        
        if not (check and check.data):
            return await interaction.followup.send(f"âš ï¸ **{user.mention}** Trust List mein hai hi nahi.")
            
        # Delete Data (ğŸ› ï¸ FIX: Wrapped in db_call)
        await db_call(lambda: supabase.table("voice_vip").delete().eq("user_id", str(user.id)).execute())
        
        # ğŸ’ ULTRA PREMIUM EMBED
        embed = discord.Embed(
            title="ğŸš« TRUST REVOKED", 
            description=f"**{user.mention}** has been permanently removed from the Trust List. ğŸ’€", 
            color=0xe74c3c # Crimson Red
        )
        embed.add_field(name="ğŸ”’ Restricted Features", value="Voice commands `/bol` and `/vcroast` are now **LOCKED**.", inline=False)
        embed.set_thumbnail(url="https://media.tenor.com/2b7lH3y8l08AAAAM/anime-disgust.gif")
        embed.set_footer(text=f"Revoked by {interaction.user.display_name} â€¢ Core System Synced âœ…", icon_url=interaction.user.display_avatar.url)
        
        await interaction.followup.send(embed=embed)
            
    except Exception as e:
        await interaction.followup.send(f"âŒ **System Glitch:** `{e}`")


# ==============================================================================
# ğŸ“œ SHOW LIST (/trust list)
# ==============================================================================
@trust_group.command(name="list", description="Dekho kon kon Trusted hai ğŸ“œ")
async def trust_list(interaction: discord.Interaction):
    
    # ğŸ”’ 1. OWNER CHECK
    if not await owner(interaction):
        return await interaction.response.send_message("âŒ **Access Denied:** Sirf Server Owner list dekh sakta hai!", ephemeral=True)

    # ğŸ”¥ Ephemeral=False (List sabke samne aayegi)
    await interaction.response.defer(ephemeral=False)

    try:
        # Fetch All Data (ğŸ› ï¸ FIX: Wrapped in db_call)
        res = await db_call(lambda: supabase.table("voice_vip").select("*").execute())
        vip_users = res.data if res else []

        if not vip_users:
            embed = discord.Embed(
                title="ğŸ¤ THE ELITE TRUST ROSTER",
                description="ğŸ“‚ **Database Empty:** Filhal koi bhi Trusted member nahi hai.",
                color=0x95a5a6 # Gray
            )
            return await interaction.followup.send(embed=embed)

        # List Format (Premium Design)
        description = ""
        for index, item in enumerate(vip_users, 1):
            user_id = item['user_id']
            description += f"`{index:02d}.` ğŸ›¡ï¸ <@{user_id}> (`{user_id}`)\n"

        # ğŸ’ ULTRA PREMIUM EMBED
        embed = discord.Embed(
            title="ğŸ¤ THE ELITE TRUST ROSTER", 
            description=f"Here are the officially verified Voice VIPs:\n\n{description}", 
            color=0x3498db # Cool Blue Color
        )
        embed.set_thumbnail(url="https://media.tenor.com/On7kvXhzml4AAAAi/loading-gif.gif")
        embed.set_footer(text=f"Total Trusted: {len(vip_users)} â€¢ Core System Synced âœ…", icon_url=interaction.user.display_avatar.url)
        
        await interaction.followup.send(embed=embed)

    except Exception as e:
        await interaction.followup.send(f"âŒ **System Glitch:** `{e}`")

# ==============================================================================
# ğŸ”¥ YE LINE BAHUT ZAROORI HAI:
# ==============================================================================
bot.tree.add_command(trust_group)


# ================== MULTI-VERIFY MANAGEMENT (PREMIUM UI) ==================
import discord
from discord import app_commands

# ================== ğŸ‘‘ MULTI-VERIFY MANAGEMENT (ULTRA PREMIUM) ==================
@bot.tree.command(name="multiaccess", description="Manage users who can verify UNLIMITED accounts â™¾ï¸")
@app_commands.choices(mode=[
    app_commands.Choice(name="ğŸŸ¢ Add Permission (Unlimited)", value="add"),
    app_commands.Choice(name="ğŸ”´ Remove Permission (Revoke)", value="remove"),
    app_commands.Choice(name="ğŸ“œ List Approved Users", value="list"),
])
@app_commands.describe(target_user="Select the user from dropdown (Required for Add/Remove)")
async def multiaccess(i: discord.Interaction, mode: app_commands.Choice[str], target_user: discord.User = None):
    
    # â³ 1. DEFER (Premium processing feel & Crash prevention)
    await i.response.defer(ephemeral=False)

    # ğŸ”’ 2. OWNER CHECK (ğŸ› ï¸ FIX: 'await' lagana bahut zaroori hai!)
    if not await owner(i):
        return await safe_send(i, emb("âŒ ACCESS DENIED", "**Aukaat mein raho!** Sirf Server Owner hi multi-access control kar sakta hai.", 0xff0000))

    # Agar user select kiya hai to uski ID nikal lo
    discord_id = str(target_user.id) if target_user else None

    try:
        # ==========================================
        # ğŸŸ¢ ADD USER (UNLIMITED ACCESS)
        # ==========================================
        if mode.value == "add":
            if not target_user:
                return await safe_send(i, emb("âŒ MISSING TARGET", "Permission dene ke liye User select karna padega!", 0xffa500))

            # ğŸ› ï¸ FIX: Wrapped in db_call! (No Lag/Crash)
            await db_call(lambda: supabase.table("multi_access").upsert({
                "discord_id": discord_id,
                "approved": True
            }).execute())

            # ğŸ’ PREMIUM EMBED 
            success_emb = emb(
                "â™¾ï¸ MULTI-ACCESS GRANTED",
                f"**Target:** {target_user.mention}\n**Discord ID:** `{discord_id}`\n\nğŸŸ¢ **Status:** `Verified Elite`\n*Ab ye user **Unlimited Roblox IDs** verify kar sakta hai bina kisi permission ke!*",
                0x2ecc71 # Emerald Green
            )
            success_emb.set_thumbnail(url=target_user.display_avatar.url)
            success_emb.set_footer(text=f"Authorized by {i.user.display_name} âœ…", icon_url=i.user.display_avatar.url)
            
            await safe_send(i, success_emb)

        # ==========================================
        # ğŸ”´ REMOVE USER (REVOKE ACCESS)
        # ==========================================
        elif mode.value == "remove":
            if not target_user:
                return await safe_send(i, emb("âŒ MISSING TARGET", "Permission chhin-ne ke liye User select karna padega!", 0xffa500))

            # ğŸ› ï¸ FIX: Wrapped in db_call!
            await db_call(lambda: supabase.table("multi_access").delete().eq("discord_id", discord_id).execute())

            # ğŸ’ PREMIUM EMBED
            revoked_emb = emb(
                "ğŸš« ACCESS REVOKED",
                f"**Target:** {target_user.mention}\n**Discord ID:** `{discord_id}`\n\nğŸ”´ **Status:** `Standard User`\n*Ab ye user **sirf 1 ID** verify kar payega. Limit reset!*",
                0xe74c3c # Crimson Red
            )
            revoked_emb.set_thumbnail(url=target_user.display_avatar.url)
            revoked_emb.set_footer(text=f"Revoked by {i.user.display_name} ğŸ›‘", icon_url=i.user.display_avatar.url)

            await safe_send(i, revoked_emb)

        # ==========================================
        # ğŸ“œ LIST USERS (VIEW ALL ALLOWED)
        # ==========================================
        elif mode.value == "list":
            # ğŸ› ï¸ FIX: Wrapped in db_call!
            res = await db_call(lambda: supabase.table("multi_access").select("*").execute())
            data = res.data if res else []

            if not data:
                empty_emb = emb(
                    "ğŸ“‚ MULTI-ACCESS ROSTER", 
                    "**Database is empty.**\nKisi ke paas bhi unlimited verification ki power nahi hai.", 
                    0x95a5a6
                )
                return await safe_send(i, empty_emb)

            txt = ""
            for index, x in enumerate(data, start=1):
                did = x['discord_id']
                txt += f"`{index:02d}.` ğŸ‘‘ <@{did}> (`{did}`)\n"

            # ğŸ’ PREMIUM EMBED FOR LIST
            list_emb = emb(
                f"ğŸ“‚ ELITE USERS LIST (Total: {len(data)})", 
                f"In logon ke paas **Unlimited Roblox Verification** ki power hai:\n\n{txt}", 
                0x3498db # Cool Blue
            )
            
            # List me Server ka icon ya Bot ka icon dikhega
            if i.guild and i.guild.icon:
                list_emb.set_thumbnail(url=i.guild.icon.url)
            else:
                list_emb.set_thumbnail(url=i.client.user.display_avatar.url)
                
            list_emb.set_footer(text="Core Security System Synced âœ…")

            await safe_send(i, list_emb)
        
    except Exception as e:
        print(f"Multiaccess Error: {e}")
        await safe_send(i, emb("âŒ SYSTEM GLITCH", f"Backend mein kuch gadbad hui hai:\n```{e}```", 0xff0000))

 # ================== 1. PAGINATOR CLASSES (Fixed: Access & Blacklist) ==================
import discord
from discord import app_commands

# --- A. ACCESS LIST PAGINATOR ---
class AccessPaginator(discord.ui.View):
    def __init__(self, data, author):
        super().__init__(timeout=60)
        self.data = data
        self.author = author
        self.per_page = 10
        self.current_page = 0
        self.total_pages = max(1, (len(data) + self.per_page - 1) // self.per_page)

    def get_embed(self):
        start = self.current_page * self.per_page
        end = start + self.per_page
        page_data = self.data[start:end]

        desc = ""
        if not page_data:
            desc = "ğŸ“­ *Database is currently empty.*"
        else:
            for index, user in enumerate(page_data):
                s_no = start + index + 1
                uid = user.get("user_id", "Unknown")
                uname = user.get("username", "Unknown")
                dname = user.get("display_name", "Unknown")
                desc += f"`{s_no:02d}.` ğŸŸ¢ **{dname}** (@{uname})\n   ğŸ†” `{uid}`\n\n"

        embed = discord.Embed(title=f"ğŸ“œ THE WHITELIST ROSTER (Total: {len(self.data)})", description=desc, color=0x2ecc71)
        embed.set_footer(text=f"Page {self.current_page + 1}/{self.total_pages} â€¢ Core Access System", icon_url=self.author.display_avatar.url)
        return embed

    def update_buttons(self):
        self.children[0].disabled = (self.current_page == 0)
        self.children[1].disabled = (self.current_page >= self.total_pages - 1)

    @discord.ui.button(label="â—€ï¸ Previous", style=discord.ButtonStyle.secondary)
    async def prev_btn(self, i: discord.Interaction, button: discord.ui.Button):
        if i.user.id != self.author.id: return await i.response.send_message("âŒ **Access Denied.**", ephemeral=True)
        self.current_page -= 1
        self.update_buttons()
        await i.response.edit_message(embed=self.get_embed(), view=self)

    @discord.ui.button(label="Next â–¶ï¸", style=discord.ButtonStyle.primary)
    async def next_btn(self, i: discord.Interaction, button: discord.ui.Button):
        if i.user.id != self.author.id: return await i.response.send_message("âŒ **Access Denied.**", ephemeral=True)
        self.current_page += 1
        self.update_buttons()
        await i.response.edit_message(embed=self.get_embed(), view=self)


# --- B. BLACKLIST PAGINATOR (Async Fetching included) ---
class BlacklistPaginator(discord.ui.View):
    def __init__(self, data, author):
        super().__init__(timeout=60)
        self.data = data
        self.author = author
        self.per_page = 5 
        self.current_page = 0
        self.total_pages = max(1, (len(data) + self.per_page - 1) // self.per_page)

    async def get_page_embed(self):
        start = self.current_page * self.per_page
        end = start + self.per_page
        page_data = self.data[start:end]

        embed = discord.Embed(title=f"ğŸš« THE BLACKLIST ROSTER (Total: {len(self.data)})", color=0x000000)
        
        if not page_data:
            embed.description = "ğŸ“­ *No users are currently blacklisted.*"
        else:
            for index, row in enumerate(page_data):
                uid = row.get("user_id")
                # Fetch info live 
                try:
                    u, d = await roblox_info(uid)
                except:
                    u, d = "Unknown", "Error Fetching"
                
                embed.add_field(
                    name=f"ğŸ’€ {d} (@{u})",
                    value=f"ğŸ†” `{uid}`",
                    inline=False
                )

        embed.set_footer(text=f"Page {self.current_page + 1}/{self.total_pages} â€¢ Threat Prevention System", icon_url=self.author.display_avatar.url)
        return embed

    def update_buttons(self):
        self.children[0].disabled = (self.current_page == 0)
        self.children[1].disabled = (self.current_page >= self.total_pages - 1)

    @discord.ui.button(label="â—€ï¸ Previous", style=discord.ButtonStyle.secondary)
    async def prev_btn(self, i: discord.Interaction, button: discord.ui.Button):
        if i.user.id != self.author.id: return await i.response.send_message("âŒ **Access Denied.**", ephemeral=True)
        self.current_page -= 1
        self.update_buttons()
        embed = await self.get_page_embed()
        await i.response.edit_message(embed=embed, view=self)

    @discord.ui.button(label="Next â–¶ï¸", style=discord.ButtonStyle.primary)
    async def next_btn(self, i: discord.Interaction, button: discord.ui.Button):
        if i.user.id != self.author.id: return await i.response.send_message("âŒ **Access Denied.**", ephemeral=True)
        self.current_page += 1
        self.update_buttons()
        embed = await self.get_page_embed()
        await i.response.edit_message(embed=embed, view=self)


# ================== 2. CLEAR CONFIRMATION VIEW (FIXED: Async Delete) ==================
class AccessClearView(discord.ui.View):
    def __init__(self, author_id):
        super().__init__(timeout=30)
        self.author_id = author_id

    @discord.ui.button(label="âš ï¸ YES - INITIATE PURGE", style=discord.ButtonStyle.danger)
    async def confirm(self, i: discord.Interaction, button: discord.ui.Button):
        if i.user.id != self.author_id: return await i.response.send_message("âŒ **Security Alert:** You cannot use this button.", ephemeral=True)
        
        await db_call(lambda: supabase.table("access_users").delete().neq("user_id", "0").execute())
        
        embed = discord.Embed(
            title="ğŸ§¨ DATABASE PURGE COMPLETE", 
            description="âœ… All whitelisted users have been **permanently erased** from the system.", 
            color=0xff0000
        )
        embed.set_thumbnail(url="https://media.tenor.com/1-11Yd6_QpYAAAAC/explosion-blast.gif")
        embed.set_footer(text=f"Purge initiated by {i.user.display_name}")
        await i.response.edit_message(embed=embed, view=None)
        self.stop()


# ================== HELPER: SYSTEM EMBED BUILDER ==================
def build_access_embed(mode_type, moderator, user_data=None, extra_info=None):
    config = {
        "on": {"title": "ğŸŸ¢ SYSTEM ONLINE", "color": 0x2ECC71, "desc": "Verification Gateway is now **OPEN & ACTIVE**."},
        "off": {"title": "ğŸ”´ SYSTEM OFFLINE", "color": 0xE74C3C, "desc": "Verification Gateway is now **LOCKED**."},
        "maint_on": {"title": "ğŸ›¡ï¸ MAINTENANCE MODE ACTIVATED", "color": 0xE67E22, "desc": "System is now in **Maintenance**.\n*Only Admins and VIPs can bypass.*"},
        "maint_off": {"title": "ğŸš€ SYSTEM LIVE", "color": 0x2ECC71, "desc": "Maintenance Mode **DEACTIVATED**.\n*System is operating normally.*"},
        "add": {"title": "ğŸ‘¤ WHITELIST GRANTED", "color": 0x2ECC71, "desc": "User has been granted **Premium Access**."},
        "remove": {"title": "ğŸ—‘ï¸ WHITELIST REVOKED", "color": 0xE74C3C, "desc": "User access has been **Revoked**."},
        "blk_add": {"title": "ğŸš« THREAT BLACKLISTED", "color": 0x000000, "desc": "User has been **Banned** from all systems."},
        "blk_remove": {"title": "âœ… THREAT NEUTRALIZED", "color": 0x3498DB, "desc": "User has been **Unbanned** from the Blacklist."},
        "clear": {"title": "âš ï¸ CRITICAL ALERT: DATABASE PURGE", "color": 0xFFAA00, "desc": "A total Wipe-Out of the Whitelist has been requested."}
    }

    cfg = config.get(mode_type, {"title": "âš™ï¸ SYSTEM UPDATE", "color": 0x2F3136, "desc": "Configuration changed."})
    
    embed = discord.Embed(title=cfg["title"], description=cfg["desc"], color=cfg["color"])
    embed.timestamp = discord.utils.utcnow() # ğŸ› ï¸ FIX: Safe Timezone
    
    if user_data:
        u_name, d_name, u_id = user_data
        embed.add_field(name="ğŸ‘¤ User Profile", value=f"**{d_name}**\n(@{u_name})", inline=True)
        embed.add_field(name="ğŸ†” Roblox ID", value=f"`{u_id}`", inline=True)
        embed.set_thumbnail(url=f"https://www.roblox.com/headshot-thumbnail/image?userId={u_id}&width=420&height=420&format=png")
    elif extra_info:
        embed.add_field(name="ğŸ“ Status Log", value=f"```{extra_info}```", inline=False)

    embed.set_footer(text=f"Operator: {moderator.display_name}", icon_url=moderator.display_avatar.url)
    return embed


# ================== 3. ULTIMATE ACCESS COMMAND ==================
@bot.tree.command(name="access", description="âš™ï¸ Master Control Panel (Whitelist, Blacklist, Security)")
@app_commands.choices(mode=[
    app_commands.Choice(name="ğŸŸ¢ Unlock Verification (Access ON)", value="on"),
    app_commands.Choice(name="ğŸ”´ Lock Verification (Access OFF)", value="off"),
    app_commands.Choice(name="ğŸ›¡ï¸ Enable Maintenance (Bot Down)", value="maint_on"),
    app_commands.Choice(name="ğŸš€ Disable Maintenance (Bot Live)", value="maint_off"),
    app_commands.Choice(name="ğŸ‘¤ Add to Whitelist", value="add"),
    app_commands.Choice(name="ğŸ—‘ï¸ Remove from Whitelist", value="remove"),
    app_commands.Choice(name="ğŸ“œ List Whitelisted Users", value="list"),
    app_commands.Choice(name="ğŸš« Add to Blacklist", value="blk_add"),
    app_commands.Choice(name="âœ… Remove from Blacklist", value="blk_remove"),
    app_commands.Choice(name="â˜ ï¸ List Blacklisted Users", value="blk_list"),
    app_commands.Choice(name="ğŸ§¨ PURGE All Whitelist", value="clear"),
])
async def access(i: discord.Interaction, mode: app_commands.Choice[str], user_id: str = None):
    
    # ğŸ”’ 1. OWNER CHECK (ğŸ› ï¸ FIX: Added 'await')
    if not await owner(i):
        return await i.response.send_message("âŒ **Security Alert:** Top-Secret Command. Owner Only.", ephemeral=True)
    
    # Clear mode ke liye defer nahi karenge (Button turant aana chahiye)
    if mode.value != "clear":
        await i.response.defer(ephemeral=False)

    try:
        # ================== 1. ACCESS ON/OFF ==================
        if mode.value in ["on", "off"]:
            val = "true" if mode.value == "on" else "false"
            
            await db_call(lambda: supabase.table("bot_settings").update({"value": val}).eq("key", "access_enabled").execute())
            
            # ğŸ› ï¸ FIX: Added 'await' to log_action
            try: await log_action(f"access_{mode.value}", "-", "-", "-", i.user.id)
            except: pass
            
            embed = build_access_embed(mode.value, i.user)
            await i.followup.send(embed=embed)


        # ================== 2. MAINTENANCE ON/OFF ==================
        elif mode.value in ["maint_on", "maint_off"]:
            val = "true" if mode.value == "maint_on" else "false"
            
            await db_call(lambda: supabase.table("bot_settings").update({"value": val}).eq("key", "maintenance").execute())
            
            # ğŸ› ï¸ FIX: Added 'await'
            try: await log_action(f"maintenance_{val}", "-", "-", "-", i.user.id)
            except: pass
            
            embed = build_access_embed(mode.value, i.user)
            await i.followup.send(embed=embed)


        # ================== 3. WHITELIST ADD ==================
        elif mode.value == "add":
            if not user_id: return await i.followup.send("âŒ **Error:** Roblox ID is required!")
            u, d = await roblox_info(user_id)
            
            await db_call(lambda: supabase.table("access_users").upsert({
                "user_id": user_id, "username": u, "display_name": d, "discord_id": str(i.user.id)
            }).execute())
            
            # ğŸ› ï¸ FIX: Added 'await'
            try: await log_action("access_add", user_id, u, d, i.user.id)
            except: pass
            
            embed = build_access_embed("add", i.user, (u, d, user_id))
            await i.followup.send(embed=embed)


        # ================== 4. WHITELIST REMOVE ==================
        elif mode.value == "remove":
            if not user_id: return await i.followup.send("âŒ **Error:** Roblox ID is required!")
            u, d = await roblox_info(user_id)
            
            await db_call(lambda: supabase.table("access_users").delete().eq("user_id", user_id).execute())
            
            # ğŸ› ï¸ FIX: Added 'await'
            try: await log_action("access_remove", user_id, u, d, i.user.id)
            except: pass
            
            embed = build_access_embed("remove", i.user, (u, d, user_id))
            await i.followup.send(embed=embed)


        # ================== 5. WHITELIST LIST ==================
        elif mode.value == "list":
            data_req = await db_call(lambda: supabase.table("access_users").select("*").execute())
            data = data_req.data if data_req else []

            if not data:
                return await i.followup.send(embed=discord.Embed(title="ğŸ“œ Whitelist Empty", description="No users are currently whitelisted.", color=0x2ECC71))
            
            view = AccessPaginator(data, i.user)
            if view.total_pages <= 1:
                view.children[0].disabled = True
                view.children[1].disabled = True
            else:
                view.update_buttons()
            
            await i.followup.send(embed=view.get_embed(), view=view)


        # ================== 6. BLACKLIST ADD ==================
        elif mode.value == "blk_add":
            if not user_id: return await i.followup.send("âŒ **Error:** Roblox ID is required!")
            u, d = await roblox_info(user_id)
            
            await db_call(lambda: supabase.table("blacklist_users").upsert({"user_id": user_id}).execute())
            try: await db_call(lambda: supabase.table("access_users").delete().eq("user_id", user_id).execute())
            except: pass
            
            # ğŸ› ï¸ FIX: Added 'await'
            try: await log_action("blacklist_add", user_id, u, d, i.user.id)
            except: pass
            
            embed = build_access_embed("blk_add", i.user, (u, d, user_id))
            await i.followup.send(embed=embed)


        # ================== 7. BLACKLIST REMOVE ==================
        elif mode.value == "blk_remove":
            # ğŸ› ï¸ FIX: Indentation error theek kar diya!
            if not user_id: return await i.followup.send("âŒ **Error:** Roblox ID is required!")
            u, d = await roblox_info(user_id)
            
            await db_call(lambda: supabase.table("blacklist_users").delete().eq("user_id", user_id).execute())
            
            # ğŸ› ï¸ FIX: Added 'await'
            try: await log_action("blacklist_remove", user_id, u, d, i.user.id)
            except: pass
            
            embed = build_access_embed("blk_remove", i.user, (u, d, user_id))
            await i.followup.send(embed=embed)


        # ================== 8. BLACKLIST LIST ==================
        elif mode.value == "blk_list":
            data_req = await db_call(lambda: supabase.table("blacklist_users").select("user_id").execute())
            data = data_req.data if data_req else []

            if not data:
                return await i.followup.send(embed=discord.Embed(title="ğŸ“œ Blacklist Empty", description="No users are currently blacklisted.", color=0x3498DB))
            
            view = BlacklistPaginator(data, i.user)
            if view.total_pages <= 1:
                view.children[0].disabled = True
                view.children[1].disabled = True
            else:
                view.update_buttons()
            
            embed = await view.get_page_embed()
            await i.followup.send(embed=embed, view=view)


        # ================== 9. CLEAR WHITELIST ==================
        elif mode.value == "clear":
            embed = build_access_embed("clear", i.user)
            embed.set_thumbnail(url="https://media.tenor.com/2b7lH3y8l08AAAAM/anime-disgust.gif")
            view = AccessClearView(i.user.id)
            await i.response.send_message(embed=embed, view=view, ephemeral=False)

    except Exception as e:
        print(f"ACCESS COMMAND ERROR: {e}")
        try:
            await i.followup.send(f"âŒ **System Glitch:** `{e}`")
        except:
            await i.response.send_message(f"âŒ **System Glitch:** `{e}`", ephemeral=True) 

            

# ================== VERIFIED LIST COMMAND (FIXED: Async & Fast) ==================
import discord
from discord import app_commands
import asyncio

@bot.tree.command(name="verifiedlist", description="ğŸ“œ Show paginated verified Roblox users (Owner Only)")
async def verifiedlist(i: discord.Interaction):
    
    # ğŸ”’ 1. OWNER CHECK (ğŸ› ï¸ FIX: Added 'await' for God-Tier Security)
    if not await owner(i):
        return await i.response.send_message("âŒ **Access Denied:** Only Server Owners can view this roster.", ephemeral=True)

    # â³ 2. DEFER (Premium processing)
    await i.response.defer(ephemeral=False)

    try:
        # âœ… FIX: Parallel Execution using your db_call!
        logs_task = db_call(lambda: supabase.table("verify_logs").select("*").order("timestamp", desc=True).execute())
        access_task = db_call(lambda: supabase.table("access_users").select("user_id").execute())

        # Dono data ek saath layenge (Super Fast)
        logs_resp, access_resp = await asyncio.gather(logs_task, access_task)

        logs = logs_resp.data if logs_resp else []
        access = access_resp.data if access_resp else []
        
        # ğŸ› ï¸ FIX: IDs ko string bana liya taaki type mismatch error na aaye
        access_ids = {str(x["user_id"]) for x in access}

    except Exception as e:
        embed = discord.Embed(title="âš ï¸ DATABASE ERROR", description=f"Failed to fetch logs:\n```{e}```", color=0xff0000)
        return await i.followup.send(embed=embed)

    if not logs:
        embed = discord.Embed(title="ğŸ“­ DATABASE EMPTY", description="No verified users found in the system logs.", color=0x95a5a6)
        return await i.followup.send(embed=embed)

    seen = set()
    entries = []

    for x in logs:
        rid = str(x.get("roblox_id", ""))

        # 1. Ignore duplicates
        if rid in seen:
            continue

        # 2. Only users who STILL HAVE ACCESS
        if rid not in access_ids:
            continue

        seen.add(rid)

        # ğŸ› ï¸ FIX: Date formatting safety (Agar timestamp None hua toh crash nahi karega)
        raw_time = x.get('timestamp', 'Unknown')
        date_str = raw_time.split('T')[0] if 'T' in str(raw_time) else raw_time

        # ğŸ’ ULTRA PREMIUM FORMATTING (Tree Style)
        entries.append(
            f"ğŸ‘¤ <@{x.get('discord_id', 'Unknown')}>\n"
            f" â”£ ğŸ†” **Roblox ID:** `{rid}`\n"
            f" â”£ ğŸ® **User:** `{x.get('username', 'Unknown')}` *( {x.get('display_name', 'Unknown')} )*\n"
            f" â”— ğŸ•’ **Verified On:** `{date_str}`\n"
        )

    if not entries:
        embed = discord.Embed(title="ğŸ“› CLEAN SLATE", description="No currently whitelisted verified users found.", color=0xe67e22)
        return await i.followup.send(embed=embed)

    # ================= PAGINATION LOGIC =================
    PAGES = []
    chunk = []

    for e in entries:
        chunk.append(e)
        if len(chunk) == 5:
            PAGES.append("\n".join(chunk))
            chunk = []

    if chunk:
        PAGES.append("\n".join(chunk))

    # ğŸ’ SMART UI VIEW
    class VerifyPages(discord.ui.View):
        def __init__(self):
            super().__init__(timeout=120)
            self.page = 0
            self.message = None # ğŸ› ï¸ FIX: Message ko store karenge timeout ke liye
            self.update_buttons()

        def update_buttons(self):
            # ğŸ› ï¸ FIX: Smart Button States
            self.children[0].disabled = (self.page == 0)
            self.children[1].disabled = (self.page == len(PAGES) - 1)

        def get_current_embed(self):
            embed = discord.Embed(
                title="ğŸ“œ ELITE VERIFIED ROSTER",
                description=f"**Total Verified & Active:** `{len(entries)}`\n\n{PAGES[self.page]}",
                color=0x2ecc71 # Emerald Green
            )
            embed.set_footer(text=f"Page {self.page+1} of {len(PAGES)} â€¢ Secured Database", icon_url=i.user.display_avatar.url)
            return embed

        async def update(self, interaction):
            self.update_buttons()
            await interaction.response.edit_message(embed=self.get_current_embed(), view=self)

        @discord.ui.button(label="â—€ï¸ Previous", style=discord.ButtonStyle.secondary)
        async def back(self, interaction: discord.Interaction, button: discord.ui.Button):
            if i.user.id != interaction.user.id: 
                return await interaction.response.send_message("âŒ **Access Denied:** Aap is menu ko control nahi kar sakte.", ephemeral=True)
            if self.page > 0:
                self.page -= 1
            await self.update(interaction)

        @discord.ui.button(label="Next â–¶ï¸", style=discord.ButtonStyle.primary)
        async def next(self, interaction: discord.Interaction, button: discord.ui.Button):
            if i.user.id != interaction.user.id: 
                return await interaction.response.send_message("âŒ **Access Denied:** Aap is menu ko control nahi kar sakte.", ephemeral=True)
            if self.page < len(PAGES) - 1:
                self.page += 1
            await self.update(interaction)

        async def on_timeout(self):
            # ğŸ› ï¸ FIX: Timeout hone par buttons disable hoke message update hoga
            for c in self.children:
                c.disabled = True
            if self.message:
                try:
                    await self.message.edit(view=self)
                except:
                    pass

    # ================= INITIALIZE AND SEND =================
    view = VerifyPages()
    
    # ğŸ› ï¸ FIX: Paginator object ke andar message save kar diya
    msg = await i.followup.send(embed=view.get_current_embed(), view=view)
    view.message = msg 
        

# ================== USER INFO (GOD MODE) ==================
import discord
from discord import app_commands
import asyncio

@bot.tree.command(name="userinfo", description="ğŸ” Deep Scan a Discord User (Discord + DB)")
@app_commands.describe(user="Tag the player (@Username)")
async def userinfo(i: discord.Interaction, user: discord.Member):
    
    # â³ 1. DEFER (Essential for deep database scans)
    await i.response.defer(ephemeral=False)

    try:
        # ğŸ› ï¸ FIX 1: Fetch user safely to get the Banner image
        fetched_user = await i.client.fetch_user(user.id)
        
        # ================= 1. DISCORD DEEP DIVE =================
        now = discord.utils.utcnow() # ğŸ› ï¸ FIX 2: Safe Discord Time
        
        # --- Dates & Age ---
        created_at = user.created_at
        acc_age = (now - created_at).days
        age_str = f"{acc_age // 365}Y, {acc_age % 365}D"
        
        joined_at = user.joined_at or now
        join_str = joined_at.strftime("%d %b %Y")
        
        # --- Join Position (Server Rank) ---
        try:
            sorted_members = sorted(i.guild.members, key=lambda m: m.joined_at or now)
            join_pos = sorted_members.index(user) + 1
            total_members = len(i.guild.members)
            join_rank = f"#{join_pos} of {total_members}"
        except:
            join_rank = "Unknown"

        # --- Roles & Perms ---
        roles = [r.mention for r in user.roles if r.name != "@everyone"]
        roles.reverse()
        role_count = len(roles)
        top_roles = ", ".join(roles[:3]) + (f" (+{role_count-3} more)" if role_count > 3 else "") if roles else "No Roles"
        
        key_perms = []
        if user.guild_permissions.administrator: key_perms.append("ğŸ‘‘ ADMIN")
        if user.guild_permissions.ban_members: key_perms.append("ğŸ”¨ BAN")
        if user.guild_permissions.kick_members: key_perms.append("ğŸ‘¢ KICK")
        if user.guild_permissions.manage_guild: key_perms.append("âš™ï¸ MANAGER")
        perm_str = " | ".join(key_perms) if key_perms else "Standard User"

        # --- Badges & Status ---
        is_bot = "ğŸ¤– YES" if user.bot else "ğŸ‘¤ NO"
        is_booster = f"ğŸš€ Since {user.premium_since.strftime('%b %Y')}" if user.premium_since else "âŒ No"
        nick = user.nick if user.nick else "None"

        # ================= 2. SUPABASE (DB) DEEP SCAN =================
        
        # A. Multi-Access (VIP) Check (ğŸ› ï¸ FIX 3: Wrapped in db_call)
        res_multi = await db_call(lambda: supabase.table("multi_access").select("discord_id").eq("discord_id", str(user.id)).execute())
        access_level = "â™¾ï¸ UNLIMITED (VIP)" if (res_multi and res_multi.data) else "ğŸ”’ LIMITED (Standard)"

        # B. Fetch All Linked Accounts (ğŸ› ï¸ FIX 3: Wrapped in db_call)
        res_accs = await db_call(lambda: supabase.table("access_users").select("*").eq("discord_id", str(user.id)).execute())
        acc_data = res_accs.data if res_accs else []
        
        roblox_list = ""
        alert_list = ""
        total_accs = len(acc_data)
        risk_score = 0
        
        if acc_data:
            if total_accs > 2: risk_score += 10
            if total_accs > 5: risk_score += 20

            for acc in acc_data:
                rid = acc['user_id']
                
                # ğŸ› ï¸ FIX 4: Added 'await' to roblox_info to prevent crash!
                try:
                    u, d = await roblox_info(rid) 
                except:
                    u, d = acc.get('username','Unknown'), acc.get('display_name','Unknown')

                # BAN & BLACKLIST CHECK (ğŸ› ï¸ FIX 3: Wrapped in db_call)
                ban_res = await db_call(lambda: supabase.table("bans").select("*").eq("user_id", rid).execute())
                blk_res = await db_call(lambda: supabase.table("blacklist_users").select("*").eq("user_id", rid).execute())
                
                ban_chk = ban_res.data if ban_res else []
                blk_chk = blk_res.data if blk_res else []
                
                status_icon = "ğŸŸ¢"
                note = ""

                if ban_chk:
                    status_icon = "ğŸ”´"
                    reason = ban_chk[0].get('reason', 'No reason')
                    alert_list += f"ğŸš¨ **BANNED:** `{u}` ({reason})\n"
                    risk_score += 50
                    note = "*(BANNED)*"

                if blk_chk:
                    status_icon = "âš«"
                    alert_list += f"ğŸš« **BLACKLIST:** `{u}`\n"
                    risk_score += 100
                    note = "*(BLACKLISTED)*"

                roblox_list += f"{status_icon} **{d}** (`@{u}`) | ğŸ†” `{rid}` {note}\n"

            if len(roblox_list) > 900:
                roblox_list = roblox_list[:900] + "\n*... (List truncated)*"
        else:
            roblox_list = "ğŸ“­ No verified Roblox accounts linked."
        
        # C. Calculate Final Risk Status & Smart Colors
        embed_color = user.color
        if risk_score == 0: 
            risk_status = "ğŸŸ¢ SAFE (Verified)"
        elif risk_score < 40: 
            risk_status = "ğŸŸ¡ MODERATE (Multi-Accounting)"
            embed_color = 0xF1C40F # Warning Yellow
        elif risk_score < 80: 
            risk_status = "ğŸŸ  HIGH RISK (Active Bans)"
            embed_color = 0xE67E22 # Orange
        else: 
            risk_status = "ğŸ”´ CRITICAL THREAT (Blacklisted)"
            embed_color = 0xE74C3C # Red

        # ================= 3. BUILD THE PREMIUM EMBED =================
        embed = discord.Embed(title="ğŸ” GLOBAL DOSSIER & DEEP SCAN", color=embed_color)
        embed.set_author(name=f"{user.name} ({user.display_name})", icon_url=user.display_avatar.url)
        embed.set_thumbnail(url=user.display_avatar.url)
        
        # Banner Image (If user has one)
        if fetched_user.banner:
            embed.set_image(url=fetched_user.banner.url)

        # --- SECTION 1: DISCORD PROFILE ---
        embed.add_field(name="ğŸ·ï¸ Identity Metrics", value=(
            f"**ID:** `{user.id}`\n"
            f"**Nickname:** `{nick}`\n"
            f"**Bot Status:** {is_bot}\n"
            f"**Nitro Booster:** {is_booster}"
        ), inline=True)

        embed.add_field(name="ğŸ“… Temporal Data", value=(
            f"**Account Age:** `{age_str}`\n"
            f"**Server Join:** `{join_str}`\n"
            f"**Join Rank:** `{join_rank}`"
        ), inline=True)

        embed.add_field(name=f"ğŸ›¡ï¸ Authority & Roles ({role_count})", value=(
            f"**Key Permissions:** `{perm_str}`\n"
            f"**Top Roles:** {top_roles}"
        ), inline=False)

        # --- SECTION 2: SYSTEM SECURITY ---
        embed.add_field(name="âš™ï¸ Verification Profile", value=(
            f"**Access Level:** {access_level}\n"
            f"**Linked Roblox Accs:** `{total_accs}`\n"
            f"**Security Threat Level:** **{risk_status}**"
        ), inline=False)

        # --- SECTION 3: ROBLOX ACCOUNTS ---
        if total_accs > 0:
            embed.add_field(name="ğŸ® Linked Roblox Connections", value=roblox_list, inline=False)

        # --- SECTION 4: ALERTS ---
        if alert_list:
            embed.add_field(name="âš ï¸ SEVERE SECURITY ALERTS", value=alert_list, inline=False)

        # Footer
        embed.set_footer(text=f"Scan requested by {i.user.display_name} â€¢ Core Database", icon_url=i.user.display_avatar.url)
        embed.timestamp = now

        await i.followup.send(embed=embed)

    except Exception as e:
        await i.followup.send(embed=discord.Embed(title="âŒ DEEP SCAN FAILED", description=f"System Error:\n```{e}```", color=0xff0000))

    
# ================== VERIFICATION HISTORY CHECK (PREMIUM UI) ==================
import discord
from discord import app_commands
import datetime as dt

# ==============================================================================
# ğŸ” VERIFY CHECK (ULTRA-PREMIUM DOSSIER)
# ==============================================================================
@bot.tree.command(name="verifycheck", description="ğŸ” Deep Scan a user's Roblox verification history")
@app_commands.describe(target_user="Select the Discord user to inspect")
async def verifycheck(i: discord.Interaction, target_user: discord.User):

    # â³ 1. DEFER (Premium processing time & Crash Prevention)
    await i.response.defer(ephemeral=False)

    # ğŸ”’ 2. OWNER CHECK (ğŸ› ï¸ FIX: 'await' lagana bahut zaroori hai!)
    if not await owner(i):
        embed = discord.Embed(title="âŒ ACCESS DENIED", description="Only Top-Level Admins can use the Verify Scanner.", color=0xff0000)
        return await safe_send(i, embed)

    discord_id = str(target_user.id)

    # ğŸ—„ï¸ 3. FETCH DATA FROM SUPABASE (ğŸ› ï¸ FIX: Wrapped in db_call)
    try:
        res = await db_call(lambda: supabase.table("verify_logs").select("*").eq("discord_id", discord_id).order("timestamp", desc=True).execute())
        data = res.data if res else []
    except Exception as e:
        embed = discord.Embed(title="âš ï¸ DATABASE ERROR", description=f"Failed to fetch logs.\n```{e}```", color=0xffa500)
        return await safe_send(i, embed)

    # ğŸ“­ 4. NO DATA FOUND
    if not data:
        no_data_emb = discord.Embed(
            title="ğŸ“­ NO VERIFICATION DATA", 
            description=f"**Target:** {target_user.mention} (`{discord_id}`)\n\n*This user has no verified Roblox accounts in the system.*", 
            color=0x95a5a6 # Grey
        )
        no_data_emb.set_thumbnail(url=target_user.display_avatar.url)
        return await safe_send(i, no_data_emb)

    # ğŸ› ï¸ 5. FORMAT THE HISTORY (Ultra-Premium Tree Style)
    txt = ""
    seen = set()
    count = 0

    for x in data:
        rid = str(x.get("roblox_id", "Unknown"))
        
        # Duplicate check
        if rid in seen:
            continue
        seen.add(rid)
        count += 1

        username = x.get('username', 'Unknown')
        display_name = x.get('display_name', 'Unknown')
        
        # Date formatting fix (Remove ugly T and milliseconds)
        raw_time = str(x.get('timestamp', 'Unknown Time'))
        date_str = raw_time.split('T')[0] if 'T' in raw_time else raw_time

        txt += (
            f"`{count:02d}.` ğŸ”— **[{username}](https://www.roblox.com/users/{rid}/profile)**\n"
            f" â”£ ğŸ†” **Roblox ID:** `{rid}`\n"
            f" â”£ âœ¨ **Display:** `{display_name}`\n"
            f" â”— ğŸ•’ **Linked On:** `{date_str}`\n\n"
        )

    # ğŸ¨ 6. SMART COLOR SYSTEM (Alt Account Detection)
    embed_color = 0x9b59b6 # Premium Purple (Safe: 1-2 accounts)
    status_msg = "ğŸŸ¢ `Normal Activity`"
    
    if count >= 3:
        embed_color = 0xF1C40F # Warning Yellow (Suspicious: 3-5 accounts)
        status_msg = "ğŸŸ¡ `Suspicious (Multiple Accounts)`"
    if count > 5:
        embed_color = 0xE74C3C # Danger Red (Alt Farming: 6+ accounts)
        status_msg = "ğŸ”´ `HIGH RISK (Alt Farming Detected)`"

    # ğŸ’ 7. BUILD PREMIUM EMBED
    result_emb = discord.Embed(
        title=f"ğŸ” VERIFICATION DOSSIER ({count} Accounts)", 
        description=f"**ğŸ‘¤ Target:** {target_user.mention}\n**ğŸ†” Discord ID:** `{discord_id}`\n**âš ï¸ Threat Level:** {status_msg}\n\n{txt[:3800]}", 
        color=embed_color
    )
    
    # Premium features: Avatar thumbnail & Footer
    result_emb.set_thumbnail(url=target_user.display_avatar.url)
    result_emb.set_footer(text=f"Scan initialized by {i.user.display_name} â€¢ Titan Security", icon_url=i.user.display_avatar.url)
    result_emb.timestamp = discord.utils.utcnow() # Live timestamp

    await safe_send(i, result_emb)


# ========================== whois =============================
import discord
from discord import app_commands
import asyncio
import time

# ==============================================================================
# ğŸ•µï¸ WHOIS: DEEP SCAN ROBLOX USER (ULTRA-PREMIUM)
# ==============================================================================
@bot.tree.command(name="whois", description="ğŸ•µï¸ Deep Scan & get detailed status of a Roblox User")
@app_commands.describe(user_id="Enter the Roblox ID (Numbers only)")
async def whois(i: discord.Interaction, user_id: str):
    
    # ğŸ”’ 1. OWNER CHECK (ğŸ› ï¸ FIX: 'await' lagana bahut zaroori hai!)
    if not await owner(i):
        embed = discord.Embed(title="âŒ ACCESS DENIED", description="Only Top-Level Admins can use the WhoIs Scanner.", color=0xff0000)
        return await i.response.send_message(embed=embed, ephemeral=True)

    # â³ 2. DEFER (Premium processing time)
    await i.response.defer(ephemeral=False)

    try:
        # ğŸ® 3. FETCH ROBLOX INFO
        username, display = await roblox_info(user_id)
        
        # Handle invalid user
        if username in ["Invalid ID", "Unknown"]:
            return await i.followup.send(embed=discord.Embed(title="âŒ INVALID TARGET", description=f"Roblox ID `{user_id}` does not exist.", color=0xff0000))

        # ğŸ—„ï¸ 4. PARALLEL DATABASE FETCHING (Super Fast!)
        # ğŸ› ï¸ FIX: Wrapped all 3 queries in db_call and ran them together using asyncio.gather
        ban_task = db_call(lambda: supabase.table("bans").select("*").eq("user_id", user_id).execute())
        acc_task = db_call(lambda: supabase.table("access_users").select("user_id").eq("user_id", user_id).execute())
        blk_task = db_call(lambda: supabase.table("blacklist_users").select("user_id").eq("user_id", user_id).execute())

        ban_res, acc_res, blk_res = await asyncio.gather(ban_task, acc_task, blk_task)

        ban_data = ban_res.data if ban_res else []
        ac = acc_res.data if acc_res else []
        blk = blk_res.data if blk_res else []

        # âš–ï¸ 5. LOGIC & FORMATTING
        color = 0x2ecc71 # Default Green
        status_emoji = "ğŸŸ¢"
        status_text = "Clean (No Active Bans)"
        threat_level = "Low Risk"

        # A. Ban Check Logic
        if ban_data:
            b = ban_data[0]
            if b.get("perm"):
                status_emoji = "ğŸ”´"
                status_text = f"**PERMANENTLY BANNED**\nReason: `{b.get('reason', 'N/A')}`"
                color = 0xff0000
                threat_level = "Critical (Banned)"
            else:
                # Time calc
                expire_time = float(b.get("expire", 0))
                left = int((expire_time - time.time()) / 60)
                if left > 0:
                    status_emoji = "ğŸŸ "
                    status_text = f"**TEMP BANNED** (`{left}m` left)\nReason: `{b.get('reason', 'N/A')}`"
                    color = 0xe67e22 # Orange
                    threat_level = "High Risk (Temp Ban)"
                else:
                    status_emoji = "ğŸŸ¢"
                    status_text = "Clean (Ban Expired)"

        # B. Blacklist Override (Blacklist is worse than a normal ban)
        blacklist_str = "ğŸŸ¢ **No**"
        if blk:
            blacklist_str = "ğŸš« **Yes (Restricted)**"
            color = 0x000000 # Pitch Black for Blacklisted
            status_emoji = "âš«"
            threat_level = "MAXIMUM THREAT (Blacklisted)"

        # C. Access Check
        access_str = "âœ… **Whitelisted**" if ac else "âŒ **Not Whitelisted**"

        # ğŸ’ 6. BUILD ULTRA-PREMIUM EMBED
        embed = discord.Embed(title=f"ğŸ•µï¸ TARGET DOSSIER: {display}", color=color)
        
        # Header (User Info - Tree Style)
        embed.add_field(
            name="ğŸ‘¤ Identity Matrix", 
            value=f" â”£ ğŸ§‘ **Username:** [{username}](https://www.roblox.com/users/{user_id}/profile)\n"
                  f" â”£ âœ¨ **Display:** `{display}`\n"
                  f" â”— ğŸ†” **Roblox ID:** `{user_id}`", 
            inline=False
        )
        
        # Moderation Alert
        embed.add_field(name="ğŸ›¡ï¸ Moderation Status", value=f"> {status_emoji} {status_text}", inline=False)
        
        # Grid Status
        embed.add_field(name="ğŸ” System Access", value=access_str, inline=True)
        embed.add_field(name="â›” Blacklist", value=blacklist_str, inline=True)
        embed.add_field(name="âš ï¸ Threat Level", value=f"`{threat_level}`", inline=True)

        # Thumbnail (Roblox Headshot)
        embed.set_thumbnail(url=f"https://www.roblox.com/headshot-thumbnail/image?userId={user_id}&width=420&height=420&format=png")
        
        # Premium Footer
        embed.set_footer(text=f"Scan initialized by {i.user.display_name} â€¢ Titan Security", icon_url=i.user.display_avatar.url)
        embed.timestamp = discord.utils.utcnow() # ğŸ› ï¸ FIX: Safe Timezone

        await i.followup.send(embed=embed)

    except Exception as e:
        print(f"WHOIS ERROR: {e}")
        await i.followup.send(embed=discord.Embed(title="âŒ DEEP SCAN FAILED", description=f"System Error:\n```{e}```", color=0xff0000))

        
# ================== STATS COMMAND (FIXED: FAST & ASYNC) ==================

import discord
from discord import app_commands
import asyncio
import time

# ==============================================================================
# ğŸ“Š SYSTEM STATS (ULTRA-PREMIUM DASHBOARD)
# ==============================================================================
@bot.tree.command(name="stats", description="ğŸ“Š View Core System Statistics & Health")
async def stats(i: discord.Interaction):
    
    # ğŸ”’ 1. OWNER CHECK (ğŸ› ï¸ FIX: Added 'await' for God-Tier Security)
    if not await owner(i):
        embed = discord.Embed(title="âŒ ACCESS DENIED", description="Administrator clearance required to view telemetry.", color=0xff0000)
        return await i.response.send_message(embed=embed, ephemeral=True)

    # â³ 2. DEFER (Essential for 6 concurrent DB calls)
    await i.response.defer(ephemeral=False)

    try:
        start_t = time.time() # Timer start for DB Ping

        # ğŸ—„ï¸ 3. PARALLEL DB FETCHING (Optimized RAM usage)
        bans_task = db_call(lambda: supabase.table("bans").select("*").execute())
        # ğŸ› ï¸ FIX: Using specific columns instead of "*" saves memory!
        access_task = db_call(lambda: supabase.table("access_users").select("user_id").execute())
        blk_task = db_call(lambda: supabase.table("blacklist_users").select("user_id").execute())
        logs_task = db_call(lambda: supabase.table("verify_logs").select("discord_id").execute())
        kick_task = db_call(lambda: supabase.table("kick_flags").select("user_id").execute())
        sett_task = db_call(lambda: supabase.table("bot_settings").select("*").execute())

        # Sabka ek saath wait karo (Super Fast)
        bans, access, blk, logs, kicks, settings = await asyncio.gather(
            bans_task, access_task, blk_task, logs_task, kick_task, sett_task
        )

        # ğŸ›¡ï¸ Data extract (Safety ke saath)
        bans_data = bans.data if bans else []
        access_data = access.data if access else []
        blk_data = blk.data if blk else []
        logs_data = logs.data if logs else []
        kicks_data = kicks.data if kicks else []
        sett_data = settings.data if settings else []

        # ğŸ§® 4. PROCESS BANS
        now = time.time()
        perm, temp = 0, 0
        for b in bans_data:
            if b.get("perm"): 
                perm += 1
            elif b.get("expire") and now < float(b.get("expire", 0)): 
                temp += 1

        # âš™ï¸ 5. PROCESS SETTINGS
        acc_status = "ğŸ”´ `DISABLED` (Open Access)"
        maint_status = "ğŸŸ¢ `ONLINE` (Stable)"
        embed_color = 0x2b2d31 # Premium Dark Theme

        for s in sett_data:
            if s.get("key") == "access_enabled" and s.get("value") == "true": 
                acc_status = "ğŸŸ¢ `ENABLED` (Strict Mode)"
            if s.get("key") == "maintenance" and s.get("value") == "true": 
                maint_status = "ğŸ› ï¸ `MAINTENANCE` (Bot Down)"
                embed_color = 0xE67E22 # Orange warning if maintenance is ON

        # â±ï¸ 6. UPTIME & LATENCY CALCULATIONS
        try:
            uptime = int(time.time() - START_TIME)
            hrs, mins = uptime // 3600, (uptime % 3600) // 60
            uptime_str = f"{hrs}h {mins}m"
        except:
            uptime_str = "Unknown"

        # Calculate Bot API Ping and Supabase Latency
        api_ping = round(i.client.latency * 1000)
        db_ping = round((time.time() - start_t) * 1000)

        # ğŸ’ 7. BUILD ULTRA-PREMIUM EMBED (Tree Style)
        embed = discord.Embed(
            title="ğŸ“Š SYSTEM HEALTH & CORE TELEMETRY", 
            description="Live dashboard of the Titan Engine infrastructure.", 
            color=embed_color
        )
        embed.set_thumbnail(url="https://media.tenor.com/On7kvXhzml4AAAAi/loading-gif.gif")
        
        embed.add_field(
            name="ğŸ›¡ï¸ Threat Management", 
            value=f" â”£ **Permanent Bans:** `{perm}`\n â”£ **Active TempBans:** `{temp}`\n â”— **Blacklisted IDs:** `{len(blk_data)}`", 
            inline=False
        )
        
        embed.add_field(
            name="ğŸ‘¥ Authorization Gateway", 
            value=f" â”£ **Whitelisted Users:** `{len(access_data)}`\n â”£ **Total Verifications:** `{len(logs_data)}`\n â”— **Kick Flags Pending:** `{len(kicks_data)}`", 
            inline=False
        )
        
        embed.add_field(
            name="âš™ï¸ Core Infrastructure", 
            value=f" â”£ **Whitelist Security:** {acc_status}\n â”— **System Mode:** {maint_status}", 
            inline=False
        )
        
        embed.add_field(
            name="ğŸ“¡ Network & Performance", 
            value=f" â”£ **System Uptime:** `{uptime_str}`\n â”£ **Discord API Ping:** `{api_ping}ms`\n â”— **Database Latency:** `{db_ping}ms` âš¡", 
            inline=False
        )
        
        embed.set_footer(text=f"Requested by {i.user.display_name} â€¢ Secure Moderation Engine", icon_url=i.user.display_avatar.url)
        embed.timestamp = discord.utils.utcnow() # ğŸ› ï¸ FIX: Safe Timezone
        
        await i.followup.send(embed=embed)

    except Exception as e:
        await i.followup.send(embed=discord.Embed(title="âŒ FATAL ERROR", description=f"Dashboard crash:\n```{e}```", color=0xff0000))


        
# ================== ALT CHECK COMMAND (FIXED: Async DB) ==================
import discord
from discord import app_commands

# ==============================================================================
# ğŸ•µï¸ ALT CHECKER (ULTRA-PREMIUM DOSSIER)
# ==============================================================================
@bot.tree.command(name="altcheck", description="ğŸ•µï¸ Deep Scan for Roblox/Discord Alt Accounts")
@app_commands.describe(
    discord_user="Tag the Discord user to check their Roblox links",
    roblox_user_id="Enter a Roblox ID to see connected Discord accounts"
)
async def altcheck(i: discord.Interaction, discord_user: discord.User = None, roblox_user_id: str = None):
    
    # â³ 1. DEFER FIRST (Premium processing time & Crash Prevention)
    await i.response.defer(ephemeral=False)

    # ğŸ”’ 2. OWNER CHECK (ğŸ› ï¸ FIX: Added 'await' for God-Tier Security)
    if not await owner(i):
        embed = discord.Embed(title="âŒ ACCESS DENIED", description="Only Top-Level Admins can use the Alt Scanner.", color=0xff0000)
        return await safe_send(i, embed)

    # âŒ 3. INVALID (Both Empty)
    if not discord_user and not roblox_user_id:
        embed = discord.Embed(
            title="âš ï¸ MISSING PARAMETERS", 
            description="Please provide either a **Discord User** OR a **Roblox ID** to scan.", 
            color=0xffa500
        )
        return await safe_send(i, embed)

    try:
        # ==========================================
        # ğŸ” MODE A: DISCORD USER SCAN
        # ==========================================
        if discord_user:
            # ğŸ› ï¸ FIX: Wrapped in db_call for 100% Crash Safety
            res = await db_call(lambda: supabase.table("verify_logs").select("*").eq("discord_id", str(discord_user.id)).execute())
            logs = res.data if res else []

            if not logs:
                embed = discord.Embed(
                    title="ğŸ“­ CLEAN SLATE",
                    description=f"**Target:** {discord_user.mention}\n*This user hasn't verified any Roblox accounts yet.*",
                    color=0x95a5a6 # Grey
                )
                embed.set_thumbnail(url=discord_user.display_avatar.url)
                return await safe_send(i, embed)

            # Filter Unique Accounts
            unique_accs = {}
            for x in logs:
                unique_accs[x["roblox_id"]] = x

            count = len(unique_accs)
            
            # ğŸ¨ Smart Colors & Threat Level
            color = 0x2ecc71 # Emerald Green
            status = "ğŸŸ¢ `CLEAN` (Single Account)"
            
            if count == 2:
                color = 0xF1C40F # Warning Yellow
                status = "ğŸŸ¡ `SUSPICIOUS` (2 Accounts Linked)"
            elif count >= 3:
                color = 0xE74C3C # Crimson Red
                status = f"ğŸ”´ `HIGH THREAT` ({count} Alt Accounts Detected)"

            # ğŸ’ Build Ultra-Premium Tree List
            txt = ""
            for idx, (rid, v) in enumerate(unique_accs.items(), 1):
                txt += (
                    f"`{idx:02d}.` ğŸ”— **[{v.get('username', 'Unknown')}](https://www.roblox.com/users/{rid}/profile)**\n"
                    f" â”£ ğŸ†” **Roblox ID:** `{rid}`\n"
                    f" â”— âœ¨ **Display:** `{v.get('display_name', 'Unknown')}`\n\n"
                )

            if len(txt) > 3000: txt = txt[:3000] + "\n... *(List truncated)*"

            embed = discord.Embed(
                title="ğŸ•µï¸ ALT-ACCOUNT DOSSIER", 
                description=f"**ğŸ‘¤ Discord Target:** {discord_user.mention}\n**âš ï¸ Threat Level:** {status}\n\n**Linked Accounts ({count}):**\n{txt}", 
                color=color
            )
            embed.set_thumbnail(url=discord_user.display_avatar.url)
            embed.set_footer(text=f"Scan initialized by {i.user.display_name} â€¢ Titan Security", icon_url=i.user.display_avatar.url)
            embed.timestamp = discord.utils.utcnow() # Safe Timezone

            return await safe_send(i, embed)

        # ==========================================
        # ğŸ” MODE B: ROBLOX ID SCAN
        # ==========================================
        if roblox_user_id:
            # ğŸ› ï¸ FIX: Wrapped in db_call for 100% Crash Safety
            res = await db_call(lambda: supabase.table("verify_logs").select("*").eq("roblox_id", roblox_user_id).execute())
            logs = res.data if res else []

            if not logs:
                embed = discord.Embed(
                    title="ğŸ“­ UNKNOWN IDENTITY",
                    description=f"Roblox ID `{roblox_user_id}` has not been verified by anyone in this server.",
                    color=0x95a5a6
                )
                return await safe_send(i, embed)

            user_info = logs[0]
            discord_ids = list({x["discord_id"] for x in logs})
            count = len(discord_ids)

            # ğŸ¨ Smart Colors & Threat Level
            color = 0x2ecc71 # Green
            status = "ğŸŸ¢ `CLEAN` (Owned by 1 Discord User)"
            
            if count == 2:
                color = 0xF1C40F # Yellow
                status = "ğŸŸ¡ `SUSPICIOUS` (Shared by 2 Users)"
            elif count >= 3:
                color = 0xE74C3C # Red
                status = f"ğŸ”´ `COMPROMISED` (Shared by {count} Discord Users)"

            # ğŸ’ Build Tree List for Discord accounts
            txt = ""
            for idx, did in enumerate(discord_ids, 1):
                txt += f"`{idx:02d}.` ğŸ‘¤ <@{did}> (`{did}`)\n"

            embed = discord.Embed(
                title="ğŸ•µï¸ ROBLOX ID DOSSIER", 
                description=(
                    f"**ğŸ® Roblox Target:** [{user_info.get('username', 'Unknown')}](https://www.roblox.com/users/{roblox_user_id}/profile)\n"
                    f"**ğŸ†” Roblox ID:** `{roblox_user_id}`\n"
                    f"**âš ï¸ Threat Level:** {status}\n\n"
                    f"**Linked Discord Accounts ({count}):**\n{txt}"
                ),
                color=color
            )
            embed.set_thumbnail(url=f"https://www.roblox.com/headshot-thumbnail/image?userId={roblox_user_id}&width=420&height=420&format=png")
            embed.set_footer(text=f"Scan initialized by {i.user.display_name} â€¢ Titan Security", icon_url=i.user.display_avatar.url)
            embed.timestamp = discord.utils.utcnow()

            return await safe_send(i, embed)

    except Exception as e:
        await safe_send(i, discord.Embed(title="âŒ FATAL ERROR", description=f"Scanner crashed:\n```{e}```", color=0xff0000))

# ================== VERIFY HISTORY COMMAND (FIXED: Async DB) ==================
import discord
from discord import app_commands
from discord import ui

# ==============================================================================
# ğŸ“œ GLOBAL VERIFICATION HISTORY (ULTRA-PREMIUM DOSSIER)
# ==============================================================================
@bot.tree.command(name="verifyhistory", description="ğŸ“œ Show global verification logs (Owner Only)")
async def verifyhistory(i: discord.Interaction):
    
    # ğŸ”’ 1. OWNER CHECK (ğŸ› ï¸ FIX: 'await' lagana bahut zaroori hai!)
    if not await owner(i):
        embed = discord.Embed(title="âŒ ACCESS DENIED", description="Only Top-Level Admins can view the global history.", color=0xff0000)
        return await safe_send(i, embed)

    # â³ 2. DEFER (Premium processing time)
    await i.response.defer(ephemeral=False)

    try:
        # ğŸ—„ï¸ 3. ASYNC DB CALL (ğŸ› ï¸ FIX: Wrapped in db_call)
        res = await db_call(lambda: supabase.table("verify_logs").select("*").order("timestamp", desc=True).execute())
        logs = res.data if res else []
    except Exception as e:
        embed = discord.Embed(title="âš ï¸ DATABASE ERROR", description=f"Failed to fetch logs:\n```{e}```", color=0xffa500)
        return await i.followup.send(embed=embed)

    # ğŸ“­ 4. NO DATA FOUND
    if not logs:
        embed = discord.Embed(title="ğŸ“­ DATABASE EMPTY", description="No one has verified their account in this server yet.", color=0x95a5a6)
        return await i.followup.send(embed=embed)

    # ğŸ’ 5. FORMATTING THE HISTORY (Ultra-Premium Tree Style)
    pages = []
    page_chunk = []

    for idx, x in enumerate(logs, 1):
        # Date formatting crash fix
        t_raw = x.get("timestamp", "Unknown")
        t = str(t_raw).replace("T", " ").split(".")[0] if "T" in str(t_raw) else t_raw
        
        # Safe extraction
        uname = x.get('username', 'Unknown')
        dname = x.get('display_name', 'Unknown')
        rid = str(x.get('roblox_id', 'Unknown'))
        did = x.get('discord_id', 'Unknown')

        page_chunk.append(
            f"`{idx:02d}.` ğŸ‘¤ <@{did}>\n"
            f" â”£ ğŸ”— **[{uname}](https://www.roblox.com/users/{rid}/profile)** *( {dname} )*\n"
            f" â”£ ğŸ†” **Roblox ID:** `{rid}`\n"
            f" â”— ğŸ•’ **Time:** `{t}`\n"
        )

        # 5 items per page looks much cleaner and premium
        if len(page_chunk) == 5:
            pages.append("\n".join(page_chunk))
            page_chunk = []

    if page_chunk:
        pages.append("\n".join(page_chunk))

    # ğŸ“± 6. SMART PAGINATION VIEW (With Timeout & Button States)
    class HistoryPager(ui.View):
        def __init__(self):
            super().__init__(timeout=120) # 2 Minutes timeout
            self.index = 0
            self.message = None
            self.update_buttons() # ğŸ› ï¸ FIX: Initial button state
        
        def update_buttons(self):
            # ğŸ› ï¸ FIX: Smart disable logic
            self.children[0].disabled = (self.index == 0)
            self.children[1].disabled = (self.index == len(pages) - 1)

        def get_embed(self):
            embed = discord.Embed(
                title="ğŸ“œ GLOBAL VERIFICATION HISTORY",
                description=f"**Total Logs:** `{len(logs)}`\n\n{pages[self.index]}",
                color=0x3498db # Premium Blue
            )
            embed.set_footer(text=f"Page {self.index + 1} of {len(pages)} â€¢ Titan Security", icon_url=i.user.display_avatar.url)
            return embed

        async def update(self, interaction):
            self.update_buttons()
            await interaction.response.edit_message(embed=self.get_embed(), view=self)

        @ui.button(label="â—€ï¸ Previous", style=discord.ButtonStyle.secondary)
        async def back(self, interaction: discord.Interaction, btn: discord.ui.Button):
            if i.user.id != interaction.user.id: 
                return await interaction.response.send_message("âŒ **Access Denied:** Aap is menu ko control nahi kar sakte.", ephemeral=True)
            
            if self.index > 0:
                self.index -= 1
            await self.update(interaction)

        @ui.button(label="Next â–¶ï¸", style=discord.ButtonStyle.primary)
        async def next(self, interaction: discord.Interaction, btn: discord.ui.Button):
            if i.user.id != interaction.user.id: 
                return await interaction.response.send_message("âŒ **Access Denied:** Aap is menu ko control nahi kar sakte.", ephemeral=True)

            if self.index < len(pages) - 1:
                self.index += 1
            await self.update(interaction)
            
        async def on_timeout(self):
            # ğŸ› ï¸ FIX: Disable buttons smoothly when time is up
            for c in self.children:
                c.disabled = True
            if self.message:
                try: await self.message.edit(view=self)
                except: pass

    # ================= INITIALIZE AND SEND =================
    view = HistoryPager()
    
    # ğŸ› ï¸ FIX: Saving the message object to handle the timeout edit
    msg = await i.followup.send(embed=view.get_embed(), view=view)
    view.message = msg

    
# ================== PROFILE COMMAND (FIXED: FAST & PARALLEL) ==================
import discord
from discord import app_commands
import asyncio

# ==============================================================================
# ğŸ“‚ PLAYER PROFILE DEEP SCAN (ULTRA-PREMIUM)
# ==============================================================================
@bot.tree.command(name="profile", description="ğŸ” Deep Scan a player's full Safety & Verification Profile")
@app_commands.describe(
    discord_user="Tag the Discord User to scan their profile",
    roblox_id="OR enter their Roblox ID directly"
)
async def profile(i: discord.Interaction, discord_user: discord.User = None, roblox_id: str = None):
    
    # â³ 1. DEFER (Premium processing time for deep scan)
    await i.response.defer(ephemeral=False)

    # ğŸ”’ 2. OWNER CHECK (ğŸ› ï¸ FIX: Added 'await' for God-Tier Security)
    if not await owner(i):
        embed = discord.Embed(title="âŒ ACCESS DENIED", description="Only Admins can access the Global Profile Scanner.", color=0xff0000)
        return await i.followup.send(embed=embed)

    # âŒ 3. VALIDATION (Ensure only one input is provided)
    if not discord_user and not roblox_id:
        return await i.followup.send(embed=discord.Embed(title="âš ï¸ MISSING DATA", description="Please provide either a **Discord User** OR a **Roblox ID**.", color=0xffa500))
    if discord_user and roblox_id:
        return await i.followup.send(embed=discord.Embed(title="âš ï¸ CONFLICT", description="Please provide ONLY ONE option (either Discord User OR Roblox ID), not both.", color=0xffa500))

    try:
        target_rid = None

        # ================= A. RESOLVE IDENTITY =================
        if discord_user:
            # Discord user se Roblox ID nikaalo
            res = await db_call(lambda: supabase.table("access_users").select("user_id").eq("discord_id", str(discord_user.id)).execute())
            if not res or not res.data:
                embed = discord.Embed(title="ğŸ“­ NO PROFILE FOUND", description=f"{discord_user.mention} is not verified in the system.", color=0x95a5a6)
                return await i.followup.send(embed=embed)
            target_rid = res.data[0].get("user_id")
        else:
            target_rid = roblox_id

        # ğŸ® Fetch Roblox Info (Async & Fast)
        username, display = await roblox_info(target_rid)

        if username in ["Invalid ID", "Unknown"]:
             return await i.followup.send(embed=discord.Embed(title="âŒ INVALID TARGET", description=f"Roblox ID `{target_rid}` does not exist.", color=0xff0000))

        # ================= B. FETCH DATA (PARALLEL SCAN) =================
        # Saari 6 tables ek saath check hongi (Wait time = 0s) âš¡
        task1 = db_call(lambda: supabase.table("access_users").select("*").eq("user_id", target_rid).execute())
        task2 = db_call(lambda: supabase.table("bans").select("*").eq("user_id", target_rid).execute())
        task3 = db_call(lambda: supabase.table("blacklist_users").select("*").eq("user_id", target_rid).execute())
        task4 = db_call(lambda: supabase.table("fake_warnings").select("*").eq("user_id", target_rid).execute())
        task5 = db_call(lambda: supabase.table("fake_flags").select("*").eq("user_id", target_rid).execute())
        task6 = db_call(lambda: supabase.table("kick_flags").select("*").eq("user_id", target_rid).execute())

        # Sabka result ek saath aayega
        res1, res2, res3, res4, res5, res6 = await asyncio.gather(task1, task2, task3, task4, task5, task6)
        
        # Data Extraction (Safe Mode)
        access = res1.data if res1 else []
        bans = res2.data if res2 else []
        blk = res3.data if res3 else []
        warnings = res4.data if res4 else []
        flags = res5.data if res5 else []
        kicks = res6.data if res6 else []

        # ================= C. PROCESS DATA =================
        color = 0x2ecc71 # Default Green (Clean)

        # --- 1. Verification Logic ---
        if access:
            data = access[0]
            verifier_id = data.get("discord_id", "Unknown")
            
            try:
                date_str = data.get("created_at", "").split("T")[0]
            except:
                date_str = "Unknown"

            verify_status = "âœ… `Whitelisted`"
            verify_desc = (
                f" â”£ ğŸ‘¤ **Discord:** <@{verifier_id}>\n"
                f" â”£ ğŸ“… **Verified On:** `{date_str}`\n"
                f" â”— ğŸ†” **Discord ID:** `{verifier_id}`"
            )
        else:
            verify_status = "âš ï¸ `Not Whitelisted`"
            verify_desc = " â”— *User is currently not verified in the database.*"
            color = 0x3498db # Blue (Neutral)

        # --- 2. Moderation & Safety Logic ---
        mod_status = []
        
        if bans:
            b = bans[0]
            if b.get('perm'):
                mod_status.append(f" â”£ ğŸ”´ **Permanent Ban:** `{b.get('reason', 'N/A')}`")
                color = 0xff0000 # Red
            else:
                mod_status.append(f" â”£ ğŸŸ  **Temp Ban:** `{b.get('reason', 'N/A')}`")
                color = 0xe67e22 if color != 0xff0000 else color # Orange

        if blk:
            mod_status.append(" â”£ ğŸš« **Status:** `BLACKLISTED`")
            color = 0x000000 # Pitch Black

        if flags:
            mod_status.append(f" â”£ ğŸš© **System Flags:** `{len(flags)} Active`")
            color = 0xF1C40F if color not in [0xff0000, 0x000000] else color # Yellow
        
        if kicks:
            mod_status.append(f" â”£ ğŸ‘¢ **Kick History:** `{len(kicks)} Kicks`")

        if warnings:
            mod_status.append(f" â”— âš ï¸ **Warnings:** `{len(warnings)} Warnings`")

        if mod_status:
            # Fix tree formatting for the last item
            mod_status[-1] = mod_status[-1].replace(" â”£ ", " â”— ")
            mod_text = "\n".join(mod_status)
        else:
            mod_text = " â”— ğŸŸ¢ **Clean Record** *(No bans, flags, or warnings)*"


        # ================= D. BUILD ULTRA-PREMIUM EMBED =================
        embed = discord.Embed(
            title=f"ğŸ“‚ MASTER DOSSIER: {display}", 
            description="Complete system background check and security profile.",
            color=color
        )
        
        # Header: User Identity
        embed.add_field(
            name="ğŸ‘¤ Identity Matrix", 
            value=f" â”£ **Roblox User:** [{username}](https://www.roblox.com/users/{target_rid}/profile)\n â”— **Roblox ID:** `{target_rid}`", 
            inline=False
        )
        
        # Section 1: Verification
        embed.add_field(name="ğŸ” Verification Status", value=verify_status, inline=True)
        embed.add_field(name="ğŸ›¡ï¸ Threat Level", value="`Calculating...`" if color == 0x2ecc71 else "`High Risk`", inline=True)
        
        # Section 2: Details
        embed.add_field(name="ğŸ“œ Access Record", value=verify_desc, inline=False)
        
        # Section 3: History
        embed.add_field(name="ğŸš¨ Moderation & Penalty Log", value=mod_text, inline=False)

        # Thumbnail
        embed.set_thumbnail(url=f"https://www.roblox.com/headshot-thumbnail/image?userId={target_rid}&width=420&height=420&format=png")
        
        # Premium Footer
        embed.set_footer(text=f"Scan initialized by {i.user.display_name} â€¢ Titan Security", icon_url=i.user.display_avatar.url)
        embed.timestamp = discord.utils.utcnow() # ğŸ› ï¸ FIX: Safe Timezone

        await i.followup.send(embed=embed)

    except Exception as e:
        print(f"PROFILE ERROR: {e}")
        await i.followup.send(embed=discord.Embed(title="âŒ DEEP SCAN FAILED", description=f"System Error:\n```{e}```", color=0xff0000))

# ================== MULTI-VERIFY COMMAND (FIXED: Async DB) ==================
import discord
from discord import app_commands

# ==============================================================================
# ğŸ” MULTI-VERIFY SCANNER (ALT ACCOUNT DETECTOR)
# ==============================================================================
@bot.tree.command(name="multiverify", description="ğŸ” Find users who verified multiple Roblox accounts")
async def multiverify(i: discord.Interaction):

    # â³ 1. DEFER (Premium processing time)
    await i.response.defer(ephemeral=False)

    # ğŸ”’ 2. OWNER CHECK (ğŸ› ï¸ FIX: Added 'await' for God-Tier Security!)
    if not await owner(i):
        embed = discord.Embed(title="âŒ ACCESS DENIED", description="Only Top-Level Admins can run the Multi-Verify Scanner.", color=0xff0000)
        return await i.followup.send(embed=embed)

    try:
        # ğŸ—„ï¸ 3. SAFE DB FETCH (ğŸ› ï¸ FIX: Using db_call)
        res = await db_call(lambda: supabase.table("access_users").select("*").execute())
        logs = res.data if res else []
    except Exception as e:
        embed = discord.Embed(title="âš ï¸ DATABASE ERROR", description=f"Failed to fetch logs:\n```{e}```", color=0xffa500)
        return await i.followup.send(embed=embed)

    if not logs:
        embed = discord.Embed(title="ğŸ“­ DATABASE EMPTY", description="No verified users found in the system.", color=0x95a5a6)
        return await i.followup.send(embed=embed)

    # âš™ï¸ 4. DATA PROCESSING
    users = {}
    for x in logs:
        did = x.get("discord_id")
        rid = str(x.get("user_id"))
        uname = x.get("username", "Unknown")
        dname = x.get("display_name", "Unknown")

        if not did or not rid: continue

        if did not in users:
            users[did] = {"roblox_ids": set(), "entries": {}}

        users[did]["roblox_ids"].add(rid)
        users[did]["entries"][rid] = (uname, dname)

    # ğŸ¨ 5. FORMATTING (Ultra-Premium Tree Style)
    result_blocks = []
    counter = 1

    for did, data in users.items():
        if len(data["roblox_ids"]) > 1: # Only multi-verifiers
            
            # Header for the Suspect
            block = f"`{counter:02d}.` ğŸ‘¤ <@{did}> (`{did}`)\n â”£ âš ï¸ **Linked Accounts:** `{len(data['roblox_ids'])}`\n"
            
            # Formatting their Roblox IDs
            entries = list(data["entries"].items())
            for idx, (rid, info) in enumerate(entries):
                uname, dname = info
                prefix = " â”— " if idx == len(entries) - 1 else " â”£ "
                block += f"{prefix}ğŸ”— **[{uname}](https://www.roblox.com/users/{rid}/profile)** *( {dname} )* | ğŸ†” `{rid}`\n"
            
            block += "\n"
            result_blocks.append(block)
            counter += 1

    if not result_blocks:
        embed = discord.Embed(
            title="âœ… SYSTEM CLEAN", 
            description="No users found with multiple verified Roblox accounts. Everyone has only 1 account linked!", 
            color=0x2ecc71 # Emerald Green
        )
        return await i.followup.send(embed=embed)

    # ğŸ“„ 6. PAGINATION SETUP
    PAGES = []
    temp = []
    for b in result_blocks:
        temp.append(b)
        if len(temp) == 3: # 3 multi-verifiers per page looks clean and premium
            PAGES.append("".join(temp))
            temp = []
    if temp:
        PAGES.append("".join(temp))

    # ğŸ“± 7. SMART PAGINATOR VIEW
    class MVPages(discord.ui.View):
        def __init__(self):
            super().__init__(timeout=120)
            self.page = 0
            self.message = None
            self.update_buttons() # ğŸ› ï¸ FIX: Initialize button states

        def update_buttons(self):
            # ğŸ› ï¸ FIX: Smart disable logic
            self.children[0].disabled = (self.page == 0)
            self.children[1].disabled = (self.page == len(PAGES) - 1)

        def get_embed(self):
            embed = discord.Embed(
                title="ğŸ” SUSPICIOUS ACTIVITY: MULTI-VERIFIERS",
                description=f"**Total Suspects Found:** `{len(result_blocks)}`\n\n{PAGES[self.page]}",
                color=0xE67E22 # Warning Orange
            )
            embed.set_footer(text=f"Page {self.page+1} of {len(PAGES)} â€¢ Alt-Detection System", icon_url=i.user.display_avatar.url)
            return embed

        async def update(self, interaction):
            self.update_buttons()
            await interaction.response.edit_message(embed=self.get_embed(), view=self)

        @discord.ui.button(label="â—€ï¸ Previous", style=discord.ButtonStyle.secondary)
        async def back(self, interaction: discord.Interaction, btn: discord.ui.Button):
            if i.user.id != interaction.user.id: 
                return await interaction.response.send_message("âŒ **Access Denied:** You cannot control this menu.", ephemeral=True)
            if self.page > 0:
                self.page -= 1
            await self.update(interaction)

        @discord.ui.button(label="Next â–¶ï¸", style=discord.ButtonStyle.primary)
        async def next(self, interaction: discord.Interaction, btn: discord.ui.Button):
            if i.user.id != interaction.user.id: 
                return await interaction.response.send_message("âŒ **Access Denied:** You cannot control this menu.", ephemeral=True)
            if self.page < len(PAGES)-1:
                self.page += 1
            await self.update(interaction)

        async def on_timeout(self):
            # ğŸ› ï¸ FIX: Safely disable buttons and update message on timeout
            for c in self.children:
                c.disabled = True
            if self.message:
                try: await self.message.edit(view=self)
                except: pass

    # ================= SEND =================
    view = MVPages()
    msg = await i.followup.send(embed=view.get_embed(), view=view)
    view.message = msg # ğŸ› ï¸ FIX: Storing message object for timeout

# ================== FAKE BAN COMMAND (FIXED: Async & No Lag) ==================
import discord
from discord import app_commands

# ==============================================================================
# ğŸ­ FAKE BAN CONTROL PANEL (ULTRA-PREMIUM TROLL SYSTEM)
# ==============================================================================
@bot.tree.command(name="fakeban", description="ğŸ­ Troll Control Panel: Manage Fake Bans (Owner Only)")
@app_commands.describe(
    action="Choose what you want to do",
    userid="Roblox User ID (Required for Add/Remove)",
    message="Custom kick/ban message for the user"
)
@app_commands.choices(action=[
    app_commands.Choice(name="â• Add Fake Ban (Troll)", value="add"),
    app_commands.Choice(name="â– Remove Fake Ban (Pardon)", value="remove"),
    app_commands.Choice(name="ğŸ“œ List Pending Fake Bans", value="list")
])
async def fakeban(i: discord.Interaction, action: app_commands.Choice[str], userid: str = None, message: str = None):

    # â³ 1. DEFER (Premium processing & Crash Prevention)
    await i.response.defer(ephemeral=False)

    # ğŸ”’ 2. OWNER CHECK (ğŸ› ï¸ FIX: Added 'await' for God-Tier Security)
    if not await owner(i):
        embed = discord.Embed(title="âŒ ACCESS DENIED", description="Only Top-Level Admins can use the Troll Control Panel.", color=0xff0000)
        return await i.followup.send(embed=embed)

    try:
        # ==========================================
        # â• ADD FAKE BAN (TROLL MODE)
        # ==========================================
        if action.value == "add":
            if not userid:
                embed = discord.Embed(title="âš ï¸ MISSING DATA", description="Roblox User ID is required to queue a fake ban.", color=0xffa500)
                return await i.followup.send(embed=embed)

            # ğŸ—„ï¸ Database Check (ğŸ› ï¸ FIX: Safe db_call)
            chk_req = await db_call(lambda: supabase.table("fake_warnings").select("user_id").eq("user_id", userid).execute())
            
            if chk_req and chk_req.data:
                embed = discord.Embed(title="âš ï¸ ALREADY QUEUED", description=f"Roblox ID `{userid}` is already in the troll queue.", color=0xF1C40F)
                return await i.followup.send(embed=embed)

            # ğŸ® Fetch Roblox Info safely
            uname, dname = await roblox_info(userid)
            
            if uname in ["Invalid ID", "Unknown"]:
                return await i.followup.send(embed=discord.Embed(title="âŒ INVALID TARGET", description=f"Roblox ID `{userid}` does not exist.", color=0xff0000))

            # ğŸ“ Default Scary Message Logic
            msg = message or "ğŸš« Account Action Required\n\nYour account has been temporarily restricted due to suspicious activity.\nDuration: 3 Days\nReference: #SEC-9043X"

            # ğŸ—„ï¸ Insert to Database
            await db_call(lambda: supabase.table("fake_warnings").insert({
                "user_id": userid,
                "username": uname,
                "display_name": dname,
                "message": msg
            }).execute())

            # ğŸ’ Ultra-Premium Embed
            embed = discord.Embed(
                title="ğŸ­ FAKE BAN SUCCESSFULLY QUEUED",
                description="The target will see a terrifying restriction message when they try to verify! ğŸ˜ˆ",
                color=0xe74c3c # Crimson Red
            )
            embed.add_field(
                name="ğŸ‘¤ Target Details", 
                value=f" â”£ **User:** [{uname}](https://www.roblox.com/users/{userid}/profile)\n â”£ **Display:** `{dname}`\n â”— **Roblox ID:** `{userid}`", 
                inline=False
            )
            embed.add_field(name="ğŸ“ The Fake Message", value=f"```{msg}```", inline=False)
            embed.set_thumbnail(url=f"https://www.roblox.com/headshot-thumbnail/image?userId={userid}&width=420&height=420&format=png")
            embed.set_footer(text=f"Troll initiated by {i.user.display_name} â€¢ System Core", icon_url=i.user.display_avatar.url)
            
            return await i.followup.send(embed=embed)

        # ==========================================
        # â– REMOVE FAKE BAN (PARDON MODE)
        # ==========================================
        elif action.value == "remove":
            if not userid:
                embed = discord.Embed(title="âš ï¸ MISSING DATA", description="Roblox User ID is required to remove a fake ban.", color=0xffa500)
                return await i.followup.send(embed=embed)

            # ğŸ—„ï¸ Safe Delete
            await db_call(lambda: supabase.table("fake_warnings").delete().eq("user_id", userid).execute())

            embed = discord.Embed(
                title="ğŸ§¹ FAKE BAN REVOKED",
                description=f"Roblox ID `{userid}` has been removed from the troll queue.\n*They are safe... for now.*",
                color=0x2ecc71 # Emerald Green
            )
            embed.set_thumbnail(url="https://media.tenor.com/2b7lH3y8l08AAAAM/anime-disgust.gif")
            embed.set_footer(text=f"Pardoned by {i.user.display_name}", icon_url=i.user.display_avatar.url)
            
            return await i.followup.send(embed=embed)

        # ==========================================
        # ğŸ“œ LIST FAKE BANS
        # ==========================================
        elif action.value == "list":
            # ğŸ—„ï¸ Safe Fetch
            data_req = await db_call(lambda: supabase.table("fake_warnings").select("*").execute())
            data = data_req.data if data_req else []

            if not data:
                embed = discord.Embed(title="ğŸ“­ TROLL QUEUE EMPTY", description="No pending fake bans in the system.", color=0x95a5a6)
                return await i.followup.send(embed=embed)

            # ğŸ’ Format Tree List
            txt = ""
            for idx, x in enumerate(data, 1):
                uid = x.get('user_id', 'Unknown')
                uname = x.get('username', 'Unknown')
                dname = x.get('display_name', 'Unknown')
                msg = x.get('message', 'No message')
                
                # Truncate long messages
                short_msg = msg[:45] + "..." if len(msg) > 45 else msg

                txt += (
                    f"`{idx:02d}.` ğŸ­ **{dname}** (`{uname}`)\n"
                    f" â”£ ğŸ†” **Roblox ID:** `{uid}`\n"
                    f" â”— ğŸ“ **Msg:** *\"{short_msg}\"*\n\n"
                )

            # Message limit safety
            if len(txt) > 3000: txt = txt[:3000] + "\n... *(List truncated)*"

            embed = discord.Embed(
                title="ğŸ“œ PENDING FAKE BANS ROSTER", 
                description=f"**Total Targets in Queue:** `{len(data)}`\n\n{txt}", 
                color=0x3498db # Cool Blue
            )
            embed.set_footer(text=f"Troll System â€¢ Core Database â€¢ Requested by {i.user.display_name}", icon_url=i.user.display_avatar.url)

            return await i.followup.send(embed=embed)

    except Exception as e:
        await i.followup.send(embed=discord.Embed(title="âŒ FATAL ERROR", description=f"System Glitch:\n```{e}```", color=0xff0000))


# ================== ADMIN LOGS COMMAND (FIXED: Async & No Duplicate) ==================
import discord
from discord import app_commands
import time
import asyncio
from collections import deque

# ==============================================================================
# ğŸ“¡ CORE TELEMETRY ENGINE (Global Trackers)
# ==============================================================================
START_TIME = time.time()
AUDIT_LOG = deque(maxlen=120)      # Last 120 checks (~1hr)
TRAFFIC_LOG = deque(maxlen=300)    # Recent API Requests
DB_FAILURES = deque(maxlen=100)    # Database connection drops

def log_request(success=True):
    TRAFFIC_LOG.append((time.time(), success))

def log_db(success=True):
    DB_FAILURES.append((time.time(), success))

def track_audit(success: bool):
    AUDIT_LOG.append((time.time(), success))


# ==============================================================================
# ğŸ—‚ï¸ MASTER ADMIN LOGS (ULTRA-PREMIUM DOSSIER)
# ==============================================================================
@bot.tree.command(name="logs", description="ğŸ—‚ï¸ View Master Admin Logs with Advanced Filters")
@app_commands.describe(filter="Select the type of logs you want to investigate")
@app_commands.choices(filter=[
    app_commands.Choice(name="ğŸŒ All Actions (Full History)", value="all"),
    app_commands.Choice(name="ğŸ› ï¸ Maintenance (On/Off)", value="maintenance"),
    app_commands.Choice(name="ğŸ›‘ System Stop/Start", value="stop"),
    app_commands.Choice(name="ğŸ”´ Ban History", value="ban"),
    app_commands.Choice(name="ğŸŸ  Tempban History", value="tempban"),
    app_commands.Choice(name="ğŸŸ¢ Unban History", value="unban"),
    app_commands.Choice(name="ğŸ‘¢ Kick History", value="kick"),
    app_commands.Choice(name="âœ… Access Granted", value="access_add"),
    app_commands.Choice(name="âŒ Access Revoked", value="access_remove"),
    app_commands.Choice(name="ğŸ‘‘ Multi-Access Granted", value="multi_add"),
    app_commands.Choice(name="ğŸ“‰ Multi-Access Revoked", value="multi_remove"),
    app_commands.Choice(name="ğŸš« Blacklist Additions", value="blacklist_add"),
    app_commands.Choice(name="â™»ï¸ Blacklist Removals", value="blacklist_remove"),
])
async def logs(i: discord.Interaction, filter: app_commands.Choice[str]):
    
    # â³ 1. DEFER (Premium processing time)
    await i.response.defer(ephemeral=False)
    log_request(True) # Telemetry Check

    # ğŸ”’ 2. OWNER CHECK (ğŸ› ï¸ FIX: Added 'await' for God-Tier Security)
    if not await owner(i):
        embed = discord.Embed(title="âŒ ACCESS DENIED", description="Only Level-10 Admins can view the system logs.", color=0xff0000)
        return await i.followup.send(embed=embed)

    try:
        # ğŸ—„ï¸ 3. ASYNC DB FETCHING
        if filter.value == "all":
            res = await db_call(lambda: supabase.table("admin_logs").select("*").order("timestamp", desc=True).limit(100).execute())
        else:
            # Partial match using .ilike
            res = await db_call(lambda: supabase.table("admin_logs").select("*").ilike("action", f"{filter.value}%").order("timestamp", desc=True).limit(100).execute())
            
        data = res.data if res else []
        log_db(True) # Telemetry Check
            
    except Exception as e:
        log_db(False) # Telemetry Failure
        embed = discord.Embed(title="âš ï¸ DATABASE ERROR", description=f"Failed to retrieve logs:\n```{e}```", color=0xff0000)
        return await i.followup.send(embed=embed)

    # ğŸ“­ 4. NO DATA
    if not data:
        embed = discord.Embed(
            title="ğŸ“­ SYSTEM CLEAN", 
            description=f"No recent logs found for the filter: **{filter.name}**", 
            color=0xF1C40F # Yellow
        )
        return await i.followup.send(embed=embed)

    # ğŸ’ 5. FORMATTING (Ultra-Premium Tree Style)
    pages = []
    chunk = []

    for x in data:
        # Timestamp Safety
        t_raw = x.get("timestamp", "Unknown Time")
        t = str(t_raw).replace("T", " ").split(".")[0] if "T" in str(t_raw) else t_raw
        
        # Executor formatting
        executor_id = str(x.get('executor', 'Unknown'))
        executor_mention = f"<@{executor_id}>" if executor_id.isdigit() else f"`{executor_id}`"

        # Action formatting
        act = str(x.get('action', 'Unknown')).replace("_", " ").title()
        target = x.get('user_id', 'System/All')

        chunk.append(
            f"ğŸ“Œ **Action:** `{act}`\n"
            f" â”£ ğŸ‘® **Admin:** {executor_mention}\n"
            f" â”£ ğŸ¯ **Target:** `{target}`\n"
            f" â”— ğŸ“… **Time:** `{t}`\n"
        )

        if len(chunk) == 5: # 5 items per page for a clean look
            pages.append("\n".join(chunk))
            chunk = []

    if chunk:
        pages.append("\n".join(chunk))

    # ğŸ“± 6. SMART PAGINATOR
    class LogPages(discord.ui.View):
        def __init__(self):
            super().__init__(timeout=120)
            self.page = 0
            self.message = None
            self.update_buttons()

        def update_buttons(self):
            # Smart button disable logic
            self.children[0].disabled = (self.page == 0)
            self.children[1].disabled = (self.page == len(pages) - 1)

        def get_embed(self):
            embed = discord.Embed(
                title=f"ğŸ—‚ï¸ AUDIT LOGS: {filter.name.upper()}",
                description=f"**Total Records Found:** `{len(data)}`\n\n{pages[self.page]}",
                color=0x3498db # Cool Blue
            )
            embed.set_footer(text=f"Page {self.page+1} of {len(pages)} â€¢ Core Audit System", icon_url=i.user.display_avatar.url)
            return embed

        async def update(self, interaction):
            self.update_buttons()
            await interaction.response.edit_message(embed=self.get_embed(), view=self)

        @discord.ui.button(label="â—€ï¸ Previous", style=discord.ButtonStyle.secondary)
        async def back(self, interaction: discord.Interaction, button: discord.ui.Button):
            if i.user.id != interaction.user.id: 
                return await interaction.response.send_message("âŒ **Access Denied.**", ephemeral=True)
            if self.page > 0:
                self.page -= 1
            await self.update(interaction)

        @discord.ui.button(label="Next â–¶ï¸", style=discord.ButtonStyle.primary)
        async def next(self, interaction: discord.Interaction, button: discord.ui.Button):
            if i.user.id != interaction.user.id: 
                return await interaction.response.send_message("âŒ **Access Denied.**", ephemeral=True)
            if self.page < len(pages) - 1:
                self.page += 1
            await self.update(interaction)
            
        async def on_timeout(self):
            for c in self.children:
                c.disabled = True
            if self.message:
                try: await self.message.edit(view=self)
                except: pass

    # ================= SEND =================
    view = LogPages()
    msg = await i.followup.send(embed=view.get_embed(), view=view)
    view.message = msg

# ================== AUDIT COMMAND (FIXED: Async & Non-Blocking) ==================
import discord
from discord import app_commands
import time

# ==============================================================================
# ğŸ§  ULTRA SYSTEM AUDIT (V3 PRO - GOD TIER)
# ==============================================================================
@bot.tree.command(name="audit", description="ğŸ§  Run Advanced Full System Health & Risk Audit")
async def audit(i: discord.Interaction):
    
    # â³ 1. DEFER (Premium processing time & Crash Prevention)
    await i.response.defer(ephemeral=False)

    # ğŸ”’ 2. OWNER CHECK (ğŸ› ï¸ FIX: Added 'await' for God-Tier Security)
    if not await owner(i):
        embed = discord.Embed(title="âŒ ACCESS DENIED", description="Only Top-Level Admins can run the System Audit.", color=0xff0000)
        return await i.followup.send(embed=embed)

    try:
        ok = True
        
        # ===============================
        # ğŸŒ BACKEND HEALTH + LATENCY
        # ===============================
        t = time.time()
        backend_online = False
        latency = 9999

        try:
            # ğŸ› ï¸ Safe session handling for external API ping
            async with bot.session.get("https://testingbot-8pb1.onrender.com/ping", timeout=6) as r:
                text = await r.text()
                backend_online = (text.strip() == "pong")
                latency = int((time.time() - t) * 1000)
                log_request(True)
        except:
            ok = False
            backend_online = False
            log_request(False)

        backend_status = "ğŸŸ¢ `ONLINE`" if backend_online else "ğŸ”´ `OFFLINE`"

        # ===============================
        # ğŸ—„ï¸ DATABASE HEALTH
        # ===============================
        t = time.time()
        db_ok = True
        q_ms = 9999

        try:
            # ğŸ› ï¸ Safe db_call execution
            await db_call(lambda: supabase.table("bot_settings").select("key").limit(1).execute())
            q_ms = int((time.time() - t) * 1000)
            log_db(True)
        except:
            db_ok = False
            ok = False
            log_db(False)

        db_status = "ğŸŸ¢ `CONNECTED`" if db_ok else "ğŸ”´ `FAILURE`"

        # ===============================
        # âš™ï¸ SYSTEM SETTINGS
        # ===============================
        try:
            settings_req = await db_call(lambda: supabase.table("bot_settings").select("*").execute())
            settings = settings_req.data if settings_req else []
        except:
            settings = []

        access = "ğŸ”´ `OFF (Open)`"
        maintenance = "ğŸŸ¢ `OFF (Stable)`"

        for s in settings:
            if s.get("key") == "access_enabled" and str(s.get("value")).lower() == "true":
                access = "ğŸŸ¢ `ON (Whitelist)`"
            if s.get("key") == "maintenance" and str(s.get("value")).lower() == "true":
                maintenance = "ğŸ”´ `ON (Locked)`"

        # ===============================
        # ğŸ¤– BOT UPTIME
        # ===============================
        up = int(time.time() - START_TIME)
        hrs, mins = up // 3600, (up % 3600) // 60
        uptime_str = f"{hrs}h {mins}m"

        # ===============================
        # ğŸ“¡ TRAFFIC MONITOR
        # ===============================
        now = time.time()
        last_min = [t_log for t_log, _ in TRAFFIC_LOG if now - t_log <= 60]
        rpm = len(last_min)
        
        # Smart Load Calculation
        load_score = max(5, min(99, rpm * 3 + (latency // 50) if backend_online else 99))

        # ===============================
        # ğŸš¨ RISK INTELLIGENCE
        # ===============================
        track_audit(ok)

        fails = sum(1 for t_log, s in AUDIT_LOG if not s and now - t_log <= 3600)
        db_recent = list(DB_FAILURES)
        db_fail_rate = int((sum(1 for _, s in db_recent if not s) / len(db_recent)) * 100) if len(db_recent) > 10 else 0

        # Auto risk detection & Color Selection
        embed_color = 0x2ecc71 # Green
        
        if not backend_online or not db_ok:
            risk = "ğŸ”´ `CRITICAL THREAT` â€” Core System Unstable"
            embed_color = 0xff0000 # Red
        elif fails >= 6 or db_fail_rate >= 40:
            risk = "ğŸ”´ `HIGH RISK` â€” Failure Activity Detected"
            embed_color = 0xe74c3c # Crimson
        elif fails >= 3 or db_fail_rate >= 20:
            risk = "ğŸŸ  `WARNING` â€” Minor Instability"
            embed_color = 0xe67e22 # Orange
        else:
            risk = "ğŸŸ¢ `STABLE & SECURE` â€” Optimal Performance"

        # ===============================
        # ğŸ’ BUILD ULTRA-PREMIUM EMBED
        # ===============================
        embed = discord.Embed(
            title="ğŸ§  ULTRA SYSTEM AUDIT: V3 PRO", 
            description="Live diagnostic scan of Titan Engine infrastructure.", 
            color=embed_color
        )
        embed.set_thumbnail(url="https://media.tenor.com/On7kvXhzml4AAAAi/loading-gif.gif")

        # Field 1: Core Connectivity
        embed.add_field(
            name="ğŸŒ Core Connectivity",
            value=(
                f" â”£ **Backend:** {backend_status}\n"
                f" â”£ **API Latency:** `{latency}ms` âš¡\n"
                f" â”£ **Database:** {db_status}\n"
                f" â”— **Query Time:** `{q_ms}ms`"
            ),
            inline=False
        )

        # Field 2: System Configuration
        embed.add_field(
            name="âš™ï¸ Configuration Matrix",
            value=(
                f" â”£ **Access Gateway:** {access}\n"
                f" â”£ **Maintenance Mode:** {maintenance}\n"
                f" â”— **Engine Uptime:** `{uptime_str}`"
            ),
            inline=False
        )

        # Field 3: Traffic & Load
        embed.add_field(
            name="ğŸ“¡ Network Traffic",
            value=(
                f" â”£ **Requests/Min (RPM):** `{rpm}`\n"
                f" â”— **Estimated Load:** `{load_score}%`"
            ),
            inline=False
        )

        # Field 4: Risk Intelligence
        embed.add_field(
            name="ğŸš¨ Risk Intelligence Module",
            value=(
                f" â”£ **Status:** {risk}\n"
                f" â”£ **Hourly Failures:** `{fails}` incidents\n"
                f" â”— **DB Drop Rate:** `{db_fail_rate}%`"
            ),
            inline=False
        )

        embed.set_footer(text=f"Audit requested by {i.user.display_name} â€¢ Titan Security", icon_url=i.user.display_avatar.url)
        embed.timestamp = discord.utils.utcnow()

        await i.followup.send(embed=embed)

    except Exception as e:
        await i.followup.send(embed=discord.Embed(title="âŒ FATAL AUDIT FAILURE", description=f"The diagnostic engine crashed:\n```{e}```", color=0xff0000))

# ================== ğŸ‘‘ OWNER MANAGEMENT (ULTRA PREMIUM) ==================
import discord
from discord import app_commands

# ==============================================================================
# ğŸ‘‘ AUTHORITY MATRIX (MANAGE CO-OWNERS)
# ==============================================================================
@bot.tree.command(name="owner", description="ğŸ‘‘ Core Security: Manage Bot Owners (ROOT Only)")
@app_commands.choices(action=[
    app_commands.Choice(name="â• Grant Root Access (Add)", value="add"),
    app_commands.Choice(name="â– Revoke Root Access (Remove)", value="remove"),
    app_commands.Choice(name="ğŸ“œ View Authority Matrix (List)", value="list"),
])
@app_commands.describe(target_user="Select a user from Discord to modify access")
async def owner_cmd(i: discord.Interaction, action: app_commands.Choice[str], target_user: discord.User = None):
    
    # ğŸ”’ 1. ROOT SECURITY CHECK (ONLY THE CREATOR)
    if str(i.user.id) != str(MY_MASTER_ID):
        embed = discord.Embed(
            title="â›” ROOT ACCESS DENIED",
            description="**SECURITY ALERT:** You do not have `MASTER` clearance to modify core owners.\nThis incident has been logged.",
            color=0xff0000,
            timestamp=discord.utils.utcnow()
        )
        embed.set_thumbnail(url="https://media.tenor.com/2b7lH3y8l08AAAAM/anime-disgust.gif")
        return await i.response.send_message(embed=embed, ephemeral=True)

    # â³ 2. DEFER (Premium processing)
    await i.response.defer(ephemeral=False)

    try:
        # ==========================================
        # â• ADD OWNER (GRANT ROOT)
        # ==========================================
        if action.value == "add":
            if not target_user:
                return await i.followup.send(embed=discord.Embed(title="âš ï¸ MISSING TARGET", description="Please select a user to grant access.", color=0xffa500))

            # Prevent adding main owner as co-owner
            if str(target_user.id) == str(MY_MASTER_ID):
                return await i.followup.send(embed=discord.Embed(title="âš ï¸ INVALID ACTION", description="This user is already the `MAIN MASTER`.", color=0xffa500))

            # ğŸ› ï¸ FIX: Safe db_call
            res = await db_call(lambda: supabase.table("bot_admins").select("user_id").eq("user_id", str(target_user.id)).execute())
            if res and res.data:
                return await i.followup.send(embed=discord.Embed(title="âš ï¸ ALREADY AUTHORIZED", description=f"{target_user.mention} already has ROOT access.", color=0xF1C40F))

            # ğŸ› ï¸ FIX: Safe Insert
            await db_call(lambda: supabase.table("bot_admins").insert({"user_id": str(target_user.id)}).execute())
            
            # ğŸ’ PREMIUM EMBED
            embed = discord.Embed(
                title="ğŸ‘‘ AUTHORITY GRANTED",
                description=f"**{target_user.mention} has been promoted to `SYSTEM OWNER`.**\nThey now have full administrative control.",
                color=0x2ecc71, # Emerald
                timestamp=discord.utils.utcnow()
            )
            embed.set_thumbnail(url=target_user.display_avatar.url)
            embed.add_field(name="ğŸ‘¤ Identity Matrix", value=f" â”£ **Name:** `{target_user.name}`\n â”£ **Display:** `{target_user.display_name}`\n â”— **ID:** `{target_user.id}`", inline=False)
            embed.set_footer(text="Titan Security â€¢ Protocol Updated", icon_url=i.user.display_avatar.url)
            
            await i.followup.send(embed=embed)

        # ==========================================
        # â– REMOVE OWNER (REVOKE ROOT)
        # ==========================================
        elif action.value == "remove":
            if not target_user:
                return await i.followup.send(embed=discord.Embed(title="âš ï¸ MISSING TARGET", description="Please select a user to revoke access.", color=0xffa500))

            # Main Owner Protection
            if str(target_user.id) == str(MY_MASTER_ID):
                return await i.followup.send(embed=discord.Embed(title="â›” FATAL ERROR", description="You cannot remove the `MAIN MASTER` from the database!", color=0xff0000))

            # ğŸ› ï¸ FIX: Safe Delete
            await db_call(lambda: supabase.table("bot_admins").delete().eq("user_id", str(target_user.id)).execute())

            # ğŸ’ PREMIUM EMBED
            embed = discord.Embed(
                title="ğŸ—‘ï¸ AUTHORITY REVOKED",
                description=f"**{target_user.mention} has been stripped of their Admin privileges.**\nTheir clearance is now `Standard`.",
                color=0xe74c3c, # Crimson Red
                timestamp=discord.utils.utcnow()
            )
            embed.set_thumbnail(url=target_user.display_avatar.url)
            embed.add_field(name="ğŸ‘¤ Target Erased", value=f" â”£ **User:** `{target_user.name}`\n â”— **ID:** `{target_user.id}`", inline=False)
            embed.set_footer(text=f"Action by: {i.user.display_name} â€¢ Titan Security", icon_url=i.user.display_avatar.url)

            await i.followup.send(embed=embed)

        # ==========================================
        # ğŸ“œ LIST OWNERS (AUTHORITY MATRIX)
        # ==========================================
        elif action.value == "list":
            # ğŸ› ï¸ FIX: Safe Fetch
            res = await db_call(lambda: supabase.table("bot_admins").select("user_id").execute())
            data = res.data if res else []
            
            # --- MAIN OWNER ---
            try:
                main_u = await i.client.fetch_user(int(MY_MASTER_ID))
                main_txt = f"ğŸ‘‘ **{main_u.name}**\n â”£ ğŸ†” `{MY_MASTER_ID}`\n â”— ğŸŒŸ *Supreme Creator / Root Host*"
            except:
                main_txt = f"ğŸ‘‘ **Unknown Entity**\n â”£ ğŸ†” `{MY_MASTER_ID}`\n â”— ğŸŒŸ *Supreme Creator*"

            # --- CO-OWNERS ---
            co_owners_txt = ""
            count = 0
            if data:
                for entry in data:
                    uid = entry['user_id']
                    count += 1
                    try:
                        u = await i.client.fetch_user(int(uid))
                        co_owners_txt += f"`{count:02d}.` ğŸ›¡ï¸ **{u.name}** *( {u.display_name} )*\n â”— ğŸ†” `{uid}`\n\n"
                    except:
                        co_owners_txt += f"`{count:02d}.` ğŸ›¡ï¸ **Unknown User**\n â”— ğŸ†” `{uid}`\n\n"
            
            if not co_owners_txt:
                co_owners_txt = "ğŸ“­ *No additional administrators found.*"

            # ğŸ’ PREMIUM EMBED
            embed = discord.Embed(
                title="ğŸ›¡ï¸ TITAN SECURITY: AUTHORITY MATRIX",
                description="Live roster of all personnel with `ROOT` & `ADMIN` clearance.",
                color=0xFFD700, # Solid Gold
                timestamp=discord.utils.utcnow()
            )
            embed.set_thumbnail(url="https://media.tenor.com/On7kvXhzml4AAAAi/loading-gif.gif") 
            
            embed.add_field(name="ğŸŒŸ LEVEL 10 CLEARANCE (MAIN OWNER)", value=main_txt, inline=False)
            embed.add_field(name=f"ğŸ‘® LEVEL 9 CLEARANCE (CO-OWNERS: {count})", value=co_owners_txt, inline=False)
            
            embed.set_footer(text="Core Infrastructure Synced", icon_url=i.client.user.display_avatar.url)

            await i.followup.send(embed=embed)

    except Exception as e:
        await i.followup.send(embed=discord.Embed(title="âŒ FATAL ERROR", description=f"Database Crash:\n```{e}```", color=0xff0000))


# ================== AUTO REMOVE ON LEAVE ==================
import discord
from discord import app_commands

# ==============================================================================
# ğŸ‘‹ AUTO-PURGE: MEMBER REMOVE EVENT (ULTRA-PREMIUM)
# ==============================================================================
@bot.event
async def on_member_remove(member: discord.Member):
    # Log channel ID jahan notification bhejna hai
    LOG_CHANNEL_ID = 1451973589342621791  # <-- Apna Log Channel ID yahan zaroor check karna
    
    try:
        # ğŸ—„ï¸ 1. SAFE FETCH (ğŸ› ï¸ FIX: Wrapped in db_call to prevent Event Loop blocking)
        res = await db_call(lambda: supabase.table("access_users").select("*").eq("discord_id", str(member.id)).execute())
        data = res.data if res else []
        
        if data:
            # ğŸ—‘ï¸ 2. SAFE DELETE ACCOUNTS
            await db_call(lambda: supabase.table("access_users").delete().eq("discord_id", str(member.id)).execute())
            
            # ğŸ—‘ï¸ 3. SAFE DELETE MULTI-ACCESS (Optional but important)
            try:
                await db_call(lambda: supabase.table("multi_access").delete().eq("discord_id", str(member.id)).execute())
            except:
                pass
                
            print(f"ğŸ›¡ï¸ AUTO-PURGE: User {member.name} left. All whitelists and VIP access erased.")

            # ğŸ’ 4. ULTRA-PREMIUM DISCORD LOGGING
            channel = bot.get_channel(LOG_CHANNEL_ID)
            if channel:
                count = len(data)
                
                # ğŸŒ³ Tree Formatting for Deleted Accounts
                accounts_list = ""
                for idx, x in enumerate(data, 1):
                    prefix = " â”— " if idx == count else " â”£ "
                    rid = x.get('user_id', 'Unknown')
                    uname = x.get('username', 'Unknown')
                    accounts_list += f"{prefix}ğŸ†” `{rid}` *( @{uname} )*\n"

                embed = discord.Embed(
                    title="ğŸ‘‹ MEMBER DEPARTURE DETECTED",
                    description=f"**Target:** {member.mention} (`{member.id}`)\n*User left the server. All associated security clearances and verifications have been automatically revoked.*",
                    color=0xe74c3c # Crimson Red (Danger/Delete)
                )
                
                embed.add_field(
                    name=f"ğŸ—‘ï¸ Purged Roblox Accounts ({count})", 
                    value=accounts_list, 
                    inline=False
                )
                
                embed.set_thumbnail(url=member.display_avatar.url)
                embed.set_footer(text="Automated Security Purge â€¢ Titan System", icon_url=bot.user.display_avatar.url if bot.user else None)
                embed.timestamp = discord.utils.utcnow() # ğŸ› ï¸ FIX: Safe Timezone
                
                await channel.send(embed=embed)

    except Exception as e:
        print(f"âš ï¸ LEAVE EVENT ERROR: {e}")

# ================== ğŸ¦‘ SQUID GAME DUEL (ORIGINAL THEME + VIP FIX) ==================
import discord
from discord import app_commands
import random
import asyncio
import datetime as dt

# ==============================================================================
# ğŸ’° SMART ECONOMY ENGINE (WALLET + BANK DEDUCTION)
# ==============================================================================
# Note: 'economy' table ka naam apne hisaab se change kar lena agar alag ho.
async def smart_charge(user_id: int, amount: int) -> bool:
    """Deducts from Wallet first, then Bank. Returns True if successful."""
    try:
        res = await db_call(lambda: supabase.table("economy").select("balance, bank").eq("user_id", str(user_id)).execute())
        if not res or not res.data: return False
        
        bal = int(res.data[0].get("balance", 0))
        bank = int(res.data[0].get("bank", 0))
        
        if (bal + bank) < amount: return False # Total net worth is less than bet
        
        if bal >= amount:
            new_bal = bal - amount
            new_bank = bank
        else:
            rem = amount - bal
            new_bal = 0
            new_bank = bank - rem
            
        await db_call(lambda: supabase.table("economy").update({"balance": new_bal, "bank": new_bank}).eq("user_id", str(user_id)).execute())
        return True
    except:
        return False

async def smart_reward(user_id: int, amount: int):
    """Adds winnings directly to Wallet."""
    try:
        res = await db_call(lambda: supabase.table("economy").select("balance").eq("user_id", str(user_id)).execute())
        if res and res.data:
            new_bal = int(res.data[0].get("balance", 0)) + amount
            await db_call(lambda: supabase.table("economy").update({"balance": new_bal}).eq("user_id", str(user_id)).execute())
    except: pass


# ==============================================================================
# ğŸ¦‘ THE SQUID DUEL V3 (SMART BANKING + AFK KILLS + ULTRA UI)
# ==============================================================================

# --- âš–ï¸ PUNISHMENT ENGINE (The Front Man's Rules) ---
async def execute_punishment(interaction, loser, level, bet):
    roles_to_restore = []
    is_admin = loser.guild_permissions.administrator
    
    # Strip Admin Powers if bot is higher
    if is_admin and interaction.guild.me.top_role > loser.top_role:
        roles_to_restore = [r for r in loser.roles if r.name != "@everyone" and not r.managed]
        if roles_to_restore:
            try: await loser.remove_roles(*roles_to_restore, reason="Squid Duel Penalty")
            except: pass

    # Level Logic
    penalties = {
        1: {"time": 60, "desc": "60 Seconds Timeout (Warning)"},
        2: {"time": 300, "desc": "5 Minutes Timeout + Minor Fine"},
        3: {"time": 3600, "desc": "1 Hour Mute (Script Ban)"},
        4: {"time": 43200, "desc": "12 Hours Mute + Heavy Fine"},
        5: {"time": 86400, "desc": "24 Hours Ban/Mute (MAXIMUM PENALTY)"}
    }
    
    p_data = penalties.get(level, penalties[1])
    duration = dt.timedelta(seconds=p_data["time"])
    
    # Extra fines for Level 2 and 4 (Deducted via Smart Charge)
    if level in [2, 4]:
        extra_fine = int(bet * 0.5) if level == 2 else bet
        await smart_charge(loser.id, extra_fine)

    # Apply Timeout
    try: await loser.timeout(duration, reason=f"Squid Duel Elimination (Level {level})")
    except: pass

    # Restore Task (Background)
    if roles_to_restore:
        async def restore_roles():
            await asyncio.sleep(p_data["time"])
            try: await loser.add_roles(*roles_to_restore, reason="Penalty Served")
            except: pass
        asyncio.create_task(restore_roles())

    return p_data["desc"]


# --- ğŸ”« PHASE 3: THE RUSSIAN ROULETTE (DEATH PHASE) ---
class RouletteView(discord.ui.View):
    def __init__(self, game):
        super().__init__(timeout=60) 
        self.game = game
        self.loser = game.rps_loser
        self.winner = game.rps_winner
        self.message = None 

    async def on_timeout(self):
        """ ğŸ”¥ THE COWARDICE EXECUTION """
        await smart_reward(self.winner.id, self.game.bet * 2) 
        
        try: await self.loser.timeout(dt.timedelta(hours=1), reason="Squid Duel: Fled from Roulette")
        except: pass

        embed = self.get_embed("DEAD")
        embed.title = "ğŸƒ COWARD ELIMINATED BY FRONT MAN!"
        embed.description = (
            f"# ğŸ’¥ EXECUTION!\n"
            f"**{self.loser.mention} refused to pull the trigger!**\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"The Front Man does not tolerate cowardice. You have been shot.\n\n"
            f" â”£ ğŸ† **WINNER:** {self.winner.mention} *( Won `${self.game.bet * 2:,}` )*\n"
            f" â”— âš–ï¸ **PUNISHMENT:** `1 Hour Mute applied.`"
        )
        if self.message:
            try: await self.message.edit(embed=embed, view=None)
            except: pass

    def get_embed(self, status="WAITING"):
        embed = discord.Embed(title="ğŸ”« THE RUSSIAN ROULETTE", color=0x0A0A0A)
        
        chambers_left = 6 - self.game.current_step
        bullets_left = sum(self.game.chambers[self.game.current_step:])
        death_chance = int((bullets_left / chambers_left) * 100) if chambers_left > 0 else 100
        
        if status == "WAITING":
            embed.description = (
                f"# ğŸ’€ FACE YOUR FATE\n"
                f"**Target:** {self.loser.mention}\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f"You lost the RPS phase. The Front Man hands you the loaded revolver.\n\n"
                f" â”£ ğŸ”„ **Pull Number:** `{self.game.current_step + 1}/6`\n"
                f" â”£ ğŸ§¨ **Bullets Remaining:** `{bullets_left}`\n"
                f" â”— âš°ï¸ **Chances of Death:** `{death_chance}%`\n\n"
                f"*Pick up the gun. Pull the trigger. You have **60 seconds**.*"
            )
            embed.set_thumbnail(url="https://media.tenor.com/y1_B0m0k_mUAAAAd/revolver-spin.gif")
            
        elif status == "SURVIVED":
            embed.color = 0x2ECC71
            embed.description = (
                f"# ğŸ’¨ *CLICK.*\n"
                f"{self.loser.mention} pulled the trigger... **The chamber was empty.**\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f"You survived this round. The gun is passed back.\n"
                f"*Prepare for the next Rock-Paper-Scissors duel!*"
            )
            embed.set_image(url="https://media.tenor.com/7b2zG74hM3UAAAAC/phew-relief.gif")
            
        elif status == "DEAD":
            embed.color = 0x8B0000
            embed.description = (
                f"# ğŸ’¥ BANG!\n"
                f"**{self.loser.mention} has been ELIMINATED.**\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f"The bullet was resting in chamber `{self.game.current_step + 1}`.\n"
            )
            embed.set_image(url="https://media.tenor.com/d6-SreC3_p8AAAAC/wasted-gta5.gif")
            
        return embed

    @discord.ui.button(label="PULL TRIGGER", style=discord.ButtonStyle.danger, emoji="ğŸ”«", custom_id="trigger_pull_btn")
    async def trigger_btn(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.loser.id:
            return await interaction.response.send_message("âŒ Bouncer: It's not your turn to die!", ephemeral=True)
            
        await interaction.response.defer()
        self.stop() 
        for child in self.children: child.disabled = True
        
        suspense_embed = discord.Embed(title="ğŸ”« PULLING THE TRIGGER...", color=0x2b2d31)
        suspense_embed.set_image(url="https://media.tenor.com/KxXW8KIf3SgAAAAC/squid-game-front-man.gif")
        await interaction.edit_original_response(embed=suspense_embed, view=None)
        await asyncio.sleep(4)

        is_bullet = self.game.chambers[self.game.current_step]

        if is_bullet:
            await smart_reward(self.winner.id, self.game.bet * 2) 
            penalty_msg = await execute_punishment(interaction, self.loser, self.game.penalty_lvl, self.game.bet)
            
            final_embed = self.get_embed("DEAD")
            final_embed.description += (
                f"\n â”£ ğŸ† **WINNER:** {self.winner.mention} *( Won `${self.game.bet * 2:,}` )*\n"
                f" â”— âš–ï¸ **PUNISHMENT APPLIED:** `{penalty_msg}`"
            )
            await interaction.edit_original_response(embed=final_embed, view=None)
        else:
            await interaction.edit_original_response(embed=self.get_embed("SURVIVED"), view=None)
            self.game.current_step += 1 
            await asyncio.sleep(4)
            await self.game.start_rps_phase(interaction) 


# --- âœŠ PHASE 2: ROCK PAPER SCISSORS (SKILL PHASE) ---
class SquidRPSView(discord.ui.View):
    def __init__(self, game):
        super().__init__(timeout=60) # ğŸ› ï¸ FIX: Added 60s AFK Timer!
        self.game = game
        self.choices = {game.p1.id: None, game.p2.id: None}
        self.message = None

    async def on_timeout(self):
        """ âš ï¸ AFK HANDLING: If someone doesn't pick in 60s! """
        p1_choice = self.choices[self.game.p1.id]
        p2_choice = self.choices[self.game.p2.id]
        
        embed = discord.Embed(title="â³ TIME'S UP - DISQUALIFICATION", color=0xFF0000)
        
        if not p1_choice and not p2_choice:
            # Both AFK
            await smart_reward(self.game.p1.id, self.game.bet)
            await smart_reward(self.game.p2.id, self.game.bet)
            embed.description = "Both players failed to make a move. The match is cancelled and bets are refunded."
        else:
            # One player AFK
            winner = self.game.p1 if p1_choice else self.game.p2
            loser = self.game.p2 if p1_choice else self.game.p1
            
            await smart_reward(winner.id, self.game.bet * 2)
            try: await loser.timeout(dt.timedelta(hours=1), reason="Squid Duel: AFK during RPS")
            except: pass
            
            embed.description = (
                f"# ğŸ’¥ EXECUTION!\n"
                f"**{loser.mention} failed to make a move in time!**\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ† **WINNER:** {winner.mention} *( Won `${self.game.bet * 2:,}` )*\n"
                f" â”— âš–ï¸ **PUNISHMENT:** `1 Hour Mute applied.`"
            )
            
        if self.message:
            try: await self.message.edit(embed=embed, view=None)
            except: pass

    def get_embed(self):
        embed = discord.Embed(title="âœŠ ROCK âœ‹ PAPER âœŒï¸ SCISSORS", color=0xE67E22)
        p1_status = "âœ… `Locked In`" if self.choices[self.game.p1.id] else "â³ `Thinking...`"
        p2_status = "âœ… `Locked In`" if self.choices[self.game.p2.id] else "â³ `Thinking...`"
        
        embed.description = (
            f"# ğŸ­ SKILL PHASE: ROUND {self.game.current_step + 1}\n"
            f"**The loser will face the loaded revolver.**\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ‘¤ {self.game.p1.mention}: {p1_status}\n"
            f" â”— ğŸ‘¤ {self.game.p2.mention}: {p2_status}\n\n"
            f"*Make your choice below. It is completely hidden. (60s Limit)*"
        )
        embed.set_thumbnail(url="https://media.tenor.com/UfB10s-pDsgAAAAC/squid-game-guard.gif")
        return embed

    async def handle_choice(self, interaction, choice):
        if interaction.user.id not in [self.game.p1.id, self.game.p2.id]:
            return await interaction.response.send_message("âŒ Guards! Remove this spectator.", ephemeral=True)
            
        await interaction.response.defer()
        self.choices[interaction.user.id] = choice
        
        await interaction.followup.send(f"âœ… You secretly locked in: **{choice}**!", ephemeral=True)
        await self.message.edit(embed=self.get_embed(), view=self)

        # Both selected
        if self.choices[self.game.p1.id] and self.choices[self.game.p2.id]:
            self.stop() # Stop timeout
            for child in self.children: child.disabled = True
            await self.message.edit(view=self)
            await self.resolve_rps(interaction)

    @discord.ui.button(emoji="ğŸª¨", style=discord.ButtonStyle.secondary)
    async def btn_rock(self, i, b): await self.handle_choice(i, "Rock")
    @discord.ui.button(emoji="ğŸ“„", style=discord.ButtonStyle.secondary)
    async def btn_paper(self, i, b): await self.handle_choice(i, "Paper")
    @discord.ui.button(emoji="âœ‚ï¸", style=discord.ButtonStyle.secondary)
    async def btn_scissors(self, i, b): await self.handle_choice(i, "Scissors")

    async def resolve_rps(self, interaction):
        c1 = self.choices[self.game.p1.id]
        c2 = self.choices[self.game.p2.id]
        beats = {"Rock": "Scissors", "Paper": "Rock", "Scissors": "Paper"}
        
        embed = discord.Embed(title="âš”ï¸ CLASH RESULTS", color=0x3498DB)
        
        if c1 == c2:
            embed.description = f"### âš–ï¸ IT'S A DRAW!\nBoth chose **{c1}**.\n*The Front Man demands a clear loser. Restarting phase...*"
            await interaction.followup.send(embed=embed)
            await asyncio.sleep(3)
            await self.game.start_rps_phase(interaction)
        else:
            if beats[c1] == c2:
                self.game.rps_winner, self.game.rps_loser = self.game.p1, self.game.p2
            else:
                self.game.rps_winner, self.game.rps_loser = self.game.p2, self.game.p1
                
            embed.description = f"### â˜ ï¸ WE HAVE A LOSER.\n{self.game.p1.mention} chose **{c1}**\n{self.game.p2.mention} chose **{c2}**\n\nğŸš¨ **{self.game.rps_loser.mention} LOST!** They must now face the Roulette."
            embed.color = 0xFF0000
            await interaction.followup.send(embed=embed)
            await asyncio.sleep(4)
            await self.game.start_roulette_phase(interaction)


# --- âš™ï¸ THE GAME ENGINE ---
class SquidGameEngine:
    def __init__(self, p1, p2, bet, penalty_lvl, bullets):
        self.p1 = p1
        self.p2 = p2
        self.bet = bet
        self.penalty_lvl = penalty_lvl
        
        self.chambers = [True] * bullets + [False] * (6 - bullets)
        random.shuffle(self.chambers) 
        self.current_step = 0 
        self.rps_winner = None
        self.rps_loser = None

    async def start_rps_phase(self, interaction):
        view = SquidRPSView(self)
        msg = await interaction.channel.send(embed=view.get_embed(), view=view)
        view.message = msg

    async def start_roulette_phase(self, interaction):
        view = RouletteView(self)
        msg = await interaction.channel.send(embed=view.get_embed("WAITING"), view=view)
        view.message = msg


# --- ğŸŸï¸ PHASE 1: LOBBY & CHALLENGE ---
class SquidDuelLobby(discord.ui.View):
    def __init__(self, host, opponent, bet, penalty_lvl, bullets):
        super().__init__(timeout=60)
        self.host = host
        self.opponent = opponent
        self.bet = bet
        self.penalty_lvl = penalty_lvl
        self.bullets = bullets
        self.accepted = False

    @discord.ui.button(label="SIGN CONTRACT (ACCEPT)", style=discord.ButtonStyle.danger, emoji="âœ…")
    async def btn_accept(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.opponent.id:
            return await interaction.response.send_message("âŒ This death warrant is not for you.", ephemeral=True)
            
        await interaction.response.defer()
        
        # ğŸ’³ SMART CHARGE CHECK FOR OPPONENT
        opp_paid = await smart_charge(self.opponent.id, self.bet)
        if not opp_paid:
            return await interaction.followup.send(f"âŒ You are too broke! You don't have `${self.bet:,}` in your Wallet + Bank combined.", ephemeral=True)
            
        # ğŸ’³ SMART CHARGE CHECK FOR HOST (In case they moved money while waiting)
        host_paid = await smart_charge(self.host.id, self.bet)
        if not host_paid:
            await smart_reward(self.opponent.id, self.bet) # Refund opponent
            return await interaction.followup.send(f"âŒ The Host ({self.host.mention}) is broke now! Match cancelled.", ephemeral=True)

        self.accepted = True
        for child in self.children: child.disabled = True
        await interaction.message.edit(view=self)
        self.stop()

    @discord.ui.button(label="COWARD'S WAY OUT", style=discord.ButtonStyle.secondary, emoji="ğŸƒ")
    async def btn_reject(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.opponent.id: 
            return await interaction.response.send_message("âŒ Mind your own business.", ephemeral=True)
        await interaction.response.defer()
        for child in self.children: child.disabled = True
        
        embed = discord.Embed(title="ğŸƒ CHALLENGE REJECTED", description=f"*{self.opponent.mention} fled in terror. The match is cancelled.*", color=0x95a5a6)
        await interaction.message.edit(content=None, embed=embed, view=None)
        self.stop()


# --- ğŸš€ THE MAIN COMMAND ---
@bot.tree.command(name="squid_duel", description="ğŸ¦‘ The Ultimate Deathmatch: RPS + Russian Roulette! (Wallet & Bank Supported)")
@app_commands.describe(
    opponent="Who do you want to drag to hell?",
    bet="Wager amount (Min 5,000)",
    punishment_level="Select the lethality of the punishment",
    bullets="How many bullets in the 6-chamber cylinder? (1 to 5)"
)
@app_commands.choices(punishment_level=[
    app_commands.Choice(name="Level 1: 60s Timeout (Light)", value=1),
    app_commands.Choice(name="Level 2: 5m Timeout + Extra Fine", value=2),
    app_commands.Choice(name="Level 3: 1h Mute (Script Ban)", value=3),
    app_commands.Choice(name="Level 4: 12h Mute + Heavy Fine", value=4),
    app_commands.Choice(name="Level 5: 24h Ban/Mute (Lethal)", value=5)
])
@check_seized() # Your existing check
async def squid_duel_cmd(i: discord.Interaction, opponent: discord.Member, bet: int, punishment_level: app_commands.Choice[int], bullets: int = 1):
    await i.response.defer()
    
    if opponent.bot or opponent.id == i.user.id:
        return await i.followup.send("âŒ **Invalid Target:** You can't duel yourself or a bot.", ephemeral=True)
    if bet < 5000:
        return await i.followup.send("âŒ **Invalid Amount:** Minimum bet is `$5,000`.", ephemeral=True)
    
    if bullets < 1 or bullets > 5:
        return await i.followup.send("âŒ **Rule Violation:** You must load between **1 and 5** bullets.", ephemeral=True)

    # Pre-check host's combined balance before starting lobby
    res = await db_call(lambda: supabase.table("economy").select("balance, bank").eq("user_id", str(i.user.id)).execute())
    if not res or not res.data:
        return await i.followup.send("âŒ You don't have an economy account!", ephemeral=True)
        
    host_total = int(res.data[0].get("balance", 0)) + int(res.data[0].get("bank", 0))
    if host_total < bet: 
        return await i.followup.send(f"âŒ You are broke! You need `${bet:,}` in your Wallet + Bank.", ephemeral=True)

    level_val = punishment_level.value
    lobby = SquidDuelLobby(i.user, opponent, bet, level_val, bullets)
    
    danger_txt = "Standard Duel"
    if bullets == 3: danger_txt = "50/50 Bloodbath"
    if bullets >= 4: danger_txt = "Suicide Mission"
    
    embed = discord.Embed(title="ğŸ¦‘ INVITATION TO THE SQUID GAMES", color=0xFF0055)
    embed.description = (
        f"**{i.user.mention} has challenged {opponent.mention} to a Deathmatch!**\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f" â”£ ğŸ’° **Total Pot:** `${bet * 2:,}`\n"
        f" â”£ âš–ï¸ **Punishment:** `Level {level_val}` *( {punishment_level.name.split(':')[1].strip()} )*\n"
        f" â”— ğŸ”« **Bullets Loaded:** `{bullets}/6` *( {danger_txt} )*\n\n"
        f"> **THE RULES:**\n"
        f"> `1.` Both players play Rock-Paper-Scissors.\n"
        f"> `2.` The loser is handed the revolver and must pull the trigger.\n"
        f"> `3.` Empty chamber? The game restarts. Bullet? The winner takes all.\n\n"
        f"*{opponent.mention}, do you have the guts to sign the contract?*"
    )
    embed.set_thumbnail(url="https://media.tenor.com/Psh5n4-XlYQAAAAC/squid-game-dalgona.gif")
    
    await i.followup.send(content=opponent.mention, embed=embed, view=lobby)
    await lobby.wait()
    
    if not lobby.accepted: return 

    game_engine = SquidGameEngine(i.user, opponent, bet, level_val, bullets)
    
    intro = discord.Embed(description="# ğŸ­ THE CONTRACT IS SEALED.\n*Guards are escorting the players to the RPS Arena...*", color=0xFF0055)
    await i.channel.send(embed=intro)
    await asyncio.sleep(3)
    
    await game_engine.start_rps_phase(i)          
         
                        
# ================== SAY COMMAND (WITH IMAGE & LOGS) ==================
import discord
from discord import app_commands

# ğŸ‘‡ Apki di hui Log Channel ID
SAY_LOG_CHANNEL_ID = 1450514760276774967

# ==============================================================================
# ğŸ“¢ MASTER BROADCAST SYSTEM (ULTRA-PREMIUM SAY COMMAND)
# ==============================================================================
@bot.tree.command(name="say", description="ğŸ“¢ Broadcast a message as the bot (With Images & Logs)")
@app_commands.describe(
    message="Message content to broadcast",
    channel="Where to send? (Default: current channel)",
    mode="Style of message (Text/Embed)",
    image="Attach an image (Optional)"
)
@app_commands.choices(mode=[
    app_commands.Choice(name="ğŸ“ Plain Text (Standard)", value="text"),
    app_commands.Choice(name="âœ… Green Embed (Success)", value="green"),
    app_commands.Choice(name="âŒ Red Embed (Error)", value="red"),
    app_commands.Choice(name="â„¹ï¸ Blue Embed (Info)", value="blue"),
])
@check_seized()
async def say(i: discord.Interaction, message: str, mode: app_commands.Choice[str] = None, channel: discord.TextChannel = None, image: discord.Attachment = None):
    
    # â³ 1. DEFER FIRST (Premium processing & Crash Prevention)
    await i.response.defer(ephemeral=True)

    # ğŸ”’ 2. PERMISSION CHECK (ğŸ› ï¸ FIX: Added 'await' & Safe db_call)
    is_authorized = await owner(i)
    if not is_authorized:
        try:
            res = await db_call(lambda: supabase.table("say_access").select("user_id").eq("user_id", str(i.user.id)).execute())
            if res and res.data: 
                is_authorized = True
        except: 
            pass

    if not is_authorized:
        embed = discord.Embed(title="â›” ACCESS DENIED", description="Aapke paas broadcast system use karne ki clearance nahi hai.", color=0xff0000)
        return await i.followup.send(embed=embed)

    # âš™ï¸ 3. SETUP
    target_channel = channel or i.channel
    mode_value = mode.value if mode else "text"

    try:
        # ğŸ–¼ï¸ IMAGE PROCESSING (ğŸ› ï¸ FIX: Safe handling of files)
        file_attachment = await image.to_file() if image else discord.utils.MISSING
        
        # ğŸš€ 4. SENDING PAYLOAD
        if mode_value == "text":
            # Plain text with optional image
            sent_msg = await target_channel.send(content=message, file=file_attachment if image else discord.utils.MISSING)
        else:
            # Smart Colors & Titles
            if mode_value == "green": color, title = 0x2ecc71, "âœ… SUCCESS"
            elif mode_value == "red": color, title = 0xe74c3c, "âŒ ERROR"
            elif mode_value == "blue": color, title = 0x3498db, "â„¹ï¸ INFORMATION"
            else: color, title = 0x2b2d31, "ğŸ“¢ NOTICE"

            # Premium Embed Generation
            embed = discord.Embed(title=title, description=message, color=color)
            
            # Embed me image fit karna (Agar di gayi hai)
            if image:
                embed.set_image(url=f"attachment://{image.filename}")
                
            sent_msg = await target_channel.send(embed=embed, file=file_attachment if image else discord.utils.MISSING)

        # âœ… 5. CONFIRMATION TO THE SENDER
        confirm_embed = discord.Embed(
            title="âœ… BROADCAST SUCCESSFUL", 
            description=f"Payload delivered safely to {target_channel.mention}.", 
            color=0x2ecc71
        )
        await i.followup.send(embed=confirm_embed)

        # ğŸ—‚ï¸ 6. ULTRA-PREMIUM LOGGING
        try:
            log_channel = i.client.get_channel(SAY_LOG_CHANNEL_ID)
            if log_channel:
                log_embed = discord.Embed(title="ğŸ“¢ SYSTEM BROADCAST AUDIT", color=0xF1C40F) # Gold/Orange Log
                
                log_embed.add_field(
                    name="ğŸ‘¤ Execution Matrix", 
                    value=(
                        f" â”£ **Operator:** {i.user.mention} (`{i.user.id}`)\n"
                        f" â”£ **Target Channel:** {target_channel.mention} (`{target_channel.id}`)\n"
                        f" â”— **Transmission Mode:** `{mode_value.upper()}`"
                    ), 
                    inline=False
                )
                
                # Truncate message if it's too huge for the log embed
                safe_msg = message[:1000] + "\n... *(Truncated)*" if len(message) > 1000 else message
                log_embed.add_field(name="ğŸ“ Payload Content", value=f"```\n{safe_msg}\n```", inline=False)
                
                # Image Logging
                if image:
                    log_embed.set_thumbnail(url=image.url)
                    log_embed.add_field(name="ğŸ–¼ï¸ Visual Attachment", value=f" â”— ğŸ”— **[Click to View Full Image]({image.url})**", inline=False)

                log_embed.set_footer(text="Titan Broadcast System", icon_url=i.user.display_avatar.url)
                log_embed.timestamp = discord.utils.utcnow() # ğŸ› ï¸ FIX: Safe Timezone
                
                await log_channel.send(embed=log_embed)
            
        except Exception as e:
            print(f"Broadcast Logging Error: {e}")

    except discord.Forbidden:
        await i.followup.send(embed=discord.Embed(title="âŒ PERMISSION ERROR", description=f"Mujhe {target_channel.mention} mein message bhejne ki permission nahi hai!", color=0xff0000))
    except Exception as e:
        await i.followup.send(embed=discord.Embed(title="âŒ SYSTEM GLITCH", description=f"Transmission failed:\n```{e}```", color=0xff0000))

import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# ğŸ HAND CRICKET: ULTRA PREMIUM EDITION (WITH SMART BANKING)
# ==============================================================================

class HandCricketGame(discord.ui.View):
    def __init__(self, p1: discord.Member, p2: discord.Member, bet: int):
        super().__init__(timeout=120) # â³ 2 minutes timeout per ball
        self.p1 = p1
        self.p2 = p2
        self.bet = bet
        self.message = None # To store the game message for edits
        
        # ğŸª™ Toss & Roles
        self.batter = random.choice([p1, p2])
        self.bowler = p1 if self.batter.id == p2.id else p2
        
        # ğŸ“Š Game State
        self.innings = 1
        self.batter_score = 0
        self.target = None
        
        self.batter_choice = None
        self.bowler_choice = None
        
        self.last_action = f"ğŸª™ **TOSS WON BY:** {self.batter.mention} *(Elected to Bat)*"
        self.gif_url = "https://media.tenor.com/DihD0-LhFCAAAAAC/cricket-batting.gif" 
        
        self.build_buttons()
        self.render_ui()

    def build_buttons(self):
        self.clear_items()
        nums = [1, 2, 3, 4, 5, 6]
        for n in nums:
            row = 0 if n <= 3 else 1
            btn = discord.ui.Button(label=str(n), style=discord.ButtonStyle.secondary, custom_id=f"hc_{n}", row=row)
            btn.callback = self.number_callback
            self.add_item(btn)

    def render_ui(self):
        # Premium Colors
        color = 0x2ecc71 if self.innings == 1 else 0xF1C40F # Green for 1st, Gold for 2nd
        title = f"ğŸ TITAN PREMIER LEAGUE â€¢ INNINGS {self.innings}"
        
        # Tree-Style Scoreboard Logic
        scoreboard = f" â”£ ğŸ **Runs Scored:** `{self.batter_score}`\n â”— ğŸ¯ **Target:** `Setting...`"
        if self.target:
            need = self.target - self.batter_score
            scoreboard = f" â”£ ğŸ **Runs Scored:** `{self.batter_score}`\n â”£ ğŸ¯ **Target:** `{self.target}`\n â”— ğŸš¨ **Need:** `{need}` Runs to Win!"

        desc = (
            f"**ğŸ’° MATCH PRIZE POOL:** `${self.bet * 2:,}`\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"ğŸ‘¤ **Batter:** {self.batter.mention}\n"
            f"ğŸ‘¤ **Bowler:** {self.bowler.mention}\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"**ğŸ“Š MATCH SCORECARD:**\n{scoreboard}\n\n"
            f"âš¡ **LAST ACTION:**\n> {self.last_action}"
        )

        self.embed = discord.Embed(title=title, description=desc, color=color)
        self.embed.set_image(url=self.gif_url)
        
        # Premium Status indicators
        b_status = "ğŸŸ¢ LOCKED" if self.batter_choice else "â³ THINKING"
        bw_status = "ğŸŸ¢ LOCKED" if self.bowler_choice else "â³ THINKING"
        self.embed.set_footer(text=f"Batter: {b_status} | Bowler: {bw_status} â€¢ Titan Games")

    async def number_callback(self, interaction: discord.Interaction):
        # Security Check
        if interaction.user.id not in [self.batter.id, self.bowler.id]:
            return await interaction.response.send_message("âŒ **Umpire:** Bahar waalo ko khelne ki permission nahi hai!", ephemeral=True)
        
        await interaction.response.defer(ephemeral=True)
        choice = int(interaction.data["custom_id"].split("_")[1])
        
        # Lock Choices
        if interaction.user.id == self.batter.id:
            if self.batter_choice is not None:
                return await interaction.followup.send("â³ Tumne pehle hi number chun liya hai. Bowler ka wait karo.", ephemeral=True)
            self.batter_choice = choice
        else:
            if self.bowler_choice is not None:
                return await interaction.followup.send("â³ Tumne pehle hi number chun liya hai. Batter ka wait karo.", ephemeral=True)
            self.bowler_choice = choice
            
        await interaction.followup.send(f"ğŸ¤« Tumne chupke se **{choice}** chuna hai.", ephemeral=True)
        
        # Check if both have chosen
        if self.batter_choice is not None and self.bowler_choice is not None:
            await self.process_ball()
        else:
            # Update UI to show 'LOCKED' status
            self.render_ui()
            if self.message:
                try: await self.message.edit(embed=self.embed, view=self)
                except: pass

    async def process_ball(self):
        bat_num = self.batter_choice
        bowl_num = self.bowler_choice
        
        # ==========================================
        # ğŸ’¥ WICKET LOGIC (CLEAN BOWLED!)
        # ==========================================
        if bat_num == bowl_num:
            if self.innings == 1:
                # Innings Change
                self.target = self.batter_score + 1
                self.last_action = f"ğŸ’€ **WICKET!** Both chose **{bat_num}**!\nğŸ”„ **INNINGS BREAK:** {self.bowler.mention} needs **{self.target}** runs to win."
                self.gif_url = "https://media.tenor.com/bW_xL9Z2tLMAAAAC/clean-bowled-stumped.gif"
                
                # Swap Roles
                self.batter, self.bowler = self.bowler, self.batter
                self.batter_score = 0
                self.innings = 2
            else:
                # Match Over - Bowler Wins
                return await self.end_game(winner=self.bowler, reason=f"ğŸ’€ **CLEAN BOWLED!** Both chose **{bat_num}**.\n{self.bowler.mention} defended the target!")
        
        # ==========================================
        # ğŸ RUN LOGIC (SMASHED IT!)
        # ==========================================
        else:
            self.batter_score += bat_num
            
            # Dynamic Action Text
            if bat_num == 6: action_text = f"ğŸš€ **SIXER!** Batter smashed **6**!"
            elif bat_num == 4: action_text = f"ğŸ”¥ **BOUNDARY!** Batter hit **4**!"
            else: action_text = f"ğŸ Batter scored **{bat_num}**."
                
            self.last_action = f"{action_text} *(Bowler threw {bowl_num})*"
            self.gif_url = "https://media.tenor.com/DihD0-LhFCAAAAAC/cricket-batting.gif"
            
            # Check Win in Innings 2 (Target Chased)
            if self.innings == 2 and self.batter_score >= self.target:
                return await self.end_game(winner=self.batter, reason=f"ğŸ† **TARGET CHASED!** Batter hit a **{bat_num}** to finish the game in style!")

        # Reset choices for next ball
        self.batter_choice = None
        self.bowler_choice = None
        
        self.render_ui()
        if self.message:
            try: await self.message.edit(embed=self.embed, view=self)
            except: pass

    async def end_game(self, winner: discord.Member, reason: str):
        self.stop()
        for child in self.children: child.disabled = True
        
        prize = self.bet * 2
        
        # ğŸ’¸ SMART REWARD UPDATE
        try:
            await smart_reward(winner.id, prize)
        except Exception as e:
            print(f"DB Error HandCricket: {e}")

        win_embed = discord.Embed(
            title="ğŸ† MATCH CONCLUDED", 
            description=f"{reason}\nâ–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\nğŸ‘‘ **WINNER:** {winner.mention}\nğŸ’¸ **Total Payout:** `${prize:,}`", 
            color=0xFFD700 # Solid Gold
        )
        win_embed.set_image(url="https://media.tenor.com/Y-q-U1N5R6UAAAAC/ms-dhoni-world-cup.gif")
        win_embed.set_footer(text="Titan Premium Games â€¢ Match Ended", icon_url=winner.display_avatar.url)
        
        if self.message:
            try: await self.message.edit(embed=win_embed, view=None)
            except: pass

    async def on_timeout(self):
        # âš ï¸ AFK REFUND LOGIC
        try:
            await smart_reward(self.p1.id, self.bet)
            await smart_reward(self.p2.id, self.bet)
        except: pass
        
        for child in self.children: child.disabled = True
        timeout_embed = discord.Embed(title="â³ MATCH ABANDONED", description="*A player went AFK. The match has been cancelled and bets are refunded.*", color=0x95a5a6)
        if self.message:
            try: await self.message.edit(embed=timeout_embed, view=None)
            except: pass


# ==============================================================================
# ğŸ“¨ HAND CRICKET INVITE VIEW
# ==============================================================================
class CricketInviteView(discord.ui.View):
    def __init__(self, *, host: discord.Member, target: discord.Member, bet: int):
        super().__init__(timeout=60)
        self.host = host
        self.target = target
        self.bet = bet
        self.message = None

    @discord.ui.button(label="STEP ON PITCH (ACCEPT)", style=discord.ButtonStyle.success, emoji="âœ…")
    async def accept(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.target.id:
            return await interaction.response.send_message("âŒ **Bouncer:** Yeh invitation tumhare liye nahi hai!", ephemeral=True)
        
        await interaction.response.defer()
        self.stop()
        
        # ğŸ’³ SMART CHARGE CHECK FOR OPPONENT
        opp_paid = await smart_charge(self.target.id, self.bet)
        if not opp_paid:
            return await interaction.followup.send(f"âŒ You are too broke! You don't have `${self.bet:,}` in your Wallet + Bank combined.", ephemeral=True)
            
        # ğŸ’³ SMART CHARGE CHECK FOR HOST (In case they moved money while waiting)
        host_paid = await smart_charge(self.host.id, self.bet)
        if not host_paid:
            await smart_reward(self.target.id, self.bet) # Refund opponent
            return await interaction.followup.send(f"âŒ The Host ({self.host.mention}) is broke now! Match cancelled.", ephemeral=True)
        
        # Start Game
        game_board = HandCricketGame(p1=self.host, p2=self.target, bet=self.bet)
        msg = await interaction.edit_original_response(content=f"ğŸš¨ **MATCH STARTING!** {self.host.mention} vs {self.target.mention}", embed=game_board.embed, view=game_board)
        game_board.message = msg

    @discord.ui.button(label="RUN AWAY", style=discord.ButtonStyle.danger, emoji="ğŸƒ")
    async def reject(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.target.id:
            return await interaction.response.send_message("âŒ **Bouncer:** Tumse kisine pucha?", ephemeral=True)
        
        await interaction.response.defer()
        self.stop()
        embed = discord.Embed(title="ğŸƒ PITCH ABANDONED", description=f"ğŸ¤¡ *{interaction.user.mention} darr gaya! Match Cancelled.*", color=0xFF0000)
        await interaction.edit_original_response(content=None, embed=embed, view=None)


# ==============================================================================
# ğŸ® SLASH COMMAND
# ==============================================================================
@bot.tree.command(name="handcricket", description="ğŸ Play Premium Hand Cricket (Wallet & Bank Supported)")
@app_commands.describe(opponent="Kisko harana hai?", bet="Kitne paise lagane hain?")
async def handcricket(i: discord.Interaction, opponent: discord.Member, bet: int):
    await i.response.defer()

    try:
        if opponent.id == i.user.id or opponent.bot:
            return await i.followup.send("âŒ **Error:** Khud se ya bot se nahi khel sakte.", ephemeral=True)
        if bet < 100:
            return await i.followup.send("âŒ **Error:** Minimum bet is `$100`.", ephemeral=True)

        # ğŸ’³ Pre-Check Balance for Host
        res = await db_call(lambda: supabase.table("economy").select("balance, bank").eq("user_id", str(i.user.id)).execute())
        if not res or not res.data:
            return await i.followup.send("âŒ You don't have an economy account!", ephemeral=True)
            
        host_total = int(res.data[0].get("balance", 0)) + int(res.data[0].get("bank", 0))
        if host_total < bet: 
            return await i.followup.send(f"âŒ You are broke! You need `${bet:,}` in your Wallet + Bank.", ephemeral=True)

        # ğŸ“¨ Invite UI
        embed = discord.Embed(
            title="ğŸ TITAN PREMIER LEAGUE (T20)", 
            description=f"# ğŸ† MEGA CLASH\n**{i.user.mention}** has challenged **{opponent.mention}**!\n\n> *\"Dekhte hain kiska bat bolta hai!\"*", 
            color=0x2b2d31
        )
        embed.add_field(name="ğŸ“œ **Rules**", value="`Same Number = WICKET`\n`Different Number = RUNS`", inline=False)
        embed.add_field(name="ğŸ’° **Bet Amount**", value=f"`${bet:,}`", inline=True)
        embed.add_field(name="ğŸ† **Winning Prize**", value=f"`${bet * 2:,}`", inline=True)
        
        embed.set_thumbnail(url=opponent.display_avatar.url)
        embed.set_image(url="https://media.tenor.com/s1K4n3qXzF4AAAAC/cricket-stadium.gif")
        
        invite_view = CricketInviteView(host=i.user, target=opponent, bet=bet)
        msg = await i.followup.send(content=f"ğŸŸï¸ **{opponent.mention}**, Pitch pe aao!", embed=embed, view=invite_view)
        invite_view.message = msg

    except Exception as e:
        await i.followup.send(embed=discord.Embed(title="âŒ FATAL ERROR", description=f"```{e}```", color=0xff0000))

# ================== ğŸ¥Š UNDERGROUND FIGHT CLUB (PREMIUM) ==================
import discord
from discord import app_commands
import random
import asyncio
import datetime as dt

# ==============================================================================
# ğŸ©¸ UNDERGROUND FIGHT CLUB: ULTRA PREMIUM EDITION
# ==============================================================================

class FightArenaView(discord.ui.View):
    def __init__(self, p1: discord.Member, p2: discord.Member, p1_inv: dict, p2_inv: dict, bet: int):
        super().__init__(timeout=60) # â³ 60s Timer to prevent AFK holding
        self.p1 = p1
        self.p2 = p2
        self.bet = bet
        self.message = None
        
        self.turn = p1.id # P1 gets the first strike
        self.logs = "ğŸ”¥ **MATCH STARTED!** The cage is locked. Fight for glory!"
        self.gif_url = "https://media.tenor.com/M_Xz29mG2LgAAAAC/fight-club.gif" # Neutral fighting GIF
        
        # --- PLAYER STATS SETUP ---
        self.stats = {
            p1.id: self.setup_stats(p1, p1_inv),
            p2.id: self.setup_stats(p2, p2_inv)
        }
        
    def setup_stats(self, user: discord.Member, inv: dict):
        # Base Stats
        hp = 100
        min_dmg = 8
        max_dmg = 15
        
        # 1. ROLE BONUSES (Safe Check)
        if hasattr(user, 'roles'):
            roles = [r.name.lower() for r in user.roles]
            if "mafia" in roles or "god" in roles: hp = 150 
            if "hitman" in roles:
                min_dmg += 5
                max_dmg += 10
            
        # 2. INVENTORY BONUSES
        if inv.get('knife', 0) > 0:
            min_dmg += 5
            max_dmg += 5
            
        if inv.get('armor', 0) > 0:
            hp += 50 # 100 -> 150 HP
            
        if inv.get('steroids', 0) > 0:
            min_dmg += 10
            
        has_life = inv.get('life', 0) > 0
        
        return {
            "hp": hp,
            "max_hp": hp, 
            "min_dmg": min_dmg,
            "max_dmg": max_dmg,
            "has_life": has_life,
            "heals": 2,
            "defending": False,
            "user": user
        }

    def get_hp_bar(self, current, maximum):
        # ğŸ’ Premium Emoji HP Bar
        percent = current / maximum
        filled = int(percent * 10)
        
        if percent > 0.5: color_box = "ğŸŸ©" # Green
        elif percent > 0.2: color_box = "ğŸŸ¨" # Yellow
        else: color_box = "ğŸŸ¥" # Red
        
        bar = (color_box * filled) + ("â¬›" * (10 - filled))
        return f"{bar} `{current}/{maximum} HP`"

    def get_embed(self, winner=None):
        color = 0xFF0000 # Blood Red
        if winner: color = 0xFFD700 # Gold
        
        s1 = self.stats[self.p1.id]
        s2 = self.stats[self.p2.id]
        
        desc = f"ğŸ’° **FIGHT PURSE:** `${(self.bet * 2):,}`\nâ–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        
        # Player 1 Bar
        def_icon1 = "ğŸ›¡ï¸ *(Blocking)*" if s1['defending'] else ""
        life_icon1 = "ğŸ’– *(Extra Life)*" if s1['has_life'] else ""
        desc += f"ğŸ¥Š **{self.p1.mention}** {def_icon1} {life_icon1}\n{self.get_hp_bar(s1['hp'], s1['max_hp'])}\n\n"
        
        desc += "âš¡ **VS** âš¡\n\n"
        
        # Player 2 Bar
        def_icon2 = "ğŸ›¡ï¸ *(Blocking)*" if s2['defending'] else ""
        life_icon2 = "ğŸ’– *(Extra Life)*" if s2['has_life'] else ""
        desc += f"ğŸ¥Š **{self.p2.mention}** {def_icon2} {life_icon2}\n{self.get_hp_bar(s2['hp'], s2['max_hp'])}\n"
        
        desc += f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\nğŸ“ **COMMENTATOR LOG:**\n> {self.logs}"
        
        if not winner:
            current_player = self.p1 if self.turn == self.p1.id else self.p2
            desc += f"\n\nğŸ‘‰ **TURN:** {current_player.mention} (You have 60s)"

        embed = discord.Embed(title="ğŸ©¸ UNDERGROUND FIGHT CLUB", description=desc, color=color)
        embed.set_image(url=self.gif_url)
        return embed

    async def check_death(self, victim_id):
        victim_stats = self.stats[victim_id]
        
        if victim_stats['hp'] <= 0:
            # ğŸ’– EXTRA LIFE CHECK
            if victim_stats['has_life']:
                victim_stats['has_life'] = False 
                victim_stats['hp'] = int(victim_stats['max_hp'] * 0.3) # Revive with 30% HP
                
                # Update DB (Async & Safe)
                try:
                    res = await db_call(lambda: supabase.table("economy").select("inventory").eq("user_id", str(victim_id)).execute())
                    if res and res.data:
                        new_inv = res.data[0].get('inventory', {})
                        if new_inv.get('life', 0) > 0:
                            new_inv['life'] -= 1
                            await db_call(lambda: supabase.table("economy").update({"inventory": new_inv}).eq("user_id", str(victim_id)).execute())
                except: pass

                self.logs = f"ğŸ’– **MIRACLE!** {victim_stats['user'].display_name} used an Extra Life and got back up!"
                self.gif_url = "https://media.tenor.com/L1Q8-7l97LAAAAAC/undertaker-rise.gif" # Undertaker revive GIF
                return False 
            
            return True # Actually Dead
        return False

    async def end_game(self, winner_id, loser_id):
        self.stop()
        for child in self.children: child.disabled = True
        
        winner_user = self.stats[winner_id]['user']
        loser_user = self.stats[loser_id]['user']
        
        # ğŸ’¸ Reward Winner
        win_amount = self.bet * 2
        await smart_reward(winner_id, win_amount) 
        
        # ğŸ¥ Hospitalize Loser (10 Mins Timeout)
        try:
            await loser_user.timeout(dt.timedelta(minutes=10), reason="Lost Underground Fight Club")
            hospital_txt = "Ambulance called. (10m Timeout)"
        except:
            hospital_txt = "Fled the arena with injuries."

        self.logs = f"ğŸ’€ **KNOCKOUT!** {winner_user.display_name} destroyed {loser_user.display_name}!"
        self.gif_url = "https://media.tenor.com/M6Lw1wD2t40AAAAC/wwe-winner.gif" # Winner GIF
        
        embed = self.get_embed(winner=winner_user)
        embed.description += (
            f"\n\nğŸ† **CHAMPION:** {winner_user.mention}\n"
            f"ğŸ’° **Purse Won:** `${win_amount:,}`\n"
            f"ğŸ¥ **Loser Fate:** `{hospital_txt}`"
        )
        
        if self.message:
            try: await self.message.edit(embed=embed, view=self)
            except: pass

    async def on_timeout(self):
        # âš ï¸ AFK LOGIC (Coward Forfeit)
        self.stop()
        for child in self.children: child.disabled = True
        
        loser_id = self.turn
        winner_id = self.p1.id if self.turn == self.p2.id else self.p2.id
        
        # Winner takes the money
        await smart_reward(winner_id, self.bet * 2)
        
        try:
            loser = self.p1 if loser_id == self.p1.id else self.p2
            await loser.timeout(dt.timedelta(minutes=30), reason="Fled from Fight Club")
        except: pass

        self.logs = "ğŸƒ **COWARDICE DETECTED!** Player failed to move in 60s."
        self.gif_url = "https://media.tenor.com/d6-SreC3_p8AAAAC/wasted-gta5.gif"
        
        embed = self.get_embed(winner=True) # Color gold
        embed.color = 0x8B0000 # Blood Red for AFK
        embed.description += f"\n\nğŸš¨ **FORFEIT:** <@{loser_id}> ran away!\nğŸ† **WINNER:** <@{winner_id}> takes the `${self.bet*2:,}` purse."
        
        if self.message:
            try: await self.message.edit(embed=embed, view=self)
            except: pass

    # --- ğŸ•¹ï¸ BUTTON CONTROLS ---
    @discord.ui.button(label="ATTACK", style=discord.ButtonStyle.danger, emoji="âš”ï¸")
    async def attack(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.turn: return await interaction.response.send_message("âŒ Referee: Wait your turn!", ephemeral=True)
        await interaction.response.defer() # ğŸ› ï¸ FIX: Prevents Crash
        
        attacker_id = self.turn
        defender_id = self.p2.id if attacker_id == self.p1.id else self.p1.id
        
        att = self.stats[attacker_id]
        defe = self.stats[defender_id]
        
        dmg = random.randint(att['min_dmg'], att['max_dmg'])
        is_crit = random.randint(1, 100) <= 20 # 20% Crit
        if is_crit: dmg = int(dmg * 1.5)
        
        # Defense Calculation
        if defe['defending']:
            dmg = int(dmg / 2)
            defe['defending'] = False 
            self.logs = f"ğŸ›¡ï¸ **BLOCKED!** {defe['user'].display_name} reduced the damage to -{dmg} HP."
            self.gif_url = "https://media.tenor.com/Z8w7t47oUdkAAAAC/block-fight.gif"
        else:
            if is_crit: 
                self.logs = f"ğŸ’¥ **CRITICAL STRIKE!** {att['user'].display_name} smashed for -{dmg} HP!"
                self.gif_url = "https://media.tenor.com/5hP4R74Xp7oAAAAC/one-punch-man-saitama.gif"
            else: 
                self.logs = f"âš”ï¸ {att['user'].display_name} landed a solid hit! (-{dmg} HP)"
                self.gif_url = "https://media.tenor.com/M_Xz29mG2LgAAAAC/fight-club.gif"
        
        defe['hp'] -= dmg
        
        is_dead = await self.check_death(defender_id)
        if is_dead:
            await self.end_game(attacker_id, defender_id)
        else:
            self.turn = defender_id 
            if self.message:
                try: await self.message.edit(embed=self.get_embed(), view=self)
                except: pass

    @discord.ui.button(label="DEFEND", style=discord.ButtonStyle.primary, emoji="ğŸ›¡ï¸")
    async def defend(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.turn: return await interaction.response.send_message("âŒ Referee: Wait your turn!", ephemeral=True)
        await interaction.response.defer()
        
        self.stats[self.turn]['defending'] = True
        self.logs = f"ğŸ›¡ï¸ {interaction.user.display_name} raised their guard! Next attack damage halved."
        self.gif_url = "https://media.tenor.com/Z8w7t47oUdkAAAAC/block-fight.gif"
        
        self.turn = self.p2.id if self.turn == self.p1.id else self.p1.id
        if self.message:
            try: await self.message.edit(embed=self.get_embed(), view=self)
            except: pass

    @discord.ui.button(label="HEAL ($500)", style=discord.ButtonStyle.success, emoji="ğŸ’‰")
    async def heal(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.turn: return await interaction.response.send_message("âŒ Referee: Wait your turn!", ephemeral=True)
        await interaction.response.defer()
        
        me = self.stats[self.turn]
        
        if me['heals'] <= 0:
            return await interaction.followup.send("âŒ You are out of Medical Stims!", ephemeral=True)
            
        # ğŸ› ï¸ FIX: Actual Money Deduction via Smart Charge
        paid = await smart_charge(self.turn, 500)
        if not paid:
            return await interaction.followup.send("âŒ You don't have `$500` to buy a Stimpack!", ephemeral=True)
            
        heal_amt = random.randint(15, 25)
        me['hp'] = min(me['hp'] + heal_amt, me['max_hp'])
        me['heals'] -= 1
        
        self.logs = f"ğŸ’‰ {interaction.user.display_name} injected a Stimpack! Recovered +{heal_amt} HP."
        self.gif_url = "https://media.tenor.com/9n9GvWq8n0IAAAAC/heal-healing.gif"
        
        self.turn = self.p2.id if self.turn == self.p1.id else self.p1.id
        if self.message:
            try: await self.message.edit(embed=self.get_embed(), view=self)
            except: pass


# --- ğŸŸï¸ CHALLENGE VIEW ---
class FightChallengeView(discord.ui.View):
    def __init__(self, p1, p2, bet):
        super().__init__(timeout=60)
        self.p1 = p1
        self.p2 = p2
        self.bet = bet
        self.message = None
    
    @discord.ui.button(label="ENTER THE CAGE (ACCEPT)", style=discord.ButtonStyle.danger, emoji="âœ…")
    async def accept(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.p2.id: return await interaction.response.send_message("âŒ Guards: This contract is not for you.", ephemeral=True)
        await interaction.response.defer()
        self.stop()
        
        # ğŸ’¸ SMART CHARGE FOR P2
        p2_paid = await smart_charge(self.p2.id, self.bet)
        if not p2_paid:
            return await interaction.followup.send(f"âŒ You are broke! You need `${self.bet:,}` in your Wallet + Bank.", ephemeral=True)
            
        # ğŸ’¸ SMART CHARGE FOR P1 (Double check before start)
        p1_paid = await smart_charge(self.p1.id, self.bet)
        if not p1_paid:
            await smart_reward(self.p2.id, self.bet) # Refund P2
            return await interaction.followup.send(f"âŒ The Challenger ({self.p1.mention}) is broke now! Fight cancelled.", ephemeral=True)
        
        # ğŸ’ Safe Inventory Fetch
        try:
            res1 = await db_call(lambda: supabase.table("economy").select("inventory").eq("user_id", str(self.p1.id)).execute())
            res2 = await db_call(lambda: supabase.table("economy").select("inventory").eq("user_id", str(self.p2.id)).execute())
            p1_inv = res1.data[0].get('inventory', {}) if (res1 and res1.data) else {}
            p2_inv = res2.data[0].get('inventory', {}) if (res2 and res2.data) else {}
        except:
            p1_inv, p2_inv = {}, {}
        
        # Start Game
        game_view = FightArenaView(self.p1, self.p2, p1_inv, p2_inv, self.bet)
        msg = await interaction.edit_original_response(content=f"ğŸš¨ **THE CAGE IS LOCKED!** {self.p1.mention} vs {self.p2.mention}", embed=game_view.get_embed(), view=game_view)
        game_view.message = msg

    @discord.ui.button(label="WALK AWAY", style=discord.ButtonStyle.secondary, emoji="ğŸƒ")
    async def decline(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id not in [self.p1.id, self.p2.id]:
            return await interaction.response.send_message("âŒ Move along, spectator.", ephemeral=True)
        
        await interaction.response.defer()
        self.stop()
        user_name = interaction.user.display_name
        embed = discord.Embed(title="ğŸƒ FIGHT CANCELLED", description=f"*{user_name} refused the fight. The crowd boos.*", color=0x95a5a6)
        await interaction.edit_original_response(content=None, view=None, embed=embed)

# ================== ğŸ® FIGHT COMMAND ==================
@bot.tree.command(name="fight", description="ğŸ¥Š Challenge user to Underground Fight Club (Wallet & Bank Supported)")
@app_commands.describe(opponent="Who do you want to destroy?", amount="How much are you betting? (Min $500)")
@check_seized()
async def fight(i: discord.Interaction, opponent: discord.Member, amount: int):
    await i.response.defer()

    if i.user.id == opponent.id or opponent.bot:
        return await i.followup.send("âŒ **Error:** You cannot fight yourself or a bot.", ephemeral=True)
        
    if amount < 500:
        return await i.followup.send("âŒ **Error:** Minimum Bet is `$500`.", ephemeral=True)
        
    # ğŸ’³ Pre-Check Balance for P1
    res = await db_call(lambda: supabase.table("economy").select("balance, bank").eq("user_id", str(i.user.id)).execute())
    if not res or not res.data:
        return await i.followup.send("âŒ You don't have an economy account!", ephemeral=True)
        
    host_total = int(res.data[0].get("balance", 0)) + int(res.data[0].get("bank", 0))
    if host_total < amount: 
        return await i.followup.send(f"âŒ You are broke! You need `${amount:,}` in your Wallet + Bank.", ephemeral=True)
        
    embed = discord.Embed(
        title="ğŸ¥Š UNDERGROUND FIGHT CLUB", 
        description=f"**{i.user.mention}** has challenged **{opponent.mention}** to a deathmatch!\n\n"
                    f" â”£ ğŸ’° **Purse:** `${amount * 2:,}`\n"
                    f" â”£ ğŸ”ª **Rules:** *Inventory weapons and armors are ALLOWED.*\n"
                    f" â”— ğŸ’€ **Penalty:** *The loser goes to the hospital (10m Timeout).*\n\n"
                    f"*{opponent.mention}, step into the cage if you dare!*", 
        color=0xFF0000
    )
    embed.set_thumbnail(url=opponent.display_avatar.url)
    embed.set_image(url="https://media.tenor.com/M_Xz29mG2LgAAAAC/fight-club.gif")
    
    view = FightChallengeView(i.user, opponent, amount)
    msg = await i.followup.send(content=f"ğŸŸï¸ **{opponent.mention}**, You have been challenged!", embed=embed, view=view)
    view.message = msg
  

# ================== ğŸ¦ HEIST: NIGHTMARE MODE (ECONOMY + VIP) ==================
import discord
from discord import app_commands
import random
import asyncio
import datetime as dt

# ==============================================================================
# ğŸ¦ HEIST: NIGHTMARE PROTOCOL (ULTRA-PREMIUM + SMART BANKING)
# ==============================================================================

# --- 1. LOBBY (CYBERPUNK TERMINAL UI) ---
class HeistLobbyView(discord.ui.View):
    def __init__(self, leader, entry_fee):
        super().__init__(timeout=300)
        self.leader = leader
        self.entry_fee = entry_fee
        self.crew = [leader] 
        self.started = False
        self.message = None

    def update_embed(self):
        crew_list = "\n".join([f" â”£ ğŸ©¸ {m.mention}" for m in self.crew])
        crew_list = crew_list.replace(" â”£ ", " â”— ") if len(self.crew) == 1 else crew_list
        
        embed = discord.Embed(title="â˜ ï¸ PROJECT: NIGHTMARE PROTOCOL", color=0x0A0A0A)
        embed.description = (
            "â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            "### ğŸ—„ï¸ TOP SECRET DOSSIER\n"
            "```yaml\n"
            "[SECURITY]: OMNICRON-LEVEL\n"
            "[SURVIVAL]: < 0.01%\n"
            "[PENALTY]:  SQUAD WIPE & FULL MUTE\n"
            "```\n"
            "â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ’¸ **BUY-IN COST:** `${self.entry_fee:,}` per ghost\n"
            f" â”£ ğŸ’ **MAX PAYOUT:** `$1,000,000` *(Split among survivors)*\n"
            f" â”— ğŸ›¡ï¸ **VIP PERKS:** Active *(Life Saver bypass enabled)*\n"
            "â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬"
        )
        embed.add_field(name=f"ğŸ‘¥ THE DEATH SQUAD ({len(self.crew)}/4)", value=crew_list if self.crew else " â”— *Waiting for ghosts...*", inline=False)
        embed.set_thumbnail(url="https://media.tenor.com/2jK3Y1s3CqAAAAAC/payday-dallas.gif") 
        embed.set_footer(text="âš ï¸ SYNDICATE WARNING: DO NOT PROCEED IF YOU VALUE YOUR LIFE.")
        return embed

    @discord.ui.button(label="SIGN IN BLOOD", style=discord.ButtonStyle.danger, emoji="ğŸ©¸")
    async def join_btn(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer()
        
        if self.started: return await interaction.followup.send("âŒ The breach has already begun.", ephemeral=True)
        if interaction.user in self.crew: return await interaction.followup.send("âš ï¸ Your signature is already in blood!", ephemeral=True)
        if len(self.crew) >= 4: return await interaction.followup.send("ğŸš« The getaway car is full!", ephemeral=True)
        
        # ğŸ’³ SMART CHARGE CHECK (Wallet + Bank)
        paid = await smart_charge(interaction.user.id, self.entry_fee)
        if not paid:
            return await interaction.followup.send(f"âŒ You are too broke. You need `${self.entry_fee:,}` in your Wallet + Bank to join!", ephemeral=True)

        self.crew.append(interaction.user)
        if self.message:
            try: await self.message.edit(embed=self.update_embed(), view=self)
            except: pass

    @discord.ui.button(label="INITIATE BREACH", style=discord.ButtonStyle.secondary, emoji="ğŸ’€")
    async def start_btn(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer() 
        
        if interaction.user.id != self.leader.id: return await interaction.followup.send("âŒ Only the Mastermind can start the heist.", ephemeral=True)
        if len(self.crew) < 2: return await interaction.followup.send("âŒ Suicide missions require at least 2 bodies.", ephemeral=True)

        self.started = True
        self.stop()
        for child in self.children: child.disabled = True
        
        if self.message:
            try: await self.message.edit(embed=self.update_embed(), view=self)
            except: pass
        
        try:
            await start_hell_heist(interaction, self.crew)
        except Exception as e:
            await interaction.followup.send(f"âŒ **System Failure:** `{e}`")

    async def on_timeout(self):
        if not self.started:
            for child in self.children: child.disabled = True
            
            # Refund everyone
            for m in self.crew:
                await smart_reward(m.id, self.entry_fee)
                
            embed = discord.Embed(title="â³ OPERATION ABORTED", description="*The squad took too long to assemble. Funds refunded.*", color=0x95a5a6)
            if self.message:
                try: await self.message.edit(embed=embed, view=None)
                except: pass


# --- 2. BASE TASK ENGINE (100% RESPONSIVE) ---
class HeistTaskView(discord.ui.View):
    def __init__(self, player, correct_val, fail_func, success_func, timeout_sec, interaction):
        super().__init__(timeout=timeout_sec) 
        self.player = player
        self.correct_val = correct_val
        self.fail_func = fail_func
        self.success_func = success_func
        self.interaction = interaction # Store interaction for timeout edit
        self.responded = False
        self.success = False

    async def on_timeout(self):
        if not self.responded:
            self.success = False
            self.stop()
            # ğŸ› ï¸ FIX: Auto trigger fail if time runs out!
            await self.fail_func(f"â³ **TOO SLOW!** {self.player.mention} hesitated and got caught!", self.player, self.interaction)

    async def verify(self, interaction, answer):
        await interaction.response.defer()
        
        if interaction.user.id != self.player.id:
            return await interaction.followup.send("âŒ GET BACK! You'll trigger the alarm!", ephemeral=True)
        
        self.responded = True
        
        if answer == self.correct_val:
            self.success = True
            self.stop()
            await self.success_func(interaction)
        else:
            self.success = False
            self.stop()
            await self.fail_func(f"âŒ **FATAL ERROR!** {self.player.mention} made the wrong move!", self.player, interaction)


# --- 3. SEQUENCE TASK ENGINE (BOMB DEFUSAL) ---
class SequenceTaskView(discord.ui.View):
    def __init__(self, player, target_sequence, fail_func, success_func, timeout_sec, btn_config, interaction):
        super().__init__(timeout=timeout_sec)
        self.player = player
        self.target_sequence = target_sequence
        self.fail_func = fail_func
        self.success_func = success_func
        self.interaction = interaction
        self.current_idx = 0
        self.responded = False
        self.success = False
        
        for label, style, emoji in btn_config:
            btn = discord.ui.Button(label=label, style=style, emoji=emoji, custom_id=label)
            btn.callback = self.make_callback(label)
            self.add_item(btn)

    async def on_timeout(self):
        if not self.responded:
            self.success = False
            self.stop()
            await self.fail_func(f"ğŸ’¥ **BOOM!** {self.player.mention} ran out of time! The bomb exploded!", self.player, self.interaction)

    def make_callback(self, val):
        async def cb(i):
            await i.response.defer() 
            
            if i.user.id != self.player.id: 
                return await i.followup.send("âŒ Back off! One wrong wire and we all die.", ephemeral=True)
            
            # ğŸ› ï¸ FIX: Indentation error resolved!
            if val == self.target_sequence[self.current_idx]:
                self.current_idx += 1
                if self.current_idx >= len(self.target_sequence):
                    self.responded = True
                    self.success = True
                    self.stop()
                    await self.success_func(i)
            else:
                self.responded = True
                self.success = False
                self.stop()
                await self.fail_func(f"ğŸ’¥ **BOOM!** {self.player.mention} cut the wrong wire!", self.player, i)
        return cb


# --- 4. MAIN GAME LOGIC (GOD MODE TASKS) ---
async def start_hell_heist(interaction, crew):
    rotation = []
    while len(rotation) < 4: rotation.extend(crew)
    stage_players = rotation[:4] 
    
    embed = discord.Embed(title="ğŸ¬ THE DESCENT", color=0x0A0A0A)
    embed.description = "# ğŸ•´ï¸ GHOSTS IN THE MACHINE...\n\n> **Objective:** Steal the Quantum Drive.\n> **Status:** Lethal Force Authorized.\n\n*Injecting payload into mainframe...*"
    embed.set_image(url="https://media.tenor.com/fM9Rofk5sRkAAAAC/cyberpunk-walking.gif")
    
    msg = await interaction.followup.send(embed=embed)
    await asyncio.sleep(4)

    # --- ğŸš¨ FAIL HANDLER (SQUAD WIPE) ---
    async def trigger_fail(reason, culprit, current_interaction):
        report = []
        for m in crew:
            status = "ğŸ’€ `Arrested & Muted`"
            is_saved = False
            
            try:
                # ğŸ› ï¸ Safe Inventory & VIP Check
                res = await db_call(lambda: supabase.table("economy").select("vip_expiry, inventory").eq("user_id", str(m.id)).execute())
                
                if res and res.data:
                    data = res.data[0]
                    inv = data.get('inventory', {}) or {}
                    
                    if data.get('vip_expiry'):
                        status = "ğŸ›¡ï¸ `Ghost Protocol (VIP Bypassed)`"
                        is_saved = True
                    elif inv.get("life", 0) > 0 and not is_saved:
                        inv["life"] -= 1
                        await db_call(lambda: supabase.table("economy").update({"inventory": inv}).eq("user_id", str(m.id)).execute())
                        status = "ğŸ’– `Revived (-1 Life Item)`"
                        is_saved = True
            except Exception as e:
                print(f"Heist Fail DB Error: {e}")

            if not is_saved:
                try: await m.timeout(dt.timedelta(minutes=5), reason="Nightmare Heist Failure")
                except: status = "ğŸ¤¡ `Arrested (Bot Missing Perms)`"
            
            report.append(f" â”£ ğŸ‘¤ {m.mention} â” {status}")

        report[-1] = report[-1].replace(" â”£ ", " â”— ") # Tree fix for last item

        fail_embed = discord.Embed(title="ğŸ©¸ OPERATION FAILED", color=0x8B0000)
        fail_embed.description = (
            f"# âŒ SQUAD WIPED!\n"
            f"> **CAUSE:** {reason}\n"
            f"> **LIABILITY:** {culprit.mention}\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"### ğŸ“‹ AFTERMATH REPORT:\n"
            f"{chr(10).join(report)}"
        )
        fail_embed.set_image(url="https://media.tenor.com/1-11Yd6_QpYAAAAC/explosion-blast.gif")
        
        try: await msg.edit(embed=fail_embed, view=None)
        except: pass

    # ==========================================
    # ğŸ’» STAGE 1: HACKER (3.5s)
    # ==========================================
    hacker = stage_players[0]
    
    chars = "Il1O08B"
    target = "".join(random.choices(chars, k=7))
    options = [target]
    while len(options) < 4:
        fake = "".join(random.choices(chars, k=7))
        if fake not in options: options.append(fake)
    random.shuffle(options)

    embed = discord.Embed(title="ğŸ’» STAGE 1: MAINFRAME HACK", color=0x00FF00)
    embed.description = (
        f"# ğŸ” DECRYPT THE HASH\n"
        f"**Hacker Assigned:** {hacker.mention}\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"Select the exact matching security key from the terminal:\n\n"
        f"```yaml\n"
        f"TARGET HASH: [ {target} ]\n"
        f"```\n"
        f"â³ *(Self-Destruct in 3.5 seconds...)*"
    )
    embed.set_thumbnail(url="https://media.tenor.com/GfSX-u7_NSAAAAAC/coding-hacker.gif") 
    
    async def pass_1(i): pass 

    view1 = HeistTaskView(hacker, target, trigger_fail, pass_1, 3.5, interaction) 
    for opt in options:
        btn = discord.ui.Button(label=opt, style=discord.ButtonStyle.secondary)
        btn.callback = lambda i, o=opt: view1.verify(i, o)
        view1.add_item(btn)

    await msg.edit(embed=embed, view=view1)
    await view1.wait()
    if not view1.success: return 

    await msg.edit(embed=discord.Embed(description="# âœ… FIREWALL SHATTERED.\n> *Moving to the Vault...*", color=0x00FF00), view=None)
    await asyncio.sleep(2)


    # ==========================================
    # ğŸ’£ STAGE 2: DEMOLITION (6.0s Reverse Wire)
    # ==========================================
    demo = stage_players[1]
    
    wires = ["ğŸ”´", "ğŸ”µ", "ğŸŸ¢", "ğŸŸ¡"]
    seq = random.choices(wires, k=6) 
    
    embed = discord.Embed(title="ğŸ’£ STAGE 2: QUANTUM THERMITE", color=0xFFA500)
    embed.description = (
        f"# ğŸ§  MEMORY OVERLOAD\n"
        f"**Demolition Expert:** {demo.mention}\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"**MEMORIZE THIS SEQUENCE:**\n\n"
        f"> {' '.join(seq)}\n\n"
        f"â³ *(Detonator arms in 4.0s...)*"
    )
    embed.set_thumbnail(url="https://media.tenor.com/fJqL8Yg9qQoAAAAC/bomb-timer.gif") 
    
    await msg.edit(embed=embed, view=None)
    await asyncio.sleep(4.0) 

    embed.description = (
        f"# âœ‚ï¸ CUT THE WIRES!\n"
        f"ğŸš¨ **{demo.mention}, CUT THEM IN __REVERSE__ ORDER!** ğŸš¨\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"â³ *(Hurry! You have 6 seconds!)*"
    )
    
    async def pass_2(i): pass

    btn_conf = [
        ("RED", discord.ButtonStyle.danger, "ğŸ”´"),
        ("BLUE", discord.ButtonStyle.primary, "ğŸ”µ"),
        ("GREEN", discord.ButtonStyle.success, "ğŸŸ¢"),
        ("YELLOW", discord.ButtonStyle.secondary, "ğŸŸ¡")
    ]
    
    color_map = {"ğŸ”´":"RED", "ğŸ”µ":"BLUE", "ğŸŸ¢":"GREEN", "ğŸŸ¡":"YELLOW"}
    target_labels = [color_map[s] for s in seq[::-1]]

    view2 = SequenceTaskView(demo, target_labels, trigger_fail, pass_2, 6.0, btn_conf, interaction)
    await msg.edit(embed=embed, view=view2)
    await view2.wait()
    if not view2.success: return

    await msg.edit(embed=discord.Embed(description="# âœ… VAULT BREACHED.\n> *Grab the loot! Swat is here!*", color=0xFFA500), view=None)
    await asyncio.sleep(2)


    # ==========================================
    # ğŸ”« STAGE 3: SHOOTER (2.5s)
    # ==========================================
    shooter = stage_players[2]
    
    embed = discord.Embed(title="ğŸ”« STAGE 3: LETHAL FORCE", color=0xFF0000)
    embed.description = (
        f"# ğŸ‘ï¸ SNIPER OVERWATCH\n"
        f"**Shooter:** {shooter.mention}\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"**HOSTAGES INTERMIXED WITH GUARDS.**\n"
        f"> Shoot the **VIP GUARD** (`ğŸ•´ï¸`).\n"
        f"> DO NOT hit civilians (`ğŸ§â€â™‚ï¸`)!\n\n"
        f"â³ *(Target moving in 2.5 seconds!)*"
    )
    embed.set_thumbnail(url="https://media.tenor.com/AMnQd8r8ZtAAAAAC/sniper-scope.gif") 
    
    async def pass_3(i): pass
    view3 = HeistTaskView(shooter, "VIP", trigger_fail, pass_3, 2.5, interaction) 
    
    btns = [("ğŸ§â€â™‚ï¸", "CIV", discord.ButtonStyle.secondary)] * 3 + [("ğŸ•´ï¸", "VIP", discord.ButtonStyle.danger)]
    random.shuffle(btns)

    for lbl, val, sty in btns:
        b = discord.ui.Button(label=lbl, style=sty)
        b.callback = lambda i, v=val: view3.verify(i, v)
        view3.add_item(b)

    await msg.edit(embed=embed, view=view3)
    await view3.wait()
    if not view3.success: return

    await msg.edit(embed=discord.Embed(description="# âœ… TARGET ELIMINATED.\n> *Get to the extraction point!*", color=0xFF0000), view=None)
    await asyncio.sleep(2)


    # ==========================================
    # ğŸš— STAGE 4: DRIVER (2.0s Reaction)
    # ==========================================
    driver = stage_players[3]
    
    scenarios = [
        {"desc": "SPIKE STRIPS DEPLOYED ON LEFT AND CENTER!", "correct": "RIGHT"},
        {"desc": "CHOPPER FIRING MISSILES AHEAD! TUNNEL ON THE LEFT!", "correct": "TUNNEL"},
        {"desc": "ROADBLOCK! NO WAY AROUND! USE THE RAMP!", "correct": "RAMP"}
    ]
    scene = random.choice(scenarios)
    
    embed = discord.Embed(title="ğŸš— STAGE 4: HIGHWAY TO HELL", color=0x3498DB)
    embed.description = (
        f"# ğŸš¨ EVASIVE MANEUVER\n"
        f"**Getaway Driver:** {driver.mention}\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"ğŸ“» **SWAT RADIO:** *\"{scene['desc']}\"*\n\n"
        f"**REACT IMMEDIATELY!** â³ (2.0s)"
    )
    embed.set_thumbnail(url="https://media.tenor.com/8QG3y-h0kFMAAAAC/need-for-speed-car-chase.gif")
    
    async def pass_4(i): pass
    view4 = HeistTaskView(driver, scene["correct"], trigger_fail, pass_4, 2.0, interaction) 
    
    options = ["LEFT", "RIGHT", "CENTER", "BRAKE", "TUNNEL", "RAMP"]
    options.remove(scene["correct"])
    fake_options = random.sample(options, 3)
    
    final_btns = fake_options + [scene["correct"]]
    random.shuffle(final_btns)
    
    for opt in final_btns:
        sty = discord.ButtonStyle.primary if opt != "BRAKE" else discord.ButtonStyle.danger
        b = discord.ui.Button(label=f"SWERVE {opt}" if opt in ["LEFT", "RIGHT", "CENTER"] else opt, style=sty, custom_id=opt)
        b.callback = lambda i, v=opt: view4.verify(i, v)
        view4.add_item(b)

    await msg.edit(embed=embed, view=view4)
    await view4.wait()
    if not view4.success: return

    # ==========================================
    # ğŸ† LEGENDARY VICTORY SCREEN
    # ==========================================
    payout = 1000000 // len(crew) # 1 Million divided by crew size!
    
    for m in crew:
        try:
            # ğŸ’¸ SMART REWARD UPDATE
            await smart_reward(m.id, payout)
        except Exception as e:
            print(f"Heist Win DB Error: {e}")

    embed = discord.Embed(title="ğŸ‘‘ THE PERFECT HEIST", color=0xFFD700)
    embed.description = (
        f"# ğŸ’ GHOSTS OF THE CITY\n"
        f"**You pulled off the impossible.**\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"ğŸ’° **PAYOUT SECURED:** `${payout:,}` *(Per Player)*\n\n"
        f"**LEGENDS OF THE UNDERGROUND:**\n"
        f"> {', '.join([m.mention for m in crew])}\n\n"
        f"**STATUS:** UNTOUCHABLE ğŸ·"
    )
    embed.set_thumbnail(url="https://media.tenor.com/p7a8o1r5c8cAAAAC/money-rain.gif")
    embed.set_footer(text="FUNDS HAVE BEEN LAUNDERED AND DEPOSITED INTO YOUR WALLETS.")
    
    await msg.edit(embed=embed, view=None)

# ==========================================
# ğŸš¨ 5. THE MAIN SLASH COMMAND
# ==========================================
@bot.tree.command(name="heist", description="ğŸ¦ Nightmare Heist (God Mode) - 2-4 Players")
@check_seized() 
async def heist_cmd(i: discord.Interaction):
    # ğŸ› ï¸ INSTANT DEFER - No more "Application did not respond"
    await i.response.defer() 
    
    entry_fee = 50000 # 50k ENTRY FEE
    
    # ğŸ’³ SMART CHARGE CHECK FOR HOST
    paid = await smart_charge(i.user.id, entry_fee)
    if not paid:
        return await i.followup.send(f"âŒ You are too broke to fund this operation! You need `${entry_fee:,}` in your Wallet + Bank.", ephemeral=True)

    # ğŸ› ï¸ Passing entry_fee safely to the View
    view = HeistLobbyView(i.user, entry_fee)
    msg = await i.followup.send(embed=view.update_embed(), view=view)
    view.message = msg # Store message to edit on timeout!      

    
import discord
from discord import app_commands
import random
import asyncio
import datetime as dt

# ==============================================================================
# ğŸ¤  WESTERN STANDOFF (ULTRA-PREMIUM DUEL SYSTEM)
# ==============================================================================

class WesternDuelGameView(discord.ui.View):
    def __init__(self, p1: discord.Member, p2: discord.Member, interaction_to_edit: discord.Interaction):
        super().__init__(timeout=60) # â³ 60s AFK Timer
        self.p1 = p1 
        self.p2 = p2 
        self.interaction_to_edit = interaction_to_edit 
        self.winner = None
        self.signal_given = False
        self.start_time = None
        self.bet = 10000 # ğŸ’° $10k Entry Fee
        
        # ğŸ›‘ INITIAL BUTTON (Danger/Red)
        self.shoot_btn = discord.ui.Button(
            label="ğŸ›‘ HOLD YOUR FIRE...", 
            style=discord.ButtonStyle.danger, 
            custom_id="shoot_btn",
            disabled=True 
        )
        self.shoot_btn.callback = self.shoot_callback
        self.add_item(self.shoot_btn)

    async def on_timeout(self):
        """ âš ï¸ AFK LOGIC: If nobody shoots after the signal! """
        if not self.winner:
            for child in self.children: child.disabled = True
            
            # Refund both players
            await smart_reward(self.p1.id, self.bet)
            await smart_reward(self.p2.id, self.bet)
            
            embed = discord.Embed(
                title="ğŸƒ STANDOFF ABANDONED", 
                description="*Both cowboys fell asleep. The duel is cancelled and bets are refunded.*", 
                color=0x95a5a6
            )
            embed.set_image(url="https://media.tenor.com/w9yv4p2y3QAAAAAC/tumbleweed.gif")
            try: await self.interaction_to_edit.edit_original_response(embed=embed, view=None)
            except: pass

    async def start_game_logic(self):
        # 1. Warmup (Enable button - RED)
        await asyncio.sleep(2)
        self.shoot_btn.disabled = False
        self.shoot_btn.label = "ğŸ›‘ STEADY... DO NOT SHOOT!"
        try: await self.interaction_to_edit.edit_original_response(view=self)
        except: pass

        # 2. Suspense Phase (Random Delay 3s to 8s)
        delay = random.uniform(3, 8)
        await asyncio.sleep(delay)
        
        if self.winner: return # Agar kisi ne pehle hi galti kar di ho

        # 3. ğŸ”¥ FIRE SIGNAL!
        self.signal_given = True
        self.start_time = dt.datetime.now().timestamp()
        
        # Update Button to GREEN
        self.shoot_btn.label = "ğŸ”¥ FIRE NOW!"
        self.shoot_btn.style = discord.ButtonStyle.success 
        self.shoot_btn.emoji = "ğŸ”«"
        
        # Premium Embed Update (Green Signal)
        embed = discord.Embed(color=0x2ecc71) # Emerald Green
        embed.set_author(name="ğŸ”¥ DRAW! DRAW! DRAW!", icon_url="https://cdn-icons-png.flaticon.com/512/1546/1546090.png")
        embed.description = (
            f"# ğŸ‘‡ SHOOT NOW! ğŸ‘‡\n"
            f"**{self.p1.mention} ğŸ†š {self.p2.mention}**\n\n"
            f"âš¡ **First to pull the trigger takes the `${(self.bet * 2):,}` pot!**"
        )
        embed.set_image(url="https://media.tenor.com/E5J0kC1yTzAAAAAC/the-good-the-bad-and-the-ugly-clint-eastwood.gif")
        
        try: await self.interaction_to_edit.edit_original_response(embed=embed, view=self)
        except: pass

    async def shoot_callback(self, interaction: discord.Interaction):
        # Security Check
        if interaction.user.id not in [self.p1.id, self.p2.id]:
            return await interaction.response.send_message("âŒ **Sheriff:** Get back! This ain't your fight.", ephemeral=True)
            
        if self.winner:
            return await interaction.response.send_message("âš°ï¸ **Too late!** The body is already cold.", ephemeral=True)

        await interaction.response.defer() # ğŸ› ï¸ FIX: Prevents Crash!

        # ==========================================
        # âŒ CASE A: EARLY FIRE (Misfire / Shot in the foot)
        # ==========================================
        if not self.signal_given:
            loser = interaction.user
            winner = self.p1 if loser.id == self.p2.id else self.p2
            self.winner = winner 
            self.stop()
            
            # ğŸ’¸ Reward Winner (Takes both entry fees)
            await smart_reward(winner.id, self.bet * 2)
            
            # ğŸ¥ Punish Loser
            try: await loser.timeout(dt.timedelta(seconds=60), reason="Duel Suicide (Misfire)")
            except: pass

            embed = discord.Embed(title="ğŸ’€ MISFIRE! (DISQUALIFIED)", color=0x2b2d31)
            embed.set_author(name=f"Foolish Mistake by {loser.display_name}", icon_url=loser.display_avatar.url)
            embed.description = (
                f"### ğŸ¤¦â€â™‚ï¸ Shot himself in the foot!\n"
                f"**{loser.mention}** panicked and pulled the trigger before the signal.\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ† **WINNER:** {winner.mention} *( Won `${(self.bet * 2):,}` )*\n"
                f" â”— ğŸ¤• **PUNISHMENT:** `60s Timeout (Hospital)`"
            )
            embed.set_thumbnail(url="https://cdn-icons-png.flaticon.com/512/463/463067.png")
            embed.set_image(url="https://media.tenor.com/12s3s2v1b4cAAAAC/gun-fail.gif")
            
            return await interaction.edit_original_response(embed=embed, view=None)

        # ==========================================
        # âœ… CASE B: PERFECT SHOT (Victory)
        # ==========================================
        reaction_time = round(dt.datetime.now().timestamp() - self.start_time, 3)
        self.winner = interaction.user
        self.stop()
        
        winner = interaction.user
        loser = self.p1 if winner.id == self.p2.id else self.p2
        
        # ğŸ’¸ Reward Winner 
        await smart_reward(winner.id, self.bet * 2)
        
        # ğŸ¥ Punish Loser
        try: await loser.timeout(dt.timedelta(seconds=60), reason="Lost Western Duel")
        except: pass
        
        embed = discord.Embed(color=0xFFD700) # Solid Gold
        embed.set_author(name=f"ğŸ† FASTEST HAND IN THE WEST: {winner.display_name}", icon_url=winner.display_avatar.url)
        embed.set_thumbnail(url=loser.display_avatar.url)
        
        embed.description = (
            f"# ğŸ’¥ HEADSHOT!\n"
            f"**Lightning fast reflexes!**\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ âš¡ **Reaction Time:** `{reaction_time}s`\n"
            f" â”£ ğŸ”« **Shooter:** {winner.mention}\n"
            f" â”£ ğŸª¦ **Victim:** {loser.mention} *( 60s Timeout )*\n"
            f" â”— ğŸ’° **Loot Secured:** `${(self.bet * 2):,}`\n"
        )
        embed.set_image(url="https://media.tenor.com/M6Lw1wD2t40AAAAC/wwe-winner.gif")
        embed.set_footer(text="The dust settles... â€¢ Titan Games", icon_url=interaction.client.user.display_avatar.url)
        
        await interaction.edit_original_response(embed=embed, view=None)


# --- ğŸ“œ CHALLENGE REQUEST VIEW ---
class DuelRequestView(discord.ui.View):
    def __init__(self, challenger: discord.Member, opponent: discord.Member):
        super().__init__(timeout=60)
        self.challenger = challenger
        self.opponent = opponent
        self.accepted = False
        self.bet = 10000 # ğŸ’° $10k Entry Fee
        self.message = None

    @discord.ui.button(label="ACCEPT DUEL", style=discord.ButtonStyle.success, emoji="âœ…")
    async def accept(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.opponent.id:
            return await interaction.response.send_message("âŒ **Sheriff:** This warrant ain't for you!", ephemeral=True)
        
        await interaction.response.defer()

        # ğŸ’³ SMART CHARGE CHECK FOR OPPONENT
        opp_paid = await smart_charge(self.opponent.id, self.bet)
        if not opp_paid:
            return await interaction.followup.send(f"âŒ You are too broke! You need `${self.bet:,}` to enter the standoff.", ephemeral=True)
            
        # ğŸ’³ SMART CHARGE CHECK FOR CHALLENGER (In case they moved money while waiting)
        challenger_paid = await smart_charge(self.challenger.id, self.bet)
        if not challenger_paid:
            await smart_reward(self.opponent.id, self.bet) # Refund opponent
            return await interaction.followup.send(f"âŒ The Challenger ({self.challenger.mention}) is broke now! Duel cancelled.", ephemeral=True)

        self.accepted = True
        self.stop() 
        
        embed = discord.Embed(title="ğŸ¤  STANDOFF INITIATED", color=0xE67E22) # Orange
        embed.description = (
            f"### ğŸ‘ï¸ EYES ON THE TRIGGER!\n"
            f"**{self.challenger.mention} ğŸ†š {self.opponent.mention}**\n\n"
            f"Wait for the button below to turn **GREEN**.\n"
            f"*(Shoot early = Suicide | Shoot late = Death)*"
        )
        embed.set_image(url="https://media.tenor.com/h5T27d4s5ogAAAAC/the-good-the-bad-and-the-ugly-clint-eastwood.gif")
        
        game_view = WesternDuelGameView(self.challenger, self.opponent, interaction)
        
        await interaction.edit_original_response(embed=embed, view=game_view)
        await game_view.start_game_logic() # Start background timer

    @discord.ui.button(label="FLEE TOWN", style=discord.ButtonStyle.secondary, emoji="ğŸƒ")
    async def decline(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.opponent.id:
            return await interaction.response.send_message("âŒ Mind your own business.", ephemeral=True)
            
        await interaction.response.defer()
        self.stop()
        
        embed = discord.Embed(title="ğŸƒ COWARD DETECTED", description=f"*{self.opponent.mention} fled town. The duel is off!*", color=0x95a5a6)
        await interaction.edit_original_response(content=None, embed=embed, view=None)

    async def on_timeout(self):
        if not self.accepted:
            for child in self.children: child.disabled = True
            timeout_embed = discord.Embed(title="â³ TIME EXPIRED", description="*The challenge expired. Nobody died today.*", color=0x95a5a6)
            if self.message:
                try: await self.message.edit(embed=timeout_embed, view=None)
                except: pass


# --- ğŸ”« MAIN COMMAND ---
@bot.tree.command(name="duel", description="ğŸ¤  Challenge a player to a Western Standoff ($10,000 Entry Fee)")
@app_commands.describe(opponent="Who do you want to shoot?")
@check_seized()
async def western_duel(i: discord.Interaction, opponent: discord.Member):
    await i.response.defer() # â³ Instant Defer

    # 1. Basic Checks
    if not i.guild.me.guild_permissions.moderate_members:
        return await i.followup.send("âŒ **System Error:** Bot lacks `Timeout` permissions!", ephemeral=True)
    if opponent.id == i.user.id or opponent.bot:
        return await i.followup.send("âŒ **Error:** You cannot duel yourself or a bot.", ephemeral=True)

    bet = 10000 # Standard Bet

    # 2. Pre-Check Challenger's Money (Wallet + Bank)
    res = await db_call(lambda: supabase.table("economy").select("balance, bank").eq("user_id", str(i.user.id)).execute())
    if not res or not res.data:
        return await i.followup.send("âŒ You don't have an economy account!", ephemeral=True)
        
    host_total = int(res.data[0].get("balance", 0)) + int(res.data[0].get("bank", 0))
    if host_total < bet: 
        return await i.followup.send(f"âŒ You are broke! You need `${bet:,}` in your Wallet + Bank to duel.", ephemeral=True)

    # 3. Challenge Embed
    embed = discord.Embed(title="ğŸ“œ HIGH NOON CHALLENGE", color=0xB8860B) # Dark Gold
    embed.set_author(name=f"{i.user.display_name} demands satisfaction!", icon_url=i.user.display_avatar.url)
    embed.set_thumbnail(url=opponent.display_avatar.url)
    
    embed.description = (
        f"# ğŸ¤  {i.user.mention} âš”ï¸ {opponent.mention}\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f" â”£ ğŸ’¸ **Entry Fee:** `${bet:,}` *(Per Player)*\n"
        f" â”£ ğŸ’° **Winner Takes:** `${(bet * 2):,}`\n"
        f" â”— ğŸ’€ **Loser Gets:** `60s Timeout (Hospital)`\n\n"
        f"ğŸ‘‡ **{opponent.mention}, do you accept?**"
    )
    
    view = DuelRequestView(i.user, opponent)
    msg = await i.followup.send(content=opponent.mention, embed=embed, view=view)
    view.message = msg # Save for timeout editing
        

# ================== ğŸ’£ HOT POTATO BOMB GAME (PREMIUM) ==================
import discord
from discord import app_commands
import random
import asyncio
import time

# ==============================================================================
# ğŸ’£ HOT POTATO: LETHAL PAYLOAD (ULTRA-PREMIUM + SMART BANKING)
# ==============================================================================

class BombPassView(discord.ui.View):
    def __init__(self, holder: discord.Member, message: discord.Message, cost: int):
        super().__init__(timeout=None) # Timer hum khud handle karenge
        self.holder = holder
        self.message = message
        self.cost = cost
        self.exploded = False
        
        # â±ï¸ Smart Bomb Timer: Random between 20s to 45s
        self.duration = random.randint(20, 45)
        self.explode_time = time.time() + self.duration
        
        # Start Timer Task safely
        self.timer_task = asyncio.create_task(self.bomb_timer())

    async def bomb_timer(self):
        """ ğŸ§  100% Stable Timer Logic (No infinite loops) """
        await asyncio.sleep(self.duration)
        
        if not self.exploded:
            self.exploded = True
            await self.trigger_explosion()

    async def trigger_explosion(self):
        """ ğŸ’¥ THE KABOOM PROTOCOL """
        self.stop()
        
        # ğŸ¥ Mute the loser for 5 minutes
        punish_msg = "Could not mute (Missing Perms)."
        try:
            punish_msg = await smart_timeout(self.message, self.holder, 300, "Held the Lethal Bomb")
        except: pass

        embed = discord.Embed(title="ğŸ’¥ KABOOOM! TARGET ELIMINATED", color=0x8B0000) # Dark Blood Red
        embed.description = (
            f"# â˜ ï¸ FATAL CASUALTY\n"
            f"**{self.holder.mention}** hesitated and the payload detonated!\n"
            f"Nothing left but ashes.\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ’£ **Deployment Cost:** `${self.cost:,}`\n"
            f" â”£ â±ï¸ **Total Fuse Time:** `{self.duration} Seconds`\n"
            f" â”— ğŸ¥ **Aftermath:** `5m Timeout Applied`"
        )
        embed.set_thumbnail(url=self.holder.display_avatar.url)
        embed.set_image(url="https://media.tenor.com/8p1jZ5jG4yQAAAAC/explosion-boom.gif")
        embed.set_footer(text="Threat Neutralized â€¢ Titan Games", icon_url=self.holder.guild.me.display_avatar.url)
        
        self.clear_items() # Remove the dropdown
        
        try:
            # ğŸ› ï¸ FIX: Safely edit the stored message
            await self.message.edit(content=f"ğŸ’€ **R.I.P** {self.holder.mention}", embed=embed, view=self)
        except Exception as e:
            print(f"Bomb Explosion Edit Error: {e}")

    @discord.ui.select(
        placeholder="ğŸ”¥ THROW THE BOMB! (Select Victim)", 
        cls=discord.ui.UserSelect, 
        max_values=1
    )
    async def pass_bomb(self, interaction: discord.Interaction, select: discord.ui.UserSelect):
        # ğŸ› ï¸ FIX: Instant Defer to prevent Interaction Failed
        await interaction.response.defer()

        if self.exploded: 
            return await interaction.followup.send("âŒ **Too late!** The bomb already exploded.", ephemeral=True)

        # Security Check
        if interaction.user.id != self.holder.id:
            return await interaction.followup.send("âŒ **Back off!** You don't have the bomb.", ephemeral=True)

        target = select.values[0]
        
        # --- ğŸ›¡ï¸ VALIDATION CHECKS ---
        if target.bot:
            return await interaction.followup.send("âŒ **Invalid Target:** Bots are immune to explosions. Pick a human!", ephemeral=True)
        if target.id == interaction.user.id:
            return await interaction.followup.send("âŒ **Are you crazy?** You can't pass the bomb to yourself!", ephemeral=True)

        # âœ… SUCCESSFUL PASS
        self.holder = target
        
        # Premium Embed Update
        embed = discord.Embed(title="ğŸ’£ LETHAL PAYLOAD PASSED!", color=0xFFA500) # Panic Orange
        embed.description = (
            f"### ğŸƒğŸ’¨ INCOMING THREAT!\n"
            f"**{interaction.user.display_name}** tossed the live explosive to **{target.mention}**!\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ›‘ **Target Locked:** {target.mention}\n"
            f" â”£ â±ï¸ **Timer:** *Tik.. Tok.. Tik.. Tok..*\n"
            f" â”— âš ï¸ **Action Required:** `Select a victim below IMMEDIATELY!`\n"
        )
        embed.set_thumbnail(url=target.display_avatar.url)
        embed.set_image(url="https://media.tenor.com/G5m6K_1u_mIAAAAC/bomb-ticking.gif")
        
        try:
            # Alert the new target with a hard ping
            await interaction.edit_original_response(
                content=f"ğŸš¨ **URGENT:** {target.mention} YOU HAVE THE BOMB! THROW IT NOW! ğŸ’£", 
                embed=embed, 
                view=self
            )
        except Exception as e:
            print(f"Bomb Pass Error: {e}")


# ==============================================================================
# ğŸš€ MAIN COMMAND
# ==============================================================================
@bot.tree.command(name="bomb_start", description="ğŸ’£ Deploy a Lethal Bomb in the server ($2,000,000 Fee)")
@check_seized()
async def start_bomb(i: discord.Interaction):
    await i.response.defer() # â³ Instant Defer

    # 1. Permission Check
    if not i.guild.me.guild_permissions.moderate_members:
        return await i.followup.send("âŒ **System Error:** I lack `Timeout` permissions to punish the loser!", ephemeral=True)

    # 2. Economy Check (ğŸ’³ Smart Charge: Wallet + Bank)
    cost = 2000000 # $2 Million
    
    paid = await smart_charge(i.user.id, cost)
    if not paid:
        return await i.followup.send(f"âŒ **Funds Insufficient:** You need `${cost:,}` in your Wallet + Bank to buy the bomb!", ephemeral=True)

    # 3. Game Start Embed
    embed = discord.Embed(title="â˜¢ï¸ ACTIVE PAYLOAD DEPLOYED!", color=0xFF4500) # Red Orange
    embed.description = (
        f"**{i.user.mention}** just purchased a Lethal Payload for **${cost:,}** and pulled the pin!\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f" â”£ ğŸ’€ **Situation:** `CRITICAL`\n"
        f" â”£ â³ **Detonation:** `UNKNOWN (20s - 45s)`\n"
        f" â”— ğŸ”‡ **Penalty:** `5m Timeout (Hospital)`\n\n"
        f"ğŸ‘‡ **{i.user.mention}, select a victim from the dropdown and throw it!**"
    )
    embed.set_thumbnail(url="https://media.tenor.com/2b7lH3y8l08AAAAM/anime-disgust.gif")
    embed.set_image(url="https://media.tenor.com/pyk_eO99u_0AAAAC/bomb-bomb-timer.gif")
    embed.set_footer(text=f"Deployment Authorized by {i.user.display_name}", icon_url=i.user.display_avatar.url)
    
    # 4. Initialize Game
    msg = await i.followup.send(content=f"ğŸš¨ **WARNING:** {i.user.mention} HAS A LIVE BOMB!", embed=embed)
    
    # Attach View safely with the message object
    view = BombPassView(holder=i.user, message=msg, cost=cost)
    await msg.edit(view=view)

# ================== ğŸ° DEVIL SLOTS (HIGH STAKES) ==================
import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# ğŸ° DEVIL SLOTS: ULTRA-PREMIUM HIGH STAKES CASINO
# ==============================================================================

# --- CONFIG ---
SLOT_FEE = 100000       # $100k Entry Cost
JACKPOT_PRIZE = 50000000 # $50 Million
WIN_PRIZE = 200000      # $200k (Profit: $100k)

class DevilSlotsView(discord.ui.View):
    def __init__(self, user: discord.Member):
        super().__init__(timeout=180) # â³ 3 Minutes idle timeout
        self.user = user
        self.message = None

    async def on_timeout(self):
        # âš ï¸ AFK LOGIC: Disable machine if not used
        for child in self.children: child.disabled = True
        timeout_embed = discord.Embed(title="ğŸ”Œ MACHINE POWERED DOWN", description="*The Devil's Slot Machine went idle and turned off.*", color=0x95a5a6)
        if self.message:
            try: await self.message.edit(embed=timeout_embed, view=None)
            except: pass

    async def assign_role(self, interaction: discord.Interaction, role_name: str, color: discord.Color):
        """ ğŸ›¡ï¸ Safely creates and assigns a role to the user """
        try:
            guild = interaction.guild
            role = discord.utils.get(guild.roles, name=role_name)
            if not role:
                role = await guild.create_role(name=role_name, color=color, hoist=True, reason="Devil Slots Reward/Punishment")
            if role not in self.user.roles:
                await self.user.add_roles(role)
            return True
        except Exception as e:
            print(f"Role Error: {e}")
            return False 

    async def check_protection(self, user_id):
        """ ğŸ›¡ï¸ VIP & Life Saver Check (Database Safe) """
        try:
            res = await db_call(lambda: supabase.table("economy").select("vip_expiry, inventory").eq("user_id", str(user_id)).execute())
            if res and res.data:
                data = res.data[0]
                if data.get("vip_expiry"): 
                    return True, "ğŸ›¡ï¸ `GHOST PROTOCOL:` VIP Shield Blocked the Punishment!"
                
                inv = data.get("inventory", {})
                if inv.get("life", 0) > 0:
                    inv["life"] -= 1
                    await db_call(lambda: supabase.table("economy").update({"inventory": inv}).eq("user_id", str(user_id)).execute())
                    return True, f"ğŸ’– `EXTRA LIFE USED:` You survived the Devil's wrath! *(Remaining: {inv['life']})*"
        except: pass
        return False, None

    @discord.ui.button(label="ğŸ° SPIN THE WHEEL ($100k)", style=discord.ButtonStyle.blurple, custom_id="spin_btn")
    async def spin_btn(self, interaction: discord.Interaction, button: discord.ui.Button):
        # ğŸ”’ Security Check
        if interaction.user.id != self.user.id:
            return await interaction.response.send_message("âŒ **Bouncer:** Step back! This is not your machine.", ephemeral=True)

        await interaction.response.defer() # ğŸ› ï¸ FIX: Instant Defer to prevent crash!

        # ğŸ’³ 1. SMART CHARGE (Wallet + Bank)
        paid = await smart_charge(self.user.id, SLOT_FEE)
        if not paid:
            return await interaction.followup.send(f"âŒ You are too broke! You need `${SLOT_FEE:,}` in your Wallet + Bank.", ephemeral=True)

        # ğŸ”„ 2. ANIMATION UI (Rolling Suspense)
        button.disabled = True
        button.label = "ğŸŒ€ ROLLING..."
        button.style = discord.ButtonStyle.secondary
        
        spin_embed = discord.Embed(title="ğŸ° CASINO ROYALE: DEVIL'S SLOTS", color=0x9b59b6) # Purple
        spin_embed.description = (
            f"ğŸ‘¤ **Player:** {self.user.mention}\n"
            f"ğŸ’¸ **Entry Paid:** `-$100,000`\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"# [ ğŸŒ€ | ğŸŒ€ | ğŸŒ€ ]\n\n"
            f"*Pray to the algorithm...*"
        )
        spin_embed.set_thumbnail(url=self.user.display_avatar.url)
        spin_embed.set_image(url="https://media.tenor.com/GoMvLaZs8KkAAAAC/slot-machine-casino.gif")
        
        await interaction.edit_original_response(embed=spin_embed, view=self)
        await asyncio.sleep(4) # â³ 4 Seconds Suspense

        # ğŸ² 3. GOD TIER LOGIC (RNG Calculation)
        roll = random.randint(1, 100000) # 1 to 100,000
        
        is_jackpot = (roll == 1) # 0.001%
        is_win = (roll <= 10000 and not is_jackpot) # 10%
        is_death = (roll > 95000) # 5%
        is_shame = (roll > 90000 and roll <= 95000) # 5%
        
        final_embed = discord.Embed()
        final_embed.set_thumbnail(url=self.user.display_avatar.url)

        # ==========================================
        # ğŸ’ CASE A: THE IMPOSSIBLE JACKPOT (0.001%)
        # ==========================================
        if is_jackpot:
            await smart_reward(self.user.id, JACKPOT_PRIZE)
            await self.assign_role(interaction, "ğŸ‘‘ CASINO GOD", discord.Color.gold())
            
            final_embed.title = "ğŸš¨ MEGA JACKPOT HIT! (0.001%)"
            final_embed.color = 0xFFD700 # Solid Gold
            final_embed.description = (
                f"# [ ğŸ’ | ğŸ’ | ğŸ’ ]\n\n"
                f"### ğŸ¤¯ IMPOSSIBLE LUCK!\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ’° **PAYOUT:** `${JACKPOT_PRIZE:,}`\n"
                f" â”£ ğŸ‘‘ **TITLE WON:** `Casino God`\n"
                f" â”— ğŸ° **ODDS BEATEN:** `1 in 100,000`\n"
            )
            final_embed.set_image(url="https://media.tenor.com/p7a8o1r5c8cAAAAC/money-rain.gif")

        # ==========================================
        # ğŸ’ CASE B: STANDARD WIN (10%)
        # ==========================================
        elif is_win:
            await smart_reward(self.user.id, WIN_PRIZE)
            
            final_embed.title = "ğŸ’ LUCKY STRIKE!"
            final_embed.color = 0x2ecc71 # Emerald Green
            final_embed.description = (
                f"# [ ğŸ’ | ğŸ’ | ğŸ’ ]\n\n"
                f"### âœ… PROFIT SECURED!\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ’° **PAYOUT:** `${WIN_PRIZE:,}`\n"
                f" â”— ğŸ“ˆ **NET PROFIT:** `$100,000`\n"
            )

        # ==========================================
        # ğŸ’€ CASE C: FATAL ERROR (5%)
        # ==========================================
        elif is_death:
            # 1 Hour Timeout
            punish_msg = "Could not mute (Missing Perms)."
            try: punish_msg = await smart_timeout(self.message, self.user, 3600, "Devil Slots Death Roll")
            except: pass
            
            final_embed.title = "ğŸ’€ FATAL ERROR: DEATH ROLL"
            final_embed.color = 0x000000 # Pitch Black
            final_embed.description = (
                f"# [ ğŸ’€ | ğŸ’€ | ğŸ’€ ]\n\n"
                f"### ğŸ”‡ SILENCED BY THE DEVIL!\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ’¸ **LOST:** `$100,000`\n"
                f" â”— ğŸ¥ **PUNISHMENT:** `1 Hour Timeout Applied`\n\n"
                f"> *{punish_msg}*"
            )
            final_embed.set_image(url="https://media.tenor.com/2147kZ75wW8AAAAC/squid-game-card.gif")

        # ==========================================
        # ğŸ’© CASE D: PUBLIC SHAME (5%)
        # ==========================================
        elif is_shame:
            saved, msg = await self.check_protection(self.user.id)
            
            if saved:
                final_embed.title = "ğŸ›¡ï¸ NARROW ESCAPE"
                final_embed.color = 0x3498db # Safe Blue
                final_embed.description = (
                    f"# [ ğŸ’© | ğŸ’© | ğŸ’© ]\n\n"
                    f"### ğŸ›‘ PUNISHMENT BLOCKED!\n"
                    f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                    f" â”£ ğŸ’¸ **LOST:** `$100,000`\n"
                    f" â”— {msg}\n"
                )
            else:
                # ğŸ› ï¸ FIX: Safe Nickname Edit
                nick_msg = "`Nickname changed to Mr. Loser ğŸ’©`"
                try: await self.user.edit(nick="Mr. Loser ğŸ’©")
                except: nick_msg = "`Could not change nickname (Role too high).`"
                
                await self.assign_role(interaction, "ğŸ’© LOSER", discord.Color.dark_orange())
                
                final_embed.title = "ğŸ’© PUBLIC SHAME DEFEAT"
                final_embed.color = 0xE67E22 # Orange/Brown
                final_embed.description = (
                    f"# [ ğŸ’© | ğŸ’© | ğŸ’© ]\n\n"
                    f"### ğŸ¤£ ABSOLUTE HUMILIATION!\n"
                    f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                    f" â”£ ğŸ’¸ **LOST:** `$100,000`\n"
                    f" â”£ ğŸ·ï¸ **ROLE ADDED:** `ğŸ’© LOSER`\n"
                    f" â”— ğŸ¤¡ {nick_msg}\n"
                )

        # ==========================================
        # âŒ CASE E: STANDARD LOSS (80%)
        # ==========================================
        else:
            final_embed.title = "âŒ THE HOUSE ALWAYS WINS"
            final_embed.color = 0xe74c3c # Crimson Red
            final_embed.description = (
                f"# [ âŒ | ğŸ‹ | ğŸ”” ]\n\n"
                f"### ğŸ’¸ WALLET DRAINED\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ“‰ **LOST:** `$100,000`\n"
                f" â”— ğŸ° *Better luck next time, gambler.*\n"
            )

        # ğŸ”„ 4. RESET BUTTON FOR NEXT SPIN
        button.disabled = False
        button.label = "SPIN AGAIN ($100k)"
        button.style = discord.ButtonStyle.primary
        
        await interaction.edit_original_response(embed=final_embed, view=self)


# ==============================================================================
# ğŸš€ MAIN COMMAND
# ==============================================================================
@bot.tree.command(name="devil_slots", description="ğŸ° High Stakes Casino. Secret Odds. ($100k Entry)")
@check_seized()
async def devil_slots(i: discord.Interaction):
    await i.response.defer() # â³ Instant Defer

    # ğŸ’³ Fetch Combined Balance (Wallet + Bank)
    try:
        res = await db_call(lambda: supabase.table("economy").select("balance, bank").eq("user_id", str(i.user.id)).execute())
        bal = int(res.data[0].get('balance', 0)) if res and res.data else 0
        bank = int(res.data[0].get('bank', 0)) if res and res.data else 0
        total_funds = bal + bank
    except:
        total_funds = 0

    embed = discord.Embed(title="ğŸ° THE DEVIL'S MACHINE", color=0x2b2d31)
    embed.description = (
        f"ğŸ‘¤ **Welcome, {i.user.mention}.**\n"
        f"ğŸ’³ **Available Funds:** `${total_funds:,}`\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f" â”£ ğŸŸï¸ **Entry Fee:** `$100,000`\n"
        f" â”— â“ **Win Chance:** `CLASSIFIED`\n\n"
        f"**ğŸ† POSSIBLE OUTCOMES:**\n"
        f"> ğŸ’ **JACKPOT:** `$50,000,000` + `God Role`\n"
        f"> ğŸ’ **LUCKY:** `$200,000` Cash\n"
        f"> ğŸ’€ **DEATH:** `1h Mute` / `Shame` / `Loss`\n\n"
        f"*{i.user.display_name}, do you have the guts to pull the lever?*"
    )
    embed.set_thumbnail(url=i.user.display_avatar.url)
    embed.set_image(url="https://media.tenor.com/7gK2N8o_3F4AAAAC/casino-neon.gif")
    embed.set_footer(text="Titan Casino â€¢ High Rollers Only", icon_url=i.client.user.display_avatar.url)
    
    view = DevilSlotsView(i.user)
    msg = await i.followup.send(embed=embed, view=view)
    view.message = msg # Store message to handle timeouts!     


# ================== ğŸª SQUID GAME: DALGONA COOKIE (ECONOMY + VIP) ==================
import discord
from discord import app_commands
import random
import asyncio
import datetime as dt

dalgona_cooldowns = {}

# ==============================================================================
# ğŸª THE ULTIMATE DALGONA: IMPOSSIBLE EDITION (SMART ECONOMY)
# ==============================================================================

class PremiumDalgonaView(discord.ui.View):
    def __init__(self, user: discord.Member, difficulty: str):
        super().__init__(timeout=90) # â³ 90s Global Timeout
        self.user = user
        self.difficulty = difficulty
        
        self.progress = 0
        self.durability = 100 
        self.game_over = False
        self.is_shaking = False
        self.heated_buff = 0  
        self.start_time = dt.datetime.now()
        self.time_limit = 90 
        self.message = None # To store message for timeout edits
        
        # âš™ï¸ 19 SHAPES CONFIGURATION (WITH TIERS & CUSTOM POP RISKS)
        self.settings = {
            # ğŸŸ¢ STANDARD TIER (No Shake | 10% Fail)
            "TRIANGLE":  {"reward": 10000,  "color": 0x2ECC71, "emoji": "ğŸ”º", "tier": "STANDARD", "pop_risk": 10, "shake": False, "img": "https://media.tenor.com/images/15e61291880564d2627993092787476e/tenor.gif"},
            "CIRCLE":    {"reward": 20000,  "color": 0x3498DB, "emoji": "â­•", "tier": "STANDARD", "pop_risk": 10, "shake": False, "img": "https://media.tenor.com/images/15e61291880564d2627993092787476e/tenor.gif"},
            "SQUARE":    {"reward": 25000,  "color": 0x1ABC9C, "emoji": "ğŸŸ¦", "tier": "STANDARD", "pop_risk": 10, "shake": False, "img": "https://media.tenor.com/images/15e61291880564d2627993092787476e/tenor.gif"},
            "STAR":      {"reward": 30000,  "color": 0xF1C40F, "emoji": "â­", "tier": "STANDARD", "pop_risk": 10, "shake": False, "img": "https://media.tenor.com/images/15e61291880564d2627993092787476e/tenor.gif"},
            
            # ğŸŸ  NIGHTMARE TIER (Shake Active | 30% Fail)
            "UMBRELLA":  {"reward": 40000,  "color": 0xE67E22, "emoji": "â˜‚ï¸", "tier": "NIGHTMARE", "pop_risk": 30, "shake": True, "img": "https://media.tenor.com/Psh5n4-XlYQAAAAC/squid-game-dalgona.gif"},
            "CLOUD":     {"reward": 45000,  "color": 0xBDC3C7, "emoji": "â˜ï¸", "tier": "NIGHTMARE", "pop_risk": 30, "shake": True, "img": "https://media.tenor.com/Psh5n4-XlYQAAAAC/squid-game-dalgona.gif"},
            "HEART":     {"reward": 50000,  "color": 0xFF69B4, "emoji": "â¤ï¸", "tier": "NIGHTMARE", "pop_risk": 30, "shake": True, "img": "https://media.tenor.com/Psh5n4-XlYQAAAAC/squid-game-dalgona.gif"},
            "LIGHTNING": {"reward": 55000,  "color": 0xF39C12, "emoji": "âš¡", "tier": "NIGHTMARE", "pop_risk": 30, "shake": True, "img": "https://media.tenor.com/Psh5n4-XlYQAAAAC/squid-game-dalgona.gif"},
            "SNOWFLAKE": {"reward": 60000,  "color": 0x9B59B6, "emoji": "â„ï¸", "tier": "NIGHTMARE", "pop_risk": 30, "shake": True, "img": "https://media.tenor.com/Psh5n4-XlYQAAAAC/squid-game-dalgona.gif"},
            
            # ğŸ’€ GOD TIER (Shake Active | 40% Fail)
            "CROWN":     {"reward": 65000,  "color": 0xFFD700, "emoji": "ğŸ‘‘", "tier": "GOD", "pop_risk": 40, "shake": True, "img": "https://media.tenor.com/y1_B0m0k_mUAAAAd/revolver-spin.gif"},
            "DRAGON":    {"reward": 70000,  "color": 0xE74C3C, "emoji": "ğŸ‰", "tier": "GOD", "pop_risk": 40, "shake": True, "img": "https://media.tenor.com/y1_B0m0k_mUAAAAd/revolver-spin.gif"},
            "SKULL":     {"reward": 75000,  "color": 0x000000, "emoji": "ğŸ’€", "tier": "GOD", "pop_risk": 40, "shake": True, "img": "https://media.tenor.com/y1_B0m0k_mUAAAAd/revolver-spin.gif"},
            "DEMON":     {"reward": 80000,  "color": 0x8B0000, "emoji": "ğŸ‘¹", "tier": "GOD", "pop_risk": 40, "shake": True, "img": "https://media.tenor.com/y1_B0m0k_mUAAAAd/revolver-spin.gif"},
            "ALIEN":     {"reward": 85000,  "color": 0x2ECC71, "emoji": "ğŸ‘½", "tier": "GOD", "pop_risk": 40, "shake": True, "img": "https://media.tenor.com/y1_B0m0k_mUAAAAd/revolver-spin.gif"},
            
            # ğŸŒŒ IMPOSSIBLE TIER (Shake Active | 99% Fail)
            "BLACKHOLE": {"reward": 1000000, "color": 0x2C3E50, "emoji": "ğŸ•³ï¸", "tier": "IMPOSSIBLE", "pop_risk": 99, "shake": True, "img": "https://media.tenor.com/1-11Yd6_QpYAAAAC/explosion-blast.gif"},
            "UNIVERSE":  {"reward": 1500000, "color": 0x8E44AD, "emoji": "ğŸŒŒ", "tier": "IMPOSSIBLE", "pop_risk": 99, "shake": True, "img": "https://media.tenor.com/1-11Yd6_QpYAAAAC/explosion-blast.gif"},
            "ILLUMINATI":{"reward": 2000000, "color": 0x16A085, "emoji": "ğŸ‘ï¸", "tier": "IMPOSSIBLE", "pop_risk": 99, "shake": True, "img": "https://media.tenor.com/1-11Yd6_QpYAAAAC/explosion-blast.gif"},
            "LABYRINTH": {"reward": 2500000, "color": 0x7F8C8D, "emoji": "ğŸŒ€", "tier": "IMPOSSIBLE", "pop_risk": 99, "shake": True, "img": "https://media.tenor.com/1-11Yd6_QpYAAAAC/explosion-blast.gif"},
            "MUSKAN":    {"reward": 3000000, "color": 0xD35400, "emoji": "ğŸ‘§", "tier": "IMPOSSIBLE", "pop_risk": 99, "shake": True, "img": "https://media.tenor.com/1-11Yd6_QpYAAAAC/explosion-blast.gif"}
        }
        self.config = self.settings[difficulty]
        self.setup_buttons()

    async def on_timeout(self):
        """ âš ï¸ AFK LOGIC: If player goes silent! """
        if not self.game_over:
            self.game_over = True
            for child in self.children: child.disabled = True
            
            try: punish_msg = await smart_timeout(self.message, self.user, 60, f"Dalgona AFK: {self.difficulty}")
            except: punish_msg = "(Missing Perms to Timeout)"
            
            embed = self.get_embed("DIED", "â³ Time expired! You stood still and the guard eliminated you.")
            embed.description += f"\n\nğŸ¥ **STATUS:** `{punish_msg}`"
            
            if self.message:
                try: await self.message.edit(embed=embed, view=None)
                except: pass

    def setup_buttons(self):
        self.clear_items()
        carve_disabled = self.progress >= 95
        
        # ROW 0: Carving
        self.add_item(discord.ui.Button(label="Light", emoji="ğŸª¡", style=discord.ButtonStyle.success, custom_id="CARVE_LIGHT", disabled=carve_disabled, row=0))
        self.add_item(discord.ui.Button(label="Medium", emoji="ğŸª¡", style=discord.ButtonStyle.primary, custom_id="CARVE_MED", disabled=carve_disabled, row=0))
        self.add_item(discord.ui.Button(label="Heavy", emoji="ğŸª¡", style=discord.ButtonStyle.danger, custom_id="CARVE_HEAVY", disabled=carve_disabled, row=0))
        
        # ROW 1: Tactics & REPAIR
        self.add_item(discord.ui.Button(label="Heat (-5s)", emoji="ğŸ”¥", style=discord.ButtonStyle.secondary, custom_id="HEAT", disabled=self.heated_buff > 0 or carve_disabled, row=1))
        self.add_item(discord.ui.Button(label="Breathe", emoji="ğŸ§˜â€â™‚ï¸", style=discord.ButtonStyle.secondary, custom_id="BREATHE", row=1))
        
        # ğŸ› ï¸ REPAIR BUTTON (Costs $10k)
        repair_disabled = carve_disabled or self.durability == 100
        self.add_item(discord.ui.Button(label="Repair ($10k)", emoji="ğŸ› ï¸", style=discord.ButtonStyle.success, custom_id="REPAIR", disabled=repair_disabled, row=1))
        
        # ROW 2: Final POP
        pop_btn = discord.ui.Button(label="POP OUT!", emoji="ğŸ’¥", style=discord.ButtonStyle.danger, custom_id="POP", disabled=not carve_disabled, row=2)
        self.add_item(pop_btn)

        for item in self.children: item.callback = self.handle_action

    def get_progress_bar(self):
        bar_len = 10
        filled = int((self.progress / 100) * bar_len)
        return f"`[{'ğŸŸ§' * filled}{'â¬›' * (bar_len - filled)}]`"

    def get_embed(self, status="PLAYING", reason=None):
        time_elapsed = (dt.datetime.now() - self.start_time).total_seconds()
        time_left = max(0, int(self.time_limit - time_elapsed))
        
        shape_icon = self.config['emoji']
        tier_name = self.config['tier']
        
        if status == "WON":
            title = f"ğŸ† FLAWLESS EXTRACTION: {shape_icon} {self.difficulty}"
            desc = (
                f"# ğŸ‰ SURVIVAL SUCCESS!\n"
                f"You perfectly extracted the shape!\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ’° **Bounty Collected:** `${self.config['reward']:,}`\n"
                f" â”— â±ï¸ **Time Remaining:** `{time_left}s`\n"
            )
            color = 0x2ecc71 # Green
            img = "https://media.tenor.com/bXjOidvDvoQAAAAC/confetti-celebrate.gif"
            
        elif status == "DIED":
            title = f"ğŸ’€ ELIMINATED: {shape_icon} {self.difficulty}"
            desc = (
                f"# ğŸ’¥ CRACK!\n"
                f"**Cause of Death:** {reason}\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”— ğŸ”‡ **Penalty Applied:** `60s Timeout (Hospital)`\n"
            )
            color = 0x8B0000 # Blood Red
            img = "https://media.tenor.com/2147kZ75wW8AAAAC/squid-game-card.gif"
            
        else:
            title = f"ğŸª DALGONA: {shape_icon} {self.difficulty} [{tier_name}]"
            
            status_fx = ""
            if self.is_shaking: status_fx += "\n â”£ ğŸš¨ **HANDS SHAKING:** `Breathe Immediately!`"
            if self.heated_buff > 0: status_fx += f"\n â”£ ğŸ”¥ **Needle Hot:** `Safe Carves x{self.heated_buff}`"
            
            if self.progress >= 95:
                status_fx += "\n â”— âš ï¸ **95% REACHED:** `Use [ğŸ’¥ POP OUT] to extract!`"
            else:
                status_fx += f"\n â”— âš ï¸ **Pop-Out Risk:** `{self.config['pop_risk']}%`"
            
            desc = (
                f"ğŸ‘¤ **Player:** {self.user.mention}\n"
                f"ğŸ’° **Prize:** `${self.config['reward']:,}`  |  â±ï¸ **Time:** `{time_left}s`\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ›¡ï¸ **Cookie Integrity:** `{self.durability}%` *(Repair if low!)*\n"
                f" â”£ ğŸ“Š **Carving Progress:** `{self.progress}%`\n"
                f" â”£ {self.get_progress_bar()}"
                f"{status_fx}\n"
            )
            color = 0xe74c3c if self.is_shaking else self.config["color"]
            img = self.config["img"] 

        embed = discord.Embed(title=title, description=desc, color=color)
        embed.set_thumbnail(url=self.user.display_avatar.url)
        embed.set_image(url=img)
        return embed

    async def handle_action(self, interaction: discord.Interaction):
        if interaction.user.id != self.user.id: 
            return await interaction.response.send_message("âŒ **Guard:** Step back! This is not your cookie.", ephemeral=True)
            
        await interaction.response.defer() # ğŸ› ï¸ Instant Defer
        action = interaction.data["custom_id"]
        
        time_elapsed = (dt.datetime.now() - self.start_time).total_seconds()
        if time_elapsed > self.time_limit:
            return await self.trigger_death(interaction, "â³ Time expired! The guard shot you.")

        # ğŸ› ï¸ REPAIR LOGIC (SMART CHARGE)
        if action == "REPAIR":
            paid = await smart_charge(self.user.id, 10000)
            if not paid:
                return await interaction.followup.send("âŒ **Bank:** You need `$10,000` in your Wallet + Bank to repair!", ephemeral=True)
                
            self.durability = 100 
            self.setup_buttons()
            return await interaction.edit_original_response(embed=self.get_embed("PLAYING"), view=self)

        # ğŸ§˜â€â™‚ï¸ BREATHE LOGIC
        if action == "BREATHE":
            if self.is_shaking:
                self.is_shaking = False
                self.time_limit -= 2 
            else:
                self.time_limit -= 2 
            self.setup_buttons()
            return await interaction.edit_original_response(embed=self.get_embed("PLAYING"), view=self)

        # ğŸ’¥ SHAKING PUNISHMENT
        if self.is_shaking and action.startswith("CARVE"):
            return await self.trigger_death(interaction, "ğŸ˜° Your hands were shaking! The needle slipped and shattered the cookie!")

        # ğŸ”¥ HEAT LOGIC
        if action == "HEAT":
            self.time_limit -= 5 
            self.heated_buff = 3 
            self.setup_buttons()
            return await interaction.edit_original_response(embed=self.get_embed("PLAYING"), view=self)

        # âœ‚ï¸ CARVE LOGIC 
        if action.startswith("CARVE"):
            base_prog, base_break, dmg = 0, 0, 0
            
            if action == "CARVE_LIGHT": 
                base_prog, base_break, dmg = 12, 0, random.randint(1, 3)
            elif action == "CARVE_MED": 
                base_prog, base_break, dmg = 20, 3, random.randint(5, 10)
            elif action == "CARVE_HEAVY": 
                base_prog, base_break, dmg = 35, 10, random.randint(15, 25)
            
            if self.heated_buff > 0:
                base_break = 0
                base_prog = int(base_prog * 1.5) 
                self.heated_buff -= 1
            
            # Apply Durability Damage
            self.durability -= dmg
            if self.durability <= 0:
                return await self.trigger_death(interaction, "ğŸ’¥ The cookie's integrity failed! It crumbled to dust. You should have repaired it!")
                
            if base_break > 0 and random.randint(1, 100) <= base_break:
                return await self.trigger_death(interaction, "ğŸ’¥ You applied too much pressure and cracked the shape!")
                
            self.progress += base_prog
            if self.progress >= 95: 
                self.progress = 95 
                self.is_shaking = False 
            
            # Tier-based Shake Logic
            if self.progress < 95 and self.config["shake"] and random.randint(1, 100) <= 15:
                self.is_shaking = True

            self.setup_buttons()
            return await interaction.edit_original_response(embed=self.get_embed("PLAYING"), view=self)

        # ğŸ’¥ FINAL POP LOGIC (Tier Based Risk)
        if action == "POP":
            pop_risk = self.config["pop_risk"]
            
            for child in self.children: child.disabled = True
            suspense_embed = discord.Embed(title="ğŸ’¥ THE FINAL POP...", description=f"*Applying thumb pressure... (Risk: {pop_risk}% Fail)*", color=0x2b2d31)
            suspense_embed.set_image(url="https://media.tenor.com/y1_B0m0k_mUAAAAd/revolver-spin.gif")
            await interaction.edit_original_response(embed=suspense_embed, view=None)
            
            await asyncio.sleep(3) # â³ Suspense
            
            if random.randint(1, 100) <= pop_risk:
                # Need a dummy interaction logic for timeout message edit
                return await self.trigger_death(interaction, "ğŸ’” The final piece snapped in half! So close!")
            else:
                try: await smart_reward(self.user.id, self.config['reward']) # ğŸ’¸ SMART REWARD
                except: pass
                self.game_over = True
                return await interaction.edit_original_response(embed=self.get_embed("WON"), view=None)

    async def trigger_death(self, interaction: discord.Interaction, reason: str):
        self.game_over = True
        for child in self.children: child.disabled = True
        
        try: punish_msg = await smart_timeout(interaction, self.user, 60, f"Dalgona Failed: {self.difficulty}")
        except: punish_msg = "(Guard failed to mute you. Lucky.)"

        embed = self.get_embed("DIED", reason)
        embed.description += f"\n\nğŸ¥ **STATUS:** `{punish_msg}`"
        
        try: await interaction.edit_original_response(embed=embed, view=None)
        except: pass


# --- ğŸ¢ ULTRA PREMIUM LOBBY (Dropdown Menu) ---
class DalgonaSelect(discord.ui.Select):
    def __init__(self, user: discord.Member):
        self.user = user
        options = [
            discord.SelectOption(label="Triangle", description="Standard | 90% Safe Pop | $10k", emoji="ğŸ”º", value="TRIANGLE"),
            discord.SelectOption(label="Circle", description="Standard | 90% Safe Pop | $25k", emoji="â­•", value="CIRCLE"),
            discord.SelectOption(label="Square", description="Standard | 90% Safe Pop | $30k", emoji="ğŸŸ¦", value="SQUARE"),
            discord.SelectOption(label="Star", description="Standard | 90% Safe Pop | $40k", emoji="â­", value="STAR"),
            
            discord.SelectOption(label="Umbrella", description="Nightmare | 70% Safe Pop | $75k", emoji="â˜‚ï¸", value="UMBRELLA"),
            discord.SelectOption(label="Cloud", description="Nightmare | 70% Safe Pop | $85k", emoji="â˜ï¸", value="CLOUD"),
            discord.SelectOption(label="Heart", description="Nightmare | 70% Safe Pop | $90k", emoji="â¤ï¸", value="HEART"),
            discord.SelectOption(label="Lightning", description="Nightmare | 70% Safe Pop | $100k", emoji="âš¡", value="LIGHTNING"),
            discord.SelectOption(label="Snowflake", description="Nightmare | 70% Safe Pop | $110k", emoji="â„ï¸", value="SNOWFLAKE"),
            
            discord.SelectOption(label="Crown", description="God Tier | 60% Safe Pop | $200k", emoji="ğŸ‘‘", value="CROWN"),
            discord.SelectOption(label="Dragon", description="God Tier | 60% Safe Pop | $250k", emoji="ğŸ‰", value="DRAGON"),
            discord.SelectOption(label="Skull", description="God Tier | 60% Safe Pop | $300k", emoji="ğŸ’€", value="SKULL"),
            discord.SelectOption(label="Demon", description="God Tier | 60% Safe Pop | $350k", emoji="ğŸ‘¹", value="DEMON"),
            discord.SelectOption(label="Alien", description="God Tier | 60% Safe Pop | $400k", emoji="ğŸ‘½", value="ALIEN"),
            
            discord.SelectOption(label="Blackhole", description="IMPOSSIBLE | 1% Safe Pop | $1M", emoji="ğŸ•³ï¸", value="BLACKHOLE"),
            discord.SelectOption(label="Universe", description="IMPOSSIBLE | 1% Safe Pop | $1.5M", emoji="ğŸŒŒ", value="UNIVERSE"),
            discord.SelectOption(label="Illuminati", description="IMPOSSIBLE | 1% Safe Pop | $2M", emoji="ğŸ‘ï¸", value="ILLUMINATI"),
            discord.SelectOption(label="Labyrinth", description="IMPOSSIBLE | 1% Safe Pop | $2.5M", emoji="ğŸŒ€", value="LABYRINTH"),
            discord.SelectOption(label="Muskan", description="IMPOSSIBLE | 1% Safe Pop | $3M", emoji="ğŸ‘§", value="MUSKAN")
        ]
        super().__init__(placeholder="ğŸ”ª Select Your Shape Tier...", min_values=1, max_values=1, options=options)

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.user.id:
            return await interaction.response.send_message("âŒ **Guard:** This is not your game!", ephemeral=True)
            
        shape = self.values[0]
        await interaction.response.defer()
        
        # Pass the message to the view to handle edits perfectly
        view = PremiumDalgonaView(self.user, shape)
        msg = await interaction.edit_original_response(embed=view.get_embed(), view=view)
        view.message = msg

class DalgonaLobbyView(discord.ui.View):
    def __init__(self, user: discord.Member):
        super().__init__(timeout=60)
        self.user = user
        self.add_item(DalgonaSelect(user))


# --- ğŸ’» MAIN COMMAND ---
@bot.tree.command(name="dalgona", description="ğŸª Play the Ultimate Dalgona Challenge (Wallet & Bank Supported)")
@check_seized()
async def dalgona(i: discord.Interaction):
    
    # â³ COOLDOWN LOGIC (30 Seconds)
    now = dt.datetime.now()
    if i.user.id in dalgona_cooldowns:
        time_passed = (now - dalgona_cooldowns[i.user.id]).total_seconds()
        if time_passed < 30: 
            wait_time = int(30 - time_passed)
            return await i.response.send_message(f"â³ **Cooldown:** Bhai thoda sabar karo! Agli cookie **{wait_time}s** baad milegi.", ephemeral=True)
            
    dalgona_cooldowns[i.user.id] = now

    if not i.guild.me.guild_permissions.moderate_members:
        return await i.response.send_message("âŒ **System Error:** I need `Timeout` permissions to punish losers!", ephemeral=True)
        
    embed = discord.Embed(title="ğŸª SQUID GAME: THE ULTIMATE DALGONA", color=0x2b2d31)
    embed.set_author(name=f"Contestant: {i.user.display_name}", icon_url=i.user.display_avatar.url)
    embed.set_thumbnail(url="https://media.tenor.com/Psh5n4-XlYQAAAAC/squid-game-dalgona.gif")
    
    embed.description = (
        "# ğŸ”ª CHOOSE YOUR FATE\n"
        "**New Rules:** Carving is easier, but breaking lowers Durability. **Repair your cookie for $10k** before it shatters! Watch out for the final POP risk!\n\n"
        "### ğŸŸ¢ STANDARD `(90% Safe Pop, No Shake)`\n"
        "ğŸ”º Triangle | â­• Circle | ğŸŸ¦ Square | â­ Star\n\n"
        "### ğŸŸ  NIGHTMARE `(70% Safe Pop, Hand Shakes)`\n"
        "â˜‚ï¸ Umbrella | â˜ï¸ Cloud | â¤ï¸ Heart | âš¡ Lightning | â„ï¸ Snowflake\n\n"
        "### ğŸ’€ GOD TIER `(60% Safe Pop)`\n"
        "ğŸ‘‘ Crown | ğŸ‰ Dragon | ğŸ’€ Skull | ğŸ‘¹ Demon | ğŸ‘½ Alien\n\n"
        "### ğŸŒŒ IMPOSSIBLE TIER `(1% Safe Pop - 99% Death)`\n"
        "ğŸ•³ï¸ Blackhole | ğŸŒŒ Universe | ğŸ‘ï¸ Illuminati | ğŸŒ€ Labyrinth | ğŸ‘§ Muskan\n\n"
        "âš ï¸ **WARNING:** Failing results in a **1 MINUTE MUTE!**"
    )
    embed.set_footer(text="Titan Premium Games", icon_url=i.client.user.display_avatar.url)
    
    view = DalgonaLobbyView(i.user)
    await i.response.send_message(embed=embed, view=view)
                          
        
# ================== ğŸ”® SQUID GAME: MARBLES (ECONOMY + VIP) ==================
import discord
from discord import app_commands
import random
import asyncio
import datetime as dt

# ==============================================================================
# ğŸ”® SQUID GAME MARBLES (ULTRA-PREMIUM + SMART BANKING)
# ==============================================================================

# --- 1. HIDDEN INPUT MODAL ---
class MarblesHideModal(discord.ui.Modal, title="ğŸ”® SQUID GAME: HIDE YOUR MARBLES"):
    number = discord.ui.TextInput(
        label="Kitne Kanche Chhupane Hain? (1-10)",
        placeholder="Enter a number (e.g. 3)",
        min_length=1,
        max_length=2,
        required=True,
        style=discord.TextStyle.short
    )

    def __init__(self, view_obj, max_bet):
        super().__init__()
        self.view_obj = view_obj
        self.max_bet = max_bet

    async def on_submit(self, interaction: discord.Interaction):
        try:
            val = int(self.number.value)
            if val < 1 or val > 10:
                return await interaction.response.send_message("âŒ **Guard:** Cheat mat karo! Sirf 1 se 10 ke beech ka number dalo.", ephemeral=True)
            if val > self.max_bet:
                return await interaction.response.send_message(f"âŒ **Guard:** Tumhare paas utne kanche nahi hain! Max limit: `{self.max_bet}`", ephemeral=True)
            
            # Update State
            self.view_obj.hidden_number = val
            self.view_obj.state = "GUESSING"
            
            # ğŸ› ï¸ FIX: Clean Modal Response Update
            status_msg = f"ğŸ‘€ **{self.view_obj.turn_guesser.mention}**, it's your turn! Guess if the hidden marbles are **ODD** or **EVEN**!"
            await self.view_obj.update_board(interaction, status_msg)
            
        except ValueError:
            await interaction.response.send_message("âŒ **Guard:** Sirf numbers (1, 2, 3...) allow hain!", ephemeral=True)


# --- 2. MAIN GAME VIEW ---
class MarblesGameView(discord.ui.View):
    def __init__(self, p1: discord.Member, p2: discord.Member, bet: int, message: discord.Message):
        super().__init__(timeout=120) # â³ 2 Min AFK Timer
        self.p1 = p1
        self.p2 = p2
        self.bet = bet
        self.message = message
        
        self.marbles = {p1.id: 10, p2.id: 10}
        self.turn_hider = p1 
        self.turn_guesser = p2
        self.hidden_number = None
        self.state = "HIDING" 
        self.setup_buttons()

    async def on_timeout(self):
        """ âš ï¸ AFK LOGIC: If a player stops responding """
        for child in self.children: child.disabled = True
        
        # Decide who gets punished (The person whose turn it was)
        loser = self.turn_hider if self.state == "HIDING" else self.turn_guesser
        winner = self.p1 if loser.id == self.p2.id else self.p2
        
        await smart_reward(winner.id, self.bet * 2) # Winner takes pot
        
        try: await loser.timeout(dt.timedelta(minutes=10), reason="AFK during Marbles Game")
        except: pass

        embed = discord.Embed(title="â³ MATCH ABANDONED (AFK)", color=0x8B0000)
        embed.description = (
            f"### ğŸ”« EXECUTION!\n"
            f"**{loser.mention}** took too long and was eliminated by the Guards.\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ† **WINNER:** {winner.mention} *( Takes `${(self.bet * 2):,}` )*\n"
            f" â”— ğŸ¥ **PENALTY:** `10m Timeout applied to AFK player.`\n"
        )
        embed.set_image(url="https://media.tenor.com/2147kZ75wW8AAAAC/squid-game-card.gif")
        
        if self.message:
            try: await self.message.edit(embed=embed, view=None)
            except: pass

    def setup_buttons(self):
        self.clear_items()
        
        if self.state == "HIDING":
            btn = discord.ui.Button(label="ğŸ–ï¸ HIDE MARBLES", style=discord.ButtonStyle.primary, custom_id="hide_btn")
            btn.callback = self.hide_callback
            self.add_item(btn)
        else:
            btn_odd = discord.ui.Button(label="ODD (1, 3, 5...)", style=discord.ButtonStyle.secondary, custom_id="odd")
            btn_even = discord.ui.Button(label="EVEN (2, 4, 6...)", style=discord.ButtonStyle.secondary, custom_id="even")
            btn_odd.callback = self.guess_callback
            btn_even.callback = self.guess_callback
            self.add_item(btn_odd)
            self.add_item(btn_even)

    async def update_board(self, interaction: discord.Interaction, status_msg: str):
        self.setup_buttons()
        
        # Emoji Visuals
        p1_m = "ğŸ”®" * self.marbles[self.p1.id]
        p2_m = "ğŸ”®" * self.marbles[self.p2.id]
        
        embed = discord.Embed(title="ğŸ”® SQUID GAME: MARBLES", color=0xE91E63)
        embed.description = (
            f"**ğŸ’° PRIZE POOL:** `${(self.bet * 2):,}`\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ‘¤ **{self.p1.mention}:** `{self.marbles[self.p1.id]}` Marbles\n"
            f" â”£ {p1_m}\n"
            f" â”ƒ\n"
            f" â”£ ğŸ‘¤ **{self.p2.mention}:** `{self.marbles[self.p2.id]}` Marbles\n"
            f" â”£ {p2_m}\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"> {status_msg}"
        )
        
        if self.state == "HIDING":
            embed.set_footer(text=f"Phase: Hiding | Waiting for {self.turn_hider.display_name}...", icon_url=self.turn_hider.display_avatar.url)
        else:
            embed.set_footer(text=f"Phase: Guessing | Waiting for {self.turn_guesser.display_name}...", icon_url=self.turn_guesser.display_avatar.url)
            
        embed.set_image(url="https://media.tenor.com/yA0wXCoqQJAAAAAC/squid-game-marbles.gif")
        
        # ğŸ› ï¸ FIX: Safe Editing Logic
        try:
            if not interaction.response.is_done():
                await interaction.response.edit_message(embed=embed, view=self)
            else:
                await interaction.edit_original_response(embed=embed, view=self)
        except Exception as e:
            print(f"Marbles Edit Error: {e}")

    # --- CALLBACKS ---
    async def hide_callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.turn_hider.id:
            return await interaction.response.send_message("âŒ **Guard:** Abhi tumhari baari nahi hai!", ephemeral=True)
        
        modal = MarblesHideModal(self, self.marbles[self.turn_hider.id])
        await interaction.response.send_modal(modal)

    async def guess_callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.turn_guesser.id:
            return await interaction.response.send_message("âŒ **Guard:** Tumhe guess nahi karna hai!", ephemeral=True)
        
        guess = interaction.data["custom_id"].upper()
        actual_is_odd = (self.hidden_number % 2 != 0)
        
        win = False
        if (guess == "ODD" and actual_is_odd) or (guess == "EVEN" and not actual_is_odd):
            win = True
            
        amount = self.hidden_number
        msg = ""
        
        if win:
            self.marbles[self.turn_guesser.id] += amount
            self.marbles[self.turn_hider.id] -= amount
            msg = f"ğŸ‰ **CORRECT GUESS!** (Hidden: `{self.hidden_number}`)\n**{self.turn_guesser.mention}** won `{amount}` marbles!"
        else:
            if self.marbles[self.turn_guesser.id] < amount:
                amount = self.marbles[self.turn_guesser.id]
            self.marbles[self.turn_guesser.id] -= amount
            self.marbles[self.turn_hider.id] += amount
            msg = f"âŒ **WRONG GUESS!** (Hidden: `{self.hidden_number}`)\n**{self.turn_guesser.mention}** lost `{amount}` marbles!"

        # CHECK GAME OVER
        if self.marbles[self.p1.id] <= 0:
            await self.end_game(interaction, winner=self.p2, loser=self.p1)
        elif self.marbles[self.p2.id] <= 0:
            await self.end_game(interaction, winner=self.p1, loser=self.p2)
        else:
            self.turn_hider, self.turn_guesser = self.turn_guesser, self.turn_hider
            self.state = "HIDING"
            self.hidden_number = None
            await self.update_board(interaction, f"{msg}\n\nğŸ”„ **ROLES SWAPPED!** Now **{self.turn_hider.mention}** will hide the marbles.")

    async def end_game(self, interaction: discord.Interaction, winner: discord.Member, loser: discord.Member):
        self.stop()
        for child in self.children: child.disabled = True
        
        # --- ğŸ’¸ ECONOMY & PUNISHMENT ---
        prize = self.bet * 2
        await smart_reward(winner.id, prize)
        
        punish_msg = "Could not mute (Missing Perms)."
        try: punish_msg = await smart_timeout(interaction, loser, 600, "Lost Squid Game Marbles")
        except: pass
        
        embed = discord.Embed(title="ğŸ’€ GAME OVER", color=0x000000)
        embed.description = (
            f"### ğŸ”« EXECUTION!\n"
            f"**{loser.display_name}** lost all their marbles...\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ† **WINNER:** {winner.mention}\n"
            f" â”£ ğŸ’° **Reward:** `${prize:,}`\n"
            f" â”— ğŸ¥ **PENALTY:** `{punish_msg}`\n"
        )
        embed.set_thumbnail(url=winner.display_avatar.url)
        embed.set_image(url="https://media.tenor.com/2147kZ75wW8AAAAC/squid-game-card.gif")
        
        try:
            if not interaction.response.is_done():
                await interaction.response.edit_message(embed=embed, view=None)
            else:
                await interaction.edit_original_response(embed=embed, view=None)
        except: pass


# --- ğŸ“œ CHALLENGE VIEW ---
class MarblesInviteView(discord.ui.View):
    def __init__(self, challenger: discord.Member, opponent: discord.Member, bet: int):
        super().__init__(timeout=60)
        self.challenger = challenger
        self.opponent = opponent
        self.bet = bet
        self.message = None

    @discord.ui.button(label="ACCEPT GAME", style=discord.ButtonStyle.success, emoji="âœ…")
    async def accept(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.opponent.id:
            return await interaction.response.send_message("âŒ **Guard:** This invitation is not for you.", ephemeral=True)
        
        await interaction.response.defer()
        
        # ğŸ’³ SMART CHARGE CHECK (Opponent)
        opp_paid = await smart_charge(self.opponent.id, self.bet)
        if not opp_paid:
            return await interaction.followup.send(f"âŒ You are too broke! You need `${self.bet:,}` in your Wallet + Bank.", ephemeral=True)
            
        # ğŸ’³ SMART CHARGE CHECK (Challenger - Double check)
        challenger_paid = await smart_charge(self.challenger.id, self.bet)
        if not challenger_paid:
            await smart_reward(self.opponent.id, self.bet) # Refund opponent
            return await interaction.followup.send(f"âŒ The Challenger ({self.challenger.mention}) is broke now! Game cancelled.", ephemeral=True)

        self.stop()
        
        # Initialize Game Board
        game_view = MarblesGameView(self.challenger, self.opponent, self.bet, self.message)
        
        p1_m = "ğŸ”®" * 10
        p2_m = "ğŸ”®" * 10
        start_embed = discord.Embed(title="ğŸ”® SQUID GAME: MARBLES", color=0xE91E63)
        start_embed.description = (
            f"**ğŸ’° PRIZE POOL:** `${(self.bet * 2):,}`\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ‘¤ **{self.challenger.mention}:** `10` Marbles\n"
            f" â”£ {p1_m}\n"
            f" â”ƒ\n"
            f" â”£ ğŸ‘¤ **{self.opponent.mention}:** `10` Marbles\n"
            f" â”£ {p2_m}\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"> ğŸ² **GAME START!** {self.challenger.mention} is hiding marbles first."
        )
        start_embed.set_footer(text=f"Phase: Hiding | Waiting for {self.challenger.display_name}...", icon_url=self.challenger.display_avatar.url)
        start_embed.set_image(url="https://media.tenor.com/yA0wXCoqQJAAAAAC/squid-game-marbles.gif")
        
        await interaction.edit_original_response(content=None, embed=start_embed, view=game_view)

    @discord.ui.button(label="REJECT", style=discord.ButtonStyle.danger, emoji="ğŸ›‘")
    async def reject(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.opponent.id:
            return await interaction.response.send_message("âŒ **Guard:** Stay out of this.", ephemeral=True)
            
        await interaction.response.defer()
        self.stop()
        embed = discord.Embed(title="ğŸƒ CHALLENGE REJECTED", description=f"*{self.opponent.mention} refused to play the game.*", color=0x95a5a6)
        await interaction.edit_original_response(content=None, embed=embed, view=None)

    async def on_timeout(self):
        for child in self.children: child.disabled = True
        if self.message:
            try: await self.message.edit(content="â³ *Invitation expired.*", view=None)
            except: pass


# --- ğŸ’» COMMAND ---
@bot.tree.command(name="marbles", description="ğŸ”® Squid Game Marbles (Betray your friends)")
@app_commands.describe(opponent="Who do you want to play with?", bet="Entry Fee amount (Min: 10,000)")
@check_seized()
async def marbles(i: discord.Interaction, opponent: discord.Member, bet: int = 25000):
    await i.response.defer()

    if opponent.id == i.user.id or opponent.bot:
        return await i.followup.send("âŒ **Guard:** You cannot play with yourself or a bot.", ephemeral=True)
    
    if bet < 10000:
        return await i.followup.send("âŒ **Guard:** Minimum entry fee is `$10,000`.", ephemeral=True)

    if not i.guild.me.guild_permissions.moderate_members:
        return await i.followup.send("âŒ **System Error:** Bot lacks `Timeout` permissions!", ephemeral=True)

    # Pre-check Challenger's Balance
    res = await db_call(lambda: supabase.table("economy").select("balance, bank").eq("user_id", str(i.user.id)).execute())
    if not res or not res.data:
        return await i.followup.send("âŒ You don't have an economy account!", ephemeral=True)
        
    host_total = int(res.data[0].get("balance", 0)) + int(res.data[0].get("bank", 0))
    if host_total < bet: 
        return await i.followup.send(f"âŒ You are broke! You need `${bet:,}` in your Wallet + Bank.", ephemeral=True)

    embed = discord.Embed(title="ğŸ”® MARBLES CHALLENGE", color=0xE91E63)
    embed.set_author(name=f"Challenger: {i.user.display_name}", icon_url=i.user.display_avatar.url)
    embed.description = (
        f"# ğŸ­ {i.user.mention} ğŸ†š {opponent.mention}\n"
        f"**Both players start with 10 Marbles.**\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f" â”£ ğŸ’¸ **Entry Fee:** `${bet:,}` *(Per Player)*\n"
        f" â”£ ğŸ’° **Winner Takes:** `${(bet * 2):,}`\n"
        f" â”— ğŸ”‡ **Loser Penalty:** `10m Timeout (Hospital)`\n\n"
        f"ğŸ‘‡ **{opponent.mention}, do you accept the game?**"
    )
    embed.set_thumbnail(url="https://media.tenor.com/yA0wXCoqQJAAAAAC/squid-game-marbles.gif")
    
    view = MarblesInviteView(i.user, opponent, bet)
    msg = await i.followup.send(content=opponent.mention, embed=embed, view=view)
    view.message = msg # Save for edits!



# ================== ğŸ² SATTA SYSTEM (FAIR & EVIL MODES) =================
import discord
from discord import app_commands
import random
import asyncio
import datetime as dt

# ==============================================================================
# ğŸ² SATTA BAZAAR (ULTRA-PREMIUM GAMBLING TERMINAL)
# ==============================================================================

class EvilSattaView(discord.ui.View):
    def __init__(self, user: discord.Member, bet_amount: int, message: discord.Message = None):
        super().__init__(timeout=60)
        self.user = user
        self.bet = bet_amount
        self.message = message

    async def on_timeout(self):
        # âš ï¸ AFK LOGIC: If player gets scared and doesn't click
        for child in self.children: child.disabled = True
        embed = discord.Embed(title="â³ SATTA EXPIRED", description="*The dealer left. Your bet was refunded.*", color=0x95a5a6)
        if self.message:
            try: await self.message.edit(embed=embed, view=None)
            except: pass

    async def run_satta(self, interaction: discord.Interaction, multiplier: int, win_chance: float, risk_type: str):
        if interaction.user.id != self.user.id: 
            return await interaction.response.send_message("âŒ **Bouncer:** Apna paisa lagao!", ephemeral=True)
        
        await interaction.response.defer() # ğŸ› ï¸ INSTANT DEFER
        self.stop() # Stop the timeout timer
        
        # ğŸ’³ 1. SMART CHARGE CHECK (Wallet + Bank)
        paid = await smart_charge(self.user.id, self.bet)
        if not paid:
            return await interaction.followup.send(f"âŒ You are too broke! You need `${self.bet:,}` in your Wallet + Bank.", ephemeral=True)

        # ğŸ° 2. START SPINNING UI
        embed_color = 0x2ecc71 if win_chance >= 20 else 0xF1C40F # Green or Yellow
        if win_chance < 1: embed_color = 0x000000 # Pitch Black for Evil modes

        spin_embed = discord.Embed(title="ğŸ² ROLLING THE DICE...", color=embed_color)
        spin_embed.description = (
            f"ğŸ’° **Bet Amount:** `${self.bet:,}`\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸš€ **Target Payout:** `{multiplier}x`\n"
            f" â”£ ğŸ€ **Win Chance:** `{win_chance}%`\n"
            f" â”— âš ï¸ **Risk Level:** `{risk_type}`\n\n"
            f"*Pray to the algorithm...*"
        )
        spin_embed.set_image(url="https://media.tenor.com/GoMvLaZs8KkAAAAC/slot-machine-casino.gif")
        
        for child in self.children: child.disabled = True
        
        try: await interaction.edit_original_response(embed=spin_embed, view=self)
        except: pass
        
        await asyncio.sleep(4) # â³ Suspense Wait

        try:
            # ğŸ² 3. DICE ROLL LOGIC
            roll = random.uniform(0, 100)
            is_win = roll <= win_chance 
            
            final_embed = discord.Embed()
            final_embed.set_thumbnail(url=self.user.display_avatar.url)

            if is_win:
                # ==========================================
                # ğŸ‰ WIN SCENARIO
                # ==========================================
                winnings = int(self.bet * multiplier)
                
                # Reward (Original Bet + Winnings)
                await smart_reward(self.user.id, self.bet + winnings)

                final_embed.title = f"ğŸ‰ JACKPOT HIT! ({multiplier}x)"
                final_embed.color = 0xFFD700 # Gold
                final_embed.description = (
                    f"### ğŸ¯ THE HOUSE LOST!\n"
                    f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                    f" â”£ ğŸ² **Your Roll:** `{roll:.2f}` *(Needed < {win_chance})*\n"
                    f" â”£ ğŸ’¸ **Original Bet:** `${self.bet:,}`\n"
                    f" â”— ğŸ’° **PURE PROFIT:** `${winnings:,}`\n"
                )
                if win_chance < 1:
                    final_embed.set_image(url="https://media.tenor.com/p7a8o1r5c8cAAAAC/money-rain.gif")
                else:
                    final_embed.set_image(url="https://media.tenor.com/bXjOidvDvoQAAAAC/confetti-celebrate.gif")

            else:
                # ==========================================
                # âŒ LOSE SCENARIO
                # ==========================================
                desc = ""
                punish_msg = ""
                
                if risk_type == "NORMAL":
                    # Money was already deducted by smart_charge
                    desc = f" â”— ğŸ’¸ **Lost Amount:** `-${self.bet:,}`"

                elif risk_type == "WIPE":
                    # Empty the entire bank and wallet!
                    await db_call(lambda: supabase.table("economy").update({"balance": 0, "bank": 0}).eq("user_id", str(self.user.id)).execute())
                    desc = f" â”£ ğŸ’¸ **LOST:** `EVERYTHING!`\n â”— ğŸ’€ **Total Net Worth:** `$0`"

                elif risk_type == "DEATH":
                    # Empty everything + Mute
                    await db_call(lambda: supabase.table("economy").update({"balance": 0, "bank": 0}).eq("user_id", str(self.user.id)).execute())
                    try:
                        await self.user.timeout(dt.timedelta(minutes=60), reason="Satta Suicide Death Roll")
                        punish_msg = "\n â”— ğŸ¤ **Punishment:** `1 Hour Mute Applied`"
                    except: 
                        punish_msg = "\n â”— ğŸ¤¡ **Punishment:** *(Failed to mute - lucky bastard)*"
                    
                    desc = f" â”£ ğŸ’¸ **LOST:** `EVERYTHING!`\n â”£ ğŸ’€ **Total Net Worth:** `$0`{punish_msg}"

                final_embed.title = "âŒ THE HOUSE ALWAYS WINS"
                final_embed.color = 0xFF0000 # Red
                final_embed.description = (
                    f"ğŸ² **Your Roll:** `{roll:.2f}` *(Needed < {win_chance})*\n"
                    f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n{desc}"
                )
                final_embed.set_image(url="https://media.tenor.com/d6-SreC3_p8AAAAC/wasted-gta5.gif")

            # 4. FINAL UI UPDATE
            await interaction.edit_original_response(embed=final_embed, view=None)

        except Exception as e:
            print(f"Error in Satta: {e}")
            await interaction.followup.send(f"âš ï¸ **Result:** Game ended, but UI failed to update. Check balance.", ephemeral=True)


    # --- ğŸŸ¢ ROW 1: FAIR PLAY ---
    @discord.ui.button(label="SAFE (2x)", style=discord.ButtonStyle.success, row=0)
    async def bet_2x(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.run_satta(interaction, multiplier=2, win_chance=20.0, risk_type="NORMAL")

    @discord.ui.button(label="RISKY (3x)", style=discord.ButtonStyle.primary, row=0)
    async def bet_3x(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.run_satta(interaction, multiplier=3, win_chance=10.0, risk_type="NORMAL")

    @discord.ui.button(label="CRAZY (5x)", style=discord.ButtonStyle.secondary, row=0)
    async def bet_5x(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.run_satta(interaction, multiplier=5, win_chance=5.0, risk_type="NORMAL")


    # --- ğŸ”´ ROW 2: EVIL MODE ---
    @discord.ui.button(label="GREEDY (10x)", style=discord.ButtonStyle.secondary, row=1)
    async def bet_10x(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.run_satta(interaction, multiplier=10, win_chance=0.1, risk_type="NORMAL")

    @discord.ui.button(label="WIPE (50x)", style=discord.ButtonStyle.danger, row=1)
    async def bet_50x(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.run_satta(interaction, multiplier=50, win_chance=0.1, risk_type="WIPE")

    @discord.ui.button(label="SUICIDE (100x)", style=discord.ButtonStyle.danger, row=1)
    async def bet_100x(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.run_satta(interaction, multiplier=100, win_chance=0.1, risk_type="DEATH")


# ==============================================================================
# ğŸš€ MAIN COMMAND
# ==============================================================================
@bot.tree.command(name="satta", description="ğŸ² Ultimate Gambling: From Safe (2x) to Suicide (100x)")
@app_commands.describe(amount="How much are you betting?")
@check_seized()
async def satta(i: discord.Interaction, amount: int):
    await i.response.defer() # â³ Instant Defer

    if amount <= 0:
        return await i.followup.send("âŒ **Error:** Amount must be greater than zero!", ephemeral=True)
    
    # ğŸ’³ Pre-Check Net Worth (Wallet + Bank)
    try:
        res = await db_call(lambda: supabase.table("economy").select("balance, bank").eq("user_id", str(i.user.id)).execute())
        bal = int(res.data[0].get('balance', 0)) if res and res.data else 0
        bank = int(res.data[0].get('bank', 0)) if res and res.data else 0
        total_funds = bal + bank
    except:
        total_funds = 0
        
    if total_funds < amount:
        return await i.followup.send(f"âŒ **Broke!** You only have `${total_funds:,}` in your Wallet + Bank combined.", ephemeral=True)

    embed = discord.Embed(title="ğŸ² SATTA BAZAAR", color=0x2b2d31)
    embed.description = (
        f"ğŸ’° **Bet Amount:** `${amount:,}`\n"
        f"ğŸ’³ **Available Funds:** `${total_funds:,}`\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"ğŸŸ¢ **SAFE (2x):** `20% Win Chance`\n"
        f"ğŸ”µ **RISKY (3x):** `10% Win Chance`\n"
        f"âšª **CRAZY (5x):** `5% Win Chance`\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"ğŸŒ‘ **GREEDY (10x):** `0.1% Chance`\n"
        f"ğŸ”´ **WIPE (50x):** `0.1% Chance | Loss = 0 Balance & Bank`\n"
        f"ğŸ’€ **SUICIDE (100x):** `0.1% Chance | Loss = 0 Bal/Bank + Mute`\n\n"
        f"ğŸ‘‡ **CHOOSE YOUR FATE:**"
    )
    embed.set_thumbnail(url=i.user.display_avatar.url)
    embed.set_footer(text="Titan Casino â€¢ Play at your own risk", icon_url=i.client.user.display_avatar.url)
    
    view = EvilSattaView(i.user, amount)
    msg = await i.followup.send(embed=embed, view=view)
    view.message = msg # Save for timeout editing!

            

# ================== ğŸ¦‘ SQUID GAME: GLASS BRIDGE (ECONOMY + VIP) ==================
import discord
from discord import app_commands
import random
import asyncio
import datetime as dt

# ==============================================================================
# ğŸ¦‘ GLASS BRIDGE: NIGHTMARE EDITION (SMART BANKING & STABLE TIMERS)
# ==============================================================================

class GlassBridgeGame(discord.ui.View):
    def __init__(self, players: list, message: discord.Message, entry_fee: int):
        super().__init__(timeout=None) # â±ï¸ Background timer will handle this
        self.message = message
        self.entry_fee = entry_fee
        self.bridge_len = 7 # 7 Steps to survive
        
        # ğŸŸ¢ Left/Right safe path generation
        self.path = [random.choice(["LEFT", "RIGHT"]) for _ in range(self.bridge_len)]
        self.revealed = [False] * self.bridge_len 
        
        random.shuffle(players) # Randomize player order
        self.players = players 
        self.dead_players = []
        
        self.current_player_idx = 0 
        self.current_step = 0 
        
        self.game_active = True
        self.start_time = dt.datetime.now()
        self.time_limit = 120 # â³ 2 Minutes total global time
        
        # Start Global Timer
        self.timer_task = asyncio.create_task(self.start_timer())
        self.setup_buttons()

    def setup_buttons(self):
        self.clear_items()
        self.add_item(discord.ui.Button(label="JUMP LEFT", style=discord.ButtonStyle.primary, emoji="â¬…ï¸", custom_id="LEFT"))
        self.add_item(discord.ui.Button(label="JUMP RIGHT", style=discord.ButtonStyle.primary, emoji="â¡ï¸", custom_id="RIGHT"))
        
        # Push button (Only active if someone is behind)
        push_disabled = (self.current_player_idx + 1) >= len(self.players)
        push_btn = discord.ui.Button(label="PUSH FRONT PLAYER", style=discord.ButtonStyle.danger, emoji="âœ‹", custom_id="PUSH", row=1, disabled=push_disabled)
        self.add_item(push_btn)
        
        for item in self.children: item.callback = self.handle_action

    async def start_timer(self):
        """ â° 100% Stable Background Timer """
        await asyncio.sleep(self.time_limit)
        
        if self.game_active:
            self.game_active = False
            self.stop()
            
            for child in self.children: child.disabled = True
            
            # Kill Everyone Remaining
            survivors = self.players[self.current_player_idx:]
            status_report = []
            
            for p in survivors:
                try: punish_msg = await smart_timeout(self.message, p, 300, "Glass Bridge Timer Expired")
                except: punish_msg = "(Mute failed)"
                status_report.append(f" â”£ ğŸ’€ {p.mention} â” `{punish_msg}`")
                
            if status_report:
                status_report[-1] = status_report[-1].replace(" â”£ ", " â”— ")

            embed = discord.Embed(title="â° TIME EXPIRED! GLASS SHATTERED!", color=0x8B0000)
            embed.description = (
                f"### ğŸ’¥ THE ENTIRE BRIDGE COLLAPSED!\n"
                f"You took too long. The Front Man pressed the detonator.\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f"**CASUALTY REPORT:**\n" + "\n".join(status_report)
            )
            embed.set_image(url="https://media.tenor.com/1-11Yd6_QpYAAAAC/explosion-blast.gif")
            
            try: await self.message.edit(embed=embed, view=None)
            except: pass

    def generate_board(self):
        """ ğŸ¨ Premium Holographic Board Visuals """
        board_str = ""
        for i in range(self.bridge_len - 1, -1, -1):
            step_marker = f"`Step {i+1}`"
            
            if i == self.current_step and self.current_player_idx < len(self.players):
                # Current Step (Unknown)
                left_icon = "â“" if not self.revealed[i] else ("ğŸŸ©" if self.path[i] == "LEFT" else "ğŸŸ¥")
                right_icon = "â“" if not self.revealed[i] else ("ğŸŸ©" if self.path[i] == "RIGHT" else "ğŸŸ¥")
                pointer = " ğŸ‘ˆ **JUMP HERE!**"
            elif i < self.current_step:
                # Past Steps (Revealed & Safe)
                left_icon = "ğŸŸ©" if self.path[i] == "LEFT" else "â¬›"
                right_icon = "ğŸŸ©" if self.path[i] == "RIGHT" else "â¬›"
                pointer = ""
            else:
                # Future Steps (Fog)
                left_icon = "ğŸŒ«ï¸"; right_icon = "ğŸŒ«ï¸"
                pointer = ""

            board_str += f"[ {left_icon} ]  [ {right_icon} ]  {step_marker}{pointer}\n"
        return board_str

    async def get_embed(self, status_msg=""):
        if not self.game_active: return None
        
        active_p = self.players[self.current_player_idx]
        next_p = self.players[self.current_player_idx + 1] if self.current_player_idx + 1 < len(self.players) else None
        
        time_elapsed = (dt.datetime.now() - self.start_time).total_seconds()
        time_left = max(0, int(self.time_limit - time_elapsed))
        
        desc = (
            f"**ğŸ’¸ Total Prize Pool:** `${(len(self.players) * self.entry_fee * 2):,}`\n"
            f"**â±ï¸ Time Remaining:** `{time_left} Seconds`\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"{self.generate_board()}\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸƒ **CURRENT TURN:** {active_p.mention}\n"
            f" â”— ğŸ˜ˆ **NEXT IN LINE:** {next_p.mention if next_p else '*(Nobody left to push)*'}\n\n"
            f"> {status_msg if status_msg else '*Will you jump... or will you push?*'}"
        )
        embed = discord.Embed(title="ğŸ¦‘ SURVIVAL: THE GLASS BRIDGE", description=desc, color=0x3498DB)
        embed.set_thumbnail(url=active_p.display_avatar.url)
        return embed

    async def handle_action(self, interaction: discord.Interaction):
        if not self.game_active: return
        await interaction.response.defer() # ğŸ› ï¸ INSTANT DEFER
        
        action = interaction.data["custom_id"]
        active_player = self.players[self.current_player_idx]
        
        # ==========================================
        # âœ‹ PUSH LOGIC (Sacrifice Front Player)
        # ==========================================
        if action == "PUSH":
            if self.current_player_idx + 1 >= len(self.players):
                return await interaction.followup.send("âŒ **Guard:** Push karne ke liye aage koi nahi hai!", ephemeral=True)
                
            pusher = self.players[self.current_player_idx + 1]
            if interaction.user.id != pusher.id:
                return await interaction.followup.send(f"âŒ **Guard:** Sirf peeche wala ({pusher.display_name}) dhakka de sakta hai!", ephemeral=True)

            # The victim is sacrificed, safe glass is revealed
            victim = active_player
            self.revealed[self.current_step] = True
            await self.handle_death(interaction, victim, f"Pushed to their death by {pusher.name}!", revealed=True)
            return

        # ==========================================
        # ğŸ¦µ JUMP LOGIC
        # ==========================================
        if interaction.user.id != active_player.id:
            return await interaction.followup.send("âŒ **Guard:** Wait for your turn!", ephemeral=True)

        chosen_side = action 
        correct_side = self.path[self.current_step]
        
        if chosen_side == correct_side:
            self.current_step += 1
            
            # --- ğŸ‰ WIN CONDITION ---
            if self.current_step >= self.bridge_len:
                self.game_active = False
                self.timer_task.cancel()
                for child in self.children: child.disabled = True
                
                # Dynamic Prize: Entry Fee * Total Players * 2
                prize = len(self.players) * self.entry_fee * 2
                await smart_reward(active_player.id, prize)
                
                embed = discord.Embed(title="ğŸ‰ FLAWLESS VICTORY!", color=0x2ecc71)
                embed.description = (
                    f"### ğŸ† THE BRIDGE IS CONQUERED!\n"
                    f"**{active_player.mention}** safely crossed the glass bridge!\n"
                    f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                    f" â”£ ğŸ’° **Reward Secured:** `${prize:,}`\n"
                    f" â”— ğŸ–ï¸ **Status:** `Legendary Survivor`"
                )
                embed.set_image(url="https://media.tenor.com/bXjOidvDvoQAAAAC/confetti-celebrate.gif")
                return await interaction.edit_original_response(content=None, embed=embed, view=None)

            # Move to next step safely
            self.setup_buttons()
            await interaction.edit_original_response(embed=await self.get_embed(f"âœ… **SAFE!** {active_player.display_name} landed on tempered glass!"), view=self)
            
        else:
            # ğŸ’€ DEATH CONDITION
            await self.handle_death(interaction, active_player, "Jumped on normal glass and shattered it!")

    async def handle_death(self, interaction: discord.Interaction, player: discord.Member, reason: str, revealed=False):
        try: punish_msg = await smart_timeout(interaction, player, 60, "Fell off the Glass Bridge")
        except: punish_msg = "(Mute failed)"
        
        self.dead_players.append(player)
        self.current_player_idx += 1 
        
        # --- â˜ ï¸ EVERYONE DIED ---
        if self.current_player_idx >= len(self.players):
            self.game_active = False
            self.timer_task.cancel()
            for child in self.children: child.disabled = True
            
            embed = discord.Embed(title="ğŸ’€ TOTAL SQUAD WIPE", color=0x000000)
            embed.description = (
                f"### ğŸª¦ NO SURVIVORS\n"
                f"The last player (**{player.display_name}**) {reason.lower()}\n"
                f"The prize money has been seized by the Front Man.\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”— ğŸ¥ **Status:** `{punish_msg}`"
            )
            embed.set_image(url="https://media.tenor.com/2147kZ75wW8AAAAC/squid-game-card.gif")
            return await interaction.edit_original_response(content=None, embed=embed, view=None)

        # --- ğŸ”„ NEXT PLAYER's TURN ---
        status_update = f"ğŸ’€ **{player.display_name}** {reason}\n> ğŸ¥ `{punish_msg}`"
        if revealed:
            status_update += "\nğŸ‘€ **PATH REVEALED!** The safe glass is now visible."

        self.setup_buttons()
        await interaction.edit_original_response(embed=await self.get_embed(status_update), view=self)


# ==============================================================================
# ğŸ¢ LOBBY SYSTEM
# ==============================================================================
class GlassLobbyView(discord.ui.View):
    def __init__(self, host: discord.Member, entry_fee: int):
        super().__init__(timeout=120)
        self.host = host
        self.entry_fee = entry_fee
        self.players = [host]
        self.started = False
        self.message = None

    def get_embed(self):
        p_list = "\n".join([f" â”£ ğŸƒ {p.mention}" for p in self.players])
        p_list = p_list.replace(" â”£ ", " â”— ") if len(self.players) == 1 else p_list
        
        embed = discord.Embed(title="ğŸ¦‘ SQUID GAME: THE GLASS BRIDGE", color=0x2b2d31)
        embed.description = (
            f"**Are you ready to risk it all?**\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ’¸ **Entry Fee:** `${self.entry_fee:,}`\n"
            f" â”£ âš–ï¸ **Rule 1:** `Two glasses. One breaks, one holds.`\n"
            f" â”£ âš–ï¸ **Rule 2:** `Player 2 can PUSH Player 1 to test the glass.`\n"
            f" â”— ğŸ”‡ **Penalty:** `60s Timeout (Hospital)`\n\n"
            f"ğŸ‘¥ **REGISTERED PLAYERS ({len(self.players)}/5):**\n{p_list}"
        )
        embed.set_image(url="https://media.tenor.com/2147kZ75wW8AAAAC/squid-game-card.gif")
        return embed

    @discord.ui.button(label="SIGN WAIVER", style=discord.ButtonStyle.success, emoji="ğŸ©¸")
    async def join_btn(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer()
        
        if self.started: return await interaction.followup.send("âŒ The game has already started!", ephemeral=True)
        if interaction.user in self.players: return await interaction.followup.send("âš ï¸ You are already in the death queue!", ephemeral=True)
        if len(self.players) >= 5: return await interaction.followup.send("ğŸš« Bridge capacity reached!", ephemeral=True)
        
        # ğŸ’³ SMART CHARGE
        paid = await smart_charge(interaction.user.id, self.entry_fee)
        if not paid:
            return await interaction.followup.send(f"âŒ You are broke! You need `${self.entry_fee:,}` in Wallet + Bank.", ephemeral=True)
            
        self.players.append(interaction.user)
        if self.message:
            try: await self.message.edit(embed=self.get_embed(), view=self)
            except: pass

    @discord.ui.button(label="OPEN DOORS", style=discord.ButtonStyle.danger, emoji="ğŸš€")
    async def start_btn(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer()
        
        if interaction.user.id != self.host.id: return await interaction.followup.send("âŒ Only the Host can open the doors.", ephemeral=True)
        if len(self.players) < 2: return await interaction.followup.send("âŒ You need at least 2 players to play this sick game!", ephemeral=True)
        
        self.started = True
        self.stop()
        for child in self.children: child.disabled = True
        
        # Initialize Game
        game_view = GlassBridgeGame(self.players, self.message, self.entry_fee)
        await interaction.edit_original_response(content="ğŸ”¢ **Assigning Player Numbers...**", embed=await game_view.get_embed("ğŸš¨ **GO! THE CLOCK IS TICKING!**"), view=game_view)

    async def on_timeout(self):
        if not self.started:
            for child in self.children: child.disabled = True
            for p in self.players: await smart_reward(p.id, self.entry_fee) # Refund
            
            timeout_embed = discord.Embed(title="â³ LOBBY CLOSED", description="*Not enough players joined. Funds refunded.*", color=0x95a5a6)
            if self.message:
                try: await self.message.edit(embed=timeout_embed, view=None)
                except: pass


# ==============================================================================
# ğŸ’» MAIN COMMAND
# ==============================================================================
@bot.tree.command(name="glass_bridge", description="ğŸ¦‘ Play the deadly Glass Bridge (Wallet & Bank Supported)")
@check_seized()
async def glass_bridge(i: discord.Interaction):
    await i.response.defer()

    if not i.guild.me.guild_permissions.moderate_members:
        return await i.followup.send("âŒ **System Error:** Bot lacks `Timeout` permissions!", ephemeral=True)
    
    entry_fee = 10000 # $10k Entry
    
    # ğŸ’³ Pre-Check Host Balance
    paid = await smart_charge(i.user.id, entry_fee)
    if not paid:
        return await i.followup.send(f"âŒ You are too broke to host! You need `${entry_fee:,}`.", ephemeral=True)

    view = GlassLobbyView(i.user, entry_fee)
    msg = await i.followup.send(embed=view.get_embed(), view=view)
    view.message = msg # Save for safe edits!

# ================== ğŸ“‰ ADMIN: REMOVE MONEY (ASSET SEIZURE) ==================
import discord
from discord import app_commands
from typing import Literal

# ==============================================================================
# ğŸš¨ ASSET SEIZURE (ULTRA-PREMIUM REMOVE MONEY)
# ==============================================================================
@bot.tree.command(name="remove_money", description="ğŸš¨ ROOT ONLY: Confiscate funds from a user's Wallet or Bank")
@app_commands.describe(
    user="Target user for asset seizure", 
    amount="Amount to confiscate",
    account_type="Target Account (Balance/Bank)"
)
async def remove_money(
    interaction: discord.Interaction, 
    user: discord.Member, 
    amount: int, 
    account_type: Literal["Balance", "Bank"] # Premium Dropdown
):
    
    # â³ 1. INSTANT DEFER (To prevent crashes)
    await interaction.response.defer(ephemeral=False) # Public naming & shaming!

    # ğŸ”’ 2. ROOT CLEARANCE CHECK (ğŸ› ï¸ FIX: Standardized Owner Check)
    if not await owner(interaction):
        embed = discord.Embed(title="â›” ACCESS DENIED", description="**SECURITY ALERT:** Only `ROOT ADMINS` can authorize asset seizures.", color=0xff0000)
        return await interaction.followup.send(embed=embed)

    # ğŸ›¡ï¸ 3. VALIDATION
    if amount <= 0:
        return await interaction.followup.send("âŒ **Error:** Please enter a valid positive amount (e.g., 5000).", ephemeral=True)

    if user.bot:
        return await interaction.followup.send("âŒ **Error:** Bots do not have bank accounts.", ephemeral=True)

    # ğŸ—„ï¸ 4. SAFE DATABASE FETCH
    try:
        res = await db_call(lambda: supabase.table("economy").select("*").eq("user_id", str(user.id)).execute())
        data = res.data if res else []
        
        if not data:
            return await interaction.followup.send(f"âŒ **No Record:** {user.mention} does not exist in the economy database.", ephemeral=True)
            
        user_data = data[0]
    except Exception as e:
        return await interaction.followup.send(embed=discord.Embed(title="âŒ DB ERROR", description=f"```{e}```", color=0xff0000))

    # ğŸ§® 5. CALCULATE DEDUCTION (Negative Balance Protection)
    col_name = account_type.lower() # Convert "Balance" -> "balance" for DB
    current_bal = int(user_data.get(col_name, 0))

    if current_bal <= 0:
        embed = discord.Embed(title="ğŸ“­ ACCOUNT EMPTY", description=f"**Target:** {user.mention}\n*Their {account_type} is already at `$0`. Nothing to seize.*", color=0x95a5a6)
        return await interaction.followup.send(embed=embed)

    # Smart Deduction: You can't seize more than what they have
    amount_to_remove = min(current_bal, amount)
    new_bal = current_bal - amount_to_remove

    # ğŸ’¾ 6. SAFE DATABASE UPDATE
    try:
        await db_call(lambda: supabase.table("economy").update({col_name: new_bal}).eq("user_id", str(user.id)).execute())
    except Exception as e:
        return await interaction.followup.send(embed=discord.Embed(title="âŒ UPDATE FAILED", description=f"```{e}```", color=0xff0000))

    # ğŸ’ 7. ULTRA-PREMIUM SEIZURE EMBED
    embed = discord.Embed(title="ğŸš¨ OPERATION: ASSET SEIZURE", color=0x8B0000) # Deep Blood Red
    
    embed.description = (
        f"### ğŸ“‰ FUNDS CONFISCATED\n"
        f"An official authorization has been executed. Funds have been forcibly seized from the target's account.\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f" â”£ ğŸ¯ **Target Profile:** {user.mention}\n"
        f" â”£ ğŸ¦ **Account Hit:** `{account_type.upper()}`\n"
        f" â”£ ğŸ”» **Amount Seized:** `-${amount_to_remove:,}`\n"
        f" â”— ğŸ’° **Remaining Balance:** `${new_bal:,}`\n"
    )
    
    embed.set_thumbnail(url=user.display_avatar.url)
    embed.set_image(url="https://media.tenor.com/EA84s3occX8AAAAC/burning-money-money.gif") 
    embed.set_footer(text=f"Authorized by {interaction.user.display_name} â€¢ Action Irreversible", icon_url=interaction.user.display_avatar.url)
    embed.timestamp = discord.utils.utcnow()

    await interaction.followup.send(embed=embed)


# ================== SAY ACCESS MANAGER (PREMIUM) ==================
import discord
from discord import app_commands
import math

# ==============================================================================
# ğŸ“¢ BROADCAST AUTHORIZATION MATRIX (SAY ACCESS)
# ==============================================================================
@bot.tree.command(name="sayaccess", description="ğŸ“¢ Core Security: Manage /say command clearances (ROOT Only)")
@app_commands.choices(action=[
    app_commands.Choice(name="â• Grant Access (Add)", value="add"),
    app_commands.Choice(name="â– Revoke Access (Remove)", value="remove"),
    app_commands.Choice(name="ğŸ“œ View Authorized List", value="list"),
])
@app_commands.describe(user="Select the target personnel")
async def sayaccess(i: discord.Interaction, action: app_commands.Choice[str], user: discord.User = None):
    
    # â³ 1. INSTANT DEFER (Crash Prevention)
    await i.response.defer(ephemeral=False)

    # ğŸ”’ 2. ROOT SECURITY CHECK (ğŸ› ï¸ FIX: Added 'await')
    if not await owner(i):
        embed = discord.Embed(title="â›” ACCESS DENIED", description="**SECURITY ALERT:** Only `ROOT ADMINS` can manage Broadcast clearances.", color=0xff0000)
        return await i.followup.send(embed=embed)

    try:
        # ==========================================
        # â• ADD USER (GRANT CLEARANCE)
        # ==========================================
        if action.value == "add":
            if not user:
                return await i.followup.send(embed=discord.Embed(title="âš ï¸ MISSING TARGET", description="Please select a user to grant clearance.", color=0xffa500))
            
            # ğŸ—„ï¸ Safe DB Upsert
            await db_call(lambda: supabase.table("say_access").upsert({
                "user_id": str(user.id),
                "added_by": str(i.user.id)
            }).execute())
            
            # ğŸ’ Premium Embed
            embed = discord.Embed(
                title="âœ… BROADCAST CLEARANCE GRANTED", 
                description=f"**{user.mention} has been authorized to use the `/say` megaphone.**", 
                color=0x2ecc71 # Emerald Green
            )
            embed.set_thumbnail(url=user.display_avatar.url)
            embed.add_field(name="ğŸ‘¤ Identity Matrix", value=f" â”£ **Name:** `{user.display_name}`\n â”— **User ID:** `{user.id}`", inline=False)
            embed.set_footer(text=f"Authorized by {i.user.display_name} â€¢ Titan Security", icon_url=i.user.display_avatar.url)
            
            await i.followup.send(embed=embed)

        # ==========================================
        # â– REMOVE USER (REVOKE CLEARANCE)
        # ==========================================
        elif action.value == "remove":
            if not user:
                return await i.followup.send(embed=discord.Embed(title="âš ï¸ MISSING TARGET", description="Please select a user to revoke clearance.", color=0xffa500))
            
            # ğŸ—„ï¸ Safe DB Delete
            await db_call(lambda: supabase.table("say_access").delete().eq("user_id", str(user.id)).execute())
            
            # ğŸ’ Premium Embed
            embed = discord.Embed(
                title="ğŸ—‘ï¸ BROADCAST CLEARANCE REVOKED", 
                description=f"**{user.mention} has been stripped of their `/say` privileges.**", 
                color=0xe74c3c # Crimson Red
            )
            embed.set_thumbnail(url=user.display_avatar.url)
            embed.add_field(name="ğŸ‘¤ Target Erased", value=f" â”£ **Name:** `{user.display_name}`\n â”— **User ID:** `{user.id}`", inline=False)
            embed.set_footer(text=f"Revoked by {i.user.display_name} â€¢ Titan Security", icon_url=i.user.display_avatar.url)

            await i.followup.send(embed=embed)

        # ==========================================
        # ğŸ“œ LIST USERS (AUTHORIZATION DATABASE)
        # ==========================================
        elif action.value == "list":
            # ğŸ—„ï¸ Safe DB Fetch
            res = await db_call(lambda: supabase.table("say_access").select("user_id").execute())
            data = res.data if res else []

            if not data:
                return await i.followup.send(embed=discord.Embed(title="ğŸ“­ DATABASE EMPTY", description="No users currently hold Broadcast clearances.", color=0x95a5a6))

            # ğŸ“„ Chunking data for Paginator (10 per page)
            pages = []
            chunk = []
            for idx, entry in enumerate(data, 1):
                uid = entry.get('user_id', 'Unknown')
                chunk.append(f"`{idx:02d}.` ğŸ‘¤ <@{uid}> `({uid})`\n")
                if len(chunk) == 10:
                    pages.append("".join(chunk))
                    chunk = []
            if chunk:
                pages.append("".join(chunk))

            # ğŸ“± SMART PAGINATOR (Built-in to avoid missing class errors)
            class SayAccessPages(discord.ui.View):
                def __init__(self):
                    super().__init__(timeout=120)
                    self.page = 0
                    self.message = None
                    self.update_buttons()

                def update_buttons(self):
                    self.children[0].disabled = (self.page == 0)
                    self.children[1].disabled = (self.page == len(pages) - 1)

                def get_embed(self):
                    embed = discord.Embed(
                        title="ğŸ“œ AUTHORIZED BROADCASTERS",
                        description=f"**Total Authorized Personnel:** `{len(data)}`\n\n{pages[self.page]}",
                        color=0x3498db # Blue
                    )
                    embed.set_footer(text=f"Page {self.page+1} of {len(pages)} â€¢ Security Matrix", icon_url=i.client.user.display_avatar.url)
                    return embed

                async def update(self, interaction):
                    self.update_buttons()
                    await interaction.response.edit_message(embed=self.get_embed(), view=self)

                @discord.ui.button(label="â—€ï¸ Previous", style=discord.ButtonStyle.secondary)
                async def back(self, interaction: discord.Interaction, button: discord.ui.Button):
                    if i.user.id != interaction.user.id: 
                        return await interaction.response.send_message("âŒ **Denied:** You cannot use this panel.", ephemeral=True)
                    if self.page > 0:
                        self.page -= 1
                    await self.update(interaction)

                @discord.ui.button(label="Next â–¶ï¸", style=discord.ButtonStyle.primary)
                async def next(self, interaction: discord.Interaction, button: discord.ui.Button):
                    if i.user.id != interaction.user.id: 
                        return await interaction.response.send_message("âŒ **Denied:** You cannot use this panel.", ephemeral=True)
                    if self.page < len(pages) - 1:
                        self.page += 1
                    await self.update(interaction)

                async def on_timeout(self):
                    for c in self.children: c.disabled = True
                    if self.message:
                        try: await self.message.edit(view=self)
                        except: pass

            # Send Paginated List
            view = SayAccessPages()
            msg = await i.followup.send(embed=view.get_embed(), view=view)
            view.message = msg

    except Exception as e:
        print(f"SAYACCESS ERROR: {e}")
        await i.followup.send(embed=discord.Embed(title="âŒ FATAL ERROR", description=f"Database Crash:\n```{e}```", color=0xff0000))


# ================== RESTRICT COMMAND (PREMIUM) ==================
import discord
from discord import app_commands

# ==============================================================================
# ğŸ›¡ï¸ AUTO-MODERATION FIREWALL (RESTRICT COMMAND)
# ==============================================================================

@bot.tree.command(name="restrict", description="ğŸ›¡ï¸ ROOT ONLY: Manage Banned Words & VIP Bypass Users")
@app_commands.choices(action=[
    app_commands.Choice(name="â• Add / Allow", value="add"),
    app_commands.Choice(name="â– Remove / Block", value="remove"),
    app_commands.Choice(name="ğŸ“œ View Roster (List)", value="list"),
])
@app_commands.describe(
    word="Comma separated words to ban/unban (e.g. word1, word2)", 
    user="Target user to grant/revoke bypass clearance"
)
async def restrict(i: discord.Interaction, action: app_commands.Choice[str], word: str = None, user: discord.User = None):
    
    # â³ 1. INSTANT DEFER
    await i.response.defer(ephemeral=False)
    
    # ğŸ”’ 2. ROOT SECURITY CHECK (ğŸ› ï¸ FIX: Added 'await')
    if not await owner(i): 
        embed = discord.Embed(title="â›” ACCESS DENIED", description="Only `ROOT ADMINS` can configure the firewall.", color=0xff0000)
        return await i.followup.send(embed=embed)

    # ğŸŒ 3. GLOBAL CACHE ACCESS
    global BANNED_WORDS_CACHE, BYPASS_USERS_CACHE

    try:
        # =====================================================================
        # ğŸ‘‘ 1. USER MANAGEMENT (VIP BYPASS)
        # =====================================================================
        if user:
            if action.value == "add":
                # ğŸ—„ï¸ Safe DB Upsert
                await db_call(lambda: supabase.table("restrict_bypass").upsert({"user_id": str(user.id)}).execute())
                BYPASS_USERS_CACHE.add(user.id)
                
                embed = discord.Embed(title="ğŸ›¡ï¸ FIREWALL EXCEPTION ADDED", color=0x2ecc71)
                embed.description = (
                    f"### ğŸ‘‘ BYPASS CLEARANCE GRANTED\n"
                    f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                    f" â”£ ğŸ‘¤ **Target:** {user.mention}\n"
                    f" â”— âš–ï¸ **Status:** `Immune to Chat Filters`"
                )
                embed.set_thumbnail(url=user.display_avatar.url)
                embed.set_footer(text=f"Authorized by {i.user.display_name}", icon_url=i.user.display_avatar.url)
                return await i.followup.send(embed=embed)

            elif action.value == "remove":
                # ğŸ—„ï¸ Safe DB Delete
                await db_call(lambda: supabase.table("restrict_bypass").delete().eq("user_id", str(user.id)).execute())
                BYPASS_USERS_CACHE.discard(user.id)

                embed = discord.Embed(title="ğŸš« FIREWALL EXCEPTION REVOKED", color=0xe74c3c)
                embed.description = (
                    f"### âš ï¸ BYPASS CLEARANCE REVOKED\n"
                    f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                    f" â”£ ğŸ‘¤ **Target:** {user.mention}\n"
                    f" â”— âš–ï¸ **Status:** `Subject to Chat Filters`"
                )
                embed.set_thumbnail(url=user.display_avatar.url)
                embed.set_footer(text=f"Revoked by {i.user.display_name}", icon_url=i.user.display_avatar.url)
                return await i.followup.send(embed=embed)
                
            elif action.value == "list":
                # ğŸ—„ï¸ Fetch fresh list from DB
                res = await db_call(lambda: supabase.table("restrict_bypass").select("user_id").execute())
                data = res.data if res else []
                
                if not data:
                    return await i.followup.send(embed=discord.Embed(title="ğŸ“­ ROSTER EMPTY", description="No users are currently immune to the firewall.", color=0x95a5a6))
                
                # ğŸ“± ğŸ› ï¸ FIX: Self-Contained User Paginator
                pages, chunk = [], []
                for idx, entry in enumerate(data, 1):
                    uid = entry.get('user_id', 'Unknown')
                    chunk.append(f"`{idx:02d}.` ğŸ‘‘ <@{uid}> `({uid})`\n")
                    if len(chunk) == 10:
                        pages.append("".join(chunk))
                        chunk = []
                if chunk: pages.append("".join(chunk))

                class UserPages(discord.ui.View):
                    def __init__(self):
                        super().__init__(timeout=120)
                        self.page = 0
                        self.message = None
                        self.children[0].disabled = True
                        if len(pages) == 1: self.children[1].disabled = True

                    def get_embed(self):
                        emb = discord.Embed(title="ğŸ“œ VIP BYPASS ROSTER", description=f"**Total Immune Users:** `{len(data)}`\n\n{pages[self.page]}", color=0xF1C40F)
                        emb.set_footer(text=f"Page {self.page+1} of {len(pages)}")
                        return emb

                    async def update(self, itx):
                        self.children[0].disabled = (self.page == 0)
                        self.children[1].disabled = (self.page == len(pages) - 1)
                        await itx.response.edit_message(embed=self.get_embed(), view=self)

                    @discord.ui.button(label="â—€ï¸ Prev", style=discord.ButtonStyle.secondary)
                    async def back(self, itx, btn):
                        if i.user.id != itx.user.id: return await itx.response.send_message("âŒ Denied.", ephemeral=True)
                        self.page -= 1
                        await self.update(itx)

                    @discord.ui.button(label="Next â–¶ï¸", style=discord.ButtonStyle.primary)
                    async def next(self, itx, btn):
                        if i.user.id != itx.user.id: return await itx.response.send_message("âŒ Denied.", ephemeral=True)
                        self.page += 1
                        await self.update(itx)

                    async def on_timeout(self):
                        for c in self.children: c.disabled = True
                        if self.message:
                            try: await self.message.edit(view=self)
                            except: pass

                view = UserPages()
                msg = await i.followup.send(embed=view.get_embed(), view=view)
                view.message = msg
                return

        # =====================================================================
        # ğŸ“ 2. WORD MANAGEMENT (BULK FIREWALL UPDATES)
        # =====================================================================
        if word:
            raw_words = [w.strip().lower() for w in word.split(',') if w.strip()]

            if action.value == "add":
                added = []
                for w in raw_words:
                    if w and w not in BANNED_WORDS_CACHE:
                        # ğŸ—„ï¸ Safe Insert
                        await db_call(lambda: supabase.table("banned_words").insert({"word": w}).execute())
                        BANNED_WORDS_CACHE.add(w)
                        added.append(w)
                
                if added:
                    msg = ", ".join([f"||`{x}`||" for x in added])
                    embed = discord.Embed(title="ğŸ›‘ FIREWALL UPDATED: WORDS BANNED", color=0xe74c3c)
                    embed.description = f"**{len(added)} new strings added to the blacklist:**\n\n{msg}"
                    embed.set_footer(text="Auto-Moderation active.")
                    return await i.followup.send(embed=embed)
                else:
                    return await i.followup.send(embed=discord.Embed(title="âš ï¸ DUPLICATE ENTRY", description="These strings are already blacklisted.", color=0xF1C40F))

            elif action.value == "remove":
                removed = []
                for w in raw_words:
                    if w in BANNED_WORDS_CACHE:
                        # ğŸ—„ï¸ Safe Delete
                        await db_call(lambda: supabase.table("banned_words").delete().eq("word", w).execute())
                        BANNED_WORDS_CACHE.discard(w)
                        removed.append(w)
                
                if removed:
                    msg = ", ".join([f"||`{x}`||" for x in removed])
                    embed = discord.Embed(title="â™»ï¸ FIREWALL UPDATED: WORDS UNBANNED", color=0x2ecc71)
                    embed.description = f"**{len(removed)} strings removed from the blacklist:**\n\n{msg}"
                    return await i.followup.send(embed=embed)
                else:
                    return await i.followup.send(embed=discord.Embed(title="âš ï¸ NOT FOUND", description="These strings were not in the blacklist.", color=0x95a5a6))
            
        # =====================================================================
        # ğŸ“œ 3. LIST ALL BANNED WORDS
        # =====================================================================
        if action.value == "list":
            all_words = sorted(list(BANNED_WORDS_CACHE))

            if not all_words:
                return await i.followup.send(embed=discord.Embed(title="ğŸ“­ FIREWALL EMPTY", description="No words are currently blacklisted.", color=0x3498db))
            
            # ğŸ“± ğŸ› ï¸ FIX: Self-Contained Word Paginator
            pages, chunk = [], []
            for idx, w in enumerate(all_words, 1):
                chunk.append(f"`{idx:02d}.` ||`{w}`||\n")
                if len(chunk) == 20: # 20 words per page
                    pages.append("".join(chunk))
                    chunk = []
            if chunk: pages.append("".join(chunk))

            class WordPages(discord.ui.View):
                def __init__(self):
                    super().__init__(timeout=120)
                    self.page = 0
                    self.message = None
                    self.children[0].disabled = True
                    if len(pages) == 1: self.children[1].disabled = True

                def get_embed(self):
                    emb = discord.Embed(title="ğŸ›‘ BLACKLISTED STRINGS DATABASE", description=f"**Total Banned Words:** `{len(all_words)}`\n\n{pages[self.page]}", color=0xe74c3c)
                    emb.set_footer(text=f"Page {self.page+1} of {len(pages)}")
                    return emb

                async def update(self, itx):
                    self.children[0].disabled = (self.page == 0)
                    self.children[1].disabled = (self.page == len(pages) - 1)
                    await itx.response.edit_message(embed=self.get_embed(), view=self)

                @discord.ui.button(label="â—€ï¸ Prev", style=discord.ButtonStyle.secondary)
                async def back(self, itx, btn):
                    if i.user.id != itx.user.id: return await itx.response.send_message("âŒ Denied.", ephemeral=True)
                    self.page -= 1
                    await self.update(itx)

                @discord.ui.button(label="Next â–¶ï¸", style=discord.ButtonStyle.primary)
                async def next(self, itx, btn):
                    if i.user.id != itx.user.id: return await itx.response.send_message("âŒ Denied.", ephemeral=True)
                    self.page += 1
                    await self.update(itx)

                async def on_timeout(self):
                    for c in self.children: c.disabled = True
                    if self.message:
                        try: await self.message.edit(view=self)
                        except: pass

            view = WordPages()
            msg = await i.followup.send(embed=view.get_embed(), view=view)
            view.message = msg
            return
        
        # âŒ If neither word nor user is provided for Add/Remove
        embed = discord.Embed(title="âš ï¸ MISSING PARAMETERS", description="You must provide either a `word` or select a `user` to modify the firewall.", color=0xffa500)
        await i.followup.send(embed=embed)

    except Exception as e:
        print(f"RESTRICT ERROR: {e}")
        await i.followup.send(embed=discord.Embed(title="âŒ SYSTEM CRASH", description=f"```{e}```", color=0xff0000))

import discord
from discord import app_commands
import datetime as dt

# --- BANKING CONSTANTS ---
MAX_LOAN = 10000000    # $1 Million
LOAN_DURATION = 24     # 24 Hours
INTEREST_LIMIT = 300000 # Loans above $300k get 10% interest every 3h

# ==============================================================================
# ğŸ¦ TITAN CENTRAL BANK: LOAN SYSTEM (SMART BANKING & CRASH PROOF)
# ==============================================================================

@bot.tree.command(name="loan", description="ğŸ’¸ Borrow money from the Underworld Bank (Repay in 24h or get SEIZED)")
@app_commands.describe(amount="How much do you want to borrow? (Min: $1,000)")
@check_seized()
async def loan(interaction: discord.Interaction, amount: int):
    # â³ 1. INSTANT DEFER
    await interaction.response.defer(ephemeral=False)
    user = interaction.user

    # ğŸ›¡ï¸ 2. CHECK: ACCOUNT STATUS (Safe DB Call)
    try:
        res = await db_call(lambda: supabase.table("economy").select("is_seized").eq("user_id", str(user.id)).execute())
        if res and res.data and res.data[0].get('is_seized', False):
            return await interaction.followup.send(embed=discord.Embed(title="ğŸš« ACCOUNT SEIZED", description="Your assets are frozen. The bank has rejected your loan application.", color=0xff0000))
    except Exception as e:
        return await interaction.followup.send(f"âŒ **System Error:** `{e}`")

    # âš–ï¸ 3. CHECK: LOAN LIMITS
    if amount > MAX_LOAN:
        return await interaction.followup.send(f"âŒ **Bank Manager:** We don't fund countries! Max Loan Limit is **${MAX_LOAN:,}**.", ephemeral=True)
    if amount < 1000:
        return await interaction.followup.send("âŒ **Bank Manager:** We don't deal in spare change. Minimum loan is **$1,000**.", ephemeral=True)

    # ğŸ“œ 4. CHECK: EXISTING DEBTS
    try:
        check_loan = await db_call(lambda: supabase.table("loans").select("*").eq("user_id", str(user.id)).execute())
        if check_loan and check_loan.data:
            return await interaction.followup.send(embed=discord.Embed(title="ğŸ›‘ APPLICATION DENIED", description="You already have an active loan! Pay your existing debt before asking for more.", color=0xffa500))
    except Exception as e:
        return await interaction.followup.send(f"âŒ **System Error:** `{e}`")

    # ğŸ¦ 5. PROCESS LOAN APPROVAL
    try:
        # A. Deposit Funds securely using your Smart Reward system
        await smart_reward(user.id, amount)

        # B. Generate Loan Contract
        due_time = dt.datetime.now(dt.timezone.utc) + dt.timedelta(hours=LOAN_DURATION)
        
        loan_data = {
            "user_id": str(user.id),
            "amount": amount,
            "total_repay": amount,
            "due_at": due_time.isoformat(),
            "last_reminder": dt.datetime.now(dt.timezone.utc).isoformat()
        }
        await db_call(lambda: supabase.table("loans").insert(loan_data).execute())

        # C. Ultra-Premium Contract Embed
        embed = discord.Embed(title="ğŸ¦ LOAN APPROVED & CREDITED", color=0x2ecc71) # Emerald Green
        
        warning_txt = (
            f"âš ï¸ **FAILURE TO REPAY WILL RESULT IN:**\n"
            f"> `1.` Complete wipe of Wallet & Bank ($0)\n"
            f"> `2.` Confiscation of all Inventory items\n"
            f"> `3.` Permanent Account Seizure (Ban)\n"
        )
        
        embed.description = (
            f"### ğŸ“œ OFFICIAL BANK CONTRACT\n"
            f"**Borrower:** {user.mention}\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ’° **Principal Amount:** `${amount:,}`\n"
            f" â”£ ğŸ“ˆ **Total Repayment:** `${amount:,}`\n"
            f" â”— â³ **Absolute Deadline:** <t:{int(due_time.timestamp())}:R>\n\n"
            f"{warning_txt}"
        )
        
        if amount > INTEREST_LIMIT:
            embed.set_footer(text="High Risk Loan: 10% interest will be compounded every 3 hours!", icon_url=interaction.client.user.display_avatar.url)
        else:
            embed.set_footer(text="Titan Central Bank â€¢ Unforgiving System", icon_url=interaction.client.user.display_avatar.url)
            
        embed.set_thumbnail(url="https://media.tenor.com/p7a8o1r5c8cAAAAC/money-rain.gif")
            
        await interaction.followup.send(embed=embed)

    except Exception as e:
        print(f"Loan Error: {e}")
        await interaction.followup.send(embed=discord.Embed(title="âŒ FATAL ERROR", description=f"The bank's servers crashed:\n```{e}```", color=0xff0000))


# ==============================================================================
# ğŸ’° TITAN CENTRAL BANK: PAYBACK SYSTEM
# ==============================================================================
@bot.tree.command(name="payback", description="ğŸ’° Clear your bank debt and regain your freedom")
async def payback(interaction: discord.Interaction):
    # â³ 1. INSTANT DEFER
    await interaction.response.defer(ephemeral=False)
    user = interaction.user
    
    # ğŸ“œ 2. FETCH ACTIVE CONTRACT
    try:
        l_res = await db_call(lambda: supabase.table("loans").select("*").eq("user_id", str(user.id)).execute())
        if not l_res or not l_res.data:
            return await interaction.followup.send(embed=discord.Embed(title="âœ… DEBT FREE", description="You have no active loans. The bank is satisfied.", color=0x2ecc71))

        loan_data = l_res.data[0]
        amount_to_pay = int(loan_data['total_repay'])

        # ğŸ’³ 3. SMART CHARGE (Checks both Wallet & Bank)
        paid = await smart_charge(user.id, amount_to_pay)
        
        if not paid:
            # ğŸ› ï¸ If failed, fetch exact balance to show them how much they are short
            e_res = await db_call(lambda: supabase.table("economy").select("balance, bank").eq("user_id", str(user.id)).execute())
            bal = int(e_res.data[0].get('balance', 0)) if e_res and e_res.data else 0
            bank = int(e_res.data[0].get('bank', 0)) if e_res and e_res.data else 0
            
            embed = discord.Embed(title="âŒ INSUFFICIENT FUNDS", color=0xe74c3c)
            embed.description = (
                f"You cannot afford to clear this debt right now!\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ“œ **Debt Required:** `${amount_to_pay:,}`\n"
                f" â”— ğŸ’³ **Total Net Worth:** `${(bal + bank):,}` *(Wallet + Bank)*\n\n"
                f"*Earn more money before the deadline!*"
            )
            return await interaction.followup.send(embed=embed)

        # ğŸ—‘ï¸ 4. BURN THE CONTRACT (Delete Loan)
        await db_call(lambda: supabase.table("loans").delete().eq("user_id", str(user.id)).execute())

        # ğŸ’ 5. PREMIUM SUCCESS EMBED
        embed = discord.Embed(title="ğŸ‰ DEBT CLEARED", color=0xFFD700) # Solid Gold
        embed.description = (
            f"### ğŸ¤ CONTRACT TERMINATED\n"
            f"**{user.mention}** has successfully repaid their loan!\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ’¸ **Amount Repaid:** `${amount_to_pay:,}`\n"
            f" â”— ğŸ”“ **Status:** `Free & Clear`\n\n"
            f"> *You are now eligible to take out a new loan.*"
        )
        embed.set_thumbnail(url="https://media.tenor.com/2jK3Y1s3CqAAAAAC/payday-dallas.gif") # Heist/Money GIF
        embed.set_footer(text="Titan Central Bank", icon_url=interaction.client.user.display_avatar.url)
        
        await interaction.followup.send(embed=embed)

    except Exception as e:
        print(f"Payback Error: {e}")
        await interaction.followup.send(embed=discord.Embed(title="âŒ FATAL ERROR", description=f"Database crashed during transaction:\n```{e}```", color=0xff0000))

# ================== ROBLOX INFO COMMAND (FINAL MEGA VERSION ğŸ‘‘) ==================
import discord
from discord import app_commands
import asyncio
from datetime import datetime

# ==============================================================================
# ğŸ” ROBLOX OSINT TERMINAL (MAXIMUM INFORMATION EXTRACTOR)
# ==============================================================================
@bot.tree.command(name="robloxinfo", description="ğŸ” Deep Scan: Socials, DevStats, Inventory, Favorites, & History")
@app_commands.describe(identifier="Target Username or Roblox ID")
async def robloxinfo(i: discord.Interaction, identifier: str):
    
    # â³ 1. INSTANT DEFER (Heavy API Load Processing)
    await i.response.defer(ephemeral=False)

    try:
        # ğŸ†” 2. IDENTITY RESOLVER (Username -> ID)
        target_id = identifier
        if not identifier.isdigit():
            payload = {"usernames": [identifier], "excludeBannedUsers": False}
            try:
                # ğŸ› ï¸ Safe Session with 5s Timeout
                async with bot.session.post("https://users.roblox.com/v1/usernames/users", json=payload, timeout=5) as res:
                    data = await res.json()
                    if data and "data" in data and len(data["data"]) > 0:
                        target_id = str(data["data"][0]["id"])
                    else:
                        return await i.followup.send(embed=discord.Embed(title="âŒ TARGET NOT FOUND", description=f"Could not locate user: `{identifier}`", color=0xff0000))
            except:
                return await i.followup.send(embed=discord.Embed(title="âš ï¸ API ERROR", description="Roblox ID Resolver is currently down. Please use a direct User ID.", color=0xF1C40F))

        # ğŸŒ 3. PARALLEL API EXTRACTION (15 ENDPOINTS)
        urls = [
            f"https://users.roblox.com/v1/users/{target_id}",                                      # 0. Core Info
            f"https://friends.roblox.com/v1/users/{target_id}/friends/count",                       # 1. Friends
            f"https://friends.roblox.com/v1/users/{target_id}/followers/count",                     # 2. Followers
            f"https://friends.roblox.com/v1/users/{target_id}/followings/count",                    # 3. Following
            f"https://presence.roblox.com/v1/presence/users",                                       # 4. Presence
            f"https://thumbnails.roblox.com/v1/users/avatar-headshot?userIds={target_id}&size=420x420&format=Png&isCircular=false", # 5. Head
            f"https://thumbnails.roblox.com/v1/users/avatar?userIds={target_id}&size=720x720&format=Png&isCircular=false",          # 6. Body (BIG IMAGE)
            f"https://users.roblox.com/v1/users/{target_id}/username-history?limit=20&sortOrder=Desc", # 7. History
            f"https://groups.roblox.com/v1/users/{target_id}/groups/roles",                          # 8. Groups
            f"https://premiumfeatures.roblox.com/v1/users/{target_id}/validate-membership",         # 9. Premium
            f"https://accountinformation.roblox.com/v1/users/{target_id}/roblox-badges",            # 10. Badges
            f"https://users.roblox.com/v1/users/{target_id}/promotion-channels",                    # 11. Socials
            f"https://games.roblox.com/v2/users/{target_id}/games?accessFilter=Public&limit=50",    # 12. Dev Stats
            f"https://inventory.roblox.com/v1/users/{target_id}/can-view-inventory",                # 13. Inventory Privacy
            f"https://games.roblox.com/v2/users/{target_id}/favorite/games?limit=1"                 # 14. Favorites
        ]

        presence_payload = {"userIds": [int(target_id)]}

        async def get_json(url, method="GET", json_body=None):
            try:
                if method == "POST":
                    async with bot.session.post(url, json=json_body, timeout=4) as r: return await r.json()
                else:
                    async with bot.session.get(url, timeout=4) as r: return await r.json()
            except: return None # ğŸ› ï¸ Silent Fail for individual APIs

        results = await asyncio.gather(
            get_json(urls[0]), get_json(urls[1]), get_json(urls[2]), get_json(urls[3]),
            get_json(urls[4], "POST", presence_payload), get_json(urls[5]), get_json(urls[6]),
            get_json(urls[7]), get_json(urls[8]), get_json(urls[9]), get_json(urls[10]),
            get_json(urls[11]), get_json(urls[12]), get_json(urls[13]), get_json(urls[14])
        )

        def get_d(res): return res["data"] if res and isinstance(res, dict) and "data" in res else []

        user_data = results[0]
        if not user_data or "id" not in user_data: 
            return await i.followup.send(embed=discord.Embed(title="ğŸš« TERMINATED", description="Target is permanently banned or deleted.", color=0xff0000))

        # ğŸ§  4. DATA PARSING & FORMATTING
        
        # A. Identity
        display_name = user_data.get('displayName', 'Unknown')
        username = user_data.get('name', 'Unknown')
        is_verified = user_data.get("hasVerifiedBadge", False)
        is_premium = results[9].get("membershipValid", False) if results[9] else False

        name_str = f"{display_name} (@{username})"
        if is_verified: name_str += " â˜‘ï¸"
        if is_premium: name_str += " ğŸ’"

        # B. Official Badges
        official_badges = []
        for badge in get_d(results[10]):
            b_name = badge.get("name")
            if b_name == "Administrator": official_badges.append("ğŸ›¡ï¸ Admin")
            elif b_name == "Creator": official_badges.append("ğŸ”¨ Creator")
            elif "Intern" in b_name: official_badges.append("ğŸ“ Intern")
            elif "Star" in b_name: official_badges.append("â­ Star")
            else: official_badges.append(f"ğŸ–ï¸ {b_name}")
        badges_str = " | ".join(official_badges) if official_badges else "`None`"

        # C. Live Status
        status_str = "âš« `Offline`"
        last_seen_str = "`Unknown`"
        
        if results[4] and "userPresences" in results[4] and results[4]["userPresences"]:
            p_data = results[4]["userPresences"][0]
            p_type = p_data.get("userPresenceType", 0)
            
            if p_data.get("lastOnline"):
                try:
                    dt = datetime.strptime(p_data["lastOnline"].split(".")[0], "%Y-%m-%dT%H:%M:%S")
                    last_seen_str = f"<t:{int(dt.timestamp())}:f>"
                except: pass

            if p_type == 1: status_str = "ğŸŸ¢ **Online** *(Web/App)*"
            elif p_type == 2:
                gname = p_data.get("lastLocation", "Unknown Game")
                pid = p_data.get("placeId")
                status_str = f"ğŸ® **Playing:** [{gname}](https://www.roblox.com/games/{pid})" if pid else f"ğŸ® **Playing:** {gname}"
            elif p_type == 3: status_str = "ğŸ”¶ **In Studio** *(Developing)*"
            else: status_str = f"âš« **Offline**\n â”— *Seen:* {last_seen_str}"

        # D. Extra Intel (Socials, Stats, Inv, Favs)
        socials = [f"[{k.capitalize()}]({v})" for k, v in (results[11] or {}).items() if v and "http" in str(v)]
        social_str = " | ".join(socials) if socials else "`Classified/None`"

        games_list = get_d(results[12])
        total_visits = sum(g.get("placeVisits", 0) for g in games_list)
        dev_stat_str = f" â”£ ğŸ® **Games Created:** `{len(games_list)}`\n â”— ğŸ‘£ **Total Visits:** `{total_visits:,}`"

        inv_open = results[13].get("canView", False) if results[13] else False
        inv_str = "ğŸ”“ `Public`" if inv_open else "ğŸ”’ `Private`"

        owned_groups = [g.get("group", {}).get("name", "Unknown") for g in get_d(results[8]) if g.get("role", {}).get("rank") == 255]
        owner_str = ", ".join(owned_groups[:2]) + ("..." if len(owned_groups) > 2 else "") if owned_groups else "`None`"

        fav_list = get_d(results[14])
        fav_game = f"[{fav_list[0].get('name')}](https://www.roblox.com/games/{fav_list[0].get('id')})" if fav_list else "`Hidden/None`"

        # ğŸ›¡ï¸ 5. INTERNAL DATABASE CHECK (TITAN SECURITY)
        tid = str(target_id)
        local_access = await db_call(lambda: supabase.table("access_users").select("*").eq("user_id", tid).execute())
        local_ban = await db_call(lambda: supabase.table("bans").select("*").eq("user_id", tid).execute())
        
        db_txt = " â”— ğŸ”’ `Not Verified in Server`"
        col = 0x2b2d31 # Default Gray
        if local_access and local_access.data: 
            db_txt = f" â”— âœ… **VERIFIED:** <@{local_access.data[0]['discord_id']}>"
            col = 0x2ecc71 # Verified Green
        if local_ban and local_ban.data:
            db_txt = f" â”— ğŸ”´ **BANNED:** `{local_ban.data[0]['reason']}`"
            col = 0xe74c3c # Banned Red

        # ğŸ’ 6. BUILD ULTRA-PREMIUM EMBED
        embed = discord.Embed(title=name_str, url=f"https://www.roblox.com/users/{target_id}/profile", color=col)
        
        # ğŸ“¸ PULLING THE IMAGES (Headshot + Full Body)
        head_list = get_d(results[5])
        body_list = get_d(results[6])
        if head_list: embed.set_thumbnail(url=head_list[0].get("imageUrl")) # Small Face
        if body_list: embed.set_image(url=body_list[0].get("imageUrl"))     # HUGE Full Body Image

        # --- FIELD 1: IDENTITY & STATUS ---
        bio = user_data.get('description', 'No Bio')
        bio = bio[:250] + "..." if len(bio) > 250 else bio
        try:
            created_ts = int(datetime.strptime(user_data["created"].split(".")[0], "%Y-%m-%dT%H:%M:%S").timestamp())
            age_str = f"<t:{created_ts}:D> (<t:{created_ts}:R>)"
        except: age_str = "`Unknown`"

        embed.add_field(
            name="ğŸ“¡ Core Intel", 
            value=(
                f" â”£ **User ID:** `{target_id}`\n"
                f" â”£ **Created:** {age_str}\n"
                f" â”— **Status:** {status_str}"
            ), 
            inline=False
        )

        # --- FIELD 2: INVENTORY & GROUPS ---
        embed.add_field(
            name="ğŸ“‚ Account Data", 
            value=(
                f" â”£ **Inventory:** {inv_str}\n"
                f" â”£ **Last Fav:** {fav_game}\n"
                f" â”— **Owns Groups:** {owner_str}"
            ), 
            inline=False
        )

        # --- FIELD 3: DEV & SOCIALS ---
        embed.add_field(
            name="ğŸ› ï¸ Developer & Media", 
            value=(
                f"{dev_stat_str}\n"
                f"ğŸ”— **Socials:** {social_str}"
            ), 
            inline=False
        )

        # --- FIELD 4: STATS & BADGES ---
        stats_txt = f"ğŸ‘¥ **Friends:** `{results[1]['count'] if results[1] else 0}` | ğŸ“¡ **Followers:** `{results[2]['count'] if results[2] else 0}` | ğŸ‘€ **Following:** `{results[3]['count'] if results[3] else 0}`"
        embed.add_field(name="ğŸ“Š Statistics", value=f"{stats_txt}\nğŸ–ï¸ **Badges:** {badges_str}", inline=False)
        
        # --- FIELD 5: TITAN DATABASE ---
        embed.add_field(name="ğŸ›¡ï¸ Titan Security Network", value=db_txt, inline=False)

        # --- FIELD 6: ALIASES (HISTORY) ---
        hist_list = get_d(results[7])
        past = ", ".join([f"`{x['name']}`" for x in hist_list]) if hist_list else "`None`"
        if len(past) > 300: past = past[:300] + "..."
        if past != "`None`": embed.add_field(name="ğŸ•°ï¸ Known Aliases", value=past, inline=False)

        # --- BIO IN QUOTES ---
        if bio != "No Bio":
            embed.description = f"```\n{bio}\n```"

        embed.set_footer(text=f"OSINT Scan requested by {i.user.display_name}", icon_url=i.user.display_avatar.url)
        embed.timestamp = discord.utils.utcnow()

        await i.followup.send(embed=embed)

    except Exception as e:
        print(f"OSINT ERROR: {e}")
        try: await i.followup.send(embed=discord.Embed(title="âŒ FATAL ERROR", description=f"OSINT Extraction Failed:\n```{e}```", color=0xff0000))
        except: pass         

# ================== ğŸ§  ULTIMATE IQ TEST CHALLENGE ==================
import random
import discord
from discord import app_commands

# ==========================================
# ğŸ§  QUESTION BANK (English & Premium)
# ==========================================
# Har question ka ek unique "id" hai taaki repeat na ho
iq_questions_en = [
    # --- SCIENCE & NATURE ---
    {"id": "q1", "q": "What is the hardest natural substance on Earth?", "a": "DIAMOND", "opts": ["GOLD", "IRON", "DIAMOND"]},
    {"id": "q2", "q": "Which planet is known as the Red Planet?", "a": "MARS", "opts": ["VENUS", "JUPITER", "MARS"]},
    {"id": "q3", "q": "How many bones are in the adult human body?", "a": "206", "opts": ["206", "208", "300"]},
    {"id": "q4", "q": "What gas do plants absorb from the atmosphere?", "a": "CARBON DIOXIDE", "opts": ["OXYGEN", "CARBON DIOXIDE", "NITROGEN"]},
    {"id": "q5", "q": "What is the chemical symbol for Gold?", "a": "Au", "opts": ["Ag", "Au", "Go"]},
    
    # --- TECH & GAMING ---
    {"id": "q6", "q": "Which company developed the Android OS?", "a": "GOOGLE", "opts": ["APPLE", "SAMSUNG", "GOOGLE"]},
    {"id": "q7", "q": "What does CPU stand for?", "a": "CENTRAL PROCESSING UNIT", "opts": ["COMPUTER PERSONAL UNIT", "CENTRAL PROCESSING UNIT", "CORE PROCESSING UNIT"]},
    {"id": "q8", "q": "In which game do you build and break blocks in a 3D world?", "a": "MINECRAFT", "opts": ["ROBLOX", "TERRARIA", "MINECRAFT"]},
    {"id": "q9", "q": "Who is the creator of Bitcoin?", "a": "SATOSHI NAKAMOTO", "opts": ["ELON MUSK", "VITALIK BUTERIN", "SATOSHI NAKAMOTO"]},
    {"id": "q10", "q": "What is the name of Goku's ultimate form?", "a": "ULTRA INSTINCT", "opts": ["SUPER SAIYAN 3", "ULTRA INSTINCT", "GEAR 5"]},
    
    # --- GEOGRAPHY & HISTORY ---
    {"id": "q11", "q": "What is the smallest country in the world?", "a": "VATICAN CITY", "opts": ["MONACO", "VATICAN CITY", "MALTA"]},
    {"id": "q12", "q": "Which ocean is the largest on Earth?", "a": "PACIFIC OCEAN", "opts": ["ATLANTIC OCEAN", "INDIAN OCEAN", "PACIFIC OCEAN"]},
    {"id": "q13", "q": "Who painted the Mona Lisa?", "a": "LEONARDO DA VINCI", "opts": ["PICASSO", "VINCENT VAN GOGH", "LEONARDO DA VINCI"]},
    {"id": "q14", "q": "In what year did the Titanic sink?", "a": "1912", "opts": ["1905", "1912", "1920"]},
    {"id": "q15", "q": "What is the capital city of Australia?", "a": "CANBERRA", "opts": ["SYDNEY", "MELBOURNE", "CANBERRA"]},

        # --- WORLD EVENTS & POLITICS (2024-2026) ---
    {"id": "q76", "q": "Which country officially joined NATO as its 32nd member in 2024?", "a": "SWEDEN", "opts": ["FINLAND", "SWEDEN", "UKRAINE"]},
    {"id": "q77", "q": "Who won the 2024 US Presidential Election?", "a": "DONALD TRUMP", "opts": ["JOE BIDEN", "DONALD TRUMP", "KAMALA HARRIS"]},
    {"id": "q78", "q": "Which nation hosted the COP29 Climate Summit in 2024?", "a": "AZERBAIJAN", "opts": ["UAE", "AZERBAIJAN", "BRAZIL"]},
    {"id": "q79", "q": "What is the name of the world's first AI-powered 'digital human' created for government service in 2025?", "a": "KAI", "opts": ["SOPHIA", "KAI", "AMEC"]},
    {"id": "q80", "q": "Which country is set to host the FIFA World Cup 2026 alongside USA and Mexico?", "a": "CANADA", "opts": ["BRAZIL", "CANADA", "FRANCE"]},
    {"id": "q81", "q": "What is the new currency introduced by Zimbabwe in 2024 to fight inflation?", "a": "ZiG", "opts": ["ZIM DOLLAR", "ZiG", "RTGS"]},
    {"id": "q82", "q": "Which island nation officially removed the British Monarch as its head of state in 2025?", "a": "JAMAICA", "opts": ["BARBADOS", "JAMAICA", "BAHAMAS"]},

    # --- ADVANCED AI & TECH (Classified Level) ---
    {"id": "q83", "q": "Which AI model surpassed GPT-4o in logical reasoning benchmarks in late 2024?", "a": "o1-PREVIEW", "opts": ["CLAUDE 3.5", "o1-PREVIEW", "GEMINI 1.5"]},
    {"id": "q84", "q": "What is the name of Neuralink's first human patient who successfully controlled a computer with his mind?", "a": "NOLAND ARBAUGH", "opts": ["ELON MUSK", "NOLAND ARBAUGH", "CONNOR BENN"]},
    {"id": "q85", "q": "Which tech giant achieved 'Quantum Supremacy' in late 2025 with a 1000-qubit processor?", "a": "IBM", "opts": ["GOOGLE", "IBM", "MICROSOFT"]},
    {"id": "q86", "q": "What does the 'S' in OpenAI's 'Sora' model represent?", "a": "SKY", "opts": ["STORY", "SPEED", "SKY"]},
    {"id": "q87", "q": "Which country launched the 'Shijian-21' satellite to clean space debris in 2024?", "a": "CHINA", "opts": ["USA", "CHINA", "INDIA"]},
    {"id": "q88", "q": "What is the name of the first-ever programmable robot made of living cells (Xenobots)?", "a": "XENOBOTS 3.0", "opts": ["XENOBOTS 3.0", "BIO-DROID", "CELL-BOT"]},

    # --- INDIA CURRENT AFFAIRS (Elite GK) ---
    {"id": "q89", "q": "Who was appointed as the Chief Justice of India in late 2024?", "a": "SANJIV KHANNA", "opts": ["D.Y. CHANDRACHUD", "SANJIV KHANNA", "U.U. LALIT"]},
    {"id": "q90", "q": "Which Indian city was officially named the 'Cleanest City' for the 8th time in 2025?", "a": "INDORE", "opts": ["SURAT", "INDORE", "MYSORE"]},
    {"id": "q91", "q": "What is the name of India's mission to send humans into space in 2025-26?", "a": "GAGANYAAN", "opts": ["CHANDRAYAAN 4", "GAGANYAAN", "ADITYA L1"]},
    {"id": "q92", "q": "Which Indian state became the first to implement the Uniform Civil Code (UCC) in 2024?", "a": "UTTARAKHAND", "opts": ["GOA", "UTTARAKHAND", "UP"]},
    {"id": "q93", "q": "Who is the current ISRO Chairman leading the Gaganyaan mission?", "a": "S. SOMANATH", "opts": ["K. SIVAN", "S. SOMANATH", "MADHAVAN NAIR"]},

    # --- SPACE & SCIENCE DISCOVERIES ---
    {"id": "q94", "q": "Which space telescope discovered the oldest galaxy 'JADES-GS-z14-0' in 2024?", "a": "JAMES WEBB", "opts": ["HUBBLE", "JAMES WEBB", "KEPLER"]},
    {"id": "q95", "q": "What is the name of NASA's mission to investigate Jupiter's moon Europa in 2024?", "a": "EUROPA CLIPPER", "opts": ["JUNO", "EUROPA CLIPPER", "ARTEMIS"]},
    {"id": "q96", "q": "In 2025, scientists synthesized which new element on the 8th row of the periodic table?", "a": "UNUNENNIUM", "opts": ["OGANESSON", "UNUNENNIUM", "TENNESSINE"]},
    {"id": "q97", "q": "Which mission successfully returned asteroid samples from Bennu to Earth?", "a": "OSIRIS-REx", "opts": ["HAYABUSA2", "OSIRIS-REx", "DART"]},

    # --- THE KILLER STREAK (Mixed Extreme Hard) ---
    {"id": "q98", "q": "Which global tech company was ordered to be broken up by the US Dept of Justice in 2025?", "a": "GOOGLE", "opts": ["APPLE", "GOOGLE", "META"]},
    {"id": "q99", "q": "What is the first-ever 3D-printed rocket launched into orbit called?", "a": "TERRAN 1", "opts": ["STARSHIP", "TERRAN 1", "FALCON 9"]},
    {"id": "q100", "q": "Which country became the first to approve a 'Gene-Editing' therapy (CRISPR) for sickle cell disease?", "a": "UK", "opts": ["USA", "UK", "CHINA"]},

    # --- ECONOMY & FINANCE ---
    {"id": "q101", "q": "Which cryptocurrency hit a record $100,000 for the first time in late 2024/25?", "a": "BITCOIN", "opts": ["ETHEREUM", "BITCOIN", "SOLANA"]},
    {"id": "q102", "q": "Who is the current Managing Director of the IMF (2025)?", "a": "KRISTALINA GEORGIEVA", "opts": ["KRISTALINA GEORGIEVA", "AJAY BANGA", "CHRISTINE LAGARDE"]},
    {"id": "q103", "q": "Which company became the world's most valuable by market cap in 2024 due to AI?", "a": "NVIDIA", "opts": ["MICROSOFT", "NVIDIA", "APPLE"]},

    # --- MORE HARD GK (Q104 - Q175) ---
    {"id": "q104", "q": "Which city is hosting the 2028 Summer Olympics?", "a": "LOS ANGELES", "opts": ["PARIS", "LOS ANGELES", "BRISBANE"]},
    {"id": "q105", "q": "What is the name of the largest volcano in the Solar System?", "a": "OLYMPUS MONS", "opts": ["MOUNT EVEREST", "OLYMPUS MONS", "MAUNA KEA"]},
    {"id": "q106", "q": "Which blood component is responsible for clotting?", "a": "PLATELETS", "opts": ["PLASMA", "PLATELETS", "HEMOGLOBIN"]},
    {"id": "q107", "q": "In computer science, what is the time complexity of a Binary Search?", "a": "O(log n)", "opts": ["O(n)", "O(log n)", "O(n^2)"]},
    {"id": "q108", "q": "Who wrote the famous book 'A Brief History of Time'?", "a": "STEPHEN HAWKING", "opts": ["ALBERT EINSTEIN", "STEPHEN HAWKING", "ISAAC NEWTON"]},
    {"id": "q109", "q": "Which country is the largest producer of Lithium?", "a": "AUSTRALIA", "opts": ["CHILE", "AUSTRALIA", "CHINA"]},
    {"id": "q110", "q": "What is the only mammal that can truly fly?", "a": "BAT", "opts": ["FLYING SQUIRREL", "BAT", "OWL"]},
    {"id": "q111", "q": "Which part of the cell is known as the 'Powerhouse'?", "a": "MITOCHONDRIA", "opts": ["NUCLEUS", "MITOCHONDRIA", "RIBOSOME"]},
    {"id": "q112", "q": "What is the chemical formula for Ozone?", "a": "O3", "opts": ["O2", "O3", "CO2"]},
    {"id": "q113", "q": "Which country invented the game of Chess?", "a": "INDIA", "opts": ["CHINA", "INDIA", "RUSSIA"]},
    {"id": "q114", "q": "What is the maximum speed of a cheetah?", "a": "120 KM/H", "opts": ["80 KM/H", "120 KM/H", "150 KM/H"]},
    {"id": "q115", "q": "How many bits make up an IPv6 address?", "a": "128", "opts": ["32", "64", "128"]},
    {"id": "q116", "q": "Which continent has no active volcanoes?", "a": "AUSTRALIA", "opts": ["AFRICA", "AUSTRALIA", "EUROPE"]},
    {"id": "q117", "q": "What is the name of the process by which plants lose water through leaves?", "a": "TRANSPIRATION", "opts": ["PHOTOSYNTHESIS", "TRANSPIRATION", "OSMOSIS"]},
    {"id": "q118", "q": "Who discovered the Law of Gravity?", "a": "ISAAC NEWTON", "opts": ["GALILEO", "ISAAC NEWTON", "EINSTEIN"]},
    {"id": "q119", "q": "Which country is called the 'Land of White Elephants'?", "a": "THAILAND", "opts": ["INDIA", "THAILAND", "MYANMAR"]},
    {"id": "q120", "q": "What is the pH value of pure water?", "a": "7", "opts": ["5", "7", "9"]},
    {"id": "q121", "q": "Which language has the most native speakers?", "a": "MANDARIN CHINESE", "opts": ["ENGLISH", "MANDARIN CHINESE", "SPANISH"]},
    {"id": "q122", "q": "How many planets in our solar system have rings?", "a": "4", "opts": ["1", "2", "4"]},
    {"id": "q123", "q": "What is the main component of natural gas?", "a": "METHANE", "opts": ["PROPANE", "METHANE", "BUTANE"]},
    {"id": "q124", "q": "Which bone is the largest in the human body?", "a": "FEMUR", "opts": ["TIBIA", "FEMUR", "SKULL"]},
    {"id": "q125", "q": "What is the SI unit of electric current?", "a": "AMPERE", "opts": ["VOLT", "WATT", "AMPERE"]},
    {"id": "q126", "q": "Which country is the world's largest exporter of coffee?", "a": "BRAZIL", "opts": ["VIETNAM", "COLOMBIA", "BRAZIL"]},
    {"id": "q127", "q": "How many players are on a water polo team?", "a": "7", "opts": ["6", "7", "11"]},
    {"id": "q128", "q": "What is the capital of South Korea?", "a": "SEOUL", "opts": ["BUSAN", "SEOUL", "TOKYO"]},
    {"id": "q129", "q": "Which is the only planet that rotates clockwise?", "a": "VENUS", "opts": ["MARS", "VENUS", "NEPTUNE"]},
    {"id": "q130", "q": "What is the chemical name of common salt?", "a": "SODIUM CHLORIDE", "opts": ["SODIUM CHLORIDE", "POTASSIUM NITRATE", "CALCIUM CARBONATE"]},
    {"id": "q131", "q": "Which is the longest river in Asia?", "a": "YANGTZE", "opts": ["GANGA", "MEKONG", "YANGTZE"]},
    {"id": "q132", "q": "In which year did the French Revolution begin?", "a": "1789", "opts": ["1776", "1789", "1815"]},
    {"id": "q133", "q": "What is the fear of heights called?", "a": "ACROPHOBIA", "opts": ["ACROPHOBIA", "AEROPHOBIA", "CLAUSTROPHOBIA"]},
    {"id": "q134", "q": "How many teeth does an adult human have (including wisdom teeth)?", "a": "32", "opts": ["28", "30", "32"]},
    {"id": "q135", "q": "Which instrument is used to measure earthquake intensity?", "a": "SEISMOGRAPH", "opts": ["BAROMETER", "SEISMOGRAPH", "HYGROMETER"]},
    {"id": "q136", "q": "What is the value of the speed of sound in air (approx)?", "a": "343 M/S", "opts": ["343 M/S", "1000 M/S", "300,000 M/S"]},
    {"id": "q137", "q": "Who was the first person to win two Nobel Prizes in different fields?", "a": "MARIE CURIE", "opts": ["ALBERT EINSTEIN", "MARIE CURIE", "LINUS PAULING"]},
    {"id": "q138", "q": "Which element is used in pencils?", "a": "GRAPHITE", "opts": ["LEAD", "GRAPHITE", "CARBON"]},
    {"id": "q139", "q": "What is the capital of Brazil?", "a": "BRASILIA", "opts": ["RIO DE JANEIRO", "SAO PAULO", "BRASILIA"]},
    {"id": "q140", "q": "How many hearts does an earthworm have?", "a": "5", "opts": ["1", "5", "0"]},
    {"id": "q141", "q": "Which is the smallest bone in the human body?", "a": "STAPES", "opts": ["STAPES", "NASAL BONE", "PHALANGE"]},
    {"id": "q142", "q": "What is the most dense planet in our solar system?", "a": "EARTH", "opts": ["JUPITER", "EARTH", "SATURN"]},
    {"id": "q143", "q": "Who invented the telephone?", "a": "ALEXANDER GRAHAM BELL", "opts": ["THOMAS EDISON", "ALEXANDER GRAHAM BELL", "NIKOLA TESLA"]},
    {"id": "q144", "q": "What is the boiling point of water at sea level?", "a": "100Â°C", "opts": ["90Â°C", "100Â°C", "120Â°C"]},
    {"id": "q145", "q": "Which gas is used in fire extinguishers?", "a": "CARBON DIOXIDE", "opts": ["NITROGEN", "OXYGEN", "CARBON DIOXIDE"]},
    {"id": "q146", "q": "What is the currency of Russia?", "a": "RUBLE", "opts": ["YEN", "RUBLE", "DINAR"]},
    {"id": "q147", "q": "How many players are on a basketball team on court?", "a": "5", "opts": ["5", "6", "11"]},
    {"id": "q148", "q": "Which is the tallest grass in the world?", "a": "BAMBOO", "opts": ["WHEAT", "SUGARCANE", "BAMBOO"]},
    {"id": "q149", "q": "Who painted the 'The Last Supper'?", "a": "LEONARDO DA VINCI", "opts": ["PICASSO", "LEONARDO DA VINCI", "MICHELANGELO"]},
    {"id": "q150", "q": "Which is the largest organ in the human body?", "a": "SKIN", "opts": ["LIVER", "SKIN", "INTESTINE"]},
    {"id": "q151", "q": "What is the most common element in the universe?", "a": "HYDROGEN", "opts": ["OXYGEN", "HYDROGEN", "HELIUM"]},
    {"id": "q152", "q": "In which city is the Burj Khalifa located?", "a": "DUBAI", "opts": ["ABU DHABI", "DUBAI", "RIYADH"]},
    {"id": "q153", "q": "How many oceans are there on Earth?", "a": "5", "opts": ["4", "5", "7"]},
    {"id": "q154", "q": "What is the primary gas in the Sun?", "a": "HYDROGEN", "opts": ["HELIUM", "HYDROGEN", "OXYGEN"]},
    {"id": "q155", "q": "Which animal is the symbol of the WWF?", "a": "GIANT PANDA", "opts": ["TIGER", "GIANT PANDA", "ELEPHANT"]},
    {"id": "q156", "q": "What is the capital of Germany?", "a": "BERLIN", "opts": ["MUNICH", "BERLIN", "HAMBURG"]},
    {"id": "q157", "q": "How many states does the USA have?", "a": "50", "opts": ["48", "50", "52"]},
    {"id": "q158", "q": "Which planet is closest to the Sun?", "a": "MERCURY", "opts": ["VENUS", "MERCURY", "EARTH"]},
    {"id": "q159", "q": "Who wrote 'Romeo and Juliet'?", "a": "SHAKESPEARE", "opts": ["CHARLES DICKENS", "SHAKESPEARE", "MARK TWAIN"]},
    {"id": "q160", "q": "What is the chemical symbol for Silver?", "a": "Ag", "opts": ["Au", "Ag", "Si"]},
    {"id": "q161", "q": "Which country is the smallest in the world?", "a": "VATICAN CITY", "opts": ["MONACO", "VATICAN CITY", "SAN MARINO"]},
    {"id": "q162", "q": "What is the currency of the UK?", "a": "POUND", "opts": ["EURO", "POUND", "DOLLAR"]},
    {"id": "q163", "q": "Which is the largest desert in the world?", "a": "ANTARCTIC DESERT", "opts": ["SAHARA", "GOBI", "ANTARCTIC DESERT"]},
    {"id": "q164", "q": "How many bones are in a shark's body?", "a": "0", "opts": ["0", "200", "500"]},
    {"id": "q165", "q": "What is the capital of France?", "a": "PARIS", "opts": ["LYON", "MARSEILLE", "PARIS"]},
    {"id": "q166", "q": "Who was the first man to walk on the moon?", "a": "NEIL ARMSTRONG", "opts": ["BUZZ ALDRIN", "NEIL ARMSTRONG", "YURI GAGARIN"]},
    {"id": "q167", "q": "What is the largest internal organ in humans?", "a": "LIVER", "opts": ["HEART", "LIVER", "KIDNEY"]},
    {"id": "q168", "q": "Which is the largest planet in our solar system?", "a": "JUPITER", "opts": ["SATURN", "JUPITER", "EARTH"]},
    {"id": "q169", "q": "How many days are in a leap year?", "a": "366", "opts": ["365", "366", "367"]},
    {"id": "q170", "q": "What is the capital of Japan?", "a": "TOKYO", "opts": ["KYOTO", "OSAKA", "TOKYO"]},
    {"id": "q171", "q": "Who invented the light bulb?", "a": "THOMAS EDISON", "opts": ["THOMAS EDISON", "NIKOLA TESLA", "GRAHAM BELL"]},
    {"id": "q172", "q": "Which is the longest river in the world?", "a": "NILE", "opts": ["AMAZON", "NILE", "MISSISSIPPI"]},
    {"id": "q173", "q": "What is the capital of India?", "a": "NEW DELHI", "opts": ["MUMBAI", "NEW DELHI", "KOLKATA"]},
    {"id": "q174", "q": "How many colors are in a rainbow?", "a": "7", "opts": ["6", "7", "8"]},
    {"id": "q175", "q": "Which planet is known as the Blue Planet?", "a": "EARTH", "opts": ["NEPTUNE", "URANUS", "EARTH"]},
    
    # --- TRICKY & LOGIC ---
    {"id": "q16", "q": "How many months have 28 days?", "a": "ALL 12", "opts": ["1 (FEBRUARY)", "6", "ALL 12"]},
    {"id": "q17", "q": "What has keys but can't open locks?", "a": "PIANO", "opts": ["DOOR", "PIANO", "TREASURE"]},
    {"id": "q18", "q": "If you are running in a race and pass the person in 2nd place, what place are you in?", "a": "2ND PLACE", "opts": ["1ST PLACE", "2ND PLACE", "3RD PLACE"]},
    {"id": "q19", "q": "I speak without a mouth and hear without ears. What am I?", "a": "ECHO", "opts": ["WIND", "ECHO", "GHOST"]},
    {"id": "q20", "q": "Which is heavier: a ton of bricks or a ton of feathers?", "a": "BOTH EQUAL", "opts": ["BRICKS", "FEATHERS", "BOTH EQUAL"]},

        # --- EXTREME HARD & TRIVIA (Brain Teasers) ---
    {"id": "q26", "q": "What was the original name of Roblox when it was created in 2004?", "a": "DYNABLOCKS", "opts": ["ROBLOXIA", "DYNABLOCKS", "BLOCKLAND"]},
    {"id": "q27", "q": "Which element has the highest melting point on the periodic table?", "a": "TUNGSTEN", "opts": ["TITANIUM", "TUNGSTEN", "OSMIUM"]},
    {"id": "q28", "q": "What is the most abundant protein found in the human body?", "a": "COLLAGEN", "opts": ["KERATIN", "COLLAGEN", "HEMOGLOBIN"]},
    {"id": "q29", "q": "In Python, which magic method is used to initialize a new object?", "a": "__init__", "opts": ["__start__", "__init__", "__main__"]},
    {"id": "q30", "q": "What is the rarest naturally occurring element in the Earth's crust?", "a": "ASTATINE", "opts": ["FRANCIUM", "ASTATINE", "RHODIUM"]},
    
    # --- DEEP GENERAL KNOWLEDGE ---
    {"id": "q31", "q": "What is the specific name for the dot over the lowercase letters 'i' and 'j'?", "a": "TITTLE", "opts": ["JOT", "TITTLE", "PUNCT"]},
    {"id": "q32", "q": "Which country has the most time zones in the world (including overseas territories)?", "a": "FRANCE", "opts": ["RUSSIA", "FRANCE", "UNITED STATES"]},
    {"id": "q33", "q": "What is the name of the supermassive black hole at the center of the Milky Way?", "a": "SAGITTARIUS A*", "opts": ["ANDROMEDA M31", "SAGITTARIUS A*", "CYGNUS X-1"]},
    {"id": "q34", "q": "I have branches, but no fruit, trunk, or leaves. What am I?", "a": "A BANK", "opts": ["A RIVER", "A BANK", "A LIBRARY"]},
    {"id": "q35", "q": "What is the hardest substance produced in the human body?", "a": "TOOTH ENAMEL", "opts": ["BONE", "TOOTH ENAMEL", "KERATIN"]},
    
    # --- ADVANCED LOGIC & HISTORY ---
    {"id": "q36", "q": "Which is the only continent situated in all four hemispheres of the Earth?", "a": "AFRICA", "opts": ["AFRICA", "ASIA", "SOUTH AMERICA"]},
    {"id": "q37", "q": "What was the name of the very first computer virus created in 1971?", "a": "CREEPER", "opts": ["ILOVEYOU", "CREEPER", "MORRIS"]},
    {"id": "q38", "q": "What is the next number in this logic sequence: 2, 6, 12, 20, 30, ...?", "a": "42", "opts": ["40", "42", "44"]},
    {"id": "q39", "q": "Who was the only US President to serve two non-consecutive terms?", "a": "GROVER CLEVELAND", "opts": ["THEODORE ROOSEVELT", "GROVER CLEVELAND", "WOODROW WILSON"]},
    {"id": "q40", "q": "How many keys are there on a standard grand piano?", "a": "88", "opts": ["76", "88", "96"]},

        # --- GEOGRAPHY & GLOBAL EXTREMES (Hard) ---
    {"id": "q46", "q": "Which country officially has the most time zones in the world?", "a": "FRANCE", "opts": ["RUSSIA", "USA", "FRANCE"]},
    {"id": "q47", "q": "Which is the only continent situated in all four hemispheres?", "a": "AFRICA", "opts": ["ASIA", "AFRICA", "EUROPE"]},
    {"id": "q48", "q": "What is the smallest ocean in the world?", "a": "ARCTIC OCEAN", "opts": ["INDIAN", "ARCTIC OCEAN", "SOUTHERN"]},
    {"id": "q49", "q": "What is the capital city of Canada?", "a": "OTTAWA", "opts": ["TORONTO", "OTTAWA", "VANCOUVER"]},
    {"id": "q50", "q": "Which African river crosses the Equator twice?", "a": "CONGO RIVER", "opts": ["AMAZON", "NILE", "CONGO RIVER"]},
    {"id": "q51", "q": "In which country can you find the world's largest salt flat, Salar de Uyuni?", "a": "BOLIVIA", "opts": ["CHILE", "BOLIVIA", "ARGENTINA"]},
    {"id": "q52", "q": "Which country is known as the 'Land of a Thousand Lakes'?", "a": "FINLAND", "opts": ["CANADA", "FINLAND", "NORWAY"]},

    # --- ADVANCED SCIENCE & BODY ---
    {"id": "q53", "q": "What is the only human organ capable of natural regeneration of lost tissue?", "a": "LIVER", "opts": ["HEART", "LIVER", "KIDNEY"]},
    {"id": "q54", "q": "Which subatomic particle has no electric charge?", "a": "NEUTRON", "opts": ["PROTON", "ELECTRON", "NEUTRON"]},
    {"id": "q55", "q": "What is the most abundant gas in the Earth's atmosphere?", "a": "NITROGEN", "opts": ["OXYGEN", "NITROGEN", "ARGON"]},
    {"id": "q56", "q": "Which part of the human brain is responsible for high-level cognitive skills?", "a": "PREFRONTAL CORTEX", "opts": ["CEREBELLUM", "PREFRONTAL CORTEX", "OCCIPITAL LOBE"]},
    {"id": "q57", "q": "What is the velocity of light in a vacuum (approx)?", "a": "300,000 KM/S", "opts": ["150,000 KM/S", "300,000 KM/S", "1,000,000 KM/S"]},
    {"id": "q58", "q": "Which metal has the symbol 'Sn' on the periodic table?", "a": "TIN", "opts": ["SILVER", "TIN", "ANTIMONY"]},

    # --- TECH, COMPUTING & HISTORY ---
    {"id": "q59", "q": "What does 'HTTP' status code 418 represent as an April Fools' joke?", "a": "I'M A TEAPOT", "opts": ["GATEWAY TIMEOUT", "I'M A TEAPOT", "PAYMENT REQUIRED"]},
    {"id": "q60", "q": "Who is credited with inventing the World Wide Web (WWW)?", "a": "TIM BERNERS-LEE", "opts": ["BILL GATES", "TIM BERNERS-LEE", "STEVE JOBS"]},
    {"id": "q61", "q": "In which year was the first domain name ever registered?", "a": "1885", "opts": ["1983", "1985", "1991"]},
    {"id": "q62", "q": "Which cryptographic hash function was designed by the NSA?", "a": "SHA-256", "opts": ["MD5", "SHA-256", "BCRYPT"]},
    {"id": "q63", "q": "What was the name of the first artificial satellite launched into space?", "a": "SPUTNIK 1", "opts": ["APOLLO 11", "SPUTNIK 1", "VOYAGER 1"]},

    # --- ELITE LOGIC & MATHEMATICS ---
    {"id": "q64", "q": "What is the value of 'Pi' (Ï€) to the first 5 decimal places?", "a": "3.14159", "opts": ["3.14159", "3.14162", "3.14258"]},
    {"id": "q65", "q": "How many bits are there in a single 'Kilobyte' (KB) in standard binary?", "a": "8192", "opts": ["1024", "8000", "8192"]},
    {"id": "q66", "q": "What is the only even prime number?", "a": "2", "opts": ["0", "2", "4"]},
    {"id": "q67", "q": "What is the sum of the first three prime numbers?", "a": "10", "opts": ["6", "10", "15"]},

        # --- GLOBAL AFFAIRS & GEOPOLITICS ---
    {"id": "q176", "q": "Which country officially withdrew from the European Union (Brexit) in 2020?", "a": "UNITED KINGDOM", "opts": ["FRANCE", "UNITED KINGDOM", "GERMANY"]},
    {"id": "q177", "q": "What is the capital city of Ukraine?", "a": "KYIV", "opts": ["MOSCOW", "KYIV", "WARSAW"]},
    {"id": "q178", "q": "Which country shares the longest border with India?", "a": "BANGLADESH", "opts": ["CHINA", "PAKISTAN", "BANGLADESH"]},
    {"id": "q179", "q": "Who is the current President of France (2026)?", "a": "EMMANUEL MACRON", "opts": ["NICOLAS SARKOZY", "EMMANUEL MACRON", "MARINE LE PEN"]},
    {"id": "q180", "q": "Which ocean is known as the 'Sargasso Sea' located in?", "a": "ATLANTIC OCEAN", "opts": ["INDIAN OCEAN", "PACIFIC OCEAN", "ATLANTIC OCEAN"]},
    {"id": "q181", "q": "What is the official language of Brazil?", "a": "PORTUGUESE", "opts": ["SPANISH", "PORTUGUESE", "BRAZILIAN"]},

    # --- ADVANCED BIOLOGY & HUMAN BODY ---
    {"id": "q182", "q": "Which blood type is known as the 'Universal Donor'?", "a": "O NEGATIVE", "opts": ["AB POSITIVE", "O NEGATIVE", "A POSITIVE"]},
    {"id": "q183", "q": "What is the scientific name for the collarbone?", "a": "CLAVICLE", "opts": ["SCAPULA", "CLAVICLE", "STERNUM"]},
    {"id": "q184", "q": "Which organ in the human body produces insulin?", "a": "PANCREAS", "opts": ["LIVER", "PANCREAS", "STOMACH"]},
    {"id": "q185", "q": "How many pairs of chromosomes do humans typically have?", "a": "23", "opts": ["23", "46", "22"]},
    {"id": "q186", "q": "What is the main pigment responsible for skin color?", "a": "MELANIN", "opts": ["KERATIN", "MELANIN", "HEMOGLOBIN"]},
    {"id": "q187", "q": "Which part of the eye is responsible for color vision?", "a": "CONES", "opts": ["RODS", "CONES", "RETINA"]},

    # --- SPACE & ASTROPHYSICS ---
    {"id": "q188", "q": "What is the speed of light in kilometers per second (approx)?", "a": "300,000", "opts": ["150,000", "300,000", "500,000"]},
    {"id": "q189", "q": "Which planet has a Great Red Spot?", "a": "JUPITER", "opts": ["MARS", "JUPITER", "SATURN"]},
    {"id": "q190", "q": "What is the name of the first woman to go into space?", "a": "VALENTINA TERESHKOVA", "opts": ["SALLY RIDE", "VALENTINA TERESHKOVA", "KALPANA CHAWLA"]},
    {"id": "q191", "q": "Which star is the closest to Earth after the Sun?", "a": "PROXIMA CENTAURI", "opts": ["SIRIUS", "ALPHA CENTAURI", "PROXIMA CENTAURI"]},
    {"id": "q192", "q": "What is the study of the universe called?", "a": "COSMOLOGY", "opts": ["ASTRONOMY", "COSMOLOGY", "ASTROLOGY"]},
    {"id": "q193", "q": "Which galaxy is the Milky Way set to collide with in billions of years?", "a": "ANDROMEDA", "opts": ["SOMBRERO", "ANDROMEDA", "TRIANGULUM"]},

    # --- TECHNOLOGY & DATA ---
    {"id": "q194", "q": "What does 'RAM' stand for in computing?", "a": "RANDOM ACCESS MEMORY", "opts": ["READ ACCESS MEMORY", "RANDOM ACCESS MEMORY", "RAPID ACCESS MEMORY"]},
    {"id": "q195", "q": "Which company created the iPhone?", "a": "APPLE", "opts": ["GOOGLE", "SAMSUNG", "APPLE"]},
    {"id": "q196", "q": "In networking, what is the default port for HTTP?", "a": "80", "opts": ["21", "80", "443"]},
    {"id": "q197", "q": "Who is the co-founder of Microsoft along with Bill Gates?", "a": "PAUL ALLEN", "opts": ["STEVE JOBS", "PAUL ALLEN", "MARK ZUCKERBERG"]},
    {"id": "q198", "q": "What is the main language used for Android app development?", "a": "KOTLIN", "opts": ["SWIFT", "KOTLIN", "PHP"]},
    {"id": "q199", "q": "Which social media platform was formerly known as 'Twitter'?", "a": "X", "opts": ["META", "X", "THREADS"]},

    # --- HISTORY & CULTURE ---
    {"id": "q200", "q": "Who was the first President of the United States?", "a": "GEORGE WASHINGTON", "opts": ["ABRAHAM LINCOLN", "GEORGE WASHINGTON", "THOMAS JEFFERSON"]},
    {"id": "q201", "q": "In which year did World War II end?", "a": "1945", "opts": ["1918", "1944", "1945"]},
    {"id": "q202", "q": "Who was the 'Maid of Orleans'?", "a": "JOAN OF ARC", "opts": ["QUEEN VICTORIA", "JOAN OF ARC", "MARIE ANTOINETTE"]},
    {"id": "q203", "q": "Which ancient civilization built the Great Wall?", "a": "CHINA", "opts": ["EGYPT", "CHINA", "ROME"]},
    {"id": "q204", "q": "Who wrote 'The Communist Manifesto'?", "a": "KARL MARX", "opts": ["ADAM SMITH", "KARL MARX", "LENIN"]},
    {"id": "q205", "q": "What was the currency of Germany before the Euro?", "a": "DEUTSCHE MARK", "opts": ["FRANC", "DEUTSCHE MARK", "LIRA"]},

    # --- GENERAL KNOWLEDGE MIX (Q206 - Q275) ---
    {"id": "q206", "q": "What is the chemical symbol for Iron?", "a": "Fe", "opts": ["Ir", "Fe", "In"]},
    {"id": "q207", "q": "Which is the largest bird in the world?", "a": "OSTRICH", "opts": ["EMU", "OSTRICH", "EAGLE"]},
    {"id": "q208", "q": "What is the capital of Italy?", "a": "ROME", "opts": ["VENICE", "ROME", "MILAN"]},
    {"id": "q209", "q": "How many strings are on a standard violin?", "a": "4", "opts": ["4", "5", "6"]},
    {"id": "q210", "q": "Which gas is known as the 'Silent Killer'?", "a": "CARBON MONOXIDE", "opts": ["CARBON DIOXIDE", "CARBON MONOXIDE", "NITROGEN"]},
    {"id": "q211", "q": "What is the capital of Japan?", "a": "TOKYO", "opts": ["KYOTO", "TOKYO", "OSAKA"]},
    {"id": "q212", "q": "Who discovered Penicillin?", "a": "ALEXANDER FLEMING", "opts": ["LOUIS PASTEUR", "ALEXANDER FLEMING", "JOSEPH LISTER"]},
    {"id": "q213", "q": "Which planet is famous for its rings?", "a": "SATURN", "opts": ["JUPITER", "SATURN", "URANUS"]},
    {"id": "q214", "q": "What is the largest country by area?", "a": "RUSSIA", "opts": ["CANADA", "USA", "RUSSIA"]},
    {"id": "q215", "q": "Who painted 'The Starry Night'?", "a": "VINCENT VAN GOGH", "opts": ["CLAUDE MONET", "VINCENT VAN GOGH", "PABLO PICASSO"]},
    {"id": "q216", "q": "What is the capital of Egypt?", "a": "CAIRO", "opts": ["ALEXANDRIA", "CAIRO", "GIZA"]},
    {"id": "q217", "q": "Which is the smallest planet in our solar system?", "a": "MERCURY", "opts": ["MERCURY", "MARS", "VENUS"]},
    {"id": "q218", "q": "Who invented the telephone?", "a": "ALEXANDER GRAHAM BELL", "opts": ["THOMAS EDISON", "ALEXANDER GRAHAM BELL", "NIKOLA TESLA"]},
    {"id": "q219", "q": "What is the chemical formula for water?", "a": "H2O", "opts": ["CO2", "H2O", "O2"]},
    {"id": "q220", "q": "How many continents are there?", "a": "7", "opts": ["5", "6", "7"]},
    {"id": "q221", "q": "Which is the longest river in the world?", "a": "NILE", "opts": ["AMAZON", "NILE", "YANGTZE"]},
    {"id": "q222", "q": "Who was the first man in space?", "a": "YURI GAGARIN", "opts": ["NEIL ARMSTRONG", "YURI GAGARIN", "BUZZ ALDRIN"]},
    {"id": "q223", "q": "What is the capital of Spain?", "a": "MADRID", "opts": ["BARCELONA", "MADRID", "VALENCIA"]},
    {"id": "q224", "q": "Which is the largest desert in the world?", "a": "ANTARCTIC DESERT", "opts": ["SAHARA", "GOBI", "ANTARCTIC DESERT"]},
    {"id": "q225", "q": "What is the symbol for Gold?", "a": "Au", "opts": ["Ag", "Au", "Gd"]},
    {"id": "q226", "q": "How many colors are in a rainbow?", "a": "7", "opts": ["6", "7", "8"]},
    {"id": "q227", "q": "Who wrote 'Hamlet'?", "a": "WILLIAM SHAKESPEARE", "opts": ["CHARLES DICKENS", "WILLIAM SHAKESPEARE", "MARK TWAIN"]},
    {"id": "q228", "q": "What is the capital of Australia?", "a": "CANBERRA", "opts": ["SYDNEY", "MELBOURNE", "CANBERRA"]},
    {"id": "q229", "q": "Which planet is known as the Red Planet?", "a": "MARS", "opts": ["VENUS", "MARS", "JUPITER"]},
    {"id": "q230", "q": "How many bones are in the human body?", "a": "206", "opts": ["200", "206", "210"]},
    {"id": "q231", "q": "What is the capital of Germany?", "a": "BERLIN", "opts": ["MUNICH", "BERLIN", "HAMBURG"]},
    {"id": "q232", "q": "Which is the largest ocean on Earth?", "a": "PACIFIC OCEAN", "opts": ["ATLANTIC OCEAN", "PACIFIC OCEAN", "INDIAN OCEAN"]},
    {"id": "q233", "q": "Who discovered gravity?", "a": "ISAAC NEWTON", "opts": ["ALBERT EINSTEIN", "ISAAC NEWTON", "GALILEO GALILEI"]},
    {"id": "q234", "q": "What is the capital of Canada?", "a": "OTTAWA", "opts": ["TORONTO", "OTTAWA", "VANCOUVER"]},
    {"id": "q235", "q": "Which gas do plants absorb?", "a": "CARBON DIOXIDE", "opts": ["OXYGEN", "CARBON DIOXIDE", "NITROGEN"]},
    {"id": "q236", "q": "What is the capital of Russia?", "a": "MOSCOW", "opts": ["ST. PETERSBURG", "MOSCOW", "KYIV"]},
    {"id": "q237", "q": "How many strings are on a standard guitar?", "a": "6", "opts": ["4", "5", "6"]},
    {"id": "q238", "q": "What is the currency of the USA?", "a": "DOLLAR", "opts": ["EURO", "POUND", "DOLLAR"]},
    {"id": "q239", "q": "Who painted the 'Mona Lisa'?", "a": "LEONARDO DA VINCI", "opts": ["MICHELANGELO", "LEONARDO DA VINCI", "RAPHAEL"]},
    {"id": "q240", "q": "What is the capital of France?", "a": "PARIS", "opts": ["MARSEILLE", "LYON", "PARIS"]},
    {"id": "q241", "q": "Which is the tallest mountain in the world?", "a": "MOUNT EVEREST", "opts": ["K2", "MOUNT EVEREST", "LHOTSE"]},
    {"id": "q242", "q": "How many days are in a leap year?", "a": "366", "opts": ["364", "365", "366"]},
    {"id": "q243", "q": "What is the symbol for Silver?", "a": "Ag", "opts": ["Ag", "Au", "Si"]},
    {"id": "q244", "q": "Who is the author of 'Harry Potter'?", "a": "J.K. ROWLING", "opts": ["J.R.R. TOLKIEN", "J.K. ROWLING", "GEORGE R.R. MARTIN"]},
    {"id": "q245", "q": "What is the capital of India?", "a": "NEW DELHI", "opts": ["MUMBAI", "NEW DELHI", "KOLKATA"]},
    {"id": "q246", "q": "Which planet is closest to the Sun?", "a": "MERCURY", "opts": ["MERCURY", "VENUS", "EARTH"]},
    {"id": "q247", "q": "How many states are in the USA?", "a": "50", "opts": ["48", "49", "50"]},
    {"id": "q248", "q": "What is the capital of China?", "a": "BEIJING", "opts": ["SHANGHAI", "BEIJING", "GUANGZHOU"]},
    {"id": "q249", "q": "Which gas is most abundant in the atmosphere?", "a": "NITROGEN", "opts": ["OXYGEN", "NITROGEN", "ARGON"]},
    {"id": "q250", "q": "What is the capital of the United Kingdom?", "a": "LONDON", "opts": ["MANCHESTER", "LONDON", "EDINBURGH"]},
    {"id": "q251", "q": "Who invented the light bulb?", "a": "THOMAS EDISON", "opts": ["THOMAS EDISON", "NIKOLA TESLA", "ALEXANDER GRAHAM BELL"]},
    {"id": "q252", "q": "What is the largest animal on Earth?", "a": "BLUE WHALE", "opts": ["ELEPHANT", "BLUE WHALE", "GIRAFFE"]},
    {"id": "q253", "q": "What is the capital of Brazil?", "a": "BRASILIA", "opts": ["RIO DE JANEIRO", "BRASILIA", "SAO PAULO"]},
    {"id": "q254", "q": "How many minutes are in an hour?", "a": "60", "opts": ["50", "60", "100"]},
    {"id": "q255", "q": "What is the chemical symbol for Oxygen?", "a": "O", "opts": ["Ox", "O", "Oz"]},
    {"id": "q256", "q": "Who was the first person to win a Nobel Prize?", "a": "WILHELM RONTGEN", "opts": ["WILHELM RONTGEN", "MARIE CURIE", "ALBERT EINSTEIN"]},
    {"id": "q257", "q": "What is the capital of Mexico?", "a": "MEXICO CITY", "opts": ["MEXICO CITY", "CANCUN", "GUADALAJARA"]},
    {"id": "q258", "q": "How many years are in a decade?", "a": "10", "opts": ["10", "50", "100"]},
    {"id": "q259", "q": "What is the capital of Argentina?", "a": "BUENOS AIRES", "opts": ["SANTIAGO", "BUENOS AIRES", "LIMA"]},
    {"id": "q260", "q": "Which planet is known as the Earth's twin?", "a": "VENUS", "opts": ["MARS", "VENUS", "JUPITER"]},
    {"id": "q261", "q": "What is the capital of South Korea?", "a": "SEOUL", "opts": ["BUSAN", "SEOUL", "INCHEON"]},
    {"id": "q262", "q": "How many hearts does an octopus have?", "a": "3", "opts": ["1", "2", "3"]},
    {"id": "q263", "q": "What is the capital of Turkey?", "a": "ANKARA", "opts": ["ISTANBUL", "ANKARA", "IZMIR"]},
    {"id": "q264", "q": "Which is the smallest country in the world?", "a": "VATICAN CITY", "opts": ["MONACO", "VATICAN CITY", "SAN MARINO"]},
    {"id": "q265", "q": "What is the capital of Egypt?", "a": "CAIRO", "opts": ["ALEXANDRIA", "CAIRO", "LUXOR"]},
    {"id": "q266", "q": "Who wrote 'The Great Gatsby'?", "a": "F. SCOTT FITZGERALD", "opts": ["ERNEST HEMINGWAY", "F. SCOTT FITZGERALD", "WILLIAM FAULKNER"]},
    {"id": "q267", "q": "What is the capital of Thailand?", "a": "BANGKOK", "opts": ["PHUKET", "BANGKOK", "CHIANG MAI"]},
    {"id": "q268", "q": "Which is the largest organ in the human body?", "a": "SKIN", "opts": ["LIVER", "SKIN", "HEART"]},
    {"id": "q269", "q": "What is the capital of Switzerland?", "a": "BERN", "opts": ["ZURICH", "BERN", "GENEVA"]},
    {"id": "q270", "q": "Who is the founder of Amazon?", "a": "JEFF BEZOS", "opts": ["ELON MUSK", "JEFF BEZOS", "BILL GATES"]},
    {"id": "q271", "q": "What is the capital of Greece?", "a": "ATHENS", "opts": ["THESSALONIKI", "ATHENS", "PATRAS"]},
    {"id": "q272", "q": "How many players are on a soccer team?", "a": "11", "opts": ["10", "11", "12"]},
    {"id": "q273", "q": "What is the capital of Portugal?", "a": "LISBON", "opts": ["PORTO", "LISBON", "FARO"]},
    {"id": "q274", "q": "Which planet is the furthest from the Sun?", "a": "NEPTUNE", "opts": ["URANUS", "NEPTUNE", "PLUTO"]},
    {"id": "q275", "q": "What is the capital of New Zealand?", "a": "WELLINGTON", "opts": ["AUCKLAND", "WELLINGTON", "CHRISTCHURCH"]},

        # ==========================================
    # ğŸ•‰ï¸ HINDU MYTHOLOGY: EXTREME HARD (RAMAYANA)
    # ==========================================
    {"id": "q276", "q": "What was the name of Ravana's primary sword in the Ramayana?", "a": "CHANDRAHAS", "opts": ["BHAVANI", "CHANDRAHAS", "KHARG"]},
    {"id": "q277", "q": "Which deity gifted the invincible 'Chandrahas' sword to Ravana?", "a": "LORD SHIVA", "opts": ["LORD BRAHMA", "LORD SHIVA", "LORD VISHNU"]},
    {"id": "q278", "q": "What was the name of Lord Rama's biological elder sister?", "a": "SHANTA", "opts": ["URMILA", "SHANTA", "MANDAVI"]},
    {"id": "q279", "q": "Which sage did Lord Rama's sister, Shanta, marry?", "a": "RISHYASHRINGA", "opts": ["DURVASA", "RISHYASHRINGA", "VISHWAMITRA"]},
    {"id": "q280", "q": "What was the name of Jatayu's elder brother who revealed Sita's location to the Vanara army?", "a": "SAMPATI", "opts": ["GARUDA", "SAMPATI", "ARUNA"]},
    {"id": "q281", "q": "Who was the father of the demon king Ravana?", "a": "VISHRAVA", "opts": ["PULASTYA", "VISHRAVA", "SUMALI"]},
    {"id": "q282", "q": "What was the name of Indrajit's (Meghnad's) wife?", "a": "SULOCHANA", "opts": ["MANDODARI", "SULOCHANA", "TARA"]},
    {"id": "q283", "q": "Who was the mother of Shatrughna?", "a": "SUMITRA", "opts": ["KAIKEYI", "SUMITRA", "KAUSHALYA"]},
    {"id": "q284", "q": "While Lakshmana's wife was Urmila, what was the name of Bharata's wife?", "a": "MANDAVI", "opts": ["SHRUTAKIRTI", "MANDAVI", "SITA"]},
    {"id": "q285", "q": "What was the name of Shatrughna's wife?", "a": "SHRUTAKIRTI", "opts": ["MANDAVI", "SHRUTAKIRTI", "MALVIKA"]},
    {"id": "q286", "q": "What was the actual birth name of King Janaka, the father of Sita?", "a": "SIRADHWAJA", "opts": ["KUSHADHWAJA", "SIRADHWAJA", "NIMI"]},
    {"id": "q287", "q": "Which deity cursed Kumbhakarna to sleep for six months at a time?", "a": "LORD BRAHMA", "opts": ["LORD INDRA", "LORD BRAHMA", "SARASWATI"]},
    {"id": "q288", "q": "What was the name of Lord Shiva's bow that Rama broke during Sita's Swayamvar?", "a": "PINAKA", "opts": ["KODANDA", "PINAKA", "SHARANGA"]},
    {"id": "q289", "q": "What was the name of Lord Rama's personal bow?", "a": "KODANDA", "opts": ["PINAKA", "KODANDA", "VIJAYA"]},
    {"id": "q290", "q": "Who was the original owner of the Pushpaka Vimana before Ravana stole it?", "a": "KUBERA", "opts": ["INDRA", "KUBERA", "VAYU"]},
    {"id": "q291", "q": "Which demoness protected and comforted Sita in the Ashoka Vatika?", "a": "TRIJATA", "opts": ["SURASA", "TRIJATA", "SIMHIKA"]},
    {"id": "q292", "q": "What was the name of the monkey king Vali's wife?", "a": "TARA", "opts": ["RUMA", "TARA", "ANJANA"]},
    {"id": "q293", "q": "What was the name of Sugriva's wife?", "a": "RUMA", "opts": ["TARA", "RUMA", "SHABARI"]},
    {"id": "q294", "q": "Who was the maternal grandfather of Ravana?", "a": "SUMALI", "opts": ["MARICHA", "SUMALI", "SUBAHU"]},
    {"id": "q295", "q": "Who was the mother of Ravana?", "a": "KAIKESI", "opts": ["TATAKA", "KAIKESI", "MANDODARI"]},
    {"id": "q296", "q": "What was the name of Shurpanakha's husband, who was accidentally killed by Ravana?", "a": "VIDYUTJIHVA", "opts": ["KHARA", "VIDYUTJIHVA", "DUSHANA"]},
    {"id": "q297", "q": "Which sage taught Lord Rama the 'Aditya Hrudayam' hymn before his final battle with Ravana?", "a": "AGASTYA", "opts": ["VASISHTHA", "AGASTYA", "VISHWAMITRA"]},
    {"id": "q298", "q": "Which divine weapon did Lakshmana use to finally kill Indrajit?", "a": "INDRASTRA", "opts": ["BRAHMASTRA", "INDRASTRA", "PASHUPATASTRA"]},
    {"id": "q299", "q": "Which sage cursed Ahalya to turn into a stone?", "a": "GAUTAMA", "opts": ["DURVASA", "GAUTAMA", "BHRIGU"]},
    {"id": "q300", "q": "From which kingdom did Kaikeyi's maid, Manthara, originally come?", "a": "KEKAYA", "opts": ["AYODHYA", "KEKAYA", "MITHILA"]},
    {"id": "q301", "q": "Who was the divine architect that built the golden city of Lanka?", "a": "VISHWAKARMA", "opts": ["MAYA DANAVA", "VISHWAKARMA", "BRAHMA"]},
    {"id": "q302", "q": "What was the name of the mountain Hanuman lifted to bring the Sanjeevani herb?", "a": "DRONAGIRI", "opts": ["KAILASH", "DRONAGIRI", "GANDHAMADAN"]},
    {"id": "q303", "q": "Nala and Nila, the builders of the Ram Setu, were the sons/avatars of which deity?", "a": "VISHWAKARMA", "opts": ["AGNI", "VISHWAKARMA", "VARUNA"]},
    {"id": "q304", "q": "Who was the father of King Dasharatha?", "a": "AJA", "opts": ["RAGHU", "AJA", "IKSHVAKU"]},
    {"id": "q305", "q": "Which is the shortest Kanda (book/chapter) in the epic Ramayana?", "a": "KISHKINDHA KANDA", "opts": ["ARANYA KANDA", "KISHKINDHA KANDA", "SUNDARA KANDA"]},
    {"id": "q306", "q": "Which is the longest Kanda in the epic Ramayana?", "a": "YUDDHA KANDA", "opts": ["BALA KANDA", "YUDDHA KANDA", "AYODHYA KANDA"]},
    {"id": "q307", "q": "What was the original name of Sage Valmiki before he became an ascetic?", "a": "RATNAKAR", "opts": ["SUDAMA", "RATNAKAR", "ANGIRAS"]},
    {"id": "q308", "q": "Who was the mother of the demons Maricha and Subahu?", "a": "TATAKA", "opts": ["SURASA", "TATAKA", "SIMHIKA"]},
    {"id": "q309", "q": "Hanuman's foster father, Kesari, was the king of which Vanara kingdom?", "a": "SUMERU", "opts": ["KISHKINDHA", "SUMERU", "LANKA"]},
    {"id": "q310", "q": "Which sage taught the secret mantras 'Bala' and 'Atibala' to Rama and Lakshmana?", "a": "VISHWAMITRA", "opts": ["VASISHTHA", "VISHWAMITRA", "PARASHURAMA"]},
    {"id": "q311", "q": "What was the name of Mata Shabari's guru?", "a": "MATANGA", "opts": ["AGASTYA", "MATANGA", "BHARADWAJA"]},
    {"id": "q312", "q": "From which village did Bharata rule Ayodhya during Rama's exile?", "a": "NANDIGRAMA", "opts": ["AYODHYA", "NANDIGRAMA", "CHITRAKOOT"]},
    {"id": "q313", "q": "What was Indrajit's original name before he defeated Lord Indra?", "a": "MEGHNAD", "opts": ["VIBHISHAN", "MEGHNAD", "AKSHAYA KUMARA"]},
    {"id": "q314", "q": "Who was the father of the giant divine birds Jatayu and Sampati?", "a": "ARUNA", "opts": ["GARUDA", "ARUNA", "KASHYAPA"]},
    {"id": "q315", "q": "In which forest did the abduction of Sita take place?", "a": "DANDAKARANYA", "opts": ["NIMISHARANYA", "DANDAKARANYA", "KHANDAVA"]},
    {"id": "q316", "q": "What was the name of the boatman king who washed Lord Rama's feet and helped him cross the river?", "a": "GUHA", "opts": ["SUGRIVA", "GUHA", "NISHADA"]},
    {"id": "q317", "q": "Which brother of Ravana was righteous but chose to fight for Lanka instead of joining Rama?", "a": "KUMBHAKARNA", "opts": ["VIBHISHANA", "KUMBHAKARNA", "KHARA"]},
    {"id": "q318", "q": "Which sage cursed Vali that his head would explode if he ever stepped on Mount Rishyamukha?", "a": "MATANGA", "opts": ["DURVASA", "MATANGA", "GAUTAMA"]},
    {"id": "q319", "q": "Who crafted the divine bow of Lord Shiva that was broken by Rama at Sita's Swayamvar?", "a": "VISHWAKARMA", "opts": ["BRAHMA", "VISHWAKARMA", "MAYA DANAVA"]},
    {"id": "q320", "q": "What was the name of King Janaka's brother, whose daughters married Bharata and Shatrughna?", "a": "KUSHADHWAJA", "opts": ["SIRADHWAJA", "KUSHADHWAJA", "NIMI"]},
    {"id": "q321", "q": "Who was the paternal grandfather of Ravana?", "a": "PULASTYA", "opts": ["KASHYAPA", "PULASTYA", "BHRIGU"]},
    {"id": "q322", "q": "Sugriva was the spiritual son of which Hindu deity?", "a": "SURYA", "opts": ["INDRA", "SURYA", "VAYU"]},
    {"id": "q323", "q": "After burning down Lanka, where did Hanuman extinguish the fire on his tail?", "a": "OCEAN (SAMUDRA)", "opts": ["RIVER GANGA", "OCEAN (SAMUDRA)", "LAKE MANASAROVAR"]},
    {"id": "q324", "q": "During his leap to Lanka, which sea-demoness did Hanuman encounter first?", "a": "SURASA", "opts": ["SIMHIKA", "SURASA", "LANKINI"]},
    {"id": "q325", "q": "Which charioteer did Lord Indra send to assist Rama in his final battle against Ravana?", "a": "MATALI", "opts": ["ARUNA", "MATALI", "DARUKA"]},

    # ==========================================
    # ğŸ•‰ï¸ HINDU MYTHOLOGY: EXTREME HARD (MAHABHARATA)
    # ==========================================
    {"id": "q326", "q": "What was the name of Yudhishthira's conch shell in the Mahabharata?", "a": "ANANTAVIJAYA", "opts": ["DEVADATTA", "ANANTAVIJAYA", "PAUNDRA"]},
    {"id": "q327", "q": "What was the name of Arjuna's conch shell?", "a": "DEVADATTA", "opts": ["SUGHOSHA", "DEVADATTA", "PANCHAJANYA"]},
    {"id": "q328", "q": "What was the name of Bhima's conch shell?", "a": "PAUNDRA", "opts": ["PAUNDRA", "MANIPUSHPAKA", "ANANTAVIJAYA"]},
    {"id": "q329", "q": "What was the name of Nakula's conch shell?", "a": "SUGHOSHA", "opts": ["SUGHOSHA", "MANIPUSHPAKA", "DEVADATTA"]},
    {"id": "q330", "q": "What was the name of Sahadeva's conch shell?", "a": "MANIPUSHPAKA", "opts": ["PAUNDRA", "MANIPUSHPAKA", "SUGHOSHA"]},
    {"id": "q331", "q": "What was the name of Lord Krishna's conch shell?", "a": "PANCHAJANYA", "opts": ["SHARANGA", "PANCHAJANYA", "KAUMODAKI"]},
    {"id": "q332", "q": "What was the name of Duryodhana's only biological sister?", "a": "DUHSALA", "opts": ["DUSHANA", "DUHSALA", "UTTARA"]},
    {"id": "q333", "q": "What was the name of Duhsala's husband (Duryodhana's brother-in-law)?", "a": "JAYADRATHA", "opts": ["SHALYA", "JAYADRATHA", "KICHAKA"]},
    {"id": "q334", "q": "Who killed Shakuni during the Kurukshetra war?", "a": "SAHADEVA", "opts": ["NAKULA", "SAHADEVA", "YUDHISHTHIRA"]},
    {"id": "q335", "q": "Who killed Shalya, the commander of the Kaurava army after Karna's death?", "a": "YUDHISHTHIRA", "opts": ["ARJUNA", "YUDHISHTHIRA", "BHIMA"]},
    {"id": "q336", "q": "Who fulfilled the terrifying vow of drinking blood from Dushasana's chest?", "a": "BHIMA", "opts": ["ARJUNA", "BHIMA", "GHATOTKACHA"]},
    {"id": "q337", "q": "Who beheaded Dronacharya during the Mahabharata war?", "a": "DHRISHTADYUMNA", "opts": ["ARJUNA", "DHRISHTADYUMNA", "SHIKHANDI"]},
    {"id": "q338", "q": "Who became the commander-in-chief of the Kaurava army immediately after Bhishma fell?", "a": "DRONACHARYA", "opts": ["KARNA", "DRONACHARYA", "ASHWATTHAMA"]},
    {"id": "q339", "q": "What was the real birth name of Bhishma Pitamah?", "a": "DEVAVRATA", "opts": ["SHANTANU", "DEVAVRATA", "GANGADATTA"]},
    {"id": "q340", "q": "Who was the mother of Sage Ved Vyasa, the author of the Mahabharata?", "a": "SATYAVATI", "opts": ["GANGA", "SATYAVATI", "KUNTI"]},
    {"id": "q341", "q": "Who was the father of Sage Ved Vyasa?", "a": "PARASHARA", "opts": ["VASISHTHA", "PARASHARA", "BHRIGU"]},
    {"id": "q342", "q": "What was the name of Karna's foster father, who was a charioteer?", "a": "ADIRATHA", "opts": ["SHALYA", "ADIRATHA", "SANJAYA"]},
    {"id": "q343", "q": "What was the name of Karna's foster mother?", "a": "RADHA", "opts": ["KUNTI", "RADHA", "VRUSHALI"]},
    {"id": "q344", "q": "What was the name of Karna's divine, unbeatable bow?", "a": "VIJAYA", "opts": ["GANDIVA", "VIJAYA", "SHARANGA"]},
    {"id": "q345", "q": "What was the name of Arjuna's celestial bow?", "a": "GANDIVA", "opts": ["PINAKA", "GANDIVA", "KODANDA"]},
    {"id": "q346", "q": "What was the name of Lord Krishna's divine bow?", "a": "SHARANGA", "opts": ["VIJAYA", "SHARANGA", "SUDARSHANA"]},
    {"id": "q347", "q": "What was the name of the son born to Bhima and the demoness Hidimbi?", "a": "GHATOTKACHA", "opts": ["BARBARIK", "GHATOTKACHA", "IRAVAN"]},
    {"id": "q348", "q": "What was the name of the son born to Arjuna and the Naga princess Ulupi?", "a": "IRAVAN", "opts": ["BABRUVAHANA", "IRAVAN", "ABHIMANYU"]},
    {"id": "q349", "q": "What was the name of Arjuna's son with Princess Chitrangada of Manipur?", "a": "BABRUVAHANA", "opts": ["IRAVAN", "BABRUVAHANA", "SRUTAKARMA"]},
    {"id": "q350", "q": "Who designed the deadly Chakravyuha formation on the 13th day of the war?", "a": "DRONACHARYA", "opts": ["SHAKUNI", "DRONACHARYA", "BHISHMA"]},
    {"id": "q351", "q": "Which supreme weapon did Karna use to kill Ghatotkacha?", "a": "VASAVI SHAKTI", "opts": ["BRAHMASTRA", "VASAVI SHAKTI", "NAGAPASHA"]},
    {"id": "q352", "q": "Which deity gifted the 'Vasavi Shakti' weapon to Karna?", "a": "INDRA", "opts": ["SURYA", "INDRA", "SHIVA"]},
    {"id": "q353", "q": "Who was the father of Guru Dronacharya?", "a": "BHARADWAJA", "opts": ["GAUTAMA", "BHARADWAJA", "AGASTYA"]},
    {"id": "q354", "q": "What was the name of Ekalavya's father, the king of the Nishadas?", "a": "HIRANYADHANUS", "opts": ["NISHADA", "HIRANYADHANUS", "KICHAKA"]},
    {"id": "q355", "q": "What alias did Yudhishthira assume during their year of incognito exile (Agyatvas)?", "a": "KANKA", "opts": ["VALLABHA", "KANKA", "TANTIPALA"]},
    {"id": "q356", "q": "Under what name did Bhima serve as a cook in King Virata's palace?", "a": "VALLABHA", "opts": ["GRANTHIKA", "VALLABHA", "KANKA"]},
    {"id": "q357", "q": "What name did Arjuna adopt when he lived as a eunuch dancing teacher?", "a": "BRIHANNALA", "opts": ["SAIRANDHRI", "BRIHANNALA", "URVASHI"]},
    {"id": "q358", "q": "What was Draupadi's assumed name while working as a maid for Queen Sudeshna?", "a": "SAIRANDHRI", "opts": ["MALINI", "SAIRANDHRI", "PANCHALI"]},
    {"id": "q359", "q": "Who killed Kichaka, the arrogant brother-in-law of King Virata?", "a": "BHIMA", "opts": ["ARJUNA", "BHIMA", "YUDHISHTHIRA"]},
    {"id": "q360", "q": "Who was the mother of the blind king Dhritarashtra?", "a": "AMBIKA", "opts": ["AMBALIKA", "AMBIKA", "AMBA"]},
    {"id": "q361", "q": "Who was the mother of King Pandu?", "a": "AMBALIKA", "opts": ["AMBIKA", "AMBALIKA", "MADRI"]},
    {"id": "q362", "q": "What was the name of Ashwatthama's mother (Dronacharya's wife)?", "a": "KRIPAI", "opts": ["DRUPI", "KRIPAI", "GANDHARI"]},
    {"id": "q363", "q": "What was the name of Abhimanyu's wife, the daughter of King Virata?", "a": "UTTARA", "opts": ["SUDESHNA", "UTTARA", "DUSHARA"]},
    {"id": "q364", "q": "Who saved the unborn Parikshit in Uttara's womb from Ashwatthama's Brahmashirsha astra?", "a": "LORD KRISHNA", "opts": ["ARJUNA", "LORD KRISHNA", "VYASA"]},
    {"id": "q365", "q": "What was the name of Duryodhana's son, who was killed by Abhimanyu in the war?", "a": "LAKSHMANA KUMARA", "opts": ["DURJAYA", "LAKSHMANA KUMARA", "VRISHAKETU"]},
    {"id": "q366", "q": "What was the name of Karna's primary wife?", "a": "VRUSHALI", "opts": ["BHANUMATI", "VRUSHALI", "DUSHARA"]},
    {"id": "q367", "q": "Which devastating weapon did Arjuna obtain from Lord Shiva after intense penance?", "a": "PASHUPATASTRA", "opts": ["BRAHMASTRA", "PASHUPATASTRA", "NARAYANA ASTRA"]},
    {"id": "q368", "q": "Who served as Karna's charioteer during his final battle against Arjuna?", "a": "SHALYA", "opts": ["KRIPA", "SHALYA", "ASHWATTHAMA"]},
    {"id": "q369", "q": "What alternative name was given to Draupadi because she was born from the sacrificial fire?", "a": "YAJNASENI", "opts": ["PANCHALI", "YAJNASENI", "KRISHNAA"]},
    {"id": "q370", "q": "Who was the divine scribe writing down the Mahabharata as Sage Vyasa dictated it?", "a": "LORD GANESHA", "opts": ["LORD BRAHMA", "LORD GANESHA", "SARASWATI"]},
    {"id": "q371", "q": "In which king's kingdom did the Pandavas hide during their 13th year of exile?", "a": "VIRATA", "opts": ["DRUPADA", "VIRATA", "SHALYA"]},
    {"id": "q372", "q": "Which sage cursed Karna that he would forget his divine mantras when he needed them the most?", "a": "PARASHURAMA", "opts": ["DURVASA", "PARASHURAMA", "BHRIGU"]},
    {"id": "q373", "q": "Which mythical serpent king bit and killed King Parikshit?", "a": "TAKSHAKA", "opts": ["VASUKI", "TAKSHAKA", "KALIA"]},
    {"id": "q374", "q": "What was the total combined number of 'Akshauhini' armies in the Kurukshetra war?", "a": "18", "opts": ["11", "18", "21"]},
    {"id": "q375", "q": "The Kauravas had 11 Akshauhini armies; how many did the Pandavas have?", "a": "7", "opts": ["7", "9", "11"]},

    # --- IMPOSSIBLE TRIVIA & STREAK BREAKERS ---
    {"id": "q68", "q": "Which animal has three hearts and blue blood?", "a": "OCTOPUS", "opts": ["SHARK", "OCTOPUS", "SQUID"]},
    {"id": "q69", "q": "What is the rarest naturally occurring element on the Earth's crust?", "a": "ASTATINE", "opts": ["FRANCIUM", "ASTATINE", "RADIUM"]},
    {"id": "q70", "q": "How many keys are there on a standard grand piano?", "a": "88", "opts": ["76", "88", "102"]},
    {"id": "q71", "q": "Which country has the most volcanoes in the world?", "a": "USA", "opts": ["INDONESIA", "USA", "ICELAND"]},
    {"id": "q72", "q": "Which year was the Python programming language first released?", "a": "1991", "opts": ["1989", "1991", "1995"]},
    {"id": "q73", "q": "What is the maximum number of moves a Rubik's Cube can always be solved in?", "a": "20", "opts": ["20", "26", "42"]},
    {"id": "q74", "q": "Which planet rotates on its side, nearly 90 degrees from its orbit?", "a": "URANUS", "opts": ["VENUS", "URANUS", "NEPTUNE"]},
    {"id": "q75", "q": "What is the specific scientific term for the fear of long words?", "a": "HIPPOPOTOMONSTROSESQUIPPEDALIOPHOBIA", "opts": ["PHOBOPHOBIA", "HIPPOPOTOMONSTROSESQUIPPEDALIOPHOBIA", "GLOSSOPHOBIA"]},
    
    
    # --- THE IMPOSSIBLE TIER ---
    {"id": "q41", "q": "What is the fear of long words called?", "a": "HIPPOPOTOMONSTROSESQUIPPEDALIOPHOBIA", "opts": ["ARACHNOPHOBIA", "HIPPOPOTOMONSTROSESQUIPPEDALIOPHOBIA", "CLAUSTROPHOBIA"]},
    {"id": "q42", "q": "In computer networking, what does the 'HTTP' status code 418 mean?", "a": "I'M A TEAPOT", "opts": ["BAD GATEWAY", "I'M A TEAPOT", "NOT FOUND"]},
    {"id": "q43", "q": "Which animal has fingerprints that are almost indistinguishable from human fingerprints?", "a": "KOALA", "opts": ["CHIMPANZEE", "KOALA", "SLOTH"]},
    {"id": "q44", "q": "What is the only even prime number?", "a": "2", "opts": ["0", "2", "4"]},
    {"id": "q45", "q": "What is the name of the deepest known point in the Earth's oceans?", "a": "CHALLENGER DEEP", "opts": ["MARIANA TRENCH", "CHALLENGER DEEP", "TONGA TRENCH"]},
    
    # --- ENTERTAINMENT ---
    {"id": "q21", "q": "Who plays Iron Man in the Marvel movies?", "a": "ROBERT DOWNEY JR", "opts": ["CHRIS EVANS", "TOM HOLLAND", "ROBERT DOWNEY JR"]},
    {"id": "q22", "q": "What is the name of Harry Potter's pet owl?", "a": "HEDWIG", "opts": ["DOBBY", "CROOKSHANKS", "HEDWIG"]},
    {"id": "q23", "q": "In 'The Matrix', what color is the pill Neo takes?", "a": "RED", "opts": ["BLUE", "RED", "GREEN"]},
    {"id": "q24", "q": "Which anime features a notebook that kills people?", "a": "DEATH NOTE", "opts": ["BLEACH", "NARUTO", "DEATH NOTE"]},
    {"id": "q25", "q": "What is the highest-grossing movie of all time?", "a": "AVATAR", "opts": ["AVENGERS: ENDGAME", "TITANIC", "AVATAR"]}
]

# ==========================================
# ğŸ§  IQ TEST GAME LOGIC
# ==========================================
import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# ğŸ§  TITAN IQ PROTOCOL (ULTRA-PREMIUM + SMART BANKING)
# ==============================================================================

class IQTestView(discord.ui.View):
    def __init__(self, user: discord.Member, game_questions: list, total_target: int, message: discord.Message):
        super().__init__(timeout=30) # â³ 30 Seconds per question
        self.user = user
        self.score = 0
        self.game_questions = game_questions 
        self.max_score = total_target
        self.current_q_index = 0
        self.message = message
        self.game_over = False
        self.setup_question()

    async def on_timeout(self):
        """ âš ï¸ AFK LOGIC: If the player's brain freezes """
        if not self.game_over:
            self.game_over = True
            for child in self.children: child.disabled = True
            
            embed = discord.Embed(title="â³ TIME EXPIRED (SLOW BRAIN)", color=0x8B0000)
            embed.description = (
                f"### ğŸŒ TOO SLOW!\n"
                f"**{self.user.mention}**, your brain couldn't process the information in time.\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”— ğŸ§  **Diagnosis:** `Processing Speed - 0%`\n\n"
                f"*The system has terminated your test.*"
            )
            embed.set_thumbnail(url=self.user.display_avatar.url)
            embed.set_image(url="https://media.tenor.com/2147kZ75wW8AAAAC/squid-game-card.gif")
            
            if self.message:
                try: await self.message.edit(embed=embed, view=None)
                except: pass
            
            # Punish for being slow
            await self.apply_humiliation(None, timeout_mode=True)

    async def save_progress(self, question_id):
        """ ğŸ—„ï¸ SAFE DB CALL: Mark question as seen so it never repeats """
        try:
            await db_call(lambda: supabase.table("user_iq_progress").upsert({
                "user_id": str(self.user.id),
                "question_id": question_id
            }).execute())
        except Exception as e:
            print(f"Failed to save IQ progress: {e}")

    def setup_question(self):
        self.clear_items()
        q_data = self.game_questions[self.current_q_index]
        
        options = q_data["opts"][:]
        random.shuffle(options)
        
        for opt in options:
            # ğŸ› ï¸ Safe label length
            safe_opt = str(opt)[:80]
            btn = discord.ui.Button(label=safe_opt, style=discord.ButtonStyle.secondary)
            btn.callback = self.make_callback(opt, q_data["id"])
            self.add_item(btn)

    def make_callback(self, selected_answer, question_id):
        async def callback(interaction: discord.Interaction):
            if interaction.user.id != self.user.id: 
                return await interaction.response.send_message("âŒ **System:** Focus on your own test, outsider!", ephemeral=True)
            
            await interaction.response.defer() # ğŸ› ï¸ INSTANT DEFER
            
            # Save progress asynchronously
            await self.save_progress(question_id)
            
            correct_ans = self.game_questions[self.current_q_index]["a"]
            
            # ==========================================
            # âœ… CORRECT ANSWER LOGIC
            # ==========================================
            if selected_answer == correct_ans:
                self.score += 1
                self.current_q_index += 1
                
                # ğŸ‰ WIN CONDITION
                if self.score >= self.max_score:
                    self.game_over = True
                    self.stop()
                    
                    prize = 100000 # $100k
                    await smart_reward(self.user.id, prize)
                    
                    embed = discord.Embed(title="ğŸ§  SUPREME GENIUS UNLOCKED!", color=0x2ecc71)
                    embed.description = (
                        f"### ğŸ† FLAWLESS VICTORY!\n"
                        f"**{self.user.mention}** has proven their intellectual superiority!\n"
                        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                        f" â”£ ğŸ§© **Questions Cleared:** `{self.max_score}/{self.max_score}`\n"
                        f" â”— ğŸ’° **Bounty Rewarded:** `${prize:,}`\n"
                    )
                    embed.set_image(url="https://media.tenor.com/bXjOidvDvoQAAAAC/confetti-celebrate.gif")
                    embed.set_footer(text="Titan Elite Intelligence Agency", icon_url=interaction.client.user.display_avatar.url)
                    
                    return await interaction.edit_original_response(embed=embed, view=None)
                
                # ğŸ”„ NEXT QUESTION
                else:
                    self.setup_question()
                    next_q = self.game_questions[self.current_q_index]
                    
                    embed = discord.Embed(title=f"ğŸ§  TITAN IQ PROTOCOL", color=0x3498DB)
                    embed.description = (
                        f"### ğŸ§© ROUND {self.current_q_index + 1} / {self.max_score}\n"
                        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                        f"**Question:**\n> {next_q['q']}\n"
                    )
                    embed.set_thumbnail(url="https://media.tenor.com/On7kvXhzml4AAAAi/loading-gif.gif")
                    embed.set_footer(text=f"Time Limit: 30 Seconds â€¢ Think Fast", icon_url=self.user.display_avatar.url)
                    
                    await interaction.edit_original_response(embed=embed, view=self)
            
            # ==========================================
            # âŒ WRONG ANSWER LOGIC
            # ==========================================
            else:
                self.game_over = True
                self.stop()
                
                # Show Failure UI
                embed = discord.Embed(title="âŒ MISSION FAILED (INCORRECT)", color=0xFF0000)
                embed.description = (
                    f"### ğŸ“‰ CRITICAL INTELLECT FAILURE\n"
                    f"**Incorrect!** The correct answer was: `{correct_ans}`\n"
                    f"Your intelligence level is disappointingly low.\n"
                    f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                    f" â”— âš™ï¸ **System Action:** `Initiating Humiliation Protocol...`\n"
                )
                embed.set_image(url="https://media.tenor.com/2147kZ75wW8AAAAC/squid-game-card.gif")
                await interaction.edit_original_response(embed=embed, view=None)
                
                # Apply Punishment
                await self.apply_humiliation(interaction, timeout_mode=False)
                
        return callback

    async def apply_humiliation(self, interaction, timeout_mode=False):
        """ ğŸ¤¡ Advanced Naming and Shaming """
        bad_names = ["Clown ğŸ¤¡", "0 IQ ğŸ§ ", "Brainless", "NPC", "Peanut Brain", "Haggu"]
        new_nick = f"{random.choice(bad_names)} {self.user.name[:10]}"
        
        msg = "`Missing Permissions to alter your identity.`"
        try:
            bot_member = self.user.guild.me
            if self.user.top_role < bot_member.top_role and self.user.id != self.user.guild.owner_id:
                await self.user.edit(nick=new_nick)
                msg = f"`Identity Overridden: {new_nick}`"
                
                # Add Haggu Role if it exists
                role = discord.utils.get(self.user.guild.roles, name="ğŸ’© HAGGU")
                if role: await self.user.add_roles(role)
            else:
                msg = "`Admin Privileges Protected Your Identity.`"
        except: pass

        # Followup to confirm the punishment (Append to original message if possible)
        try:
            punish_embed = discord.Embed(color=0x2b2d31, description=f" â”— ğŸ“› **Status:** {msg}")
            if interaction: await interaction.followup.send(content=self.user.mention, embed=punish_embed)
            elif self.message: await self.message.reply(content=self.user.mention, embed=punish_embed)
        except: pass


# ==============================================================================
# ğŸš€ MAIN SLASH COMMAND
# ==============================================================================
# ğŸ› ï¸ Assume 'games_group' is your app_commands.Group
@bot.tree.command(name="iq_test", description="ğŸ§  Ultimate IQ Challenge: Answer unique questions for $100k")
@check_seized() # ğŸ›¡ï¸ Seized protection added!
async def iq_test(interaction: discord.Interaction):
    await interaction.response.defer(ephemeral=False) # â³ Instant Defer
    
    # Permission Check
    if not interaction.guild.me.guild_permissions.manage_nicknames:
        return await interaction.followup.send("âŒ **System Error:** I need `Manage Nicknames` permission to run this deadly game.", ephemeral=True)
        
    user_id = str(interaction.user.id)
    
    # ğŸ—„ï¸ Safe Fetch of Answered Questions
    try:
        res = await db_call(lambda: supabase.table("user_iq_progress").select("question_id").eq("user_id", user_id).execute())
        answered_ids = [row['question_id'] for row in res.data] if res and res.data else []
    except Exception as e:
        print(f"Database Error: {e}")
        answered_ids = []

    # ğŸ§  Assuming 'iq_questions_en' is defined globally in your code
    available_qs = [q for q in iq_questions_en if q['id'] not in answered_ids]
    
    # ğŸ† Check if user has completed EVERYTHING
    if len(available_qs) == 0:
        win_embed = discord.Embed(title="ğŸ† OMNISCIENT BEING", color=0xFFD700)
        win_embed.description = (
            f"### ğŸ¤¯ ABSOLUTE GENIUS!\n"
            f"You have successfully answered **EVERY SINGLE QUESTION** in the Titan Database.\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"There is nothing more to teach you. Wait for the developers to add new questions!"
        )
        win_embed.set_thumbnail(url="https://media.tenor.com/p7a8o1r5c8cAAAAC/money-rain.gif")
        return await interaction.followup.send(embed=win_embed)

    # ğŸ¯ Pick Target (Max 20, or less if few remain)
    target_score = min(20, len(available_qs))
    game_questions = random.sample(available_qs, target_score)

    # ğŸ’ Premium Intro Embed
    embed = discord.Embed(title="ğŸ§  TITAN IQ PROTOCOL", color=0xFFA500)
    embed.description = (
        f"### âš ï¸ INTELLIGENCE CALIBRATION\n"
        f"**Subject:** {interaction.user.mention}\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f" â”£ ğŸ¯ **Target:** `Answer {target_score} unique questions consecutively`\n"
        f" â”£ ğŸ’° **Reward:** `$100,000`\n"
        f" â”— ğŸ’€ **Penalty:** `Public Humiliation (Nickname Override)`\n\n"
        f"*Initializing neural connection...*\n"
    )
    embed.set_thumbnail(url=interaction.user.display_avatar.url)
    
    # Initializing Game View
    msg = await interaction.followup.send(embed=embed)
    view = IQTestView(interaction.user, game_questions, target_score, msg)
    
    # Send First Question
    q = view.game_questions[0]
    first_q_embed = discord.Embed(title=f"ğŸ§  TITAN IQ PROTOCOL", color=0x3498DB)
    first_q_embed.description = (
        f"### ğŸ§© ROUND 1 / {target_score}\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"**Question:**\n> {q['q']}\n"
    )
    first_q_embed.set_thumbnail(url="https://media.tenor.com/On7kvXhzml4AAAAi/loading-gif.gif")
    first_q_embed.set_footer(text=f"Time Limit: 30 Seconds â€¢ Think Fast", icon_url=interaction.client.user.display_avatar.url)
    
    await asyncio.sleep(2) # Fake loading for suspense
    await msg.edit(embed=first_q_embed, view=view)


# ================== ğŸ’¸ MONEY TRANSFER SYSTEM (TAX LOGIC) ==================
import discord
from discord import app_commands
import datetime

# ==============================================================================
# ğŸ’¸ WIRE TRANSFER SYSTEM (ULTRA-PREMIUM + SMART BANKING)
# ==============================================================================

@bot.tree.command(name="transfer", description="ğŸ’¸ Wire funds to another user (15 Min Cooldown | Tax Applied)")
@app_commands.describe(user="Who is receiving the funds?", amount="Amount to transfer (Min: $1)")
@app_commands.checks.cooldown(1, 900.0, key=lambda i: i.user.id) # â³ 1 use per 15 Mins
@check_seized()
async def transfer(interaction: discord.Interaction, user: discord.Member, amount: int):
    
    # â³ 1. INSTANT DEFER (Crash Prevention)
    await interaction.response.defer(ephemeral=False)
    
    # ğŸ›¡ï¸ 2. BASIC SECURITY CHECKS
    if user.id == interaction.user.id:
        return await interaction.followup.send("âŒ **Error:** You cannot wire funds to your own account.", ephemeral=True)
    
    if user.bot:
        return await interaction.followup.send("âŒ **Error:** Bots do not have bank accounts.", ephemeral=True)
        
    if amount <= 0:
        return await interaction.followup.send("âŒ **Error:** Transfer amount must be positive.", ephemeral=True)

    # ğŸ‘‘ 3. VIP CLEARANCE CHECK (Safe DB Call)
    is_vip = False
    try:
        res = await db_call(lambda: supabase.table("economy").select("vip_expiry").eq("user_id", str(interaction.user.id)).execute())
        if res and res.data:
            vip_expiry = res.data[0].get('vip_expiry')
            if vip_expiry:
                if vip_expiry.startswith("9999"):
                    is_vip = True
                else:
                    # ğŸ› ï¸ Safe Timezone Handling
                    exp_dt = datetime.datetime.fromisoformat(vip_expiry)
                    if discord.utils.utcnow() < exp_dt:
                        is_vip = True
    except Exception as e:
        print(f"Transfer VIP Check Error: {e}")

    # âš–ï¸ 4. TAX CALCULATION ENGINE
    tax_rate = 0.10 # 10% Default
    tax_status = "ğŸ›ï¸ `Standard State Tax (10%)`"
    embed_color = 0x3498db # Blue for normal
    
    if amount > 200000:
        tax_rate = 0.50 
        tax_status = "âš ï¸ `High-Value Asset Tax (50%)`"
        embed_color = 0xe74c3c # Red for heavy tax
    elif is_vip:
        tax_rate = 0.0
        tax_status = "ğŸ‘‘ `VIP Tax Exemption (0%)`"
        embed_color = 0xF1C40F # Gold for VIP

    tax_amount = int(amount * tax_rate)
    final_amount = amount - tax_amount

    # ğŸ’³ 5. EXECUTE SMART TRANSACTION (Wallet + Bank Support)
    # This automatically checks if they have enough money in Wallet + Bank and deducts it safely!
    paid = await smart_charge(interaction.user.id, amount)
    
    if not paid:
        return await interaction.followup.send(f"âŒ **Insufficient Funds!** You need `${amount:,}` in your Wallet + Bank to execute this transfer.", ephemeral=True)

    # Deposit the after-tax amount safely to the receiver
    await smart_reward(user.id, final_amount)

    # ğŸ’ 6. ULTRA-PREMIUM RECEIPT EMBED
    embed = discord.Embed(title="ğŸ’¸ WIRE TRANSFER COMPLETED", color=embed_color)
    
    embed.description = (
        f"### ğŸ§¾ OFFICIAL BANK RECEIPT\n"
        f"Funds have been successfully routed to the target account.\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f" â”£ ğŸ“¤ **Sender:** {interaction.user.mention}\n"
        f" â”£ ğŸ“¥ **Beneficiary:** {user.mention}\n"
        f" â”£ ğŸ’° **Gross Amount:** `${amount:,}`\n"
    )

    # Dynamic Tax Display
    if tax_rate == 0.0:
        embed.description += f" â”£ ğŸ›¡ï¸ **Tax Deducted:** ~~${int(amount * 0.10):,}~~ `$0` *(VIP)*\n"
    else:
        embed.description += f" â”£ ğŸ“‰ **Tax Deducted:** `-${tax_amount:,}`\n"

    embed.description += (
        f" â”— âœ… **Net Delivered:** `${final_amount:,}`\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"> **Policy:** {tax_status}"
    )

    embed.set_thumbnail(url="https://media.tenor.com/J3i6jGgFqsgAAAAC/money-transfer.gif")
    embed.set_footer(text="Titan Central Bank â€¢ Secure Transfer", icon_url=interaction.client.user.display_avatar.url)
    embed.timestamp = discord.utils.utcnow()

    await interaction.followup.send(content=f"ğŸ”” {user.mention}, you received a transfer!", embed=embed)

# ==============================================================================
# â³ COOLDOWN ERROR HANDLER (Strictly for /transfer)
# ==============================================================================
@transfer.error
async def transfer_error(interaction: discord.Interaction, error: app_commands.AppCommandError):
    if isinstance(error, app_commands.CommandOnCooldown):
        minutes, seconds = divmod(int(error.retry_after), 60)
        
        embed = discord.Embed(
            title="â³ TRANSACTION BLOCKED", 
            description=f"**Anti-Spam System Active!**\nThe bank needs time to process your last request.\n\nâ±ï¸ **Try again in:** `{minutes}m {seconds}s`", 
            color=0xffa500
        )
        embed.set_thumbnail(url="https://media.tenor.com/On7kvXhzml4AAAAi/loading-gif.gif")
        
        # We use .response.send_message because cooldown errors trigger before defer()
        await interaction.response.send_message(embed=embed, ephemeral=True)
    else:
        print(f"Transfer Error: {error}")

# ================== ğŸ”ª HIDE & SEEK: NIGHT MASSACRE ==================
import discord
from discord import app_commands
import random
import asyncio
import datetime as dt

# ==============================================================================
# ğŸ”ª NIGHT MASSACRE: HIDE & SEEK (SMART ECONOMY + VIP LOGIC)
# ==============================================================================

class HideSeekGameView(discord.ui.View):
    def __init__(self, killer: discord.Member, victims: list, traitor: discord.Member, pot_money: int, message: discord.Message):
        super().__init__(timeout=60) # â³ 60s Global Timeout for Hiding/Killing
        self.killer = killer
        self.victims = victims
        self.traitor = traitor 
        self.pot_money = pot_money
        self.message = message
        
        self.locations = ["ğŸ›ï¸ Under the Bed", "ğŸšª Behind Curtains", "ğŸ§¥ Inside Closet", "ğŸ› In the Bathtub", "ğŸª‘ Under the Table"]
        self.victim_choices = {} 
        self.killer_choice = None
        self.killed_players = []
        self.phase = "HIDING" 
        
        self.setup_buttons()

    def setup_buttons(self):
        self.clear_items()
        
        if self.phase == "HIDING":
            # Hider Buttons
            for loc in self.locations:
                btn = discord.ui.Button(label=loc.split(" ")[1], emoji=loc.split(" ")[0], style=discord.ButtonStyle.secondary, custom_id=loc)
                btn.callback = self.hider_callback
                self.add_item(btn)
        else:
            # Killer Dropdown
            self.kill_select = discord.ui.Select(
                placeholder="ğŸ”ª KILLER: WHERE WILL YOU SHOOT?",
                options=[discord.SelectOption(label=l.split(" ")[1], emoji=l.split(" ")[0]) for l in self.locations],
                custom_id="kill_select"
            )
            self.kill_select.callback = self.killer_callback
            self.add_item(self.kill_select)

    async def on_timeout(self):
        """ âš ï¸ AFK LOGIC: If someone stalls the game """
        for child in self.children: child.disabled = True
        
        if self.phase == "HIDING":
            title = "â³ TIME EXPIRED (HIDING PHASE)"
            desc = "*Some victims failed to hide in time. The Front Man cancelled the match and seized the pot.*"
        else:
            title = "â³ TIME EXPIRED (KILLING PHASE)"
            desc = f"*{self.killer.mention} hesitated and didn't shoot. The victims survived and split the pot!*"
            # Distribute money to survivors
            if self.victims:
                share = self.pot_money // len(self.victims)
                for s in self.victims: await smart_reward(s.id, share)
                
        embed = discord.Embed(title=title, description=desc, color=0x95a5a6)
        if self.message:
            try: await self.message.edit(embed=embed, view=None)
            except: pass

    async def hider_callback(self, interaction: discord.Interaction):
        if interaction.user.id == self.killer.id:
            return await interaction.response.send_message("âŒ **Guard:** You are the Killer! You hunt, you don't hide.", ephemeral=True)
        
        if interaction.user not in self.victims:
            return await interaction.response.send_message("âŒ **Guard:** Spectators are not allowed.", ephemeral=True)

        await interaction.response.defer() # ğŸ› ï¸ INSTANT DEFER
        
        loc_chosen = interaction.data["custom_id"]
        self.victim_choices[interaction.user.id] = loc_chosen
        
        await interaction.followup.send(f"ğŸ¤« **Shh!** You are quietly hiding in: **{loc_chosen}**", ephemeral=True)
        
        # Check if all victims hid
        if len(self.victim_choices) >= len(self.victims):
            self.phase = "KILLING"
            self.setup_buttons()
            
            embed = discord.Embed(title="ğŸ’€ THE HUNT BEGINS!", color=0x8B0000)
            embed.description = (
                f"ğŸ©¸ **{self.killer.mention} has loaded the gun.**\n"
                f"ğŸšª All exits have been locked.\n\n"
                f"ğŸ”« **KILLER:** `Select a location from the dropdown below to shoot!`\n"
                f"â³ **Time Limit:** `60 Seconds`"
            )
            embed.set_image(url="https://media.tenor.com/yJ3j3rX08F0AAAAC/squid-game-front-man.gif")
            
            await interaction.edit_original_response(embed=embed, view=self)
            
            # ğŸ•µï¸ TRAITOR HINT SYSTEM
            if self.traitor:
                try: 
                    # 50% Chance of Real Hint, 50% Chance of Fake Hint
                    hint_loc = random.choice(self.locations)
                    msg = f"ğŸ•µï¸ **TRAITOR PROTOCOL ACTIVE!**\n> *I suggest you check:* **{hint_loc}**\n*(Is this a real hint or a trap? Who knows...)*"
                    await self.killer.send(msg)
                except: pass

    async def killer_callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.killer.id:
            return await interaction.response.send_message("âŒ **Guard:** Back off! Only the Killer can shoot.", ephemeral=True)
            
        await interaction.response.defer() # ğŸ› ï¸ INSTANT DEFER
        
        # Match choice with full string format
        short_choice = self.kill_select.values[0]
        self.killer_choice = next(l for l in self.locations if short_choice in l)
        
        self.stop()
        await self.end_game(interaction)

    async def end_game(self, interaction: discord.Interaction):
        # --- ğŸ‘‘ SAFE VIP CHECK (Killer) ---
        killer_is_vip = False
        try:
            k_res = await db_call(lambda: supabase.table("economy").select("vip_expiry").eq("user_id", str(self.killer.id)).execute())
            if k_res and k_res.data and k_res.data[0].get("vip_expiry"):
                killer_is_vip = True
        except: pass

        dead_text = []
        survivors = []
        
        # ğŸ©¸ SLAUGHTER CALCULATION
        for victim in self.victims:
            chosen_loc = self.victim_choices.get(victim.id, "ğŸš· In the Open (Panic)")
            
            if chosen_loc == self.killer_choice:
                # --- ğŸ›¡ï¸ VICTIM DEFENSE LOGIC ---
                saved = False
                reason = "`Dead (No Defense)`"
                
                # Fetch Victim Data Safely
                try:
                    v_res = await db_call(lambda: supabase.table("economy").select("vip_expiry, inventory").eq("user_id", str(victim.id)).execute())
                    v_data = v_res.data[0] if v_res and v_res.data else {}
                    victim_is_vip = bool(v_data.get("vip_expiry"))
                    inv = v_data.get("inventory", {})
                    
                    # 1. Extra Life (Priority)
                    if inv.get("life", 0) > 0:
                        inv["life"] -= 1
                        await db_call(lambda: supabase.table("economy").update({"inventory": inv}).eq("user_id", str(victim.id)).execute())
                        saved = True
                        reason = "ğŸ’– `Survived: Used Extra Life`"
                    
                    # 2. VIP Vest (50% Luck)
                    elif victim_is_vip and random.random() < 0.5:
                        if killer_is_vip:
                            saved = False 
                            reason = "ğŸ›¡ï¸ğŸ’¥ `VIP Vest Pierced! (Killer is also VIP)`"
                        else:
                            saved = True
                            reason = "ğŸ›¡ï¸ `Survived: VIP Matrix Dodge`"
                except: pass
                
                # EXECUTION
                if saved:
                    survivors.append(victim)
                    dead_text.append(f" â”£ ğŸ¤• **{victim.name}** shot in {chosen_loc} â” {reason}")
                else:
                    dead_text.append(f" â”£ ğŸ’€ **{victim.name}** FOUND in {chosen_loc} â” `ELIMINATED`")
                    self.killed_players.append(victim)
                    try: await smart_timeout(interaction, victim, 300, "Shot by Night Massacre Killer")
                    except: pass
            else:
                survivors.append(victim)
        
        # Format Dead Text nicely
        if dead_text: dead_text[-1] = dead_text[-1].replace(" â”£ ", " â”— ")
        report_str = "\n".join(dead_text) if dead_text else " â”— *(No one was found here)*"

        # --- ğŸ† WINNER CALCULATION & REWARDS ---
        if not self.killed_players: 
            title = "âŒ THE KILLER MISSED!"
            desc = (
                f"### ğŸ•Šï¸ EVERYONE SURVIVED!\n"
                f"**{self.killer.mention}** shot blindly into the **{self.killer_choice}** but it was empty!\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ’° **Pot Distributed:** `${self.pot_money:,}`\n"
                f" â”— ğŸƒ **Survivors:** `{len(survivors)}`\n"
            )
            color = 0x2ecc71 # Green
            img = "https://media.tenor.com/bXjOidvDvoQAAAAC/confetti-celebrate.gif"
            
            if survivors:
                share = self.pot_money // len(survivors)
                for s in survivors: await smart_reward(s.id, share)
                
        elif len(survivors) == 0: 
            title = "ğŸ©¸ TOTAL MASSACRE!"
            desc = (
                f"### ğŸª¦ NO SURVIVORS LEFT\n"
                f"**{self.killer.mention}** found everyone hiding in the **{self.killer_choice}**!\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f"**CASUALTY REPORT:**\n{report_str}\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”— ğŸ’° **Killer Takes All:** `${self.pot_money:,}`\n"
            )
            color = 0x8B0000 # Blood Red
            img = "https://media.tenor.com/d6-SreC3_p8AAAAC/wasted-gta5.gif"
            await smart_reward(self.killer.id, self.pot_money)
            
        else: 
            title = "ğŸ”« BLOODY SURVIVAL!"
            desc = (
                f"### âš”ï¸ PARTIAL MASSACRE\n"
                f"**{self.killer.mention}** shot up the **{self.killer_choice}**!\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f"**CASUALTY REPORT:**\n{report_str}\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸƒ **Survivors Left:** `{len(survivors)}`\n"
                f" â”— ğŸ’° **Pot Split:** *Among Killer & Survivors*\n"
            )
            color = 0xF1C40F # Gold
            img = "https://media.tenor.com/y1_B0m0k_mUAAAAd/revolver-spin.gif"
            
            share = self.pot_money // (len(survivors) + 1)
            for s in survivors: await smart_reward(s.id, share)
            await smart_reward(self.killer.id, share)

        embed = discord.Embed(title=title, description=desc, color=color)
        embed.set_thumbnail(url=self.killer.display_avatar.url)
        embed.set_image(url=img)
        embed.set_footer(text="Titan Premium Games", icon_url=interaction.client.user.display_avatar.url)
        
        for item in self.children: item.disabled = True
        await interaction.edit_original_response(embed=embed, view=None)


# ==============================================================================
# ğŸ¢ LOBBY SYSTEM
# ==============================================================================
class HideLobbyView(discord.ui.View):
    def __init__(self, host: discord.Member, fee: int):
        super().__init__(timeout=120)
        self.host = host
        self.players = [host]
        self.fee = fee
        self.started = False
        self.message = None

    def get_embed(self):
        plist = "\n".join([f" â”£ ğŸ‘¤ {u.mention}" for u in self.players])
        if plist: plist = plist.replace(" â”£ ", " â”— ") if len(self.players) == 1 else plist

        embed = discord.Embed(title="ğŸŒƒ NIGHT MASSACRE (LOBBY)", color=0x2C3E50)
        embed.description = (
            f"**Are you brave enough to survive the night?**\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ‘‘ **Host:** {self.host.mention}\n"
            f" â”£ ğŸ’µ **Entry Fee:** `${self.fee:,}`\n"
            f" â”— ğŸ‘¥ **Players Joined:** `{len(self.players)}`\n\n"
            f"**ğŸ­ SECRET ROLES:**\n"
            f"> ğŸ”ª **1x Killer:** `Gets the gun. Must find the victims.`\n"
            f"> ğŸ˜± **Victims:** `Must pick a location to hide.`\n"
            f"> ğŸ•µï¸ **1x Traitor:** `Victim who gets a secret hint (Real or Fake!)`\n\n"
            f"**REGISTERED SQUAD:**\n{plist if self.players else ' â”— *Empty*'}"
        )
        embed.set_image(url="https://media.tenor.com/Xv5Wl2l_u-AAAAAC/squid-game-soldier.gif")
        return embed

    @discord.ui.button(label="ENTER THE HOUSE", style=discord.ButtonStyle.primary, emoji="ğŸ©¸")
    async def join(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer()
        
        if self.started: return await interaction.followup.send("âŒ The doors are locked. Game started!", ephemeral=True)
        if interaction.user in self.players: return await interaction.followup.send("âš ï¸ You are already in the house.", ephemeral=True)
        
        # ğŸ’³ SMART CHARGE
        paid = await smart_charge(interaction.user.id, self.fee)
        if not paid:
            return await interaction.followup.send(f"âŒ You need `${self.fee:,}` in your Wallet + Bank to enter!", ephemeral=True)
            
        self.players.append(interaction.user)
        if self.message:
            try: await self.message.edit(embed=self.get_embed(), view=self)
            except: pass

    @discord.ui.button(label="LOCK DOORS (START)", style=discord.ButtonStyle.danger, emoji="ğŸšª")
    async def start(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer()


# ================== ğŸš¦ RED LIGHT, GREEN LIGHT (SQUID GAME) ==================
          
import discord
from discord import app_commands
import random
import asyncio
import datetime as dt

# ==============================================================================
# ğŸš¦ RED LIGHT, GREEN LIGHT (ULTRA-PREMIUM SQUID GAME)
# ==============================================================================

# --- ğŸ› ï¸ HELPER: PREMIUM PROGRESS BAR ---
def create_track(dist, goal=100, length=10):
    """Creates a visual progress bar like ğŸŸ©ğŸŸ©ğŸƒâ¬›â¬›"""
    if dist >= goal:
        return "ğŸ† `[ SAFE ZONE ]`"
    
    progress = int((dist / goal) * length)
    bar = ("ğŸŸ©" * progress) + "ğŸƒ" + ("â¬›" * (length - progress - 1))
    return f"{bar} `{dist}m`"


# --- ğŸš¥ MAIN GAME ARENA ---
class RedLightGameView(discord.ui.View):
    def __init__(self, players: list, interaction: discord.Interaction):
        super().__init__(timeout=600) # â³ 10 Minutes Max
        self.players = players
        self.prize_pool = 50000 # ğŸ’° $50k Free Prize Pool
        self.interaction = interaction
        self.message = None
        
        # Player Data tracker
        self.active_players = {uid: {"dist": 0, "status": "ALIVE", "name": f"<@{uid}>"} for uid in players}
        
        self.game_state = "GREEN" 
        self.goal = 100
        self.is_game_over = False
        
        # ğŸƒ RUN BUTTON
        self.run_btn = discord.ui.Button(
            label="SPRINT! (SPAM CLICK)", 
            style=discord.ButtonStyle.success, 
            custom_id="run_btn",
            emoji="ğŸƒâ€â™‚ï¸"
        )
        self.run_btn.callback = self.run_callback
        self.add_item(self.run_btn)
        
        # Start the terrifying game loop
        self.loop_task = asyncio.create_task(self.game_loop())

    def get_leaderboard(self):
        desc = ""
        sorted_players = sorted(self.active_players.items(), key=lambda x: x[1]['dist'], reverse=True)
        
        for uid, data in sorted_players:
            if data['status'] == "ALIVE":
                track = create_track(data['dist'], self.goal)
                desc += f" â”£ {data['name']}: {track}\n"
            elif data['status'] == "DEAD":
                 desc += f" â”£ ğŸ’€ ~~{data['name']}~~ `(ELIMINATED)`\n"
            else:
                 desc += f" â”£ ğŸ‘‘ **{data['name']}** `(CROSSED THE LINE)`\n"
                 
        if desc: desc = desc.replace(" â”£ ", " â”— ", 1) if len(self.players) == 1 else desc # Tree format fix
        # Just manually replace the last â”£ with â”— for aesthetics
        if "â”£" in desc:
            parts = desc.rsplit(" â”£ ", 1)
            desc = " â”— ".join(parts)
            
        return desc

    async def update_display(self, embed_color, title, image_url, footer_text):
        if self.is_game_over: return
        
        embed = discord.Embed(title=title, color=embed_color)
        embed.description = (
            f"ğŸ’° **Prize Pool:** `${self.prize_pool:,}`\n"
            f"ğŸ **Finish Line:** `{self.goal} meters`\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"**LIVE TRACKER:**\n"
            f"{self.get_leaderboard()}"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        )
        embed.set_image(url=image_url)
        embed.set_footer(text=footer_text, icon_url=self.interaction.client.user.display_avatar.url)
        
        try:
            if self.message: await self.message.edit(embed=embed, view=self)
            else: await self.interaction.edit_original_response(embed=embed, view=self)
        except: pass

    async def game_loop(self):
        await asyncio.sleep(2) # Initial boot delay
        
        while not self.is_game_over:
            # ==========================================
            # ğŸŸ¢ GREEN LIGHT PHASE
            # ==========================================
            self.game_state = "GREEN"
            self.run_btn.style = discord.ButtonStyle.success
            self.run_btn.label = "SPRINT! (SPAM CLICK)"
            self.run_btn.disabled = False
            
            await self.update_display(
                0x2ecc71, # Emerald Green
                "ğŸŸ¢ GREEN LIGHT: RUN NOW!", 
                "https://media.tenor.com/F_r_03yJqG4AAAAC/squid-game-green-light.gif",
                "Spam the button to move forward!"
            )
            
            await asyncio.sleep(random.uniform(4, 7)) # 4 to 7 seconds of running

            # ==========================================
            # ğŸŸ¡ YELLOW LIGHT PHASE
            # ==========================================
            self.game_state = "YELLOW"
            self.run_btn.style = discord.ButtonStyle.primary
            self.run_btn.label = "SLOW DOWN..."
            
            await self.update_display(
                0xF1C40F, # Warning Gold
                "ğŸŸ¡ YELLOW LIGHT: SLOWING DOWN!", 
                "https://media.tenor.com/13_uMh8cM9gAAAAC/squid-game.gif",
                "The doll is turning around. Stop clicking!"
            )
            
            await asyncio.sleep(1.5) # Short warning before death

            # ==========================================
            # ğŸ”´ RED LIGHT PHASE
            # ==========================================
            self.game_state = "RED"
            self.run_btn.style = discord.ButtonStyle.danger
            self.run_btn.label = "ğŸ›‘ FREEZE! (DO NOT CLICK)"
            
            await self.update_display(
                0xe74c3c, # Blood Red
                "ğŸ”´ RED LIGHT: DO NOT MOVE!", 
                "https://media.tenor.com/v1sLzJqf8i8AAAAC/squid-game-doll.gif",
                "Any movement now means INSTANT DEATH!"
            )
            
            await asyncio.sleep(random.uniform(3, 5)) # Deadly silence phase
            
            # Check if anyone is left alive
            alive_count = sum(1 for p in self.active_players.values() if p['status'] == "ALIVE")
            if alive_count == 0:
                await self.end_game()
                break
                
            await self.check_all_finished()

    # ğŸ› ï¸ FIX: Proper indentation inside the class
    async def run_callback(self, interaction: discord.Interaction):
        uid = interaction.user.id
        
        if uid not in self.players:
            return await interaction.response.send_message("âŒ **Guard:** Spectators stay off the field!", ephemeral=True)
            
        p_data = self.active_players[uid]
        
        if p_data["status"] != "ALIVE":
            return await interaction.response.send_message("ğŸš« **System:** You are already eliminated.", ephemeral=True)

        # --- LOGIC HANDLING ---
        if self.game_state == "GREEN":
            # âœ… Safe Movement
            move = random.randint(4, 8) 
            p_data["dist"] += move
            
            if p_data["dist"] >= self.goal:
                p_data["status"] = "WON"
                await interaction.response.send_message("ğŸ‰ **CROSSED THE LINE!** You are safe!", ephemeral=True)
            else:
                await interaction.response.defer() # Silent rapid update

        elif self.game_state == "YELLOW":
            # âš ï¸ Risky Movement
            if random.random() < 0.3: 
                await interaction.response.send_message("âš ï¸ **You stumbled!** (0m gained)", ephemeral=True)
            else:
                p_data["dist"] += 2 
                await interaction.response.defer()

        elif self.game_state == "RED":
            # ğŸ’€ FATAL MOVEMENT
            saved = False
            reason = "Headshot"
            
            # ğŸ—„ï¸ SAFE DB FETCH FOR INVENTORY/VIP
            try:
                res = await db_call(lambda: supabase.table("economy").select("vip_expiry, inventory").eq("user_id", str(uid)).execute())
                if res and res.data:
                    user_db = res.data[0]
                    inv = user_db.get("inventory", {})
                    
                    # 1. Check Extra Life
                    if inv.get("life", 0) > 0:
                        inv["life"] -= 1
                        await db_call(lambda: supabase.table("economy").update({"inventory": inv}).eq("user_id", str(uid)).execute())
                        saved = True
                    
                    # 2. Check VIP Dodge
                    elif user_db.get("vip_expiry") and random.random() < 0.4:
                        saved = True
            except: pass

            if saved:
                await interaction.response.send_message("ğŸ›¡ï¸ **DEFENSE TRIGGERED!** You survived the sniper shot!", ephemeral=True)
            else:
                p_data["status"] = "DEAD"
                
                # Apply Mute Punishment
                try: await smart_timeout(interaction, interaction.user, 60, "Moved during Red Light")
                except: pass
                
                await interaction.response.send_message("ğŸ’€ **BANG! YOU WERE ELIMINATED!**", ephemeral=True)

    async def check_all_finished(self):
        still_running = [p for p in self.active_players.values() if p['status'] == "ALIVE"]
        if not still_running:
            await self.end_game()

    async def end_game(self):
        self.is_game_over = True
        self.loop_task.cancel()
        for child in self.children: child.disabled = True
        
        winners = [uid for uid, data in self.active_players.items() if data["status"] == "WON"]
        
        if winners:
            share = self.prize_pool // len(winners)
            names = []
            for uid in winners:
                await smart_reward(uid, share) # ğŸ’¸ SAFE REWARD
                names.append(f"<@{uid}>")
            
            embed = discord.Embed(title="ğŸ† GAME OVER: SURVIVORS", color=0x2ecc71)
            embed.description = (
                f"### ğŸ‰ THEY CROSSED THE LINE!\n"
                f"{', '.join(names)}\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ’° **Total Prize Pool:** `${self.prize_pool:,}`\n"
                f" â”— ğŸ’µ **Payout Per Survivor:** `${share:,}`\n"
            )
            embed.set_image(url="https://media.tenor.com/bXjOidvDvoQAAAAC/confetti-celebrate.gif")
        else:
            embed = discord.Embed(title="ğŸ’€ GAME OVER: SLAUGHTER", color=0x000000)
            embed.description = (
                f"### ğŸª¦ NO SURVIVORS\n"
                f"Everyone was eliminated before crossing the finish line.\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”— ğŸ”¥ **Prize Money:** `Incinerated`"
            )
            embed.set_image(url="https://media.tenor.com/d6-SreC3_p8AAAAC/wasted-gta5.gif")

        try:
            if self.message: await self.message.edit(embed=embed, view=None)
            else: await self.interaction.edit_original_response(embed=embed, view=None)
        except: pass


# --- ğŸ¨ LOBBY SYSTEM ---
class RedLightLobby(discord.ui.View):
    def __init__(self, host: discord.Member):
        super().__init__(timeout=180)
        self.host = host
        self.players = [host.id]
        self.started = False
        self.message = None

    def get_embed(self):
        embed = discord.Embed(title="ğŸš¥ SQUID GAME: RED LIGHT, GREEN LIGHT", color=0xE74C3C)
        embed.description = (
            f"**Are you fast enough to survive?**\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ‘‘ **Host:** {self.host.mention}\n"
            f" â”£ ğŸŸï¸ **Entry Fee:** `FREE`\n"
            f" â”£ ğŸ’° **Prize Pool:** `$50,000`\n"
            f" â”— ğŸ‘¥ **Players Registered:** `{len(self.players)}`\n\n"
            f"> **RULES:** Green means SPRINT. Red means FREEZE. Move on red, and you die."
        )
        embed.set_thumbnail(url="https://i.pinimg.com/originals/c6/32/30/c63230ws.jpg") 
        embed.set_image(url="https://media.tenor.com/Xv5Wl2l_u-AAAAAC/squid-game-soldier.gif")
        return embed

    @discord.ui.button(label="ENTER ARENA (FREE)", style=discord.ButtonStyle.primary, emoji="ğŸ«")
    async def join(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer()
        if self.started: return await interaction.followup.send("âŒ The doors are closed!", ephemeral=True)
        if interaction.user.id in self.players:
            return await interaction.followup.send("âš ï¸ You are already in the arena. Wait for the host.", ephemeral=True)
        
        self.players.append(interaction.user.id)
        if self.message:
            try: await self.message.edit(embed=self.get_embed(), view=self)
            except: pass

    @discord.ui.button(label="START GAME", style=discord.ButtonStyle.danger, emoji="â–¶ï¸")
    async def start(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer()
        if interaction.user.id != self.host.id:
            return await interaction.followup.send("âŒ Only the Host can start the game.", ephemeral=True)
        
        self.started = True
        self.stop()
        for child in self.children: child.disabled = True
        
        game_view = RedLightGameView(self.players, interaction)
        
        loading_embed = discord.Embed(title="âš™ï¸ INITIALIZING ARENA...", description="> *Loading assets...*\n> *Waking up the Doll...*\n> *Snipers in position...*", color=0x2b2d31)
        msg = await interaction.edit_original_response(embed=loading_embed, view=game_view)
        game_view.message = msg # Store message for smooth edits!

    async def on_timeout(self):
        if not self.started:
            for child in self.children: child.disabled = True
            embed = discord.Embed(title="â³ ARENA CLOSED", description="*The host took too long to start. Match cancelled.*", color=0x95a5a6)
            if self.message:
                try: await self.message.edit(embed=embed, view=None)
                except: pass


# ==============================================================================
# ğŸ’» MAIN COMMAND
# ==============================================================================
@bot.tree.command(name="red_light", description="ğŸš¥ Play Red Light, Green Light (Free Entry, $50k Prize)")
@check_seized()
async def red_light(i: discord.Interaction):
    await i.response.defer()

    if not i.guild.me.guild_permissions.moderate_members:
        return await i.followup.send("âŒ **System Error:** Bot lacks `Timeout` permissions to eliminate players!", ephemeral=True)
    
    view = RedLightLobby(i.user)
    msg = await i.followup.send(embed=view.get_embed(), view=view)
    view.message = msg

# ================== ğŸ¦‘ SQUID PENTATHLON (TEAM RELAY MODE) ==================
import discord
from discord import app_commands
import random
import asyncio
import datetime as dt

# ==============================================================================
# ğŸ¦‘ SQUID PENTATHLON: TEAM RELAY (ULTRA-PREMIUM + SMART BANKING)
# ==============================================================================

class PentathlonGameView(discord.ui.View):
    def __init__(self, players: list, pot_per_winner: int, message: discord.Message):
        super().__init__(timeout=None) # Timer hum dynamically handle karenge
        self.players = players 
        self.pot_prize = pot_per_winner
        self.message = message
        
        self.round_index = 0
        self.game_active = True
        self.current_turn_player = None
        self.timer_task = None
        
        # ğŸ® 5 KOREAN GAMES DATA
        self.games = [
            {
                "name": "ğŸ”´ Ddakji (Card Flip)",
                "desc": "Blue Card or Red Card? Choose carefully to flip it!",
                "img": "https://media.tenor.com/lZ2tS1uXv4AAAAAC/squid-game-slap.gif",
                "opts": ["ğŸŸ¦ BLUE", "ğŸŸ¥ RED"],
                "win_chance": 0.6,
                "color": 0x3498db
            },
            {
                "name": "ğŸ¦¶ Jegi Chagi (Sack Kick)",
                "desc": "Balance the sack in the air. Don't let it drop!",
                "img": "https://media.tenor.com/yv-15Xn4x4AAAAAC/korean-game.gif",
                "opts": ["ğŸ¦µ KICK LEFT", "ğŸ¦µ KICK RIGHT"],
                "win_chance": 0.6,
                "color": 0x2ecc71
            },
            {
                "name": "ğŸ² Gonggi (Stone Catch)",
                "desc": "Throw the stones and catch them before they hit the ground!",
                "img": "https://media.tenor.com/images/3d51737e45b42661502f676458564e9a/tenor.gif",
                "opts": ["âœ‹ GRAB FAST", "ğŸ¢ GRAB SLOW"],
                "win_chance": 0.5,
                "color": 0x9b59b6
            },
            {
                "name": "ğŸŒªï¸ Spinning Top",
                "desc": "Spin it perfectly! Keep the balance alive!",
                "img": "https://media.tenor.com/Im_hKqCg4iUAAAAC/inception-top.gif",
                "opts": ["âš–ï¸ BALANCE", "ğŸš€ SPIN HARD"],
                "win_chance": 0.5,
                "color": 0xf1c40f
            },
            {
                "name": "ğŸ¦‘ Squid Final (Defense)",
                "desc": "The final stand. Cross the line or defend the head!",
                "img": "https://media.tenor.com/Xv5Wl2l_u-AAAAAC/squid-game-soldier.gif",
                "opts": ["âš”ï¸ ATTACK", "ğŸ›¡ï¸ DEFEND"],
                "win_chance": 0.5,
                "color": 0xe74c3c
            }
        ]
        
        # Start First Round
        asyncio.create_task(self.load_round())

    async def start_round_timer(self):
        """ â³ 20s AFK Timer per round! """
        await asyncio.sleep(20)
        if self.game_active:
            await self.team_eliminate(self.current_turn_player, reason="AFK / Hesitation")

    async def load_round(self):
        if not self.game_active: return
        
        # ğŸ‰ Win Condition: 5 Rounds complete
        if self.round_index >= 5:
            await self.team_win()
            return

        # Determine Current Player (Relay Style)
        self.current_turn_player = self.players[self.round_index % len(self.players)]
        game_data = self.games[self.round_index]

        # Embed Setup
        embed = discord.Embed(title=f"ğŸ† TEAM RELAY: ROUND {self.round_index + 1}/5", color=game_data['color'])
        embed.description = (
            f"ğŸ® **Game:** `{game_data['name']}`\n"
            f"ğŸ“ **Task:** `{game_data['desc']}`\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ‘‰ **Active Player:** {self.current_turn_player.mention}\n"
            f" â”£ âš ï¸ **Warning:** `If they fail, the WHOLE TEAM DIES!`\n"
            f" â”— â±ï¸ **Time Limit:** `20 Seconds`\n"
        )
        embed.set_image(url=game_data['img'])
        embed.set_footer(text="Team Death Mode: One Fails = All Fail", icon_url=self.current_turn_player.display_avatar.url)

        # Buttons Setup
        self.clear_items()
        
        btn1 = discord.ui.Button(label=game_data['opts'][0], style=discord.ButtonStyle.primary, custom_id="opt_1")
        btn2 = discord.ui.Button(label=game_data['opts'][1], style=discord.ButtonStyle.danger, custom_id="opt_2")
        btn1.callback = self.game_action
        btn2.callback = self.game_action
        self.add_item(btn1)
        self.add_item(btn2)

        try: await self.message.edit(embed=embed, view=self)
        except: pass

        # Start AFK Timer for this specific round
        if self.timer_task: self.timer_task.cancel()
        self.timer_task = asyncio.create_task(self.start_round_timer())

    async def game_action(self, interaction: discord.Interaction):
        if interaction.user.id != self.current_turn_player.id:
            return await interaction.response.send_message("âŒ **Guard:** Stay back! It's not your turn.", ephemeral=True)

        await interaction.response.defer() # ğŸ› ï¸ INSTANT DEFER
        
        # Stop the round timer since they clicked
        if self.timer_task: self.timer_task.cancel()
        
        # ğŸ² Game Logic
        game_data = self.games[self.round_index]
        is_win = random.random() < game_data['win_chance']
        
        # --- ğŸ›¡ï¸ VIP & LIFE CHECK (Saving Logic) ---
        saved = False
        save_msg = ""
        
        if not is_win:
            try:
                # ğŸ—„ï¸ SAFE DB FETCH
                res = await db_call(lambda: supabase.table("economy").select("vip_expiry, inventory").eq("user_id", str(interaction.user.id)).execute())
                
                if res and res.data:
                    data = res.data[0]
                    
                    # 1. VIP Check (50% Chance to Save Team)
                    is_vip = bool(data.get("vip_expiry"))
                    
                    if is_vip and random.random() < 0.5:
                        is_win = True
                        saved = True
                        save_msg = "*(ğŸ‘‘ VIP Aura Saved the Team!)*"
                    
                    # 2. Extra Life Check (Guaranteed Save)
                    elif data.get("inventory", {}).get("life", 0) > 0:
                        inv = data.get("inventory")
                        inv["life"] -= 1
                        await db_call(lambda: supabase.table("economy").update({"inventory": inv}).eq("user_id", str(interaction.user.id)).execute())
                        is_win = True
                        saved = True
                        save_msg = "*(ğŸ’– Extra Life Used! Team Survived!)*"
            except: pass

        # ==========================================
        # âœ… ROUND PASSED
        # ==========================================
        if is_win:
            if saved:
                try: await interaction.followup.send(f"ğŸ˜° **CLOSE CALL!** {save_msg}", ephemeral=True)
                except: pass
            
            self.round_index += 1
            await self.load_round()
            
        # ==========================================
        # âŒ ROUND FAILED = TEAM ELIMINATED
        # ==========================================
        else:
            await self.team_eliminate(interaction.user, reason="Failed the Minigame")

    async def team_eliminate(self, loser: discord.Member, reason: str):
        self.game_active = False
        self.clear_items()
        
        # ğŸ’€ Punish EVERYONE (Team Wipeout)
        punish_logs = []
        for p in self.players:
            # Smart Timeout for all team members (1 Min)
            try: await smart_timeout(None, p, 60, f"Pentathlon Failed by {loser.name}")
            except: pass
            punish_logs.append(f" â”£ ğŸ’€ {p.mention}")

        if punish_logs: punish_logs[-1] = punish_logs[-1].replace(" â”£ ", " â”— ")

        embed = discord.Embed(title="ğŸ’€ ENTIRE SQUAD WIPED OUT!", color=0x000000)
        embed.description = (
            f"### ğŸª¦ ELIMINATION TRIGGERED\n"
            f"**{loser.mention}** {reason.lower()} in `{self.games[self.round_index]['name']}`.\n"
            f"Because of them, the whole team has been executed.\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"**CASUALTY REPORT (60s Mute):**\n" + "\n".join(punish_logs) + "\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”— ğŸ’¸ **Prize Money Burned:** `${len(self.players) * self.pot_prize:,}`\n"
        )
        embed.set_image(url="https://media.tenor.com/d6-SreC3_p8AAAAC/wasted-gta5.gif")
        
        try: await self.message.edit(embed=embed, view=None)
        except: pass

    async def team_win(self):
        self.game_active = False
        self.clear_items()
        
        # ğŸ‰ Reward EVERYONE using Smart Reward
        winners_list = []
        for p in self.players:
            await smart_reward(p.id, self.pot_prize)
            winners_list.append(f" â”£ ğŸƒ {p.mention}")
            
        if winners_list: winners_list[-1] = winners_list[-1].replace(" â”£ ", " â”— ")
            
        embed = discord.Embed(title="ğŸ‰ FLAWLESS TEAMWORK!", color=0xFFD700) # Gold
        embed.description = (
            f"### ğŸ† ALL 5 ROUNDS CLEARED!\n"
            f"You stuck together and survived the ultimate Pentathlon.\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"**THE SURVIVORS:**\n" + "\n".join(winners_list) + "\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”— ğŸ’° **Payout Per Player:** `${self.pot_prize:,}`\n"
        )
        embed.set_image(url="https://media.tenor.com/p7a8o1r5c8cAAAAC/money-rain.gif")
        
        try: await self.message.edit(embed=embed, view=None)
        except: pass


# ==============================================================================
# ğŸ¢ LOBBY SYSTEM
# ==============================================================================
class PentaLobby(discord.ui.View):
    def __init__(self, host: discord.Member):
        super().__init__(timeout=120)
        self.host = host
        self.players = [host]
        self.started = False
        self.message = None

    def get_embed(self):
        plist = "\n".join([f" â”£ ğŸƒ {u.mention}" for u in self.players])
        if plist: plist = plist.replace(" â”£ ", " â”— ") if len(self.players) == 1 else plist

        embed = discord.Embed(title="ğŸ¦‘ SQUID PENTATHLON (TEAM MODE)", color=0xE91E63) # Squid Pink
        embed.description = (
            f"**Will you trust your teammates with your life?**\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ‘‘ **Host:** {self.host.mention}\n"
            f" â”£ ğŸŸï¸ **Entry Fee:** `FREE`\n"
            f" â”£ ğŸ’° **Prize:** `$100,000` *(Per Survivor)*\n"
            f" â”— ğŸ‘¥ **Players:** `{len(self.players)}/5` *(Min 2)*\n\n"
            f"âš ï¸ **THE RULE:** `If ONE player fails a minigame, the ENTIRE TEAM dies!`\n\n"
            f"**ğŸ”¥ THE 5 RELAY GAMES:**\n"
            f"`1.` ğŸ”´ Ddakji  âœ  `2.` ğŸ¦¶ Jegi  âœ  `3.` ğŸ² Gonggi\n"
            f"âœ `4.` ğŸŒªï¸ Spinning Top  âœ  `5.` ğŸ¦‘ Squid Final\n\n"
            f"**CURRENT SQUAD:**\n{plist}"
        )
        embed.set_thumbnail(url="https://media.tenor.com/yv-15Xn4x4AAAAAC/korean-game.gif")
        return embed

    @discord.ui.button(label="JOIN THE SQUAD", style=discord.ButtonStyle.success, emoji="ğŸ¤")
    async def join(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer()
        
        if self.started:
            return await interaction.followup.send("âŒ Game has already started!", ephemeral=True)
        if interaction.user in self.players:
            return await interaction.followup.send("âš ï¸ You are already in the squad!", ephemeral=True)
        if len(self.players) >= 5:
            return await interaction.followup.send("ğŸš« Squad is full! (Max 5)", ephemeral=True)
            
        self.players.append(interaction.user)
        if self.message:
            try: await self.message.edit(embed=self.get_embed(), view=self)
            except: pass

    @discord.ui.button(label="START RELAY", style=discord.ButtonStyle.danger, emoji="ğŸš€")
    async def start(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer()
        
        if interaction.user != self.host: return await interaction.followup.send("âŒ Only the Host can start the relay.", ephemeral=True)
        if len(self.players) < 2: return await interaction.followup.send("âŒ You need at least 2 players to form a relay squad!", ephemeral=True)
        
        self.started = True
        self.stop()
        for child in self.children: child.disabled = True
        
        game_view = PentathlonGameView(self.players, 100000, self.message)
        
        loading_embed = discord.Embed(title="âš™ï¸ INITIALIZING RELAY...", description="> *Loading Minigames...*\n> *Testing Traps...*\n> *Preparing Body Bags...*", color=0x2b2d31)
        await interaction.edit_original_response(embed=loading_embed, view=game_view)


# ==============================================================================
# ğŸ’» MAIN COMMAND
# ==============================================================================
@bot.tree.command(name="pentathlon", description="ğŸ¦‘ 5-Game Relay Challenge (If ONE fails, the ENTIRE team dies!)")
@check_seized()
async def pentathlon(i: discord.Interaction):
    await i.response.defer()

    if not i.guild.me.guild_permissions.moderate_members:
        return await i.followup.send("âŒ **System Error:** Bot lacks `Timeout` permissions to punish the squad!", ephemeral=True)
        
    view = PentaLobby(i.user)
    msg = await i.followup.send(embed=view.get_embed(), view=view)
    view.message = msg # Save for stable edits



# ================== ğŸ“Ÿ MATRIX CYBER TERMINAL (LEVEL SELECTOR) ==================
import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# ğŸ“Ÿ MATRIX TERMINAL (ULTRA-PREMIUM HACKING MINIGAME)
# ==============================================================================

# âš™ï¸ GLOBAL CONFIG
MATRIX_LEVELS = {
    1: {"size": 3, "green": 3, "bomb": 0, "time": 8,  "prize": 10000,  "label": "Level 1 (Easy)"},
    2: {"size": 4, "green": 4, "bomb": 0, "time": 8,  "prize": 20000,  "label": "Level 2 (Medium)"},
    3: {"size": 4, "green": 5, "bomb": 1, "time": 10, "prize": 30000,  "label": "Level 3 (Hard)"},
    4: {"size": 5, "green": 6, "bomb": 2, "time": 12, "prize": 50000,  "label": "Level 4 (Expert)"},
    5: {"size": 6, "green": 7, "bomb": 3, "time": 15, "prize": 100000, "label": "Level 5 (Master)"},
    6: {"size": 7, "green": 8, "bomb": 5, "time": 18, "prize": 150000, "label": "Level 6 (Grandmaster)"},
    7: {"size": 7, "green": 10,"bomb": 8, "time": 20, "prize": 200000, "label": "Level 7 (GOD MODE)"},
}

# --- 1. HIDDEN INPUT MODAL ---
class MatrixInputModal(discord.ui.Modal, title="ğŸ“Ÿ ROOT TERMINAL ACCESS"):
    answer = discord.ui.TextInput(
        label="ENTER OVERRIDE COORDINATES",
        placeholder="Example: A1 B3 C2 (Separate with spaces)",
        required=True,
        max_length=100,
        style=discord.TextStyle.short
    )

    def __init__(self, view):
        super().__init__()
        self.view = view

    async def on_submit(self, interaction: discord.Interaction):
        await self.view.check_answer(interaction, self.answer.value)

# --- 2. TERMINAL GAME VIEW ---
class MatrixTerminalView(discord.ui.View):
    def __init__(self, player: discord.Member, interaction: discord.Interaction, level: int):
        super().__init__(timeout=120) # â³ 2 Min Timeout
        self.player = player
        self.interaction = interaction
        self.level = level 
        self.game_active = True
        self.rows = "ABCDEFG"
        
        asyncio.create_task(self.start_game())

    async def on_timeout(self):
        """ âš ï¸ AFK LOGIC: Hacker took too long to inject code """
        if self.game_active:
            self.game_active = False
            self.clear_items()
            await self.game_over("TIMEOUT")

    def generate_grid_str(self, show=False):
        """ ğŸ¨ Premium Matrix Grid Generator """
        config = MATRIX_LEVELS[self.level]
        size = config["size"]
        
        header = "   " + " ".join([str(i+1) for i in range(size)])
        board = [header]
        
        for r in range(size):
            row_char = self.rows[r]
            row_line = f"`{row_char}` "
            
            for c in range(size):
                coord = f"{row_char}{c+1}"
                if show:
                    if coord in self.correct_coords: icon = "ğŸŸ©"
                    elif coord in self.bomb_coords: icon = "ğŸŸ¥"
                    else: icon = "â¬›"
                else:
                    icon = "ğŸ”³"
                row_line += f" {icon}"
            board.append(row_line)
        
        return "\n".join(board)

    async def start_game(self):
        if not self.game_active: return
        
        config = MATRIX_LEVELS[self.level]
        grid_size = config["size"]
        
        # 1. Generate Complex Pattern
        all_coords = [f"{self.rows[r]}{c+1}" for r in range(grid_size) for c in range(grid_size)]
        
        self.correct_coords = random.sample(all_coords, config["green"])
        remaining = [x for x in all_coords if x not in self.correct_coords]
        self.bomb_coords = random.sample(remaining, config["bomb"])
        
        # 2. SHOW PHASE (Memorize)
        grid_str = self.generate_grid_str(show=True)
        embed = discord.Embed(title=f"ğŸ“Ÿ BREACHING FIREWALL: LEVEL {self.level}", color=0x2ecc71)
        embed.description = (
            f"**MEMORIZE THE ACCESS NODES**\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"{grid_str}\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ’° **Potential Payout:** `${config['prize']:,}`\n"
            f" â”£ ğŸŸ© **Safe Nodes:** `{config['green']}`\n"
            f" â”£ ğŸŸ¥ **Security Traps:** `{config['bomb']}`\n"
            f" â”— â³ **Time Remaining:** `{config['time']} Seconds`\n"
        )
        self.clear_items()
        await self.interaction.edit_original_response(embed=embed, view=self)
        
        await asyncio.sleep(config["time"]) # Wait for memory phase
        if not self.game_active: return
        
        # 3. INPUT PHASE (Hidden)
        grid_str = self.generate_grid_str(show=False)
        embed = discord.Embed(title=f"ğŸ”’ MAINFRAME LOCKED", color=0x3498db)
        embed.description = (
            f"**INJECT BYPASS COORDINATES NOW**\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"{grid_str}\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"> âŒ¨ï¸ Click the button below to type the Safe Node coordinates.\n"
            f"> ğŸ“ *Format:* `{self.correct_coords[0]} {self.correct_coords[1]} ...`\n"
        )
        
        self.clear_items()
        btn = discord.ui.Button(label="OPEN TERMINAL", style=discord.ButtonStyle.success, emoji="ğŸ’»")
        btn.callback = self.open_modal
        self.add_item(btn)
        
        await self.interaction.edit_original_response(embed=embed, view=self)

    async def open_modal(self, interaction: discord.Interaction):
        if interaction.user.id != self.player.id:
            return await interaction.response.send_message("âŒ **Access Denied:** Unauthorized IP detected.", ephemeral=True)
        await interaction.response.send_modal(MatrixInputModal(self))

    async def check_answer(self, interaction: discord.Interaction, answer_str: str):
        await interaction.response.defer() # ğŸ› ï¸ INSTANT DEFER
        
        # ğŸ› ï¸ THE EXPLOIT FIX: Use set() to remove duplicate coordinate spam (e.g. A1 A1 A1)
        raw_inputs = answer_str.upper().replace(",", " ").split()
        user_inputs = list(set(raw_inputs)) 
        
        config = MATRIX_LEVELS[self.level]
        correct_hits = 0
        hit_bomb = False
        wrong_input = False
        
        for inp in user_inputs:
            if inp in self.bomb_coords:
                hit_bomb = True
                break
            elif inp in self.correct_coords:
                correct_hits += 1
            else:
                wrong_input = True
        
        if hit_bomb: await self.game_over("BOMB")
        elif wrong_input: await self.game_over("WRONG")
        elif correct_hits < config["green"]: await self.game_over("INCOMPLETE")
        else:
            # âœ… SMART REWARD FOR WIN
            await smart_reward(self.player.id, config["prize"])
            await self.game_win(config["prize"])

    async def game_over(self, reason):
        self.game_active = False
        self.clear_items()
        
        final_grid = self.generate_grid_str(show=True)
        
        if reason == "BOMB": txt = "ğŸ’£ **SYSTEM FAILURE:** Security trap triggered!"
        elif reason == "WRONG": txt = "âŒ **ACCESS DENIED:** Invalid node coordinates entered."
        elif reason == "INCOMPLETE": txt = "âš ï¸ **PROTOCOL ERROR:** Insufficient nodes entered."
        elif reason == "TIMEOUT": txt = "â³ **CONNECTION LOST:** You took too long to hack."
        else: txt = "ğŸ’€ **DISCONNECTED.**"

        # ğŸ—„ï¸ SAFE DB CHECK FOR VIP/LIFE
        is_safe = False
        footer_txt = "ğŸ’€ Penalty: 60s Timeout (Hospital)"
        try:
            res = await db_call(lambda: supabase.table("economy").select("vip_expiry, inventory").eq("user_id", str(self.player.id)).execute())
            if res and res.data:
                data = res.data[0]
                inv = data.get("inventory", {})
                
                if data.get("vip_expiry"): 
                    is_safe = True
                    footer_txt = "ğŸ›¡ï¸ VIP Firewall: Punishment Bypassed"
                elif inv.get("life", 0) > 0:
                    inv["life"] -= 1
                    await db_call(lambda: supabase.table("economy").update({"inventory": inv}).eq("user_id", str(self.player.id)).execute())
                    is_safe = True
                    footer_txt = "ğŸ’– Extra Life Consumed: Punishment Bypassed"
        except: pass

        if not is_safe:
             try: await smart_timeout(self.interaction, self.player, 60, "Matrix Hack Failed")
             except: pass

        embed = discord.Embed(title="ğŸš« BREACH FAILED", color=0xe74c3c)
        embed.description = (
            f"### {txt}\n"
            f"The authorities have been alerted.\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"**ACTUAL OVERRIDE PATTERN:**\n"
            f"{final_grid}\n"
        )
        embed.set_footer(text=footer_txt)
        embed.set_image(url="https://media.tenor.com/1-11Yd6_QpYAAAAC/explosion-blast.gif")
        
        try: await self.interaction.edit_original_response(embed=embed, view=None)
        except: pass

    async def game_win(self, amount):
        self.game_active = False
        self.clear_items()
        
        embed = discord.Embed(title="âœ… MAINFRAME HACKED", color=0xFFD700) # Gold
        embed.description = (
            f"### ğŸ‰ ROOT ACCESS GRANTED!\n"
            f"**Level {self.level} Firewall has been shattered.**\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ’¾ **Data Extracted Successfully.**\n"
            f" â”— ğŸ’¸ **Funds Transferred:** `${amount:,}`\n"
        )
        embed.set_image(url="https://media.tenor.com/GfSX-u7_NSAAAAAC/coding-hacker.gif")
        
        try: await self.interaction.edit_original_response(embed=embed, view=None)
        except: pass


# --- ğŸ•¹ï¸ LEVEL SELECTION LOBBY ---
class LevelSelectView(discord.ui.View):
    def __init__(self, player: discord.Member):
        super().__init__(timeout=60)
        self.player = player
        self.fee = 5000

    @discord.ui.select(
        placeholder="Select target security level...",
        options=[
            discord.SelectOption(label=info["label"], value=str(lvl), emoji="ğŸ–¥ï¸", description=f"Payout: ${info['prize']:,} | Size: {info['size']}x{info['size']}")
            for lvl, info in MATRIX_LEVELS.items()
        ]
    )
    async def select_level(self, interaction: discord.Interaction, select: discord.ui.Select):
        if interaction.user.id != self.player.id:
            return await interaction.response.send_message("âŒ Use your own terminal.", ephemeral=True)
        
        await interaction.response.defer() # ğŸ› ï¸ INSTANT DEFER
        selected_lvl = int(select.values[0])
        
        # ğŸ’³ SMART CHARGE
        paid = await smart_charge(self.player.id, self.fee)
        if not paid:
            return await interaction.followup.send(f"âŒ **Error:** You need `${self.fee:,}` in Wallet + Bank to fund this hack!", ephemeral=True)
            
        self.stop()
        for child in self.children: child.disabled = True
        
        game_view = MatrixTerminalView(self.player, interaction, selected_lvl)
        await interaction.edit_original_response(content=f"ğŸš€ **Establishing connection to Level {selected_lvl} Server...** `(-${self.fee:,})`", embed=None, view=game_view)


# ==============================================================================
# ğŸ’» MAIN COMMAND
# ==============================================================================
@bot.tree.command(name="matrix", description="ğŸ“Ÿ Hack the mainframe grid (Memory Game) - $5k Entry")
@check_seized()
async def matrix_terminal(i: discord.Interaction):
    await i.response.defer() # â³ Instant Defer
    
    fee = 5000
    
    # Pre-Check Balance to save time
    paid = await smart_charge(i.user.id, 0) # Just checking if they exist in DB
    if paid is False:
        return await i.followup.send(f"âŒ You don't have an economy account!", ephemeral=True)

    embed = discord.Embed(title="ğŸ“Ÿ MATRIX OS: ROOT TERMINAL", color=0x2ECC71)
    embed.description = (
        f"**Welcome to the Underground Network, {i.user.mention}.**\n"
        f"Select a target server to breach. Memorize the green nodes, avoid the red traps.\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f" â”£ ğŸ’¸ **Connection Cost:** `${fee:,}` *(Flat Rate)*\n"
        f" â”— ğŸ’€ **Failure Risk:** `60s System Lockdown (Timeout)`\n\n"
        f"ğŸ‘‡ **Select your target below:**"
    )
    embed.set_thumbnail(url="https://media.tenor.com/On7kvXhzml4AAAAi/loading-gif.gif")
    
    view = LevelSelectView(i.user)
    await i.followup.send(embed=embed, view=view)

# ================== ğŸ§‘â€ğŸ’» THE HACKER RUN (TYPING SPEED GAME) ==================
import discord
from discord import app_commands
import random
import asyncio
import io
import string
import datetime as dt
from PIL import Image, ImageDraw, ImageFont

# ==============================================================================
# ğŸ‘¨â€ğŸ’» HACKER RUN (ULTRA-PREMIUM CAPTCHA/CODE BREAKER)
# ==============================================================================

# âš™ï¸ GLOBAL CONFIG
HACKER_GAME_CONFIG = {
    1: {"len": 5,  "time": 45, "fee": 100,  "prize": 1000,   "label": "Level 1: Script Kiddie", "desc": "Easy | 5 Chars"},
    2: {"len": 6,  "time": 40, "fee": 2000, "prize": 15000,  "label": "Level 2: Code Breaker",  "desc": "Medium | 6 Chars"},
    3: {"len": 12, "time": 35, "fee": 5000, "prize": 25000,  "label": "Level 3: Black Hat",     "desc": "Hard | 12 Chars"},
    4: {"len": 20, "time": 30, "fee": 7000, "prize": 50000,  "label": "Level 4: Elite Hacker",  "desc": "Expert | 20 Chars"},
    5: {"len": 35, "time": 25, "fee": 10000,"prize": 100000, "label": "Level 5: ANONYMOUS",     "desc": "GOD MODE | 35 Chars"},
}

# ğŸ–¼ï¸ SAFE IMAGE GENERATOR (Crash-Proof)
def generate_hacker_image(text):
    try:
        width, height = 600, 180
        background_color = (5, 10, 5) # Dark Matrix Green
        text_color = (0, 255, 65) # Neon Green
        
        image = Image.new('RGB', (width, height), color=background_color)
        draw = ImageDraw.Draw(image)
        
        # ğŸ›¡ï¸ Fallback Font Logic (Works on Render/Linux)
        font = None
        try: font = ImageFont.truetype("arial.ttf", 40)
        except: 
            try: font = ImageFont.truetype("DejaVuSans.ttf", 40)
            except: font = ImageFont.load_default()

        # ğŸ¯ Centering Text Safely
        try:
            bbox = draw.textbbox((0, 0), text, font=font)
            text_w = bbox[2] - bbox[0]
            text_h = bbox[3] - bbox[1]
            x = (width - text_w) / 2
            y = (height - text_h) / 2
        except:
            x, y = 50, 50 # Ultimate Fallback

        # ğŸ“º Add Noise (Hacker Static)
        for _ in range(80):
            nx = random.randint(0, width)
            ny = random.randint(0, height)
            draw.text((nx, ny), random.choice(string.digits), font=font, fill=(0, 60, 0))

        # Write Main Text
        draw.text((x, y), text, font=font, fill=text_color)
        
        # âš¡ Add Glitch Lines
        for _ in range(8):
            x1, y1 = random.randint(0, width), random.randint(0, height)
            x2, y2 = random.randint(0, width), random.randint(0, height)
            draw.line([(x1, y1), (x2, y2)], fill=(0, 200, 50), width=2)

        buffer = io.BytesIO()
        image.save(buffer, format='PNG')
        buffer.seek(0)
        return discord.File(buffer, filename="matrix_code.png")
    except Exception as e:
        print(f"Hacker Image Error: {e}")
        return None

# --- âŒ¨ï¸ HIDDEN INPUT MODAL ---
class HackerInputModal(discord.ui.Modal, title="ğŸ’» TERMINAL OVERRIDE"):
    answer = discord.ui.TextInput(
        label="DECRYPT ENCRYPTED HASH",
        placeholder="Type the exact code from the image...",
        required=True,
        style=discord.TextStyle.short
    )

    def __init__(self, view):
        super().__init__()
        self.view = view

    async def on_submit(self, interaction: discord.Interaction):
        try:
            await self.view.check_code(interaction, self.answer.value)
        except Exception as e:
            await interaction.response.send_message(f"âŒ **System Error:** `{e}`", ephemeral=True)


# --- ğŸ® MAIN GAME VIEW ---
class HackerRunView(discord.ui.View):
    def __init__(self, player: discord.Member, level_id: int):
        super().__init__(timeout=None) # Timer handled manually
        self.player = player
        self.level_id = level_id
        self.config = HACKER_GAME_CONFIG[level_id]
        
        # Remove confusing characters like I, l, 1, O, 0
        chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789" 
        self.current_code = ''.join(random.choice(chars) for _ in range(self.config["len"]))
        self.game_active = True
        self.message = None

    async def start_timer(self, interaction: discord.Interaction):
        """ â³ True AFK Auto-Destruct Timer """
        await asyncio.sleep(self.config["time"])
        if self.game_active:
            self.game_active = False
            self.clear_items()
            await self.game_over(interaction, reason="TIMEOUT")

    async def send_challenge(self, interaction: discord.Interaction):
        file = generate_hacker_image(self.current_code)
        if not file:
            return await interaction.edit_original_response(content="âŒ **Error:** Image Generation Failed. Try again.")

        embed = discord.Embed(title=f"ğŸ‘¨â€ğŸ’» SYSTEM BREACH: {self.config['label']}", color=0x00FF41)
        embed.description = (
            f"**INJECT BYPASS HASH TO PROCEED**\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ’° **Potential Bounty:** `${self.config['prize']:,}`\n"
            f" â”£ ğŸ” **Hash Length:** `{self.config['len']} Characters`\n"
            f" â”— â³ **Time Limit:** `{self.config['time']} Seconds`\n\n"
            f"> ğŸ‘‡ **Click the button and type the code exactly!**"
        )
        embed.set_image(url="attachment://matrix_code.png")
        embed.set_footer(text="âš ï¸ SECURITY ALERT: Case Sensitive (Use Uppercase)")

        self.clear_items()
        btn = discord.ui.Button(label="OPEN TERMINAL", style=discord.ButtonStyle.success, emoji="âŒ¨ï¸")
        btn.callback = self.open_modal
        self.add_item(btn)
        
        msg = await interaction.edit_original_response(embed=embed, view=self, attachments=[file])
        self.message = msg # Save for timeout edits
        
        # Start true timer
        asyncio.create_task(self.start_timer(interaction))

    async def open_modal(self, interaction: discord.Interaction):
        if interaction.user.id != self.player.id:
            return await interaction.response.send_message("âŒ **Access Denied:** Unauthorized IP.", ephemeral=True)
        await interaction.response.send_modal(HackerInputModal(self))

    async def check_code(self, interaction: discord.Interaction, user_input: str):
        if not self.game_active:
            return await interaction.response.send_message("â³ **Too Late!** The firewall already reset.", ephemeral=True)
            
        await interaction.response.defer() # ğŸ› ï¸ INSTANT DEFER
        self.game_active = False # Stop the timer

        # ğŸ› ï¸ Safe checking
        if user_input.strip() == self.current_code:
            # ==========================================
            # âœ… SUCCESSFUL HACK
            # ==========================================
            await smart_reward(self.player.id, self.config["prize"]) # ğŸ’¸ Safe Economy
            
            embed = discord.Embed(title="âœ… MAINFRAME BREACHED", color=0x2ecc71)
            embed.description = (
                f"### ğŸ‰ ROOT ACCESS GRANTED!\n"
                f"**Hash Decrypted Successfully.**\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ’° **Funds Stolen:** `${self.config['prize']:,}`\n"
                f" â”— ğŸ–ï¸ **Status:** `Elite Hacker`\n"
            )
            embed.set_image(url="https://media.tenor.com/GfSX-u7_NSAAAAAC/coding-hacker.gif")
            
            await interaction.edit_original_response(embed=embed, view=None, attachments=[])
        else:
            # ==========================================
            # âŒ FAILED HACK
            # ==========================================
            await self.game_over(interaction, reason="WRONG", user_input=user_input)

    async def game_over(self, interaction: discord.Interaction, reason: str, user_input="None"):
        punish_msg = "`60s Timeout (Hospital)`"
        
        # ğŸ›¡ï¸ VIP & Life Saver Check
        is_safe = False
        try:
            res = await db_call(lambda: supabase.table("economy").select("vip_expiry, inventory").eq("user_id", str(self.player.id)).execute())
            if res and res.data:
                data = res.data[0]
                if data.get("vip_expiry"):
                    is_safe = True
                    punish_msg = "ğŸ›¡ï¸ `VIP Firewall: Punishment Blocked`"
                elif data.get("inventory", {}).get("life", 0) > 0:
                    inv = data.get("inventory")
                    inv["life"] -= 1
                    await db_call(lambda: supabase.table("economy").update({"inventory": inv}).eq("user_id", str(self.player.id)).execute())
                    is_safe = True
                    punish_msg = "ğŸ’– `Extra Life Used: Saved from Ban`"
        except: pass

        if not is_safe:
            try: await smart_timeout(self.message or interaction, self.player, 60, "Hack Failed")
            except: punish_msg = "(Mute Failed)"

        embed = discord.Embed(title="ğŸš« ACCESS DENIED", color=0xe74c3c)
        if reason == "TIMEOUT":
            embed.description = (
                f"### â³ TRACE COMPLETED\n"
                f"You took too long to decrypt the hash!\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”— ğŸ¥ **Penalty:** {punish_msg}\n"
            )
        else:
            embed.description = (
                f"### âŒ INVALID HASH DETECTED\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ âŒ¨ï¸ **Your Input:** `{user_input}`\n"
                f" â”£ âœ… **Correct Code:** `{self.current_code}`\n"
                f" â”— ğŸ¥ **Penalty:** {punish_msg}\n"
            )
        
        embed.set_image(url="https://media.tenor.com/1-11Yd6_QpYAAAAC/explosion-blast.gif") 
        
        try:
            if self.message: await self.message.edit(embed=embed, view=None, attachments=[])
            else: await interaction.edit_original_response(embed=embed, view=None, attachments=[])
        except: pass


# --- ğŸ•¹ï¸ SELECTOR VIEW ---
class HackerLevelSelectView(discord.ui.View):
    def __init__(self, player: discord.Member):
        super().__init__(timeout=60)
        self.player = player

    @discord.ui.select(
        placeholder="Select Firewall Difficulty...",
        options=[
            discord.SelectOption(label=info["label"], value=str(lvl), emoji="ğŸ–¥ï¸", description=f"Fee: ${info['fee']:,} | Reward: ${info['prize']:,}")
            for lvl, info in HACKER_GAME_CONFIG.items()
        ]
    )
    async def select_level(self, interaction: discord.Interaction, select: discord.ui.Select):
        if interaction.user.id != self.player.id:
            return await interaction.response.send_message("âŒ **Guard:** Use your own terminal!", ephemeral=True)
        
        await interaction.response.defer() # ğŸ› ï¸ CRITICAL DEFER
        self.stop()
        
        lvl_id = int(select.values[0])
        config = HACKER_GAME_CONFIG[lvl_id]
        
        # ğŸ’³ SMART CHARGE CHECK
        paid = await smart_charge(self.player.id, config["fee"])
        if not paid:
            return await interaction.followup.send(f"âŒ You need `${config['fee']:,}` in your Wallet + Bank to fund this hack!", ephemeral=True)

        # ğŸš€ START GAME
        for child in self.children: child.disabled = True
        loading_embed = discord.Embed(title="âš™ï¸ ESTABLISHING CONNECTION...", description=f"Connecting to Level {lvl_id} Mainframe...\n`[-${config['fee']:,} Deducted]`", color=0x2b2d31)
        await interaction.edit_original_response(embed=loading_embed, view=self)

        game_view = HackerRunView(interaction.user, lvl_id)
        await game_view.send_challenge(interaction)


# ==============================================================================
# ğŸ’» MAIN COMMAND
# ==============================================================================
@bot.tree.command(name="hacker_run", description="ğŸ‘¨â€ğŸ’» Decrypt the visual hash to earn huge bounties")
@check_seized()
async def hacker_run(i: discord.Interaction):
    await i.response.defer() # â³ Instant Defer

    embed = discord.Embed(title="ğŸ–¥ï¸ THE DARK WEB TERMINAL", color=0x2ECC71)
    embed.description = (
        f"**Welcome to the Shadows, {i.user.mention}.**\n"
        f"Select a target firewall. You must decrypt the visual hash before the trace completes.\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f" â”£ ğŸ’¸ **Requirement:** `Entry Fee based on Level`\n"
        f" â”— ğŸ’€ **Risk:** `60s Mute (Hospital) upon failure`\n\n"
        f"ğŸ‘‡ **Select your target difficulty:**"
    )
    embed.set_thumbnail(url="https://media.tenor.com/On7kvXhzml4AAAAi/loading-gif.gif")
    embed.set_image(url="https://media.tenor.com/4J1d3uJtB3QAAAAC/matrix-code.gif")
    
    view = HackerLevelSelectView(i.user)
    await i.followup.send(embed=embed, view=view)                
            

# ================== ğŸ§  INSANE TRIVIA (UPSC LEVEL) ==================

# ğŸ¤¯ QUESTION BANK (HARDCORE)
TRIVIA_QUESTIONS = [
    {
        "q": "The 'Voynich Manuscript' has baffled cryptographers for centuries. Carbon dating places it in which century?",
        "o": ["13th Century", "15th Century", "17th Century", "11th Century"],
        "a": "15th Century"
    },
    {
        "q": "In Quantum Mechanics, 'SchrÃ¶dinger's Cat' experiment hypothetically used which radioactive substance?",
        "o": ["Uranium-235", "Radium", "Polonium", "Minute amount of any source"],
        "a": "Minute amount of any source"
    },
    {
        "q": "The 'Antikythera Mechanism' (world's first analog computer) was primarily used to predict what?",
        "o": ["Earthquakes", "Astronomical Positions", "Weather Patterns", "Sea Tides"],
        "a": "Astronomical Positions"
    },
    {
        "q": "Which treaty signed in 1648 is credited with creating the modern nation-state system (Westphalian sovereignty)?",
        "o": ["Treaty of Versailles", "Peace of Westphalia", "Treaty of Utrecht", "Congress of Vienna"],
        "a": "Peace of Westphalia"
    },
    {
        "q": "The Event Horizon Telescope captured the first image of a Black Hole in which galaxy?",
        "o": ["Milky Way", "Andromeda", "Messier 87 (M87)", "Triangulum"],
        "a": "Messier 87 (M87)"
    },
    {
        "q": "In Mahabharata, what was the specific name of the weapon Ashwatthama used against the Pandavas?",
        "o": ["Brahmastra", "Pashupatastra", "Brahmashirsha Astra", "Narayanastra"],
        "a": "Brahmashirsha Astra"
    },
    {
        "q": "What is the biological term for the 'Process of Programmed Cell Death'?",
        "o": ["Necrosis", "Apoptosis", "Mitosis", "Phagocytosis"],
        "a": "Apoptosis"
    },
    {
        "q": "Which obscure Indian dynasty ruled Kamarupa (Assam) from 350-650 CE and claimed descent from Narakasura?",
        "o": ["Ahom Dynasty", "Varman Dynasty", "Pala Dynasty", "Chutia Dynasty"],
        "a": "Varman Dynasty"
    },
    {
        "q": "The mathematical constant 'e' (Euler's number) is the base of which logarithm?",
        "o": ["Common Logarithm", "Binary Logarithm", "Natural Logarithm", "Complex Logarithm"],
        "a": "Natural Logarithm"
    },
    {
        "q": "In 1908, a massive explosion flattened 2,000 sq km of Siberian forest. What is this event called?",
        "o": ["Chelyabinsk Event", "Tunguska Event", "Sikhote-Alin Event", "Vredefort Impact"],
        "a": "Tunguska Event"
    },
    {
        "q": "In the world of Cryptocurrency, what is the specific term for a crypto wallet that is NOT connected to the internet (for security)?",
        "o": ["Hot Wallet", "Cold Wallet", "Dead Wallet", "Hard Drive"],
        "a": "Cold Wallet"
    },
    {
        "q": "The 'Barren Island', the only active volcano in India, is located in which part of the Andaman & Nicobar Islands?",
        "o": ["Great Nicobar", "North Andaman", "Little Andaman", "East of Middle Andaman"],
        "a": "East of Middle Andaman"
    },
    {
        "q": "Who was the revolutionary who shot dead Robert Ashe, the Collector of Tirunelveli, in 1911 and then committed suicide?",
        "o": ["Vanchinathan", "Tiruppur Kumaran", "Subramania Siva", "V.O. Chidambaram Pillai"],
        "a": "Vanchinathan"
    },
    {
        "q": "Which female revolutionary fired five shots at the Governor of Bengal, Stanley Jackson, during the Convocation Hall ceremony in 1932?",
        "o": ["Pritilata Waddedar", "Kalpana Datta", "Bina Das", "Matangini Hazra"],
        "a": "Bina Das"
    },
    {
        "q": "Which country has no official capital city?",
        "o": ["Monaco", "Nauru", "Vatican City", "Tuvalu"],
        "a": "Nauru"
    },
    {
        "q": "What is the name of the 'Point of Inaccessibility' in the ocean, which is the farthest point from any land?",
        "o": ["Challenger Deep", "Point Nemo", "Bermuda Triangle", "Mariana Trench"],
        "a": "Point Nemo"
    },
    {
        "q": "In the Solar System, which planet has the 'Great Dark Spot' (similar to Jupiter's Red Spot)?",
        "o": ["Uranus", "Neptune", "Saturn", "Mars"],
        "a": "Neptune"
    },
    {
        "q": "Which war in history is recorded as the 'Shortest War' ever fought (lasting only 38 to 45 minutes)?",
        "o": ["Anglo-Zanzibar War", "Six-Day War", "Football War", "Falklands War"],
        "a": "Anglo-Zanzibar War"
    },
    {
        "q": "The 'Valles Marineris' is a massive canyon system (larger than the Grand Canyon) located on which planet?",
        "o": ["Venus", "Mars", "Mercury", "Earth"],
        "a": "Mars"
    },
    {
        "q": "Which country has the most time zones (including overseas territories)?",
        "o": ["Russia", "France", "USA", "China"],
        "a": "France"
    },
    {
        "q": "What is the name of the star that is currently the 'North Star' (Pole Star)?",
        "o": ["Sirius", "Polaris", "Vega", "Betelgeuse"],
        "a": "Polaris"
    },
    {
        "q": "Which is the only sea in the world that has no coastline?",
        "o": ["Sargasso Sea", "Dead Sea", "Caspian Sea", "Red Sea"],
        "a": "Sargasso Sea"
    },
    {
        "q": "The 'Fermi Paradox' is a scientific concept that questions...",
        "o": ["The stability of black holes", "Where are all the aliens?", "The speed of light limit", "Time travel possibilities"],
        "a": "Where are all the aliens?"
    },
    {
        "q": "Which African country was formerly known as 'Abyssinia'?",
        "o": ["Ethiopia", "Sudan", "Liberia", "Zimbabwe"],
        "a": "Ethiopia"
    },
    {
        "q": "What is the specific term for a Neutron Star that spins rapidly and emits beams of radiation?",
        "o": ["Quasar", "Pulsar", "Magnetar", "White Dwarf"],
        "a": "Pulsar"
    },
    {
        "q": "Which element has the highest melting point of all elements?",
        "o": ["Tungsten", "Carbon", "Titanium", "Platinum"],
        "a": "Tungsten"
    },
    {
        "q": "The 'Diomede Islands' are unique because they are separated by only 3.8 km but have a time difference of?",
        "o": ["1 Hour", "21 Hours", "12 Hours", "30 Minutes"],
        "a": "21 Hours"
    },
    {
        "q": "Which chemical element is named after the creator of the Periodic Table?",
        "o": ["Mendelevium", "Curium", "Einsteinium", "Nobelium"],
        "a": "Mendelevium"
    },
    {
        "q": "Which is the most abundant gas in the atmosphere of Venus?",
        "o": ["Nitrogen", "Carbon Dioxide", "Methane", "Sulfuric Acid"],
        "a": "Carbon Dioxide"
    },
    {
        "q": "What is the name of the largest known volcano in the Solar System?",
        "o": ["Mount Everest", "Olympus Mons", "Mauna Kea", "Maxwell Montes"],
        "a": "Olympus Mons"
    },
    {
        "q": "The 'Library of Alexandria' was located in which modern-day country?",
        "o": ["Greece", "Egypt", "Italy", "Turkey"],
        "a": "Egypt"
    },
    {
        "q": "Which country is home to the 'Door to Hell' (Darvaza Gas Crater)?",
        "o": ["Kazakhstan", "Turkmenistan", "Uzbekistan", "Iran"],
        "a": "Turkmenistan"
    },
    {
        "q": "The 'Oort Cloud' is a theoretical shell of icy objects located...",
        "o": ["Between Mars and Jupiter", "Beyond Pluto (Outer Solar System)", "Around Saturn's Rings", "Inside the Sun's core"],
        "a": "Beyond Pluto (Outer Solar System)"
    },
    {
        "q": "Which treaty officially ended World War I?",
        "o": ["Treaty of Paris", "Treaty of Versailles", "Treaty of Ghent", "Treaty of Tordesillas"],
        "a": "Treaty of Versailles"
    },
    {
        "q": "What color is the sunset on Mars?",
        "o": ["Red", "Blue", "Green", "Yellow"],
        "a": "Blue"
    },
    {
        "q": "Which is the only country in the world to have a non-rectangular flag?",
        "o": ["Switzerland", "Nepal", "Vatican City", "Bhutan"],
        "a": "Nepal"
    },
    {
        "q": "The 'Tunguska Event' of 1908 occurred in which country?",
        "o": ["USA", "Russia", "Canada", "China"],
        "a": "Russia"
    },
    {
        "q": "Which planet rotates on its side (like a rolling ball)?",
        "o": ["Venus", "Uranus", "Neptune", "Saturn"],
        "a": "Uranus"
    },
    {
        "q": "The 'Hague' is the seat of government for which country, though not its capital?",
        "o": ["Belgium", "Netherlands", "Switzerland", "Denmark"],
        "a": "Netherlands"
    },
    {
        "q": "What is the name of the boundary that marks the edge of the heliosphere (Sun's influence)?",
        "o": ["Kuiper Belt", "Heliopause", "Oort Cloud", "Magnetosphere"],
        "a": "Heliopause"
    },
    {
        "q": "Which two countries share the longest international border?",
        "o": ["Russia and China", "USA and Canada", "Argentina and Chile", "India and China"],
        "a": "USA and Canada"
    },
    {
        "q": "The 'Year Without a Summer' (1816) was caused by the eruption of which volcano?",
        "o": ["Krakatoa", "Mount Tambora", "Vesuvius", "Mount St. Helens"],
        "a": "Mount Tambora"
    },
    {
        "q": "Which moon of Jupiter is considered the most likely place to find extraterrestrial life?",
        "o": ["Io", "Europa", "Ganymede", "Callisto"],
        "a": "Europa"
    },
    {
        "q": "The 'Zimmermann Telegram' was a secret diplomatic communication that pushed which country into WWI?",
        "o": ["Russia", "USA", "UK", "Italy"],
        "a": "USA"
    },
    {
        "q": "Which is the smallest country in the world by land area?",
        "o": ["Monaco", "Vatican City", "Nauru", "San Marino"],
        "a": "Vatican City"
    },
    {
        "q": "What is the term for a black hole formed by the collapse of a massive star?",
        "o": ["Supermassive Black Hole", "Stellar Black Hole", "Primordial Black Hole", "Miniature Black Hole"],
        "a": "Stellar Black Hole"
    },
    {
        "q": "Which country was formerly known as 'Ceylon'?",
        "o": ["Myanmar", "Sri Lanka", "Thailand", "Cambodia"],
        "a": "Sri Lanka"
    },
    {
        "q": "The 'Chandrasekhar Limit' (1.4 solar masses) determines the maximum mass of a...",
        "o": ["Neutron Star", "White Dwarf", "Black Hole", "Red Giant"],
        "a": "White Dwarf"
    },
    {
        "q": "Which South American country has two capitals (La Paz and Sucre)?",
        "o": ["Peru", "Bolivia", "Chile", "Ecuador"],
        "a": "Bolivia"
    },
    {
        "q": "The 'Goldilocks Zone' in astronomy refers to...",
        "o": ["Area with most gold asteroids", "Habitable zone around a star", "Center of the galaxy", "Safe zone for black holes"],
        "a": "Habitable zone around a star"
    },
    {
        "q": "Which empire was ruled by the 'Inca' civilization?",
        "o": ["Mexico", "Peru (Andes Region)", "Brazil", "Egypt"],
        "a": "Peru (Andes Region)"
    },
    {
        "q": "What is the name of the galaxy that is on a collision course with the Milky Way?",
        "o": ["Triangulum", "Andromeda", "Whirlpool", "Sombrero"],
        "a": "Andromeda"
    },
    {
        "q": "Which is the only continent with no active volcanoes?",
        "o": ["Australia", "Antarctica", "Europe", "Africa"],
        "a": "Australia"
    },
    {
        "q": "The 'Manhattan Project' was the research project that produced the first...",
        "o": ["Space Rocket", "Nuclear Weapon", "Internet", "Computer"],
        "a": "Nuclear Weapon"
    },
    {
        "q": "Which planet has the shortest day in the Solar System (rotates fastest)?",
        "o": ["Mercury", "Jupiter", "Earth", "Mars"],
        "a": "Jupiter"
    },
    {
        "q": "The 'Bering Strait' separates which two countries?",
        "o": ["UK and France", "USA (Alaska) and Russia", "Spain and Morocco", "Japan and Korea"],
        "a": "USA (Alaska) and Russia"
    },
    {
        "q": "Which chemical element has the symbol 'W'?",
        "o": ["Wolfram (Tungsten)", "Water", "White Phosphorous", "Wanium"],
        "a": "Wolfram (Tungsten)"
    },
    {
        "q": "The 'Great Red Spot' on Jupiter is essentially a massive...",
        "o": ["Volcano", "Storm (Anticyclone)", "Crater", "Ocean"],
        "a": "Storm (Anticyclone)"
    },
    {
        "q": "Which country is known as the 'Land of the Thunderbolt'?",
        "o": ["Nepal", "Bhutan", "Japan", "Tibet"],
        "a": "Bhutan"
    },
    {
        "q": "What is the theoretical boundary around a black hole called?",
        "o": ["Singularity", "Event Horizon", "Photon Ring", "Accretion Disk"],
        "a": "Event Horizon"
    },
    {
        "q": "Which war lasted for 335 years (1651â€“1986) without a single shot being fired?",
        "o": ["Three Hundred and Thirty Five Years' War", "Cold War", "Anglo-Dutch War", "The Silent War"],
        "a": "Three Hundred and Thirty Five Years' War"
    },
    {
        "q": "Which planet is known as the 'Morning Star' or 'Evening Star'?",
        "o": ["Mars", "Venus", "Mercury", "Jupiter"],
        "a": "Venus"
    },
    {
        "q": "The 'Dead Sea' is located between which two countries?",
        "o": ["Israel and Jordan", "Egypt and Saudi Arabia", "Turkey and Syria", "Iran and Iraq"],
        "a": "Israel and Jordan"
    },
    {
        "q": "Which spacecraft was the first to land humans on the Moon?",
        "o": ["Apollo 11", "Apollo 13", "Vostok 1", "Gemini 8"],
        "a": "Apollo 11"
    },
    {
        "q": "Which country has the most lakes in the world?",
        "o": ["USA", "Canada", "Russia", "Finland"],
        "a": "Canada"
    },
    {
        "q": "What is the term for the explosion of a dying star?",
        "o": ["Nebula", "Supernova", "Black Dwarf", "Red Giant"],
        "a": "Supernova"
    },
    {
        "q": "Which African nation was created by freed American slaves?",
        "o": ["Nigeria", "Liberia", "Ghana", "Kenya"],
        "a": "Liberia"
    },
    {
        "q": "The 'Kuiper Belt' is the home of which famous dwarf planet?",
        "o": ["Ceres", "Pluto", "Eris", "Sedna"],
        "a": "Pluto"
    },
    {
        "q": "Which city is located on two continents (Europe and Asia)?",
        "o": ["Moscow", "Istanbul", "Cairo", "Dubai"],
        "a": "Istanbul"
    },
    {
        "q": "Which gas gives Neptune and Uranus their blue color?",
        "o": ["Oxygen", "Methane", "Hydrogen", "Helium"],
        "a": "Methane"
    },
    {
        "q": "The 'Magna Carta' (1215) was signed by which King of England?",
        "o": ["King Henry VIII", "King John", "King Richard", "King George"],
        "a": "King John"
    },
    {
        "q": "What is the only substance on Earth found naturally in three forms (Solid, Liquid, Gas)?",
        "o": ["Mercury", "Water", "Carbon Dioxide", "Nitrogen"],
        "a": "Water"
    },
    {
        "q": "Which country owns the island of Greenland?",
        "o": ["Canada", "Denmark", "USA", "Norway"],
        "a": "Denmark"
    },
    {
        "q": "The 'Pillars of Creation' are located in which Nebula?",
        "o": ["Crab Nebula", "Eagle Nebula", "Orion Nebula", "Horsehead Nebula"],
        "a": "Eagle Nebula"
    },
    {
        "q": "Which ancient civilization built the Machu Picchu?",
        "o": ["Aztec", "Inca", "Maya", "Olmec"],
        "a": "Inca"
    },
    {
        "q": "What is the name of the first dog sent into space?",
        "o": ["Belka", "Laika", "Strelka", "Sputnik"],
        "a": "Laika"
    },
    {
        "q": "Which country is the largest producer of Coffee in the world?",
        "o": ["Colombia", "Brazil", "Vietnam", "Ethiopia"],
        "a": "Brazil"
    },
    {
        "q": "What phenomenon causes the 'Northern Lights'?",
        "o": ["Reflection of ice", "Solar Wind interacting with Magnetosphere", "Moonlight", "Volcanic Dust"],
        "a": "Solar Wind interacting with Magnetosphere"
    },
    {
        "q": "Which is the deepest known point in the Earth's oceans?",
        "o": ["Tonga Trench", "Challenger Deep (Mariana Trench)", "Puerto Rico Trench", "Java Trench"],
        "a": "Challenger Deep (Mariana Trench)"
    },
    {
        "q": "Who was the first person to travel into space?",
        "o": ["Neil Armstrong", "Yuri Gagarin", "Alan Shepard", "Buzz Aldrin"],
        "a": "Yuri Gagarin"
    },
    {
        "q": "Which country has the nickname 'The Land of Fire and Ice'?",
        "o": ["Greenland", "Iceland", "Norway", "New Zealand"],
        "a": "Iceland"
    },
    {
        "q": "The 'Zimmermann Plan' was a conspiracy between the Ghadar Party and which country to ship arms into India for a revolt?",
        "o": ["Japan", "Germany", "Russia", "Turkey"],
        "a": "Germany"
    },
    {
        "q": "Who was the defense lawyer for Bhagat Singh and Batukeshwar Dutt in the Assembly Bomb Case?",
        "o": ["Asaf Ali", "Bhulabhai Desai", "Tej Bahadur Sapru", "Kailash Nath Katju"],
        "a": "Asaf Ali"
    },
    {
        "q": "In the 1857 Revolt, who led the rebels in the region of Arrah (Bihar) and famously cut off his own injured hand to offer it to the Ganges?",
        "o": ["Nana Sahib", "Kunwar Singh", "Tatya Tope", "Maulvi Ahmadullah"],
        "a": "Kunwar Singh"
    },
    {
        "q": "Who founded the 'India House' in London, which became a hub for Indian revolutionaries abroad?",
        "o": ["Dadabhai Naoroji", "Shyamji Krishna Varma", "Madam Bhikaji Cama", "V.D. Savarkar"],
        "a": "Shyamji Krishna Varma"
    },
    {
        "q": "The 'Rampa Rebellion' of 1922-24 in Andhra Pradesh was led by which legendary tribal leader?",
        "o": ["Birsa Munda", "Alluri Sitarama Raju", "Komaram Bheem", "Sidhu Murmu"],
        "a": "Alluri Sitarama Raju"
    },
    {
        "q": "Who was the only woman to be part of the 'Hindustan Socialist Republican Association' (HSRA) core group?",
        "o": ["Durga Bhabhi (Durga Devi Vohra)", "Sushila Didi", "Kalpana Datta", "Lakshmi Sahgal"],
        "a": "Durga Bhabhi (Durga Devi Vohra)"
    },
    {
        "q": "Bagha Jatin (Jatin Mukherjee) died fighting the British police in a trench battle at which location in 1915?",
        "o": ["Chittagong", "Balasore", "Midnapore", "Alipore"],
        "a": "Balasore"
    },
    {
        "q": "Who authored the controversial book 'The Indian War of Independence, 1857', which was banned by the British?",
        "o": ["Lala Lajpat Rai", "V.D. Savarkar", "Bal Gangadhar Tilak", "Subhash Chandra Bose"],
        "a": "V.D. Savarkar"
    },
    {
        "q": "The 'Komagata Maru' incident involved a Japanese steamship chartered by whom?",
        "o": ["Kartar Singh Sarabha", "Gurdit Singh", "Sohan Singh Bhakna", "Lala Har Dayal"],
        "a": "Gurdit Singh"
    },
    {
        "q": "Who was the Commander-in-Chief of the 'Rani of Jhansi Regiment' of the INA?",
        "o": ["Lakshmi Sahgal", "Janaky Athi Nahappan", "Rasammah Bhupalan", "Aruna Asaf Ali"],
        "a": "Lakshmi Sahgal"
    },
    {
        "q": "Which revolutionary was known as 'Masterda' and led the Chittagong Armoury Raid in 1930?",
        "o": ["Surya Sen", "Rash Behari Bose", "Jatindranath Das", "Barindra Kumar Ghosh"],
        "a": "Surya Sen"
    },
    {
        "q": "Who betrayed the revolutionaries in the 'Kakori Conspiracy Case' by becoming an approver (government witness)?",
        "o": ["Banwari Lal", "Ram Prasad Bismil", "Ashfaqullah Khan", "Roshan Singh"],
        "a": "Banwari Lal"
    },
    {
        "q": "Jatindranath Das died in Lahore Jail after a hunger strike of how many days?",
        "o": ["50 Days", "63 Days", "90 Days", "45 Days"],
        "a": "63 Days"
    },
    {
        "q": "Who gave the title 'Mahatma' to Gandhi (often debated, but historically attributed to)?",
        "o": ["Subhash Chandra Bose", "Rabindranath Tagore", "Gopal Krishna Gokhale", "Jawaharlal Nehru"],
        "a": "Rabindranath Tagore"
    },
    {
        "q": "The 'Cunningham Circular' imposed in Assam during the Civil Disobedience Movement was against?",
        "o": ["Students participating in politics", "Farmers growing opium", "Tea garden workers", "Press freedom"],
        "a": "Students participating in politics"
    },
    {
        "q": "Who was the founder of the secret society 'Abhinav Bharat'?",
        "o": ["Aurobindo Ghosh", "V.D. Savarkar", "Pulin Behari Das", "Bhagat Singh"],
        "a": "V.D. Savarkar"
    },
    {
        "q": "In the Alipore Bomb Case (1908), who successfully defended Aurobindo Ghosh?",
        "o": ["C.R. Das (Chittaranjan Das)", "Motilal Nehru", "B.R. Ambedkar", "W.C. Bonnerjee"],
        "a": "C.R. Das (Chittaranjan Das)"
    },
    {
        "q": "Who hoisted the first version of the Indian flag at Stuttgart, Germany in 1907?",
        "o": ["Annie Besant", "Madam Bhikaji Cama", "Sarojini Naidu", "Sister Nivedita"],
        "a": "Madam Bhikaji Cama"
    },
    {
        "q": "Which British officer was assassinated by the Chapekar Brothers (Damodar and Balkrishna) in 1897?",
        "o": ["W.C. Rand", "Curzon Wyllie", "John Saunders", "General Dyer"],
        "a": "W.C. Rand"
    },
    {
        "q": "The 'Ulgulan' is a term associated with the rebellion led by?",
        "o": ["Sidhu and Kanhu", "Birsa Munda", "Tantia Bhil", "Rani Gaidinliu"],
        "a": "Birsa Munda"
    },
    {
        "q": "Who established the 'Provisional Government of Free India' in Kabul in 1915?",
        "o": ["Raja Mahendra Pratap", "Subhash Chandra Bose", "Rash Behari Bose", "Lala Har Dayal"],
        "a": "Raja Mahendra Pratap"
    },
    {
        "q": "Which revolutionary is known for the 'Silk Letter Conspiracy' (Reshmi Rumal Tehrik)?",
        "o": ["Maulana Abul Kalam Azad", "Maulana Ubaidullah Sindhi", "Khan Abdul Ghaffar Khan", "Hasrat Mohani"],
        "a": "Maulana Ubaidullah Sindhi"
    },
    {
        "q": "Who was the first President of the Ghadar Party?",
        "o": ["Lala Har Dayal", "Sohan Singh Bhakna", "Kartar Singh Sarabha", "Taraknath Das"],
        "a": "Sohan Singh Bhakna"
    },
    {
        "q": "The 'Royal Indian Navy (RIN) Mutiny' of 1946 started on which ship?",
        "o": ["HMIS Talwar", "HMIS Bombay", "HMIS Hindustan", "HMIS Shivaji"],
        "a": "HMIS Talwar"
    },
    {
        "q": "Who was the Viceroy of India when the Jallianwala Bagh Massacre took place?",
        "o": ["Lord Curzon", "Lord Chelmsford", "Lord Irwin", "Lord Reading"],
        "a": "Lord Chelmsford"
    },
    {
        "q": "Who wrote the song 'Sarfaroshi Ki Tamanna' made famous by Ram Prasad Bismil?",
        "o": ["Ram Prasad Bismil", "Bismil Azimabadi", "Mirza Ghalib", "Faiz Ahmed Faiz"],
        "a": "Bismil Azimabadi"
    },
    {
        "q": "The 'August Offer' of 1940 was proposed by which Viceroy?",
        "o": ["Lord Linlithgow", "Lord Wavell", "Lord Mountbatten", "Lord Willingdon"],
        "a": "Lord Linlithgow"
    },
    {
        "q": "Who was the only Indian to be elected as a Member of the British House of Commons in the 19th Century?",
        "o": ["Dadabhai Naoroji", "W.C. Bonnerjee", "Ferozeshah Mehta", "G.K. Gokhale"],
        "a": "Dadabhai Naoroji"
    },
    {
        "q": "Which organization was founded by Khan Abdul Ghaffar Khan (Frontier Gandhi)?",
        "o": ["Khudai Khidmatgar", "Ahrar Party", "Khaksar Party", "Muslim League"],
        "a": "Khudai Khidmatgar"
    },
    {
        "q": "Who called Subhash Chandra Bose 'Desh Nayak'?",
        "o": ["Mahatma Gandhi", "Rabindranath Tagore", "Jawaharlal Nehru", "Sardar Patel"],
        "a": "Rabindranath Tagore"
    },
    {
        "q": "The 'Bardoli Satyagraha' (1928) earned Vallabhbhai Patel which title?",
        "o": ["Iron Man", "Sardar", "Lokmanya", "Acharya"],
        "a": "Sardar"
    },
    {
        "q": "Who assassinated Sir Curzon Wyllie in London in 1909?",
        "o": ["Madan Lal Dhingra", "Udham Singh", "Bhagat Singh", "V.D. Savarkar"],
        "a": "Madan Lal Dhingra"
    },
    {
        "q": "The 'Vaikom Satyagraha' in Kerala was primarily related to?",
        "o": ["Temple Entry for lower castes", "Salt Tax", "Land rights for peasants", "Educational rights"],
        "a": "Temple Entry for lower castes"
    },
    {
        "q": "Who founded the 'All India Forward Bloc' after resigning from the Congress?",
        "o": ["M.N. Roy", "Subhash Chandra Bose", "J.P. Narayan", "Acharya Narendra Dev"],
        "a": "Subhash Chandra Bose"
    },
    {
        "q": "Which revolutionary shot dead the Approver (traitor) Phanindranath Ghosh who betrayed Bhagat Singh?",
        "o": ["Baikuntha Shukla", "Yogendra Shukla", "Batukeshwar Dutt", "Sukhdev"],
        "a": "Baikuntha Shukla"
    },
    {
        "q": "Who was the 'Political Guru' of Mahatma Gandhi?",
        "o": ["Bal Gangadhar Tilak", "Gopal Krishna Gokhale", "Dadabhai Naoroji", "Leo Tolstoy"],
        "a": "Gopal Krishna Gokhale"
    },
    {
        "q": "Who led the 'Revolt of 1857' in Lucknow?",
        "o": ["Begum Hazrat Mahal", "Rani Laxmibai", "Nana Sahib", "Khan Bahadur Khan"],
        "a": "Begum Hazrat Mahal"
    },
    {
        "q": "Which act was popularly known as the 'Black Act'?",
        "o": ["Rowlatt Act", "Vernacular Press Act", "Arms Act", "Ilbert Bill"],
        "a": "Rowlatt Act"
    },
    {
        "q": "The 'Teebhaga Movement' was a peasant agitation in which region?",
        "o": ["Bengal", "Telangana", "Punjab", "Madras"],
        "a": "Bengal"
    },
    {
        "q": "Who authored the book 'Poverty and Un-British Rule in India'?",
        "o": ["R.C. Dutt", "Dadabhai Naoroji", "M.G. Ranade", "G.K. Gokhale"],
        "a": "Dadabhai Naoroji"
    },
    {
        "q": "Which Session of Congress passed the 'Purna Swaraj' (Complete Independence) resolution?",
        "o": ["Lahore Session (1929)", "Calcutta Session (1928)", "Madras Session (1927)", "Karachi Session (1931)"],
        "a": "Lahore Session (1929)"
    },
    {
        "q": "Who was known as the 'Mother of Indian Revolution'?",
        "o": ["Sarojini Naidu", "Madam Bhikaji Cama", "Annie Besant", "Kasturba Gandhi"],
        "a": "Madam Bhikaji Cama"
    },
    {
        "q": "The famous 'Tryst with Destiny' speech was delivered by Nehru on?",
        "o": ["Midnight of Aug 14-15, 1947", "Jan 26, 1950", "Aug 15 Morning, 1947", "Jan 26, 1930"],
        "a": "Midnight of Aug 14-15, 1947"
    },
    {
        "q": "Who commanded the 'Gandhi Brigade' of the INA?",
        "o": ["Inayat Kiani", "Shah Nawaz Khan", "Prem Sahgal", "Gurbaksh Singh Dhillon"],
        "a": "Inayat Kiani"
    },
    {
        "q": "Who famously said 'Swaraj is my birthright and I shall have it'?",
        "o": ["Bal Gangadhar Tilak", "Lala Lajpat Rai", "Bipin Chandra Pal", "Aurobindo Ghosh"],
        "a": "Bal Gangadhar Tilak"
    },
    {
        "q": "Which revolutionary was popularly known as 'Sher-e-Punjab'?",
        "o": ["Bhagat Singh", "Lala Lajpat Rai", "Udham Singh", "Ranjit Singh"],
        "a": "Lala Lajpat Rai"
    },
    {
        "q": "The 'Moplah Rebellion' (1921) took place in which region?",
        "o": ["Malabar (Kerala)", "Konkan (Maharashtra)", "Coromandel (Tamil Nadu)", "Vidarbha"],
        "a": "Malabar (Kerala)"
    },
    {
        "q": "Who was the first Indian woman to become the President of the Indian National Congress?",
        "o": ["Annie Besant", "Sarojini Naidu", "Nellie Sengupta", "Sucheta Kripalani"],
        "a": "Sarojini Naidu"
    },
    {
        "q": "Who designed the current National Flag of India?",
        "o": ["Pingali Venkayya", "Rabindranath Tagore", "Bankim Chandra Chatterjee", "Alluri Sitarama Raju"],
        "a": "Pingali Venkayya"
    },
    {
        "q": "Who led the 'Salt Satyagraha' in Tamil Nadu (Vedaranyam March)?",
        "o": ["C. Rajagopalachari", "K. Kamaraj", "Subramania Siva", "V.O. Chidambaram"],
        "a": "C. Rajagopalachari"
    },
    {
        "q": "The 'Chauri Chaura' incident (1922) led to the withdrawal of which movement?",
        "o": ["Non-Cooperation Movement", "Civil Disobedience Movement", "Quit India Movement", "Khilafat Movement"],
        "a": "Non-Cooperation Movement"
    },
    {
        "q": "Who founded the 'Servants of India Society'?",
        "o": ["Gopal Krishna Gokhale", "Bal Gangadhar Tilak", "Lala Lajpat Rai", "M.G. Ranade"],
        "a": "Gopal Krishna Gokhale"
    },
    {
        "q": "Which revolutionary threw a bomb at Viceroy Lord Hardinge in 1912?",
        "o": ["Rash Behari Bose", "Bhagat Singh", "Khudiram Bose", "Prafulla Chaki"],
        "a": "Rash Behari Bose"
    },
    {
        "q": "Who was the only person to be elected President of the Congress for six consecutive years (1940-46)?",
        "o": ["Jawaharlal Nehru", "Abul Kalam Azad", "Vallabhbhai Patel", "J.B. Kripalani"],
        "a": "Abul Kalam Azad"
    },
    {
        "q": "The 'Mountbatten Plan' which led to the partition was announced on?",
        "o": ["June 3, 1947", "August 15, 1947", "January 26, 1947", "March 23, 1947"],
        "a": "June 3, 1947"
    },
    {
        "q": "Who was the Viceroy during the 'Quit India Movement' (1942)?",
        "o": ["Lord Linlithgow", "Lord Wavell", "Lord Mountbatten", "Lord Willingdon"],
        "a": "Lord Linlithgow"
    },
    {
        "q": "Who led the 'Red Shirts' (Kudai Khidmatgars) movement?",
        "o": ["Khan Abdul Ghaffar Khan", "Muhammad Ali Jinnah", "Liaquat Ali Khan", "Maulana Azad"],
        "a": "Khan Abdul Ghaffar Khan"
    },
    {
        "q": "Which revolutionary group was involved in the 'Lahore Conspiracy Case'?",
        "o": ["Hindustan Socialist Republican Association (HSRA)", "Anushilan Samiti", "Jugantar", "Ghadar Party"],
        "a": "Hindustan Socialist Republican Association (HSRA)"
    },
    {
        "q": "Who was the first martyr of the 1857 Revolt?",
        "o": ["Mangal Pandey", "Tatya Tope", "Nana Sahib", "Rani Laxmibai"],
        "a": "Mangal Pandey"
    },
    {
        "q": "Which newspaper was started by Bal Gangadhar Tilak?",
        "o": ["Kesari", "The Hindu", "Amrita Bazar Patrika", "Young India"],
        "a": "Kesari"
    },
    {
        "q": "Who is known as the 'Grand Old Man of India'?",
        "o": ["Dadabhai Naoroji", "W.C. Bonnerjee", "Mahatma Gandhi", "Madan Mohan Malaviya"],
        "a": "Dadabhai Naoroji"
    },
    {
        "q": "Who founded the 'Swatantra Party' after independence?",
        "o": ["C. Rajagopalachari", "J.B. Kripalani", "Dr. B.R. Ambedkar", "Shyama Prasad Mukherjee"],
        "a": "C. Rajagopalachari"
    },
    {
        "q": "The 'Direct Action Day' (1946) was called by which party?",
        "o": ["Muslim League", "Indian National Congress", "Hindu Mahasabha", "Communist Party"],
        "a": "Muslim League"
    },
    {
        "q": "Who was the defence lawyer for the INA Trials at Red Fort?",
        "o": ["Bhulabhai Desai", "B.R. Ambedkar", "Motilal Nehru", "Sardar Patel"],
        "a": "Bhulabhai Desai"
    },
    {
        "q": "Who established the 'Ramakrishna Mission'?",
        "o": ["Swami Vivekananda", "Ramakrishna Paramhansa", "Dayanand Saraswati", "Raja Ram Mohan Roy"],
        "a": "Swami Vivekananda"
    },
    {
        "q": "Which social reformer is associated with the abolition of Sati?",
        "o": ["Raja Ram Mohan Roy", "Ishwar Chandra Vidyasagar", "Dayanand Saraswati", "Jyotiba Phule"],
        "a": "Raja Ram Mohan Roy"
    },
    {
        "q": "Who wrote 'Gulamgiri'?",
        "o": ["Jyotiba Phule", "B.R. Ambedkar", "Periyar E.V. Ramasamy", "Kanshi Ram"],
        "a": "Jyotiba Phule"
    },
    {
        "q": "Who led the 'Paika Rebellion' (1817) in Odisha?",
        "o": ["Bakshi Jagabandhu", "Veer Surendra Sai", "Tantia Bhil", "Birsa Munda"],
        "a": "Bakshi Jagabandhu"
    },
    {
        "q": "Which river is known as the 'Sorrow of Bihar' because of its frequent course changes and floods?",
        "o": ["Gandak", "Kosi", "Son", "Ghaghara"],
        "a": "Kosi"
    },
    {
        "q": "The 'Duncan Passage' separates which two islands?",
        "o": ["South Andaman and Little Andaman", "Little Andaman and Car Nicobar", "North Andaman and Middle Andaman", "Minicoy and Maldives"],
        "a": "South Andaman and Little Andaman"
    },
    {
        "q": "Which mountain range separates the Indo-Gangetic plain from the Deccan Plateau?",
        "o": ["Aravalli", "Vindhya", "Satpura", "Western Ghats"],
        "a": "Vindhya"
    },
    {
        "q": "The famous 'Loktak Lake', known for its floating phumdis (islands), is located in which state?",
        "o": ["Mizoram", "Manipur", "Meghalaya", "Tripura"],
        "a": "Manipur"
    },
    {
        "q": "Which is the highest peak of the Satpura Range?",
        "o": ["Guru Shikhar", "Dhupgarh", "Pachmarhi", "Mahendragiri"],
        "a": "Dhupgarh"
    },
    {
        "q": "The 'Main Central Thrust' (MCT) separates which two geological zones of the Himalayas?",
        "o": ["Great Himalayas and Lesser Himalayas", "Lesser Himalayas and Shiwaliks", "Trans Himalayas and Great Himalayas", "Shiwaliks and Northern Plains"],
        "a": "Great Himalayas and Lesser Himalayas"
    },
    {
        "q": "Which river in India crosses the Tropic of Cancer twice?",
        "o": ["Narmada", "Tapi", "Mahi", "Sabarmati"],
        "a": "Mahi"
    },
    {
        "q": "The 'Silent Valley National Park' is located in which hill range?",
        "o": ["Nilgiri Hills", "Cardamom Hills", "Palani Hills", "Anaimalai Hills"],
        "a": "Nilgiri Hills"
    },
    {
        "q": "Which state has the largest coastline in India?",
        "o": ["Tamil Nadu", "Maharashtra", "Andhra Pradesh", "Gujarat"],
        "a": "Gujarat"
    },
    {
        "q": "The 'Karewas' of Kashmir are famous for the cultivation of which crop?",
        "o": ["Apple", "Walnut", "Saffron (Zafran)", "Almond"],
        "a": "Saffron (Zafran)"
    },
    {
        "q": "Which river flows through a Rift Valley between the Vindhya and Satpura ranges?",
        "o": ["Godavari", "Mahanadi", "Narmada", "Krishna"],
        "a": "Narmada"
    },
    {
        "q": "At which place does the Alaknanda and Bhagirathi rivers meet to form the Ganga?",
        "o": ["Rudraprayag", "Devprayag", "Karnaprayag", "Vishnuprayag"],
        "a": "Devprayag"
    },
    {
        "q": "The 'Palk Strait' lies between which two countries?",
        "o": ["India and Maldives", "India and Sri Lanka", "India and Indonesia", "Andaman and Thailand"],
        "a": "India and Sri Lanka"
    },
    {
        "q": "Which soil is popularly known as 'Regur Soil'?",
        "o": ["Alluvial Soil", "Red Soil", "Black Soil", "Laterite Soil"],
        "a": "Black Soil"
    },
    {
        "q": "The 'Nathu La' pass connects India with which country?",
        "o": ["Pakistan", "Nepal", "China (Tibet)", "Bhutan"],
        "a": "China (Tibet)"
    },
    {
        "q": "Which is the only floating National Park in the world?",
        "o": ["Kaziranga", "Keibul Lamjao", "Manas", "Sundarbans"],
        "a": "Keibul Lamjao"
    },
    {
        "q": "The 'Western Disturbances' which cause winter rains in North-West India originate from?",
        "o": ["Arabian Sea", "Bay of Bengal", "Mediterranean Sea", "Caspian Sea"],
        "a": "Mediterranean Sea"
    },
    {
        "q": "Which Indian state shares its border with the maximum number of other Indian states?",
        "o": ["Madhya Pradesh", "Uttar Pradesh", "Maharashtra", "Assam"],
        "a": "Uttar Pradesh"
    },
    {
        "q": "The 'Majuli' island, the largest river island in the world, is formed by which river?",
        "o": ["Ganga", "Brahmaputra", "Indus", "Godavari"],
        "a": "Brahmaputra"
    },
    {
        "q": "Which place in India is famously known as the 'Coldest Inhabited Place'?",
        "o": ["Leh", "Dras", "Kargil", "Siachen"],
        "a": "Dras"
    },
    {
        "q": "The 'Toda' tribe is the original inhabitant of which region?",
        "o": ["Aravalli Range", "Nilgiri Hills", "Garo Hills", "Bastar"],
        "a": "Nilgiri Hills"
    },
    {
        "q": "Which port is known as the 'Queen of Arabian Sea'?",
        "o": ["Mumbai Port", "Kochi Port", "Kandla Port", "Marmagao Port"],
        "a": "Kochi Port"
    },
    {
        "q": "The highest peak of the Eastern Ghats is...",
        "o": ["Mahendragiri", "Arma Konda", "Jindhagada", "Shevaroy"],
        "a": "Jindhagada"
    },
    {
        "q": "Which Indian state is known as the 'Molasses Basin'?",
        "o": ["Mizoram", "Bihar", "Assam", "Uttar Pradesh"],
        "a": "Mizoram"
    },
    {
        "q": "The Tropic of Cancer does NOT pass through which of these Indian states?",
        "o": ["Tripura", "Mizoram", "Odisha", "Jharkhand"],
        "a": "Odisha"
    },
    {
        "q": "Which channel separates the Lakshadweep Islands from the Maldives?",
        "o": ["8 Degree Channel", "9 Degree Channel", "10 Degree Channel", "Duncan Passage"],
        "a": "8 Degree Channel"
    },
    {
        "q": "The famous 'Hornbill Festival' is celebrated in which state?",
        "o": ["Manipur", "Nagaland", "Arunachal Pradesh", "Meghalaya"],
        "a": "Nagaland"
    },
    {
        "q": "Where is the 'Great Indian Bustard' primarily found?",
        "o": ["Desert National Park", "Jim Corbett", "Kaziranga", "Gir Forest"],
        "a": "Desert National Park"
    },
    {
        "q": "The 'Diphu Pass' is a tri-junction between which three countries?",
        "o": ["India, Nepal, China", "India, China, Myanmar", "India, Bhutan, China", "India, Myanmar, Bangladesh"],
        "a": "India, China, Myanmar"
    },
    {
        "q": "Which river is the longest tributary of the Ganga?",
        "o": ["Yamuna", "Son", "Gomti", "Kosi"],
        "a": "Yamuna"
    },
    {
        "q": "The 'Zoji La' pass connects which two locations?",
        "o": ["Srinagar and Leh", "Manali and Leh", "Jammu and Srinagar", "Leh and Siachen"],
        "a": "Srinagar and Leh"
    },
    {
        "q": "Which Indian state has the highest forest cover in terms of area?",
        "o": ["Arunachal Pradesh", "Madhya Pradesh", "Chhattisgarh", "Odisha"],
        "a": "Madhya Pradesh"
    },
    {
        "q": "The 'Jaduguda' mines in Jharkhand are famous for?",
        "o": ["Coal", "Uranium", "Iron Ore", "Bauxite"],
        "a": "Uranium"
    },
    {
        "q": "Which waterfall is the highest plunge waterfall in India?",
        "o": ["Jog Falls", "Kunchikal Falls", "Nohkalikai Falls", "Dudhsagar Falls"],
        "a": "Nohkalikai Falls"
    },
    {
        "q": "The 'Coromandel Coast' receives most of its rainfall during which season?",
        "o": ["South-West Monsoon", "North-East Monsoon (Winter)", "Summer", "Pre-Monsoon Showers"],
        "a": "North-East Monsoon (Winter)"
    },
    {
        "q": "Which is the largest lagoon lake in India?",
        "o": ["Pulicat Lake", "Chilika Lake", "Vembanad Lake", "Sambhar Lake"],
        "a": "Chilika Lake"
    },
    {
        "q": "The 'Indira Point', the southernmost point of India, is located in?",
        "o": ["Little Nicobar", "Great Nicobar", "Car Nicobar", "North Andaman"],
        "a": "Great Nicobar"
    },
    {
        "q": "Which river originates from the Amarkantak Plateau?",
        "o": ["Narmada", "Godavari", "Krishna", "Kaveri"],
        "a": "Narmada"
    },
    {
        "q": "The 'Saddle Peak' is the highest peak of Andaman and Nicobar. Where is it located?",
        "o": ["North Andaman", "Middle Andaman", "South Andaman", "Great Nicobar"],
        "a": "North Andaman"
    },
    {
        "q": "Which state is the largest producer of Coffee in India?",
        "o": ["Kerala", "Karnataka", "Tamil Nadu", "Assam"],
        "a": "Karnataka"
    },
    {
        "q": "The 'Sahyadri' is another name for which mountain range?",
        "o": ["Eastern Ghats", "Western Ghats", "Aravalli", "Himalayas"],
        "a": "Western Ghats"
    },
    {
        "q": "Which river is known as 'Dakshin Ganga' (Ganga of the South)?",
        "o": ["Krishna", "Kaveri", "Godavari", "Mahanadi"],
        "a": "Godavari"
    },
    {
        "q": "In which state is the 'Gahirmatha Marine Sanctuary', famous for Olive Ridley Turtles, located?",
        "o": ["West Bengal", "Odisha", "Andhra Pradesh", "Tamil Nadu"],
        "a": "Odisha"
    },
    {
        "q": "The 'Malwa Plateau' spreads across which states?",
        "o": ["MP, Gujarat, Rajasthan", "Maharashtra, MP, UP", "Gujarat, Rajasthan, Haryana", "MP, Chhattisgarh, Jharkhand"],
        "a": "MP, Gujarat, Rajasthan"
    },
    {
        "q": "What is the approximate total length of India's coastline (including islands)?",
        "o": ["6100 km", "7516 km", "8100 km", "5400 km"],
        "a": "7516 km"
    },
    {
        "q": "Which Indian river flows into the Arabian Sea?",
        "o": ["Mahanadi", "Godavari", "Tapi", "Krishna"],
        "a": "Tapi"
    },
    {
        "q": "The 'Patkai Bum' hills form the boundary between India and?",
        "o": ["China", "Myanmar", "Bangladesh", "Bhutan"],
        "a": "Myanmar"
    },
    {
        "q": "Which glacier is the source of the River Yamuna?",
        "o": ["Gangotri", "Yamunotri (Bandarpunch)", "Milam", "Pindari"],
        "a": "Yamunotri (Bandarpunch)"
    },
    {
        "q": "The 'Khajjiar' lake, often called 'Mini Switzerland of India', is in?",
        "o": ["Uttarakhand", "Himachal Pradesh", "Jammu & Kashmir", "Sikkim"],
        "a": "Himachal Pradesh"
    },
    {
        "q": "The 'Dead Internet Theory' is a conspiracy theory suggesting that the majority of internet traffic is actually...",
        "o": ["Government Spies", "Bots interacting with other Bots", "Aliens", "Hackers"],
        "a": "Bots interacting with other Bots"
    },
    {
        "q": "Which modern psychological condition is defined as 'the fear of being out of mobile phone contact'?",
        "o": ["Technophobia", "Nomophobia", "Cyberphobia", "Telephobia"],
        "a": "Nomophobia"
    },
    {
        "q": "In 2010, the 'Stuxnet' computer worm was discovered. It was unique because it was the first cyberweapon specifically designed to target...",
        "o": ["Bank Accounts", "Social Media Passwords", "Nuclear Centrifuges (SCADA systems)", "Satellite GPS"],
        "a": "Nuclear Centrifuges (SCADA systems)"
    },
    {
        "q": "What is the name of the specific 'Consensus Mechanism' that Bitcoin uses to secure its network (which requires high energy)?",
        "o": ["Proof of Stake", "Proof of Work", "Proof of History", "Proof of Authority"],
        "a": "Proof of Work"
    },
    {
        "q": "Elon Musk's SpaceX became the first private company to send humans to the ISS. What was the name of the capsule they used?",
        "o": ["Starship", "Dragon Endeavour", "Falcon Heavy", "Orion"],
        "a": "Dragon Endeavour"
    },
    {
        "q": "In the context of Artificial Intelligence (AI), what does 'GPT' stand for in models like ChatGPT?",
        "o": ["General Processing Tool", "Generative Pre-trained Transformer", "Global Positioning Tech", "Genetic Programming Transmitter"],
        "a": "Generative Pre-trained Transformer"
    },
    {
        "q": "Which company owns the advanced robotics firm 'Boston Dynamics' (creators of Spot and Atlas) as of 2024?",
        "o": ["Google", "SoftBank", "Hyundai", "Tesla"],
        "a": "Hyundai"
    },
    {
        "q": "The 'Mandela Effect' is a phenomenon where a large group of people remember something differently than how it occurred. Which character is often cited as an example (monocle confusion)?",
        "o": ["Mickey Mouse", "Richie Rich", "Mr. Monopoly (Monopoly Man)", "Pringles Man"],
        "a": "Mr. Monopoly (Monopoly Man)"
    },
    {
        "q": "What is the specific HTTP Status Code for 'Censored / Unavailable For Legal Reasons'?",
        "o": ["404", "403", "451", "500"],
        "a": "451"
    },
    {
        "q": "In modern economics, a startup company valued at over $10 billion is specifically called a...?",
        "o": ["Unicorn", "Decacorn", "Hectocorn", "Centicorn"],
        "a": "Decacorn"
    },
    {
        "q": "The 'Dark Web' is often accessed using the TOR browser. What does TOR stand for?",
        "o": ["The Onion Router", "The Open Road", "Total Online Resistance", "The Obscure Relay"],
        "a": "The Onion Router"
    },
    {
        "q": "Which controversial gene-editing technology won the Nobel Prize in Chemistry in 2020?",
        "o": ["mRNA", "CRISPR-Cas9", "Cloning", "Stem Cell Therapy"],
        "a": "CRISPR-Cas9"
    },
    {
        "q": "What is the name of the 'limit' that suggests Moore's Law (computing power doubling) will eventually stop due to quantum effects?",
        "o": ["The Silicon Wall", "The Quantum Limit", "The Thermal Ceiling", "The Atomic Limit"],
        "a": "The Thermal Ceiling"
    },
    {
        "q": "In 2021, a digital artwork by Beeple sold for $69 million as an NFT. What was the title of this piece?",
        "o": ["The First 5000 Days", "CryptoPunks #1", "Bored Ape", "Quantum Genesis"],
        "a": "The First 5000 Days"
    },
    {
        "q": "Which social media platform was originally known as 'Musical.ly' before it was rebranded?",
        "o": ["Snapchat", "TikTok", "Vine", "Instagram Reels"],
        "a": "TikTok"
    },
    {
        "q": "The 'James Webb Space Telescope' orbits the Sun at a specific stable point called...?",
        "o": ["Low Earth Orbit", "Lagrange Point 2 (L2)", "Geostationary Orbit", "Lunar Orbit"],
        "a": "Lagrange Point 2 (L2)"
    },
    {
        "q": "What is the term for the psychological phenomenon where people with low ability at a task overestimate their ability (often seen on the internet)?",
        "o": ["Imposter Syndrome", "Dunning-Kruger Effect", "Placebo Effect", "Stockholm Syndrome"],
        "a": "Dunning-Kruger Effect"
    },
    {
        "q": "In the context of 5G technology, which frequency band offers the highest speeds but the shortest range (easily blocked by walls)?",
        "o": ["Sub-6 GHz", "mmWave (Millimeter Wave)", "Low-Band", "Mid-Band"],
        "a": "mmWave (Millimeter Wave)"
    },
    {
        "q": "The first-ever video uploaded to YouTube in 2005 is titled...?",
        "o": ["My Cat", "Hello World", "Me at the zoo", "Evolution of Dance"],
        "a": "Me at the zoo"
    },
    {
        "q": "Which element is crucial for Lithium-ion batteries but is controversial due to unethical mining practices in the DRC?",
        "o": ["Nickel", "Cobalt", "Manganese", "Graphite"],
        "a": "Cobalt"
    },
    {
        "q": "What does the 'S' stand for in the HTTPS protocol used for secure browsing?",
        "o": ["Standard", "System", "Secure", "Socket"],
        "a": "Secure"
    },
    {
        "q": "In the Marvel Cinematic Universe (MCU), which material is Captain America's shield made of?",
        "o": ["Adamantium", "Vibranium", "Uru", "Carbonadium"],
        "a": "Vibranium"
    },
    {
        "q": "The 'Great Pacific Garbage Patch' is primarily located between which two landmasses?",
        "o": ["California and Hawaii", "Japan and Philippines", "Australia and New Zealand", "Chile and Easter Island"],
        "a": "California and Hawaii"
    },
    {
        "q": "Who is the mysterious creator of Bitcoin (whose real identity is still unknown)?",
        "o": ["Vitalik Buterin", "Satoshi Nakamoto", "Nick Szabo", "Craig Wright"],
        "a": "Satoshi Nakamoto"
    },
    {
        "q": "In modern gaming, what does the term 'NPC' stand for?",
        "o": ["Non-Playable Character", "New Player Control", "Network Protocol Code", "Natural Person Character"],
        "a": "Non-Playable Character"
    },
    {
        "q": "Which tech company reached a $3 Trillion market cap first?",
        "o": ["Microsoft", "Apple", "Nvidia", "Amazon"],
        "a": "Apple"
    },
    {
        "q": "What is the name of the AI developed by DeepMind that defeated the world champion of the board game 'Go' in 2016?",
        "o": ["Deep Blue", "AlphaGo", "Watson", "Stockfish"],
        "a": "AlphaGo"
    },
    {
        "q": "The 'Blue Screen of Death' (BSOD) is associated with which Operating System?",
        "o": ["macOS", "Linux", "Windows", "Android"],
        "a": "Windows"
    },
    {
        "q": "Which country became the first in the world to make Bitcoin legal tender in 2021?",
        "o": ["El Salvador", "Venezuela", "Japan", "Switzerland"],
        "a": "El Salvador"
    },
    {
        "q": "In the world of streaming, which platform was acquired by Amazon for $970 million in 2014?",
        "o": ["YouTube Gaming", "Twitch", "Mixer", "Kick"],
        "a": "Twitch"
    },
    {
        "q": "What is the term for 'Malware that locks your files and demands payment to unlock them'?",
        "o": ["Spyware", "Ransomware", "Adware", "Worm"],
        "a": "Ransomware"
    },
    {
        "q": "Which famous whistleblower leaked classified NSA documents in 2013 regarding global surveillance?",
        "o": ["Julian Assange", "Edward Snowden", "Chelsea Manning", "Aaron Swartz"],
        "a": "Edward Snowden"
    },
    {
        "q": "In modern dating slang, what does 'Ghosting' mean?",
        "o": ["Stalking someone online", "Cutting off communication without warning", "Dating two people at once", "Using a fake profile photo"],
        "a": "Cutting off communication without warning"
    },
    {
        "q": "The 'Metaverse' concept was popularized by Neal Stephenson in his 1992 novel. What is the book's title?",
        "o": ["Ready Player One", "Snow Crash", "Neuromancer", "The Matrix"],
        "a": "Snow Crash"
    },
    {
        "q": "Which company created the programming language 'Java'?",
        "o": ["Microsoft", "Sun Microsystems", "Apple", "Oracle (Acquired later)"],
        "a": "Sun Microsystems"
    },
    {
        "q": "What is the name of the cognitive bias where people rely too heavily on the first piece of information offered (the 'anchor')?",
        "o": ["Confirmation Bias", "Anchoring Bias", "Recency Bias", "Hindsight Bias"],
        "a": "Anchoring Bias"
    },
    {
        "q": "The 'Panama Papers' leak in 2016 exposed the financial secrets of the wealthy. Which law firm was at the center of it?",
        "o": ["Mossack Fonseca", "Baker McKenzie", "Clifford Chance", "Skadden Arps"],
        "a": "Mossack Fonseca"
    },
    {
        "q": "In modern slang, what does 'FOMO' stand for?",
        "o": ["Fear Of Moving On", "Fear Of Missing Out", "For Our Mom Only", "Fear Of Making Over"],
        "a": "Fear Of Missing Out"
    },
    {
        "q": "Which specific isotope of Uranium is needed for a nuclear fission chain reaction (atomic bomb)?",
        "o": ["U-238", "U-235", "U-234", "U-239"],
        "a": "U-235"
    },
    {
        "q": "The 'Turing Test', proposed by Alan Turing, was designed to test a machine's ability to...",
        "o": ["Calculate faster than humans", "Exhibit intelligent behavior equivalent to a human", "Play Chess", "Translate languages"],
        "a": "Exhibit intelligent behavior equivalent to a human"
    },
    {
        "q": "What is the term for a cyber attack where a system is flooded with traffic to crash it?",
        "o": ["Phishing", "DDoS (Distributed Denial of Service)", "SQL Injection", "Man-in-the-Middle"],
        "a": "DDoS (Distributed Denial of Service)"
    },
    {
        "q": "Which famous car brand owns 'Bugatti' (as part of a joint venture with Rimac)?",
        "o": ["Ferrari", "Porsche (VW Group)", "Mercedes", "BMW"],
        "a": "Porsche (VW Group)"
    },
    {
        "q": "The 'QR' in QR Code stands for...?",
        "o": ["Quick Response", "Quantum Read", "Quality Register", "Quick Register"],
        "a": "Quick Response"
    },
    {
        "q": "Which modern tech giant was originally founded under the name 'Cadabra'?",
        "o": ["eBay", "Amazon", "Netflix", "Google"],
        "a": "Amazon"
    },
    {
        "q": "In the show 'Squid Game', what is the shape on the mask of the Workers (lowest rank)?",
        "o": ["Square", "Triangle", "Circle", "Star"],
        "a": "Circle"
    },
    {
        "q": "The 'Doomsday Clock', which represents the likelihood of a man-made global catastrophe, is currently set at...?",
        "o": ["5 Minutes to Midnight", "100 Seconds to Midnight", "90 Seconds to Midnight", "1 Minute to Midnight"],
        "a": "90 Seconds to Midnight"
    },
    {
        "q": "Which country is home to 'TSMC', the world's most valuable semiconductor (chip) manufacturing company?",
        "o": ["China", "Taiwan", "South Korea", "USA"],
        "a": "Taiwan"
    },
    {
        "q": "What does the 'G' in '5G' network stand for?",
        "o": ["Gigabyte", "Generation", "Global", "GHz"],
        "a": "Generation"
    },
    {
        "q": "Who is the artist behind the shredded artwork 'Girl with Balloon' (Love is in the Bin)?",
        "o": ["Kaws", "Banksy", "Damien Hirst", "Yayoi Kusama"],
        "a": "Banksy"
    },
    {
        "q": "Which enzyme is used in PCR to amplify DNA, isolated from a thermophilic bacterium?",
        "o": ["Pepsin", "Taq Polymerase", "Amylase", "Helicase"],
        "a": "Taq Polymerase"
    },
    {
        "q": "Operation 'Smiling Buddha' (1974) was India's first nuclear test. Where did it take place?",
        "o": ["Kargil", "Pokhran", "Sriharikota", "Chandipur"],
        "a": "Pokhran"
    },
    {
        "q": "The 'Piri Reis Map' (1513) is controversial because it seemingly depicts which landmass?",
        "o": ["Australia", "Antarctica (coastline)", "Greenland", "Japan"],
        "a": "Antarctica (coastline)"
    },
    {
        "q": "The 'Razmnama' is a famous illustrated Persian translation of a Hindu epic commissioned by Emperor Akbar. Which epic is it?",
        "o": ["Ramayana", "Mahabharata", "Atharva Veda", "Bhagavad Gita"],
        "a": "Mahabharata"
    },
    {
        "q": "During the Cold War, the CIA spent $20 million on 'Operation Acoustic Kitty'. What was the objective?",
        "o": ["Train cats to spy on the Soviets", "Use cats to detect nuclear radiation", "Drop cats with parachutes for morale", "Use cats to hunt rats in bunkers"],
        "a": "Train cats to spy on the Soviets"
    },
    {
        "q": "Which is the only letter of the English alphabet that does NOT appear in the Periodic Table of Elements?",
        "o": ["J", "Q", "X", "Z"],
        "a": "J"
    },
    {
        "q": "In the Mahabharata, who was the only Kaurava brother who fought on the side of the Pandavas during the Kurukshetra war?",
        "o": ["Vikarna", "Yuyutsu", "Dussasana", "Durmukha"],
        "a": "Yuyutsu"
    },
    {
        "q": "The 'Baghdad Battery', a set of artifacts dating back to the Parthian/Sassanid periods, suggests that ancient people might have had knowledge of...",
        "o": ["Gunpowder", "Electroplating/Electricity", "Steam Engine", "Telescopes"],
        "a": "Electroplating/Electricity"
    },
    {
        "q": "Which country technically has the most Time Zones in the world (including overseas territories)?",
        "o": ["Russia", "China", "USA", "France"],
        "a": "France"
    },
    {
        "q": "In computing, the HTTP Error Code '418' is a real standard defined in RFC 2324. What does it stand for?",
        "o": ["I'm a teapot", "Payment Required", "Legal Obstacle", "Method Not Allowed"],
        "a": "I'm a teapot"
    },
    {
        "q": "The 'Peacock Throne' (Takht-i-Taus) of Shah Jahan was famously looted by Nadir Shah in 1739. Which precious gem was NOT originally part of it?",
        "o": ["Koh-i-Noor", "Akbar Shah Diamond", "Hope Diamond", "Timur Ruby"],
        "a": "Hope Diamond"
    },
    {
        "q": "What is the name of the specific boundary around a Black Hole beyond which nothing, not even light, can escape?",
        "o": ["Singularity", "Accretion Disk", "Event Horizon", "Photon Sphere"],
        "a": "Event Horizon"
    },
    {
        "q": "Who was the first human to calculate the circumference of the Earth with surprising accuracy using only sticks and shadows?",
        "o": ["Pythagoras", "Eratosthenes", "Archimedes", "Aristotle"],
        "a": "Eratosthenes"
    },
    {
        "q": "The 'Code of Hammurabi' is one of the oldest deciphered writings of significant length. It works on the principle of 'Lex Talionis', which means?",
        "o": ["Innocent until proven guilty", "Eye for an eye", "Divine right of kings", "Taxation for protection"],
        "a": "Eye for an eye"
    },
    {
        "q": "In the human body, the 'Hyoid Bone' is unique because it is the only bone that...",
        "o": ["Cannot break", "Is not connected to any other bone", "Does not stop growing", "Is made of cartilage"],
        "a": "Is not connected to any other bone"
    },
    {
        "q": "The 'Wow! Signal' (1977) was a strong narrowband radio signal received from space. Which constellation did it appear to come from?",
        "o": ["Orion", "Sagittarius", "Ursa Major", "Andromeda"],
        "a": "Sagittarius"
    },
    {
        "q": "Which Mughal Emperor re-imposed the 'Jizya' tax on non-Muslims in 1679, almost a century after it was abolished by Akbar?",
        "o": ["Jahangir", "Shah Jahan", "Aurangzeb", "Bahadur Shah I"],
        "a": "Aurangzeb"
    },
    {
        "q": "The 'Dancing Girl' statue from Mohenjo-daro is made of which material?",
        "o": ["Terracotta", "Bronze", "Steatite", "Gold"],
        "a": "Bronze"
    },
    {
        "q": "The 'Demon Core' was a subcritical mass of Plutonium involved in two fatal accidents at Los Alamos. What tool did physicist Louis Slotin use to accidentally slip, causing the burst?",
        "o": ["A Screwdriver", "A Pair of Tongs", "A Wrench", "A Robotic Arm"],
        "a": "A Screwdriver"
    },
    {
        "q": "In the Indian Constitution, the original handwritten document was calligraphed by Prem Behari Narain Raizada, but who was the specific artist responsible for the illustrations/artwork?",
        "o": ["Rabindranath Tagore", "Nandalal Bose", "Raja Ravi Varma", "Abanindranath Tagore"],
        "a": "Nandalal Bose"
    },
    {
        "q": "The 'Sargasso Sea' is unique in the world because it is the only sea that...",
        "o": ["Has no coastlines", "Has zero salt content", "Is located underground", "Freezes completely in winter"],
        "a": "Has no coastlines"
    },
    {
        "q": "In 1990, the 'Pale Blue Dot' photograph of Earth was taken by Voyager 1 from a distance of 6 billion kilometers. Who famously requested this photo be taken?",
        "o": ["Carl Sagan", "Neil deGrasse Tyson", "Stephen Hawking", "Elon Musk"],
        "a": "Carl Sagan"
    },
    {
        "q": "The 'Great Attractor' is a gravitational anomaly in intergalactic space. Which supercluster is our Milky Way galaxy being pulled towards because of it?",
        "o": ["Virgo Supercluster", "Laniakea Supercluster", "Coma Supercluster", "Perseus-Pisces Supercluster"],
        "a": "Laniakea Supercluster"
    },
    {
        "q": "Which obscure Mughal Prince translated 50 Upanishads from Sanskrit into Persian, calling the collection 'Sirr-i-Akbar' (The Great Secret)?",
        "o": ["Dara Shikoh", "Aurangzeb", "Jahangir", "Shah Shuja"],
        "a": "Dara Shikoh"
    },
    {
        "q": "The 'Ship of Theseus' is a famous paradox in philosophy. It questions the nature of identity by asking what happens if...",
        "o": ["A ship sinks and is rebuilt", "Every wooden part is replaced one by one", "It sails forever without stopping", "It has no captain"],
        "a": "Every wooden part is replaced one by one"
    },
    {
        "q": "In 1971, Ray Tomlinson sent the first ARPANET email. What symbol did he choose to separate the user name from the destination address?",
        "o": ["# (Hash)", "@ (At)", "/ (Slash)", ". (Dot)"],
        "a": "@ (At)"
    },
    {
        "q": "The 'Rosetta Stone' was key to deciphering Egyptian Hieroglyphs. It features three scripts: Hieroglyphic, Greek, and...?",
        "o": ["Demotic", "Coptic", "Latin", "Sanskrit"],
        "a": "Demotic"
    },
    {
        "q": "What is the specific name of the rust-resistant iron used in the 'Iron Pillar of Delhi', which has prevented corrosion for over 1600 years?",
        "o": ["Stainless Steel", "Wrought Iron with high Phosphorus", "Galvanized Iron", "Titanium Alloy"],
        "a": "Wrought Iron with high Phosphorus"
    },
    {
        "q": "In the Ramayana, who was the only warrior capable of using the 'Vaishnavastra' besides Lord Rama and Lakshmana?",
        "o": ["Ravana", "Indrajit (Meghanada)", "Kumbhakarna", "Vibhishana"],
        "a": "Indrajit (Meghanada)"
    },
    {
        "q": "The 'Kardashev Scale' measures a civilization's technological advancement based on what specific metric?",
        "o": ["Population size", "Information storage capacity", "Energy consumption", "Space colonization range"],
        "a": "Energy consumption"
    },
    {
        "q": "Which gas is primarily responsible for the distinct smell of rain on dry soil (Petrichor)?",
        "o": ["Ozone", "Geosmin", "Methane", "Nitrous Oxide"],
        "a": "Geosmin"
    },
    {
        "q": "The 'Beale Ciphers' are a set of three ciphertexts that supposedly reveal the location of buried treasure worth $60 million. Which famous document is the key to the second cipher?",
        "o": ["Magna Carta", "The US Declaration of Independence", "The Bible", "Shakespeare's Sonnets"],
        "a": "The US Declaration of Independence"
    },
    {
        "q": "In computer programming, the date 'January 19, 2038' is significant because of the 'Year 2038 Problem'. Which systems will this affect?",
        "o": ["64-bit systems", "32-bit signed integer systems", "Quantum Computers", "Windows 11"],
        "a": "32-bit signed integer systems"
    },
    {
        "q": "In computer science, 'P vs NP' is a major problem. What does 'NP' stand for?",
        "o": ["Non-Polynomial", "Nondeterministic Polynomial", "New Programming", "Null Pointer"],
        "a": "Nondeterministic Polynomial"
    }
]

# ================== ğŸ§  TRIVIA GAUNTLET (7 ROUNDS) ==================
import discord
import random

class TriviaGauntletView(discord.ui.View):
    def __init__(self, player, bet, interaction, questions_list):
        super().__init__(timeout=10) # âš¡ 10 SECONDS PER QUESTION
        self.player = player
        self.bet = bet
        self.interaction = interaction
        self.questions = questions_list # List of 7 questions
        self.current_index = 0
        self.game_ended = False # Bug Fix ke liye flag
        
        # Load First Question
        self.load_question()

    def load_question(self):
        self.clear_items() # Purane buttons hatao
        
        current_q_data = self.questions[self.current_index]
        self.correct_ans = current_q_data["a"]
        
        # Shuffle Options
        self.options = current_q_data["o"].copy()
        random.shuffle(self.options)
        
        # Create New Buttons
        labels = ["A", "B", "C", "D"]
        for i, opt in enumerate(self.options):
            # ğŸ› ï¸ FIX 1: Discord max button text limit is 80 characters.
            safe_label = f"{labels[i]}: {opt}"[:80] 
            btn = discord.ui.Button(label=safe_label, style=discord.ButtonStyle.secondary, custom_id=opt)
            btn.callback = self.answer_callback
            self.add_item(btn)

    async def on_timeout(self):
        if self.game_ended: return # Agar game pehle hi khatam ho gaya to ignore karo

        self.game_ended = True
        for item in self.children: item.disabled = True
        
        # --- PUNISHMENT LOGIC ---
        await self.apply_punishment("Too Slow (Timeout)")
        
        embed = discord.Embed(title="âŒ› TIME'S UP!", color=0xFF0000)
        embed.description = (
            f"âŒ **Bahut slow ho!** 10 Second nikal gaye.\n"
            f"ğŸ“‰ **Stage:** {self.current_index + 1}/7 par haar gaye.\n"
            f"ğŸ’¸ **Lost:** ${self.bet:,}"
        )
        embed.set_footer(text="Penalty: 1 Hour Mute applied!")
        embed.set_thumbnail(url="https://media.tenor.com/images/3e877e504c35e320f7725964f4040939/tenor.gif")
        
        try:
            await self.interaction.edit_original_response(embed=embed, view=self)
        except:
            pass
        self.stop()

    async def answer_callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.player.id:
            return await interaction.response.send_message("âŒ Apna game khelo!", ephemeral=True)

        if self.game_ended: return
        
        # ğŸ› ï¸ FIX 2: Instant defer taaki "Interaction Failed" ka error na aaye
        await interaction.response.defer()
        
        selected_ans = interaction.data["custom_id"]
        
        # 1. WRONG ANSWER CHECK
        if selected_ans != self.correct_ans:
            self.game_ended = True
            
            # Button Red karo
            for item in self.children:
                item.disabled = True
                if item.custom_id == selected_ans: item.style = discord.ButtonStyle.danger
                if item.custom_id == self.correct_ans: item.style = discord.ButtonStyle.success

            await self.apply_punishment("Wrong Answer")
            
            embed = discord.Embed(title="ğŸš« WRONG ANSWER!", color=0xFF0000)
            embed.description = (
                f"âŒ **Galat Jawab!** Khel Khatam.\n"
                f"âœ… Correct: **{self.correct_ans}**\n"
                f"ğŸ“‰ **Failed at Stage:** {self.current_index + 1}/7\n"
                f"ğŸ’¸ **Lost:** ${self.bet:,}"
            )
            embed.set_footer(text="Penalty: 1 Hour Mute applied!")
            embed.set_thumbnail(url="https://media.tenor.com/images/3e877e504c35e320f7725964f4040939/tenor.gif")
            
            # ğŸ› ï¸ FIX 3: Defer ke baad 'edit_original_response' use karte hain
            await interaction.edit_original_response(embed=embed, view=self)
            self.stop() # ğŸ›‘ Timer yahi rook do
            return

        # 2. CORRECT ANSWER CHECK
        # Kya ye last question tha (7th)?
        if self.current_index == 6:
            self.game_ended = True
            
            # JACKPOT WIN (10x Reward)
            winnings = self.bet * 10
            await update_balance(self.player.id, winnings)
            
            for item in self.children:
                item.disabled = True
                if item.custom_id == selected_ans: item.style = discord.ButtonStyle.success

            embed = discord.Embed(title="ğŸ† ULTIMATE CHAMPION!", color=0xFFD700)
            embed.description = (
                f"ğŸ‰ **INCREDIBLE!** Tumne lagatar 7 Hard Sawal sahi diye!\n"
                f"ğŸ¤¯ **IQ Level:** God Mode\n\n"
                f"ğŸ’° **Bet:** ${self.bet:,}\n"
                f"ğŸ¤‘ **JACKPOT WON:** ${winnings:,} (10x)"
            )
            embed.set_image(url="https://media.tenor.com/p7a8o1r5c8cAAAAC/money-rain.gif")
            
            await interaction.edit_original_response(embed=embed, view=self)
            self.stop() # ğŸ›‘ Timer rook do
        
        else:
            # NEXT QUESTION
            self.current_index += 1
            self.load_question() # Load next buttons
            
            q_text = self.questions[self.current_index]["q"]
            
            embed = discord.Embed(title=f"ğŸ§  STAGE {self.current_index + 1} / 7", color=0x9B59B6)
            embed.description = (
                f"**Player:** {self.player.mention}\n"
                f"ğŸ’° **Pot:** ${self.bet:,} (Win 7/7 to get 10x)\n\n"
                f"â“ **{q_text}**\n\n"
                f"âš¡ **10 Seconds Left!**"
            )
            embed.set_footer(text="Ek galti aur game over!")
            
            await interaction.edit_original_response(embed=embed, view=self)
            # Note: View ka timer interaction hone par apne aap reset ho jata hai 10s par.

    async def apply_punishment(self, reason):
        # ğŸ› ï¸ FIX 4: Safety block taaki timeout API crash na kare
        try:
            data = await get_data(self.player.id)
            is_safe = False
            
            if data.get("vip_expiry"):
                is_safe = True
            elif data.get("inventory", {}).get("life", 0) > 0:
                await update_inventory(self.player.id, "life", -1)
                is_safe = True

            if not is_safe:
                await smart_timeout(self.interaction, self.player, 3600, reason)
        except Exception as e:
            print(f"Punishment Error: {e}")              
        
# ================== ğŸ§¬ NEET BIOLOGY GAUNTLET (UNIQUE QUESTIONS) ==================

# ğŸ’¾ USER QUESTION HISTORY (Taaki sawal repeat na hon)
# Isko database me save karna behtar hoga, abhi RAM me hai.
USER_USED_QUESTIONS = {} # {user_id: [q_id1, q_id2, ...]}

# ğŸ“š BIOLOGY QUESTION BANK (IDs zaroori hain unique check ke liye)
BIO_QUESTIONS = [
    {"id": 1, "q": "Which of the following is not a feature of the plasmids?", "o": ["Transferable", "Single-stranded", "Independent replication", "Circular structure"], "a": "Single-stranded"},
    {"id": 2, "q": "Which one of the following is not a constituent of cell membrane?", "o": ["Glycolipids", "Proline", "Phospholipids", "Cholesterol"], "a": "Proline"},
    {"id": 101, "q": "Which of the following are the twin characteristics of growth?", "o": ["Increase in mass and increase in number", "Increase in height and width", "Differentiation and dedifferentiation", "Metabolism and catabolism"], "a": "Increase in mass and increase in number"},
    {"id": 102, "q": "In which organisms does growth and reproduction refer to the same event?", "o": ["Multicellular organisms", "Higher plants", "Unicellular organisms like Amoeba", "All animals"], "a": "Unicellular organisms like Amoeba"},
    {"id": 103, "q": "Which of the following is a defining property of living organisms without exception?", "o": ["Growth", "Reproduction", "Consciousness/Metabolism", "Self-replication"], "a": "Consciousness/Metabolism"},
    {"id": 104, "q": "Photoperiod affects reproduction in:", "o": ["Seasonal breeders, both plants and animals", "Only seasonal breeder plants", "Only seasonal breeder animals", "Continuous breeders"], "a": "Seasonal breeders, both plants and animals"},
    {"id": 105, "q": "The sum total of all chemical reactions occurring in our body is known as:", "o": ["Anabolism", "Catabolism", "Metabolism", "Digestion"], "a": "Metabolism"},
    {"id": 106, "q": "Which of the following organisms do NOT reproduce?", "o": ["Mules", "Sterile worker bees", "Infertile human couples", "All of the above"], "a": "All of the above"},
    {"id": 107, "q": "Metabolic reactions can be demonstrated outside the body in cell-free systems. These isolated reactions are:", "o": ["Living things", "Non-living things", "Living reactions but not living things", "Neither living nor non-living"], "a": "Living reactions but not living things"},
    {"id": 108, "q": "For higher plants and animals, growth and reproduction are:", "o": ["Mutually inclusive events", "Mutually exclusive events", "Synonymous events", "None of the above"], "a": "Mutually exclusive events"},

    # --- TOPIC: DIVERSITY & NOMENCLATURE ---
    {"id": 109, "q": "The number of species that are known and described range between:", "o": ["1.5 to 1.6 million", "1.7 to 1.8 million", "2.0 to 2.5 million", "1.0 to 1.2 million"], "a": "1.7 to 1.8 million"},
    {"id": 110, "q": "ICBN stands for:", "o": ["International Code for Botanical Nomenclature", "Indian Code of Botanical Nomenclature", "International Code of Biological Naming", "International Classification of Biological Nomenclature"], "a": "International Code for Botanical Nomenclature"},
    {"id": 111, "q": "The scientific name of Mango is correctly written as:", "o": ["Mangifera Indica", "Mangifera indica", "mangifera Indica", "Mangifera Indica Linn"], "a": "Mangifera indica"},
    {"id": 112, "q": "In 'Mangifera indica Linn.', the word 'Linn' indicates:", "o": ["The species is extinct", "The variety of mango", "The author Linnaeus who first described it", "The place where it was found"], "a": "The author Linnaeus who first described it"},
    {"id": 113, "q": "The system of providing a name with two components is called:", "o": ["Trinomial nomenclature", "Binomial nomenclature", "Polynomial nomenclature", "Chemotaxonomy"], "a": "Binomial nomenclature"},
    {"id": 114, "q": "Biological names are generally in which language?", "o": ["Greek", "Latin", "English", "Sanskrit"], "a": "Latin"},
    {"id": 115, "q": "The process of classification is based on:", "o": ["External and internal structure", "Cell structure", "Development process and ecological info", "All of the above"], "a": "All of the above"},
    {"id": 116, "q": "The term 'Systematics' is derived from the Latin word 'systema' which means:", "o": ["System of naming", "Systematic arrangement of organisms", "Study of systems", "Evolutionary history"], "a": "Systematic arrangement of organisms"},
    {"id": 117, "q": "Who wrote the book 'Systema Naturae'?", "o": ["Darwin", "Aristotle", "Linnaeus", "Bentham and Hooker"], "a": "Linnaeus"},
    {"id": 118, "q": "The basic unit of classification is:", "o": ["Kingdom", "Family", "Species", "Genus"], "a": "Species"},

    # --- TOPIC: TAXONOMIC CATEGORIES ---
    {"id": 119, "q": "A group of related genera with still less number of similarities as compared to genus and species constitutes a:", "o": ["Order", "Class", "Family", "Division"], "a": "Family"},
    {"id": 120, "q": "Which of the following suffixes is used for 'Family' in plants?", "o": ["-ales", "-aceae", "-idae", "-ae"], "a": "-aceae"},
    {"id": 121, "q": "Which suffix is used for 'Order' in plants?", "o": ["-ales", "-aceae", "-phyta", "-opsida"], "a": "-ales"},
    {"id": 122, "q": "Solanum, Petunia, and Datura are placed in which Family?", "o": ["Solanaceae", "Liliaceae", "Poaceae", "Fabaceae"], "a": "Solanaceae"},
    {"id": 123, "q": "Order Polymoniales includes families like:", "o": ["Solanaceae and Convolvulaceae", "Solanaceae and Liliaceae", "Fabaceae and Poaceae", "Felidae and Canidae"], "a": "Solanaceae and Convolvulaceae"},
    {"id": 124, "q": "The order 'Polymoniales' is mainly based on:", "o": ["Vegetative characters", "Floral characters", "Root system", "Stem modifications"], "a": "Floral characters"},
    {"id": 125, "q": "As we go from Species to Kingdom, the number of common characteristics:", "o": ["Increases", "Decreases", "Remains same", "First increases then decreases"], "a": "Decreases"},
    {"id": 126, "q": "Which of the following categories contains organisms with the least similar traits?", "o": ["Class", "Order", "Family", "Genus"], "a": "Class"},
    {"id": 127, "q": "Panthera leo and Panthera tigris belong to the genus:", "o": ["Felis", "Panthera", "Canis", "Solanum"], "a": "Panthera"},
    {"id": 128, "q": "Cats belong to the family:", "o": ["Canidae", "Felidae", "Hominidae", "Muscidae"], "a": "Felidae"},
    {"id": 129, "q": "Dogs belong to the family:", "o": ["Canidae", "Felidae", "Ursidae", "Hominidae"], "a": "Canidae"},
    {"id": 130, "q": "Which of the following is a correct sequence of taxonomic categories?", "o": ["Species -> Genus -> Order -> Family", "Species -> Genus -> Family -> Order", "Genus -> Species -> Family -> Order", "Family -> Order -> Genus -> Species"], "a": "Species -> Genus -> Family -> Order"},

    # --- TOPIC: SPECIFIC EXAMPLES (TABLE 1.1 NCERT) ---
    {"id": 131, "q": "What is the Family of Man (Homo sapiens)?", "o": ["Hominidae", "Primata", "Mammalia", "Chordata"], "a": "Hominidae"},
    {"id": 132, "q": "What is the Order of Housefly (Musca domestica)?", "o": ["Diptera", "Insecta", "Arthropoda", "Muscidae"], "a": "Diptera"},
    {"id": 133, "q": "What is the Class of Mango?", "o": ["Monocotyledonae", "Dicotyledonae", "Angiospermae", "Sapindales"], "a": "Dicotyledonae"},
    {"id": 134, "q": "Wheat belongs to the Order:", "o": ["Sapindales", "Poales", "Polymoniales", "Diptera"], "a": "Poales"},
    {"id": 135, "q": "What is the Phylum of Human beings?", "o": ["Mammalia", "Chordata", "Primata", "Hominidae"], "a": "Chordata"},
    {"id": 136, "q": "The biological name of Wheat is:", "o": ["Triticum aestivum", "Oryza sativa", "Zea mays", "Mangifera indica"], "a": "Triticum aestivum"},
    {"id": 137, "q": "Housefly belongs to which Class?", "o": ["Insecta", "Arthropoda", "Diptera", "Muscidae"], "a": "Insecta"},
    {"id": 138, "q": "Mango belongs to the Order:", "o": ["Poales", "Sapindales", "Polymoniales", "Rosales"], "a": "Sapindales"},
    {"id": 139, "q": "Which of the following represents 'Genus'?", "o": ["Solanum", "Tuberosum", "Nigrum", "Melongena"], "a": "Solanum"},
    {"id": 140, "q": "Classes comprising animals like fishes, amphibians, reptiles, birds along with mammals constitute the next higher category called:", "o": ["Kingdom", "Phylum", "Division", "Order"], "a": "Phylum"},
    {"id": 201, "q": "Who proposed the Five Kingdom Classification?", "o": ["R.H. Whittaker", "Carolus Linnaeus", "Aristotle", "Ernst Haeckel"], "a": "R.H. Whittaker"},
    {"id": 202, "q": "The main criteria for Whittaker's classification did NOT include:", "o": ["Cell structure", "Thallus organisation", "Mode of nutrition", "Gross morphology"], "a": "Gross morphology"},
    {"id": 203, "q": "In the Two Kingdom classification, bacteria, blue-green algae, and fungi were placed under:", "o": ["Animalia", "Plantae", "Monera", "Protista"], "a": "Plantae"},
    {"id": 204, "q": "The three-domain system divides which Kingdom into two domains?", "o": ["Monera", "Protista", "Fungi", "Plantae"], "a": "Monera"},
    {"id": 205, "q": "Who was the earliest to attempt a more scientific basis for classification?", "o": ["Linnaeus", "Aristotle", "Theophrastus", "Darwin"], "a": "Aristotle"},

    # --- SYSTEMS OF CLASSIFICATION ---
    {"id": 276, "q": "In Whittaker's classification, which kingdom has no defined boundaries?", "o": ["Monera", "Protista", "Fungi", "Plantae"], "a": "Protista"},
    {"id": 277, "q": "The main basis for classification in the Five Kingdom system is:", "o": ["Structure of nucleus", "Mode of nutrition", "Structure of cell wall", "Asexual reproduction"], "a": "Mode of nutrition"},
    {"id": 278, "q": "Chlamydomonas and Chlorella were earlier placed in Algae within Plants, but now they are in:", "o": ["Monera", "Protista", "Fungi", "Plantae"], "a": "Protista"},
    {"id": 279, "q": "Which kingdom includes organisms that are exclusively heterotrophic?", "o": ["Monera", "Protista", "Fungi", "Plantae"], "a": "Fungi"},

    # --- MONERA (BACTERIA DETAILS) ---
    {"id": 280, "q": "Bacteria are grouped under four categories based on their:", "o": ["Respiration", "Shape", "Nutrition", "Reproduction"], "a": "Shape"},
    {"id": 281, "q": "The rod-shaped bacteria are called:", "o": ["Coccus", "Bacillus", "Vibrio", "Spirillum"], "a": "Bacillus"},
    {"id": 282, "q": "The comma-shaped bacteria are called:", "o": ["Coccus", "Bacillus", "Vibrio", "Spirillum"], "a": "Vibrio"},
    {"id": 283, "q": "Which structure helps bacteria in motility?", "o": ["Pili", "Fimbriae", "Flagella", "Cilia"], "a": "Flagella"},
    {"id": 284, "q": "The vast majority of bacteria are:", "o": ["Photosynthetic autotrophs", "Chemosynthetic autotrophs", "Heterotrophs", "Parasites"], "a": "Heterotrophs"},
    {"id": 285, "q": "Bacteria reproduce mainly by:", "o": ["Fission", "Spore formation", "Sexual reproduction", "Budding"], "a": "Fission"},
    {"id": 286, "q": "Under unfavorable conditions, bacteria produce:", "o": ["Cysts", "Spores", "Gametes", "Zygotes"], "a": "Spores"},
    {"id": 287, "q": "Nostoc and Anabaena can fix atmospheric nitrogen in specialized cells called:", "o": ["Homocysts", "Heterocysts", "Akinetes", "Endospores"], "a": "Heterocysts"},
    {"id": 288, "q": "Which of the following plays a great role in recycling nutrients like Nitrogen and Phosphorus?", "o": ["Chemosynthetic autotrophic bacteria", "Photosynthetic autotrophic bacteria", "Parasitic bacteria", "Symbiotic bacteria"], "a": "Chemosynthetic autotrophic bacteria"},
    {"id": 289, "q": "Mycoplasma are pathogenic to:", "o": ["Only Animals", "Only Plants", "Both Plants and Animals", "None"], "a": "Both Plants and Animals"},
    {"id": 290, "q": "The primitive bacteria living in salty areas are called:", "o": ["Methanogens", "Thermoacidophiles", "Halophiles", "Heliozoans"], "a": "Halophiles"},
    {"id": 291, "q": "Methanogens are present in the gut of:", "o": ["Humans", "Birds", "Ruminants", "Carnivores"], "a": "Ruminants"},

    # --- PROTISTA (DEEP DIVE) ---
    {"id": 292, "q": "Chrysophytes include:", "o": ["Diatoms and Desmids", "Dinoflagellates and Euglenoids", "Slime moulds and Protozoans", "Bacteria and Blue-green algae"], "a": "Diatoms and Desmids"},
    {"id": 293, "q": "Desmids are also known as:", "o": ["Red Algae", "Golden Algae", "Brown Algae", "Blue Algae"], "a": "Golden Algae"},
    {"id": 294, "q": "In Diatoms, the cell walls form two thin overlapping shells which fit together as in a:", "o": ["Matchbox", "Soap box", "Tiffin box", "Shoe box"], "a": "Soap box"},
    {"id": 295, "q": "The accumulation of cell wall deposits of Diatoms over billions of years is called:", "o": ["Coral reef", "Diatomaceous earth", "Siliceous earth", "Calcareous earth"], "a": "Diatomaceous earth"},
    {"id": 296, "q": "Most of the Dinoflagellates have:", "o": ["Two flagella", "One flagellum", "Many flagella", "No flagella"], "a": "Two flagella"},
    {"id": 297, "q": "Red tides are caused by rapid multiplication of:", "o": ["Gonyaulax", "Noctiluca", "Ceratium", "Gymnodinium"], "a": "Gonyaulax"},
    {"id": 298, "q": "Euglenoids are found in:", "o": ["Marine water", "Stagnant fresh water", "Running fresh water", "Damp soil"], "a": "Stagnant fresh water"},
    {"id": 299, "q": "Though Euglenoids are photosynthetic, in the absence of sunlight they behave like:", "o": ["Autotrophs", "Heterotrophs", "Chemotrophs", "Parasites"], "a": "Heterotrophs"},
    {"id": 300, "q": "The pigments of Euglenoids are identical to those present in:", "o": ["Higher plants", "Lower plants", "Red algae", "Blue-green algae"], "a": "Higher plants"},
    {"id": 301, "q": "Slime moulds are:", "o": ["Parasitic protists", "Saprophytic protists", "Autotrophic protists", "Symbiotic protists"], "a": "Saprophytic protists"},
    {"id": 302, "q": "During unfavorable conditions, the plasmodium of slime moulds differentiates to form:", "o": ["Fruiting bodies bearing spores", "Zygote", "Gametes", "Cysts"], "a": "Fruiting bodies bearing spores"},
    {"id": 303, "q": "The spores of slime moulds possess:", "o": ["No walls", "True walls", "Pseudowalls", "Silica walls"], "a": "True walls"},
    {"id": 304, "q": "Protozoans are believed to be primitive relatives of:", "o": ["Plants", "Fungi", "Animals", "Monerans"], "a": "Animals"},
    {"id": 305, "q": "Entamoeba histolytica is an example of:", "o": ["Flagellated protozoan", "Ciliated protozoan", "Amoeboid protozoan", "Sporozoan"], "a": "Amoeboid protozoan"},
    {"id": 306, "q": "Which form of Entamoeba is a parasite?", "o": ["Marine forms", "Freshwater forms", "Terrestrial forms", "Endoparasitic forms"], "a": "Endoparasitic forms"},
    {"id": 307, "q": "Trypanosoma is a:", "o": ["Ciliated protozoan", "Flagellated protozoan", "Amoeboid protozoan", "Sporozoan"], "a": "Flagellated protozoan"},
    {"id": 308, "q": "Which of the following has a cavity (gullet) that opens to the outside of the cell surface?", "o": ["Amoeba", "Paramoecium", "Euglena", "Plasmodium"], "a": "Paramoecium"},
    {"id": 309, "q": "The most notorious Sporozoan is:", "o": ["Plasmodium", "Monocystis", "Eimeria", "Babesia"], "a": "Plasmodium"},

    # --- FUNGI (EXAMPLES & CLASSES) ---
    {"id": 310, "q": "Fungi prefer to grow in:", "o": ["Cold and dry places", "Warm and humid places", "Hot and dry places", "Cold and wet places"], "a": "Warm and humid places"},
    {"id": 311, "q": "The only fungus which is unicellular is:", "o": ["Mucor", "Yeast", "Penicillium", "Agaricus"], "a": "Yeast"},
    {"id": 312, "q": "Vegetative reproduction in fungi takes place by:", "o": ["Fragmentation", "Fission", "Budding", "All of the above"], "a": "All of the above"},
    {"id": 313, "q": "Asexual reproduction in fungi is by spores called:", "o": ["Conidia, Sporangiospores, Zoospores", "Oospores, Ascospores, Basidiospores", "Zygospores only", "Aplanospores only"], "a": "Conidia, Sporangiospores, Zoospores"},
    {"id": 314, "q": "Sexual reproduction in fungi is by:", "o": ["Oospores, Ascospores, Basidiospores", "Conidia, Zoospores", "Sporangiospores", "Aplanospores"], "a": "Oospores, Ascospores, Basidiospores"},
    {"id": 315, "q": "Fusion of two nuclei is called:", "o": ["Plasmogamy", "Karyogamy", "Meiosis", "Cytokinesis"], "a": "Karyogamy"},
    {"id": 316, "q": "In which fungi does the fusion of two haploid cells immediately result in diploid cells?", "o": ["Phycomycetes", "Ascomycetes", "Basidiomycetes", "Deuteromycetes"], "a": "Phycomycetes"},
    {"id": 317, "q": "Dikaryophase (n + n condition) is seen in:", "o": ["Phycomycetes and Ascomycetes", "Ascomycetes and Basidiomycetes", "Phycomycetes and Deuteromycetes", "Basidiomycetes and Deuteromycetes"], "a": "Ascomycetes and Basidiomycetes"},
    {"id": 318, "q": "Phycomycetes are found in:", "o": ["Aquatic habitats", "Decaying wood", "Damp places", "All of the above"], "a": "All of the above"},
    {"id": 319, "q": "The mycelium in Phycomycetes is:", "o": ["Septate and branched", "Aseptate and coenocytic", "Septate and unbranched", "Aseptate and uninucleate"], "a": "Aseptate and coenocytic"},
    {"id": 320, "q": "Identify the Phycomycete parasitic on mustard:", "o": ["Rhizopus", "Mucor", "Albugo", "Penicillium"], "a": "Albugo"},
    {"id": 321, "q": "The common name for Ascomycetes is:", "o": ["Sac fungi", "Club fungi", "Algal fungi", "Imperfect fungi"], "a": "Sac fungi"},
    {"id": 322, "q": "Coprophilous fungi grow on:", "o": ["Wood", "Dung", "Soil", "Rocks"], "a": "Dung"},
    {"id": 323, "q": "The asexual spores 'Conidia' are produced:", "o": ["Endogenously on conidiophores", "Exogenously on conidiophores", "Endogenously in sporangium", "Exogenously in sporangium"], "a": "Exogenously on conidiophores"},
    {"id": 324, "q": "Sexual spores 'Ascospores' are produced:", "o": ["Endogenously in asci", "Exogenously in asci", "Exogenously on basidium", "Endogenously on basidium"], "a": "Endogenously in asci"},
    {"id": 325, "q": "Which fungus is used in the production of antibiotics?", "o": ["Yeast", "Penicillium", "Rhizopus", "Agaricus"], "a": "Penicillium"},
    {"id": 326, "q": "Neurospora is used extensively in:", "o": ["Alcohol industry", "Biochemical and genetic work", "Making bread", "Medicine"], "a": "Biochemical and genetic work"},
    {"id": 327, "q": "Common name for Basidiomycetes is:", "o": ["Sac fungi", "Club fungi", "Dust fungi", "Algal fungi"], "a": "Club fungi"},
    {"id": 328, "q": "The mycelium in Basidiomycetes is:", "o": ["Branched and septate", "Unbranched and septate", "Branched and aseptate", "Coenocytic"], "a": "Branched and septate"},
    {"id": 329, "q": "Vegetative reproduction is very common in Basidiomycetes by:", "o": ["Budding", "Fragmentation", "Fission", "Spore formation"], "a": "Fragmentation"},
    {"id": 330, "q": "Sex organs are absent, but plasmogamy is brought about by fusion of two vegetative cells in:", "o": ["Phycomycetes", "Ascomycetes", "Basidiomycetes", "Deuteromycetes"], "a": "Basidiomycetes"},
    {"id": 331, "q": "Karyogamy and meiosis take place in the Basidium producing:", "o": ["Two basidiospores", "Four basidiospores", "Eight basidiospores", "Infinite basidiospores"], "a": "Four basidiospores"},
    {"id": 332, "q": "Basidiospores are produced:", "o": ["Endogenously", "Exogenously", "Inside ascus", "Inside sporangium"], "a": "Exogenously"},
    {"id": 333, "q": "Puccinia causes:", "o": ["Wheat rust", "Smut", "White spots", "Blight"], "a": "Wheat rust"},
    {"id": 334, "q": "Ustilago causes:", "o": ["Rust", "Smut", "Rot", "Wilt"], "a": "Smut"},
    {"id": 335, "q": "Deuteromycetes reproduce only by asexual spores known as:", "o": ["Conidia", "Oospores", "Zoospores", "Ascospores"], "a": "Conidia"},
    {"id": 336, "q": "Once the sexual stage of members of Deuteromycetes were discovered, they were moved to:", "o": ["Phycomycetes and Ascomycetes", "Ascomycetes and Basidiomycetes", "Basidiomycetes and Phycomycetes", "Protista"], "a": "Ascomycetes and Basidiomycetes"},
    {"id": 337, "q": "Which class of fungi helps largely in mineral cycling?", "o": ["Phycomycetes", "Ascomycetes", "Basidiomycetes", "Deuteromycetes"], "a": "Deuteromycetes"},
    {"id": 338, "q": "Colletotrichum, Alternaria, and Trichoderma belong to:", "o": ["Deuteromycetes", "Ascomycetes", "Basidiomycetes", "Phycomycetes"], "a": "Deuteromycetes"},

    # --- VIRUS, VIROIDS, LICHENS (DETAILS) ---
    {"id": 339, "q": "Viruses did not find a place in classification because:", "o": ["They are too small", "They are not considered truly living", "They cause diseases", "They have no nucleus"], "a": "They are not considered truly living"},
    {"id": 340, "q": "A virus is a:", "o": ["Nucleoprotein", "Lipoprotein", "Glycoprotein", "Phosphoprotein"], "a": "Nucleoprotein"},
    {"id": 341, "q": "The genetic material of a virus is:", "o": ["DNA only", "RNA only", "Either DNA or RNA", "Both DNA and RNA"], "a": "Either DNA or RNA"},
    {"id": 342, "q": "Viruses that infect plants usually have:", "o": ["Single stranded RNA", "Double stranded RNA", "Double stranded DNA", "Single stranded DNA"], "a": "Single stranded RNA"},
    {"id": 343, "q": "Viruses that infect animals may have:", "o": ["Single or double stranded RNA or double stranded DNA", "Only single stranded DNA", "Only double stranded RNA", "Only single stranded RNA"], "a": "Single or double stranded RNA or double stranded DNA"},
    {"id": 344, "q": "Bacteriophages (viruses infecting bacteria) are usually:", "o": ["Single stranded RNA viruses", "Double stranded RNA viruses", "Single stranded DNA viruses", "Double stranded DNA viruses"], "a": "Double stranded DNA viruses"},
    {"id": 345, "q": "Capsomeres are arranged in:", "o": ["Helical or Polyhedral geometric forms", "Linear forms", "Circular forms", "Random forms"], "a": "Helical or Polyhedral geometric forms"},
    {"id": 346, "q": "Mumps, Smallpox, Herpes, and Influenza are caused by:", "o": ["Bacteria", "Viruses", "Fungi", "Protozoa"], "a": "Viruses"},
    {"id": 347, "q": "In humans, AIDS is caused by a:", "o": ["Bacterium", "Fungus", "Virus", "Viroid"], "a": "Virus"},
    {"id": 348, "q": "Symptoms of viral infection in plants include:", "o": ["Mosaic formation, leaf rolling, curling", "Yellowing and vein clearing", "Dwarfing and stunted growth", "All of the above"], "a": "All of the above"},
    {"id": 349, "q": "Viroids were discovered in the year:", "o": ["1971", "1981", "1892", "1935"], "a": "1971"},
    {"id": 350, "q": "The RNA of the viroid is of:", "o": ["High molecular weight", "Low molecular weight", "Same weight as virus", "None of these"], "a": "Low molecular weight"},
    {"id": 351, "q": "Lichens are mutually useful associations between:", "o": ["Algae and Fungi", "Algae and Bacteria", "Fungi and Roots", "Bacteria and Roots"], "a": "Algae and Fungi"},
    {"id": 352, "q": "The algal component of lichen is called:", "o": ["Phycobiont", "Mycobiont", "Symbiont", "Parasite"], "a": "Phycobiont"},
    {"id": 353, "q": "The fungal component of lichen is called:", "o": ["Phycobiont", "Mycobiont", "Autotroph", "Producer"], "a": "Mycobiont"},
    {"id": 354, "q": "In Lichens, algae prepare food and fungi provide:", "o": ["Shelter and absorb mineral nutrients/water", "Only water", "Only minerals", "Only protection"], "a": "Shelter and absorb mineral nutrients/water"},
    {"id": 355, "q": "Lichens are very good pollution indicators as they do not grow in:", "o": ["Clean areas", "Polluted areas", "High altitude areas", "Water"], "a": "Polluted areas"},

    # --- SCIENTISTS & DISCOVERIES ---
    {"id": 356, "q": "Who used simple morphological characters to classify plants into trees, shrubs, and herbs?", "o": ["Linnaeus", "Aristotle", "Whittaker", "Pasteur"], "a": "Aristotle"},
    {"id": 357, "q": "Linnaeus's Two Kingdom system distinguished between:", "o": ["Plantae and Animalia", "Eukaryotes and Prokaryotes", "Unicellular and Multicellular", "Photosynthetic and Non-photosynthetic"], "a": "Plantae and Animalia"},
    {"id": 358, "q": "The 'Contagium vivum fluidum' was proposed by:", "o": ["M.W. Beijerinck", "D.J. Ivanowsky", "W.M. Stanley", "Pasteur"], "a": "M.W. Beijerinck"},
    {"id": 359, "q": "Who showed that viruses could be crystallized and crystals consist largely of proteins?", "o": ["W.M. Stanley", "Ivanowsky", "Beijerinck", "Diener"], "a": "W.M. Stanley"},

    # --- KINGDOM MONERA (BACTERIA) ---
    {"id": 206, "q": "Which organisms are the sole members of the Kingdom Monera?", "o": ["Viruses", "Bacteria", "Amoeba", "Fungi"], "a": "Bacteria"},
    {"id": 207, "q": "Bacteria that can survive in extreme salty areas are called:", "o": ["Methanogens", "Thermoacidophiles", "Halophiles", "Cyanobacteria"], "a": "Halophiles"},
    {"id": 208, "q": "Methanogens are responsible for the production of biogas from the dung of ruminants. They belong to:", "o": ["Eubacteria", "Archaebacteria", "Dinoflagellates", "Slime moulds"], "a": "Archaebacteria"},
    {"id": 209, "q": "The cell wall of Archaebacteria differs from other bacteria, helping them survive in:", "o": ["Extreme conditions", "Fresh water", "Host body", "Air"], "a": "Extreme conditions"},
    {"id": 210, "q": "Cyanobacteria are also known as:", "o": ["Golden Algae", "Blue-green Algae", "Slime Moulds", "Protozoans"], "a": "Blue-green Algae"},
    {"id": 211, "q": "Specialized cells in Nostoc and Anabaena used for nitrogen fixation are called:", "o": ["Akinetes", "Heterocysts", "Hormogonia", "Endospores"], "a": "Heterocysts"},
    {"id": 212, "q": "Citrus canker is a disease caused by:", "o": ["Virus", "Fungi", "Bacteria", "Mycoplasma"], "a": "Bacteria"},
    {"id": 213, "q": "Mycoplasma are unique because they:", "o": ["Have a rigid cell wall", "Completely lack a cell wall", "Are multicellular", "Cannot survive without oxygen"], "a": "Completely lack a cell wall"},
    {"id": 214, "q": "Which bacteria play a great role in recycling nutrients like N, P, Fe, and S?", "o": ["Photosynthetic autotrophs", "Chemosynthetic autotrophs", "Heterotrophs", "Pathogens"], "a": "Chemosynthetic autotrophs"},
    {"id": 215, "q": "The smallest living cells known that can survive without oxygen are:", "o": ["Yeast", "Mycoplasma", "Virus", "Euglena"], "a": "Mycoplasma"},

    # --- KINGDOM PROTISTA ---
    {"id": 216, "q": "All single-celled eukaryotes are placed under:", "o": ["Monera", "Protista", "Fungi", "Animalia"], "a": "Protista"},
    {"id": 217, "q": "The cell walls of Diatoms are embedded with:", "o": ["Calcium", "Chitin", "Silica", "Pectin"], "a": "Silica"},
    {"id": 218, "q": "Diatomaceous earth is used in:", "o": ["Polishing and filtration", "Biogas production", "Nitrogen fixation", "Bread making"], "a": "Polishing and filtration"},
    {"id": 219, "q": "Which organism is responsible for 'Red Tides'?", "o": ["Euglena", "Gonyaulax", "Trypanosoma", "Plasmodium"], "a": "Gonyaulax"},
    {"id": 220, "q": "Euglenoids have a protein-rich layer instead of a cell wall called:", "o": ["Capsid", "Pellicle", "Cuticle", "Sheath"], "a": "Pellicle"},
    {"id": 221, "q": "Slime moulds are:", "o": ["Saprophytic protists", "Parasitic fungi", "Autotrophic bacteria", "Photosynthetic protists"], "a": "Saprophytic protists"},
    {"id": 222, "q": "Under suitable conditions, slime moulds form an aggregation called:", "o": ["Mycelium", "Plasmodium", "Fruiting body", "Spore"], "a": "Plasmodium"},
    {"id": 223, "q": "Which protozoan causes Sleeping Sickness?", "o": ["Entamoeba", "Trypanosoma", "Paramecium", "Plasmodium"], "a": "Trypanosoma"},
    {"id": 224, "q": "Which group of Protozoans moves by using pseudopodia?", "o": ["Flagellated", "Ciliated", "Amoeboid", "Sporozoans"], "a": "Amoeboid"},
    {"id": 225, "q": "Paramecium moves using thousands of:", "o": ["Flagella", "Cilia", "Tentacles", "Pseudopodia"], "a": "Cilia"},
    {"id": 226, "q": "The malarial parasite Plasmodium belongs to which group?", "o": ["Sporozoans", "Ciliated protozoans", "Flagellated protozoans", "Amoeboid protozoans"], "a": "Sporozoans"},
    {"id": 227, "q": "Which of the following connects plants and animals (Mixotroph)?", "o": ["Slime Mould", "Euglena", "Amoeba", "Paramoecium"], "a": "Euglena"},

    # --- KINGDOM FUNGI ---
    {"id": 228, "q": "The cell wall of fungi is composed of:", "o": ["Cellulose", "Chitin and polysaccharides", "Peptidoglycan", "Pectin"], "a": "Chitin and polysaccharides"},
    {"id": 229, "q": "A network of hyphae is known as:", "o": ["Thallus", "Mycelium", "Plasmodium", "Fruiting body"], "a": "Mycelium"},
    {"id": 230, "q": "Association of fungi with roots of higher plants is called:", "o": ["Lichen", "Mycorrhiza", "Coralloid roots", "Rhizome"], "a": "Mycorrhiza"},
    {"id": 231, "q": "Fusion of protoplasms between two motile or non-motile gametes is called:", "o": ["Karyogamy", "Plasmogamy", "Meiosis", "Syngamy"], "a": "Plasmogamy"},
    {"id": 232, "q": "Phycomycetes are also known as:", "o": ["Sac fungi", "Club fungi", "Algal fungi", "Imperfect fungi"], "a": "Algal fungi"},
    {"id": 233, "q": "Rhizopus (Bread mould) belongs to which class of fungi?", "o": ["Ascomycetes", "Phycomycetes", "Basidiomycetes", "Deuteromycetes"], "a": "Phycomycetes"},
    {"id": 234, "q": "Yeast and Penicillium belong to:", "o": ["Phycomycetes", "Ascomycetes", "Basidiomycetes", "Deuteromycetes"], "a": "Ascomycetes"},
    {"id": 235, "q": "Which fungus is used extensively in biochemical and genetic work?", "o": ["Neurospora", "Aspergillus", "Claviceps", "Mucor"], "a": "Neurospora"},
    {"id": 236, "q": "Mushrooms, bracket fungi, and puffballs belong to:", "o": ["Phycomycetes", "Ascomycetes", "Basidiomycetes", "Deuteromycetes"], "a": "Basidiomycetes"},
    {"id": 237, "q": "In Basidiomycetes, the sex organs are:", "o": ["Well developed", "Absent", "Unicellular", "Multicellular"], "a": "Absent"},
    {"id": 238, "q": "Deuteromycetes are known as 'Imperfect Fungi' because:", "o": ["They cause diseases", "They have no cell wall", "Only asexual/vegetative phases are known", "They are autotrophic"], "a": "Only asexual/vegetative phases are known"},
    {"id": 239, "q": "Trichoderma and Alternaria belong to:", "o": ["Phycomycetes", "Ascomycetes", "Deuteromycetes", "Basidiomycetes"], "a": "Deuteromycetes"},
    {"id": 240, "q": "White spots seen on mustard leaves are due to a parasitic fungus:", "o": ["Albugo", "Mucor", "Rhizopus", "Puccinia"], "a": "Albugo"},
    {"id": 241, "q": "Wheat Rust is caused by:", "o": ["Ustilago", "Puccinia", "Alternaria", "Colletotrichum"], "a": "Puccinia"},
    {"id": 242, "q": "The dikaryophase (n + n) is a specific characteristic of:", "o": ["Phycomycetes and Ascomycetes", "Basidiomycetes and Deuteromycetes", "Ascomycetes and Basidiomycetes", "Phycomycetes and Deuteromycetes"], "a": "Ascomycetes and Basidiomycetes"},
    {"id": 243, "q": "Morels and Truffles are edible delicacies belonging to:", "o": ["Basidiomycetes", "Ascomycetes", "Phycomycetes", "Deuteromycetes"], "a": "Ascomycetes"},

    # --- VIRUSES, VIROIDS, PRIONS, LICHENS ---
    {"id": 244, "q": "Viruses are:", "o": ["Living", "Non-living", "Connecting link", "Non-cellular organisms"], "a": "Non-cellular organisms"},
    {"id": 245, "q": "The name 'virus' that means venom or poisonous fluid was given by:", "o": ["D.J. Ivanowsky", "M.W. Beijerinck", "Pasteur", "W.M. Stanley"], "a": "Pasteur"},
    {"id": 246, "q": "Who demonstrated that the extract of infected tobacco plants could cause infection (Contagium vivum fluidum)?", "o": ["Ivanowsky", "Beijerinck", "Stanley", "Diener"], "a": "Beijerinck"},
    {"id": 247, "q": "Who showed that viruses could be crystallised?", "o": ["W.M. Stanley", "Ivanowsky", "Beijerinck", "Pasteur"], "a": "W.M. Stanley"},
    {"id": 248, "q": "The protein coat of a virus is called:", "o": ["Capsid", "Capsomere", "Envelope", "Sheath"], "a": "Capsid"},
    {"id": 249, "q": "Viruses that infect bacteria are called:", "o": ["Tobacco Mosaic Virus", "Bacteriophages", "Retroviruses", "Viroids"], "a": "Bacteriophages"},
    {"id": 250, "q": "The genetic material in Bacteriophages is usually:", "o": ["Single stranded RNA", "Single stranded DNA", "Double stranded DNA", "Double stranded RNA"], "a": "Double stranded DNA"},
    {"id": 251, "q": "Viroids differ from viruses in having:", "o": ["DNA molecules without protein coat", "RNA molecules with protein coat", "RNA molecules without protein coat", "DNA molecules with protein coat"], "a": "RNA molecules without protein coat"},
    {"id": 252, "q": "Potato Spindle Tuber disease is caused by:", "o": ["Virus", "Bacteria", "Viroid", "Prion"], "a": "Viroid"},
    {"id": 253, "q": "Who discovered Viroids?", "o": ["T.O. Diener", "W.M. Stanley", "Pasteur", "Ivanowsky"], "a": "T.O. Diener"},
    {"id": 254, "q": "Prions are known to cause which disease in cattle?", "o": ["Mad Cow Disease (BSE)", "Cr-Jacob Disease", "Foot and Mouth Disease", "Anthrax"], "a": "Mad Cow Disease (BSE)"},
    {"id": 255, "q": "Prions consist of abnormally folded:", "o": ["DNA", "RNA", "Proteins", "Lipids"], "a": "Proteins"},
    {"id": 256, "q": "The algal component of a Lichen is known as:", "o": ["Mycobiont", "Phycobiont", "Symbiont", "Parasite"], "a": "Phycobiont"},
    {"id": 257, "q": "Lichens are very good pollution indicators because they:", "o": ["Grow rapidly in polluted areas", "Do not grow in polluted areas", "Change color in pollution", "Absorb all pollutants"], "a": "Do not grow in polluted areas"},

    # --- ADVANCED / TRICKY / MATCHING TYPE LOGIC ---
    {"id": 258, "q": "In which group of organisms is the cell wall forming two thin overlapping shells which fit together as in a soap box?", "o": ["Dinoflagellates", "Slime moulds", "Chrysophytes", "Euglenoids"], "a": "Chrysophytes"},
    {"id": 259, "q": "The sexual cycle in fungi involves the following steps in correct order:", "o": ["Karyogamy -> Plasmogamy -> Meiosis", "Plasmogamy -> Karyogamy -> Meiosis", "Meiosis -> Plasmogamy -> Karyogamy", "Karyogamy -> Meiosis -> Plasmogamy"], "a": "Plasmogamy -> Karyogamy -> Meiosis"},
    {"id": 260, "q": "Which of the following statement is correct about Viruses?", "o": ["They have both DNA and RNA", "They are obligate parasites", "They can reproduce outside a host", "Antibiotics kill them easily"], "a": "They are obligate parasites"},
    {"id": 261, "q": "Coenocytic mycelium (multinucleate and aseptate) is found in:", "o": ["Deuteromycetes", "Phycomycetes", "Ascomycetes", "Basidiomycetes"], "a": "Phycomycetes"},
    {"id": 262, "q": "Clamp connections are a characteristic feature of:", "o": ["Ascomycetes", "Basidiomycetes", "Phycomycetes", "Deuteromycetes"], "a": "Basidiomycetes"},
    {"id": 263, "q": "Which of the following is NOT an example of Basidiomycetes?", "o": ["Agaricus", "Ustilago", "Puccinia", "Colletotrichum"], "a": "Colletotrichum"},
    {"id": 264, "q": "The imperfect fungi which are decomposers of litter and help in mineral cycling belong to:", "o": ["Basidiomycetes", "Phycomycetes", "Ascomycetes", "Deuteromycetes"], "a": "Deuteromycetes"},
    {"id": 265, "q": "Red Rot of Sugarcane is caused by Colletotrichum, which belongs to:", "o": ["Phycomycetes", "Deuteromycetes", "Basidiomycetes", "Ascomycetes"], "a": "Deuteromycetes"},
    {"id": 266, "q": "Heterotrophic bacteria are most abundant in nature. The majority of them are:", "o": ["Important Decomposers", "Pathogens", "Nitrogen fixers", "Autotrophs"], "a": "Important Decomposers"},
    {"id": 267, "q": "Kingdom Protista forms a link with:", "o": ["Plants only", "Animals only", "Plants, Animals and Fungi", "Monera only"], "a": "Plants, Animals and Fungi"},
    {"id": 268, "q": "In which kingdom did Whittaker place Chlamydomonas and Chlorella?", "o": ["Plantae", "Monera", "Protista", "Algae"], "a": "Protista"},
    {"id": 269, "q": "The protein coat of viruses (Capsid) is made of small subunits called:", "o": ["Peplomers", "Capsomeres", "Protomers", "Capsules"], "a": "Capsomeres"},
    {"id": 270, "q": "Bacteriophages usually have:", "o": ["dsDNA", "ssDNA", "dsRNA", "ssRNA"], "a": "dsDNA"},
    {"id": 271, "q": "Which of the following is an edible fungus?", "o": ["Mucor", "Penicillium", "Agaricus", "Rhizopus"], "a": "Agaricus"},
    {"id": 272, "q": "Sexual reproduction is absent in:", "o": ["Ascomycetes", "Deuteromycetes", "Basidiomycetes", "Phycomycetes"], "a": "Deuteromycetes"},
    {"id": 273, "q": "Identify the incorrect statement about Cyanobacteria:", "o": ["They are photoautotrophs", "They lack heterocysts", "They often form blooms in polluted water", "They are unicellular, colonial or filamentous"], "a": "They lack heterocysts"},
    {"id": 274, "q": "Which pigment is present in Cyanobacteria similar to green plants?", "o": ["Chlorophyll b", "Chlorophyll a", "Xanthophyll", "Carotene"], "a": "Chlorophyll a"},
    {"id": 275, "q": "Who showed that the virus is distinct from bacteria by passing them through bacteria-proof filters?", "o": ["Pasteur", "Ivanowsky", "Stanley", "Beijerinck"], "a": "Ivanowsky"},
    {"id": 442, "q": "Bryophytes are commonly called 'Amphibians of the Plant Kingdom' because:", "o": ["They live in soil but depend on water for sexual reproduction", "They live in water but lay eggs on land", "They have vascular tissues", "They are aquatic only"], "a": "They live in soil but depend on water for sexual reproduction"},
    {"id": 443, "q": "The plant body of Bryophytes is:", "o": ["Thallus-like and haploid", "Differentiated into roots and diploid", "Filamentous and diploid", "Having xylem and phloem"], "a": "Thallus-like and haploid"},
    {"id": 444, "q": "The main plant body of the bryophyte is:", "o": ["Gametophyte", "Sporophyte", "Zygote", "Embryo"], "a": "Gametophyte"},
    {"id": 445, "q": "The male sex organ in bryophytes is called:", "o": ["Antheridium", "Archegonium", "Oogonium", "Stamen"], "a": "Antheridium"},
    {"id": 446, "q": "The female sex organ in bryophytes is flask-shaped and called:", "o": ["Archegonium", "Antheridium", "Ovary", "Carple"], "a": "Archegonium"},
    {"id": 447, "q": "Antheridium produces:", "o": ["Biflagellate antherozoids", "Non-motile pollen", "Quadriflagellate spores", "Egg"], "a": "Biflagellate antherozoids"},
    {"id": 448, "q": "In Bryophytes, the Sporophyte is:", "o": ["Attached to gametophyte and dependent on it", "Free-living", "Photosynthetic and independent", "Unicellular"], "a": "Attached to gametophyte and dependent on it"},
    {"id": 449, "q": "Peat, used as fuel and packing material, is provided by:", "o": ["Sphagnum", "Funaria", "Marchantia", "Polytrichum"], "a": "Sphagnum"},
    {"id": 450, "q": "Liverworts reproduce asexually by fragmentation or by specialized structures called:", "o": ["Gemmae", "Buds", "Tubers", "Conidia"], "a": "Gemmae"},
    {"id": 451, "q": "Gemmae are:", "o": ["Green, multicellular, asexual buds", "Non-green, unicellular buds", "Sexual spores", "Roots"], "a": "Green, multicellular, asexual buds"},
    {"id": 452, "q": "In Mosses, the predominant stage of the life cycle is:", "o": ["Gametophyte", "Sporophyte", "Prothallus", "Zygote"], "a": "Gametophyte"},
    {"id": 453, "q": "The first stage of the moss gametophyte is called:", "o": ["Protonema", "Leafy stage", "Prothallus", "Capsule"], "a": "Protonema"},
    {"id": 454, "q": "The leafy stage of moss develops from the secondary protonema as a:", "o": ["Lateral bud", "Apical bud", "Root", "Rhizoid"], "a": "Lateral bud"},
    {"id": 455, "q": "Vegetative reproduction in mosses is by fragmentation and budding in the:", "o": ["Secondary protonema", "Primary protonema", "Sporophyte", "Capsule"], "a": "Secondary protonema"},
    {"id": 456, "q": "Which of the following are examples of Mosses?", "o": ["Funaria, Polytrichum, Sphagnum", "Marchantia, Riccia", "Selaginella, Equisetum", "Cycas, Pinus"], "a": "Funaria, Polytrichum, Sphagnum"},

    # --- GYMNOSPERMS ---
    {"id": 473, "q": "Gymnosperms are plants in which the ovules are:", "o": ["Not enclosed by any ovary wall (Naked)", "Enclosed by ovary", "Absent", "Covered by fruit"], "a": "Not enclosed by any ovary wall (Naked)"},
    {"id": 474, "q": "The giant redwood tree Sequoia is a:", "o": ["Gymnosperm", "Angiosperm", "Pteridophyte", "Bryophyte"], "a": "Gymnosperm"},
    {"id": 475, "q": "Fungal association (Mycorrhiza) is found in the roots of:", "o": ["Pinus", "Cycas", "Cedrus", "Sequoia"], "a": "Pinus"},
    {"id": 476, "q": "Coralloid roots associated with N2-fixing cyanobacteria are found in:", "o": ["Cycas", "Pinus", "Ginkgo", "Cedrus"], "a": "Cycas"},
    {"id": 477, "q": "Branched stems are found in:", "o": ["Pinus and Cedrus", "Cycas", "All gymnosperms", "None"], "a": "Pinus and Cedrus"},
    {"id": 478, "q": "Unbranched stems are found in:", "o": ["Cycas", "Pinus", "Cedrus", "Sequoia"], "a": "Cycas"},
    {"id": 479, "q": "In Conifers, the needle-like leaves, thick cuticle, and sunken stomata help to:", "o": ["Reduce water loss", "Increase photosynthesis", "Increase transpiration", "Attract insects"], "a": "Reduce water loss"},
    {"id": 480, "q": "Gymnosperms are:", "o": ["Heterosporous", "Homosporous", "Both", "None"], "a": "Heterosporous"},
    {"id": 481, "q": "In Gymnosperms, the male and female cones may be borne on the same tree (Monoecious) in:", "o": ["Pinus", "Cycas", "Ginkgo", "Marchantia"], "a": "Pinus"},
    {"id": 482, "q": "Male and female cones are borne on different trees (Dioecious) in:", "o": ["Cycas", "Pinus", "Cedrus", "Sequoia"], "a": "Cycas"},
    {"id": 483, "q": "In Gymnosperms, the male gametophyte is highly reduced and is called:", "o": ["Pollen grain", "Antheridium", "Microspore", "Sperm"], "a": "Pollen grain"},
    {"id": 484, "q": "Unlike Bryophytes and Pteridophytes, in Gymnosperms the male and female gametophytes:", "o": ["Do not have an independent free-living existence", "Are free-living", "Are photosynthetic", "Are dominant"], "a": "Do not have an independent free-living existence"},
    {"id": 485, "q": "The pollination in Gymnosperms is generally by:", "o": ["Wind (Anemophily)", "Insects", "Water", "Animals"], "a": "Wind (Anemophily)"},
    {"id": 486, "q": "In Gymnosperms, the embryo develops into:", "o": ["Seed", "Fruit", "Flower", "Cone"], "a": "Seed"},

    # --- ANGIOSPERMS (GENERAL) ---
    {"id": 487, "q": "The unique feature of Angiosperms is:", "o": ["Double Fertilization", "Naked seeds", "Presence of cones", "Dominant gametophyte"], "a": "Double Fertilization"},
    {"id": 488, "q": "In Angiosperms, the male sex organ in a flower is:", "o": ["Stamen", "Pistil", "Carpel", "Sepal"], "a": "Stamen"},
    {"id": 489, "q": "The female sex organ in a flower is:", "o": ["Pistil/Carpel", "Stamen", "Anther", "Filament"], "a": "Pistil/Carpel"},
    {"id": 490, "q": "The embryo sac formation is preceded by:", "o": ["Meiosis", "Mitosis only", "Fertilization", "Pollination"], "a": "Meiosis"},
    {"id": 491, "q": "A typical Embryo Sac is:", "o": ["7-celled and 8-nucleate", "8-celled and 7-nucleate", "7-celled and 7-nucleate", "8-celled and 8-nucleate"], "a": "7-celled and 8-nucleate"},
    {"id": 492, "q": "One male gamete fuses with the egg cell (Syngamy) to form:", "o": ["Zygote", "Endosperm", "Embryo", "Seed"], "a": "Zygote"},
    {"id": 493, "q": "The second male gamete fuses with the diploid secondary nucleus to form:", "o": ["Triploid Primary Endosperm Nucleus (PEN)", "Zygote", "Embryo", "Seed Coat"], "a": "Triploid Primary Endosperm Nucleus (PEN)"},
    {"id": 494, "q": "The function of Endosperm is to:", "o": ["Provide nourishment to the developing embryo", "Protect the seed", "Form the fruit", "Attract insects"], "a": "Provide nourishment to the developing embryo"},
    {"id": 495, "q": "After fertilization, the ovary develops into:", "o": ["Fruit", "Seed", "Embryo", "Pericarp"], "a": "Fruit"},
    {"id": 496, "q": "After fertilization, ovules develop into:", "o": ["Seeds", "Fruits", "Ovary", "Flower"], "a": "Seeds"},


    # --- PLOIDY & DNA CONTENT LOGIC (NEET FAVOURITE) ---
    {"id": 2001, "q": "In a diploid cell (2n), at G1 phase, chromosomes are:", "o": ["2n", "n", "4n", "n/2"], "a": "2n"},
    {"id": 2002, "q": "In a diploid cell (2n), at G1 phase, chromatids per chromosome is:", "o": ["1", "2", "4", "0"], "a": "1"},
    {"id": 2003, "q": "After S phase, the chromosome number is ______ and chromatid number is ______.", "o": ["2n; Doubled", "4n; Doubled", "2n; Same", "n; Half"], "a": "2n; Doubled"},
    {"id": 2004, "q": "At Metaphase of Mitosis, each chromosome has:", "o": ["2 Chromatids", "1 Chromatid", "4 Chromatids", "No Chromatids"], "a": "2 Chromatids"},
    {"id": 2005, "q": "At Anaphase of Mitosis, the chromosome number temporarily becomes:", "o": ["4n (Tetraploid)", "2n", "n", "8n"], "a": "4n (Tetraploid)"},
    {"id": 2006, "q": "At the end of Mitosis (Telophase), each daughter nucleus has:", "o": ["2n chromosomes, 2C DNA", "2n chromosomes, 4C DNA", "n chromosomes, 1C DNA", "4n chromosomes"], "a": "2n chromosomes, 2C DNA"},
    {"id": 2007, "q": "In Meiosis, at Anaphase I, the ploidy of the cell is effectively:", "o": ["2n (but homologous move apart)", "n", "4n", "3n"], "a": "2n (but homologous move apart)"},
    {"id": 2008, "q": "The product of Meiosis I (Dyad) has:", "o": ["n chromosomes, 2C DNA", "n chromosomes, 1C DNA", "2n chromosomes, 2C DNA", "2n chromosomes, 4C DNA"], "a": "n chromosomes, 2C DNA"},
    {"id": 2009, "q": "At Anaphase II, the centromere splits. The chromosome number in the cell temporarily becomes:", "o": ["2n (from n)", "n", "4n", "8n"], "a": "2n (from n)"},
    {"id": 2010, "q": "The final product of Meiosis II (Tetrad) has:", "o": ["n chromosomes, 1C DNA", "n chromosomes, 2C DNA", "2n chromosomes, 2C DNA", "n chromosomes, 4C DNA"], "a": "n chromosomes, 1C DNA"},
    
    # --- PHASE RECOGNITION (DIAGRAM BASED LOGIC) ---
    {"id": 2011, "q": "Chromosomes cluster at opposite spindle poles and their identity is lost as discrete elements. This is:", "o": ["Telophase", "Anaphase", "Metaphase", "Prophase"], "a": "Telophase"},
    {"id": 2012, "q": "Chromosomes are thickest and shortest at:", "o": ["Metaphase", "Prophase", "Anaphase", "Telophase"], "a": "Metaphase"},
    {"id": 2013, "q": "Nuclear membrane, Golgi, ER disappear at end of:", "o": ["Prophase", "Metaphase", "Telophase", "Anaphase"], "a": "Prophase"},
    {"id": 2014, "q": "Nuclear membrane, Golgi, ER reappear at:", "o": ["Telophase", "Prophase", "Anaphase", "Metaphase"], "a": "Telophase"},
    {"id": 2015, "q": "Synaptonemal complex dissolves at:", "o": ["Diplotene", "Pachytene", "Zygotene", "Diakinesis"], "a": "Diplotene"},
    
    # --- TRICKY STATEMENTS ---
    {"id": 2016, "q": "Statement: Interphase is the resting phase.", "o": ["True (but metabolically active)", "False", "Only G0 is resting", "It is M phase"], "a": "True (but metabolically active)"},
    {"id": 2017, "q": "Statement: Meiosis increases the specific chromosome number of the species.", "o": ["False (It conserves it)", "True", "Doubles it", "Triples it"], "a": "False (It conserves it)"},
    {"id": 2018, "q": "Statement: Variations are very important for the process of evolution.", "o": ["True", "False", "Only mutations matter", "Variations are bad"], "a": "True"},
    {"id": 2019, "q": "Bivalent chromosomes align on the equatorial plate in:", "o": ["Metaphase I", "Metaphase II", "Metaphase of Mitosis", "Anaphase I"], "a": "Metaphase I"},
    {"id": 2020, "q": "Univalent chromosomes (individual) align on the equator in:", "o": ["Metaphase of Mitosis and Metaphase II", "Metaphase I", "Anaphase I", "Prophase I"], "a": "Metaphase of Mitosis and Metaphase II"},
    
    # --- FINAL CHECK ---
    {"id": 2021, "q": "The stage between Meiosis I and Meiosis II is:", "o": ["Interkinesis", "Interphase", "S phase", "G0"], "a": "Interkinesis"},
    {"id": 2022, "q": "DNA replication occurs in Interkinesis.", "o": ["False", "True", "Sometimes", "Only in plants"], "a": "False"},
    {"id": 2023, "q": "How many chromatids are present in a human cell at Metaphase I?", "o": ["92", "46", "23", "184"], "a": "92"}, # (46 chromosomes x 2 chromatids each)
    {"id": 2024, "q": "How many centromeres are present in a human cell at Metaphase I?", "o": ["46", "92", "23", "10"], "a": "46"},
    {"id": 2025, "q": "In a human cell, at Anaphase I, how many chromosomes move to each pole?", "o": ["23 (Double stranded)", "46", "23 (Single stranded)", "92"], "a": "23 (Double stranded)"},
    # --- SPINDLE & APPARATUS ---
    {"id": 1976, "q": "Spindle fibres are made up of:", "o": ["Tubulin protein", "Actin", "Myosin", "Flagellin"], "a": "Tubulin protein"},
    {"id": 1977, "q": "The structure that initiates the formation of the spindle apparatus in animal cells is:", "o": ["Centrosome/Centriole", "Nucleolus", "Kinetochore", "Chromatid"], "a": "Centrosome/Centriole"},
    {"id": 1978, "q": "Plant cells lack centrioles and asters, so their mitosis is called:", "o": ["Anastral", "Amphiastral", "Centric", "Astral"], "a": "Anastral"},
    {"id": 1979, "q": "Animal mitosis is called ______ because of the presence of asters.", "o": ["Amphiastral", "Anastral", "Acentric", "Linear"], "a": "Amphiastral"},
    {"id": 1980, "q": "Colchicine is a chemical that:", "o": ["Inhibits spindle formation", "Promotes DNA replication", "Inhibits cytokinesis", "Promotes pairing"], "a": "Inhibits spindle formation"},
    {"id": 1981, "q": "Because Colchicine inhibits spindle formation, it arrests the cell at:", "o": ["Metaphase", "Prophase", "Anaphase", "Telophase"], "a": "Metaphase"},
    {"id": 1982, "q": "Application of Colchicine results in:", "o": ["Polyploidy (Doubling of chromosomes)", "Haploidy", "Cell death", "Cancer"], "a": "Polyploidy (Doubling of chromosomes)"},

    # --- CYTOKINESIS DETAILS ---
    {"id": 1983, "q": "The precursor of the cell plate in plant cytokinesis is:", "o": ["Phragmoplast", "Spindle", "Centriole", "Chloroplast"], "a": "Phragmoplast"},
    {"id": 1984, "q": "Cell plate formation proceeds in which direction?", "o": ["Centrifugal (Center to Periphery)", "Centripetal (Periphery to Center)", "Top to Bottom", "Random"], "a": "Centrifugal (Center to Periphery)"},
    {"id": 1985, "q": "Animal cytokinesis (Furrow formation) proceeds in which direction?", "o": ["Centripetal (Periphery to Center)", "Centrifugal", "Bottom to Top", "Random"], "a": "Centripetal (Periphery to Center)"},
    {"id": 1986, "q": "Mitochondria and Plastids get distributed between the two daughter cells during:", "o": ["Cytokinesis", "Karyokinesis", "S phase", "G2 phase"], "a": "Cytokinesis"},

    # --- COMPARISON: MITOSIS VS MEIOSIS ---
    {"id": 1987, "q": "DNA replication occurs:", "o": ["Only once before both Mitosis and Meiosis", "Twice in Meiosis", "Once in Mitosis, Twice in Meiosis", "Never"], "a": "Only once before both Mitosis and Meiosis"},
    {"id": 1988, "q": "Homologous pairing is unique to:", "o": ["Meiosis", "Mitosis", "Amitosis", "Binary fission"], "a": "Meiosis"},
    {"id": 1989, "q": "Sister chromatids separate in:", "o": ["Anaphase of Mitosis and Anaphase II", "Anaphase I", "Metaphase I", "Prophase I"], "a": "Anaphase of Mitosis and Anaphase II"},
    {"id": 1990, "q": "The chromosome number is reduced to half in:", "o": ["Anaphase I", "Anaphase II", "Metaphase II", "Telophase II"], "a": "Anaphase I"},
    {"id": 1991, "q": "Meiosis is also called:", "o": ["Reductional division", "Equational division", "Multiplication division", "Direct division"], "a": "Reductional division"},
    {"id": 1992, "q": "Mitosis is also called:", "o": ["Equational division", "Reductional division", "Generative division", "Meiotic"], "a": "Equational division"},
    {"id": 1993, "q": "Meiosis II is called equational division because:", "o": ["Chromosome number remains same as produced at end of Meiosis I", "DNA replicates", "Ploidy doubles", "Crossing over happens"], "a": "Chromosome number remains same as produced at end of Meiosis I"},

    # --- SPECIFIC EXAMPLES ---
    {"id": 1994, "q": "Best material to study Mitosis in laboratory is:", "o": ["Onion root tip", "Onion peel", "Anther", "Flower bud"], "a": "Onion root tip"},
    {"id": 1995, "q": "Best material to study Meiosis in laboratory is:", "o": ["Young Anther (Flower bud)", "Root tip", "Shoot tip", "Leaf"], "a": "Young Anther (Flower bud)"},
    {"id": 1996, "q": "In which organisms can Mitosis occur in haploid cells?", "o": ["Male Honey Bees (Drones) and some plants", "Humans", "Dogs", "Frogs"], "a": "Male Honey Bees (Drones) and some plants"},
    {"id": 1997, "q": "Bacteria divide mainly by:", "o": ["Binary Fission (Amitosis)", "Mitosis", "Meiosis", "Spore formation"], "a": "Binary Fission (Amitosis)"},
    {"id": 1998, "q": "Cancer cells are characterized by:", "o": ["Uncontrolled cell division (Loss of contact inhibition)", "Controlled division", "Meiosis", "Dormancy"], "a": "Uncontrolled cell division (Loss of contact inhibition)"},
    {"id": 1999, "q": "A cell in G1 phase has 20 chromosomes. After S phase it will have:", "o": ["20 chromosomes", "40 chromosomes", "10 chromosomes", "80 chromosomes"], "a": "20 chromosomes"},
    {"id": 2000, "q": "If a cell has 2C DNA in G1. What is DNA content in G2?", "o": ["4C", "2C", "1C", "8C"], "a": "4C"},
    
    # --- NUMERICALS (VERY IMP FOR NEET) ---
    {"id": 1964, "q": "A cell has 2n=16 chromosomes. After S-phase, the number of chromosomes will be:", "o": ["16", "32", "8", "64"], "a": "16"},
    {"id": 1965, "q": "A cell has 2n=16 chromosomes. After S-phase, the DNA content (C) changes from 2C to:", "o": ["4C", "2C", "1C", "8C"], "a": "4C"},
    {"id": 1966, "q": "At Anaphase of Mitosis, if the cell starts with 16 chromosomes, how many chromosomes are present in the cell (before cytokinesis)?", "o": ["32", "16", "8", "64"], "a": "32"}, # (Centromeres split, so chromatids become chromosomes)
    {"id": 1967, "q": "At Anaphase I of Meiosis, if 2n=16, how many chromosomes move to each pole?", "o": ["8 (n)", "16 (2n)", "32", "4"], "a": "8 (n)"},
    {"id": 1968, "q": "How many meiotic divisions are required to produce 100 pollen grains?", "o": ["25", "50", "100", "10"], "a": "25"}, # (1 meiosis = 4 pollen)
    {"id": 1969, "q": "How many mitotic divisions are required to form 128 cells from a single cell?", "o": ["7", "64", "127", "128"], "a": "7"}, # (2^7 = 128)

    # --- CONCEPTUAL STATEMENTS ---
    {"id": 1970, "q": "Identify the MISMATCH:", "o": ["Anaphase I - Splitting of Centromere", "Metaphase I - Bivalents align", "Zygotene - Synapsis", "Pachytene - Crossing Over"], "a": "Anaphase I - Splitting of Centromere"}, # (Splitting happens in Anaphase II or Mitosis)
    {"id": 1971, "q": "Recombination nodules appear during:", "o": ["Pachytene", "Leptotene", "Zygotene", "Diakinesis"], "a": "Pachytene"},
    {"id": 1972, "q": "The final stage of meiotic prophase I is:", "o": ["Diakinesis", "Diplotene", "Telophase", "Cytokinesis"], "a": "Diakinesis"},
    {"id": 1973, "q": "Diakinesis is marked by:", "o": ["Terminalization of chiasmata", "Formation of chiasmata", "Synapsis", "Crossing over"], "a": "Terminalization of chiasmata"},
    {"id": 1974, "q": "In oocytes, the special diplotene stage is called:", "o": ["Dictyotene", "Leptotene", "Zygotene", "Pachytene"], "a": "Dictyotene"}, # (Extra edge)
    {"id": 1975, "q": "Which checkpoint controls the entry into S-phase?", "o": ["G1/S Checkpoint", "G2/M Checkpoint", "M Checkpoint", "G0 Checkpoint"], "a": "G1/S Checkpoint"},
    
    # --- MEIOSIS BASICS ---
    {"id": 1941, "q": "Meiosis ensures the production of haploid phase in life cycle, while fertilization restores the:", "o": ["Diploid phase", "Haploid phase", "Polyploid phase", "Triploid phase"], "a": "Diploid phase"},
    {"id": 1942, "q": "Meiosis involves:", "o": ["Two cycles of division but one cycle of DNA replication", "Two cycles of DNA replication", "One cycle of division", "No DNA replication"], "a": "Two cycles of division but one cycle of DNA replication"},
    {"id": 1943, "q": "Pairing of homologous chromosomes and recombination occurs in:", "o": ["Meiosis I", "Meiosis II", "Mitosis", "Amitosis"], "a": "Meiosis I"},

    # --- PROPHASE I (LZPDD - SEQUENCE IS KEY) ---
    {"id": 1944, "q": "Which is the longest and most complex phase of Meiosis?", "o": ["Prophase I", "Metaphase I", "Anaphase I", "Prophase II"], "a": "Prophase I"},
    {"id": 1945, "q": "The correct sequence of Prophase I is:", "o": ["Leptotene, Zygotene, Pachytene, Diplotene, Diakinesis", "Leptotene, Pachytene, Zygotene, Diakinesis, Diplotene", "Zygotene, Leptotene, Pachytene, Diplotene, Diakinesis", "Leptotene, Zygotene, Diplotene, Pachytene, Diakinesis"], "a": "Leptotene, Zygotene, Pachytene, Diplotene, Diakinesis"},
    {"id": 1946, "q": "Compaction of chromosomes continues throughout:", "o": ["Leptotene", "Zygotene", "Pachytene", "Diplotene"], "a": "Leptotene"},
    {"id": 1947, "q": "Synapsis (pairing of homologous chromosomes) occurs in:", "o": ["Zygotene", "Leptotene", "Pachytene", "Diplotene"], "a": "Zygotene"},
    {"id": 1948, "q": "The complex formed by a pair of synapsed homologous chromosomes is called a:", "o": ["Bivalent or Tetrad", "Monad", "Dyad", "Triad"], "a": "Bivalent or Tetrad"},
    {"id": 1949, "q": "Formation of Synaptonemal Complex is a characteristic of:", "o": ["Zygotene", "Leptotene", "Pachytene", "Diakinesis"], "a": "Zygotene"},
    {"id": 1950, "q": "Crossing Over occurs during:", "o": ["Pachytene", "Zygotene", "Diplotene", "Diakinesis"], "a": "Pachytene"},
    {"id": 1951, "q": "Crossing over is an enzyme-mediated process. The enzyme involved is:", "o": ["Recombinase", "Ligase", "Helicase", "Polymerase"], "a": "Recombinase"},
    {"id": 1952, "q": "The X-shaped structures called 'Chiasmata' are seen in:", "o": ["Diplotene", "Pachytene", "Zygotene", "Diakinesis"], "a": "Diplotene"},
    {"id": 1953, "q": "Dissolution of the synaptonemal complex occurs in:", "o": ["Diplotene", "Pachytene", "Zygotene", "Diakinesis"], "a": "Diplotene"},
    {"id": 1954, "q": "In oocytes of some vertebrates, Diplotene can last for:", "o": ["Months or years", "Minutes", "Hours", "Days"], "a": "Months or years"},
    {"id": 1955, "q": "Terminalization of chiasmata occurs in:", "o": ["Diakinesis", "Diplotene", "Pachytene", "Metaphase I"], "a": "Diakinesis"},

    # --- MEIOSIS I (META, ANA, TELO) ---
    {"id": 1956, "q": "In Metaphase I, the bivalent chromosomes align on the:", "o": ["Equatorial plate", "Poles", "Nucleus", "Membrane"], "a": "Equatorial plate"},
    {"id": 1957, "q": "In Anaphase I, the homologous chromosomes separate, while sister chromatids:", "o": ["Remain associated at their centromeres", "Separate", "Dissolve", "Fuse"], "a": "Remain associated at their centromeres"},
    {"id": 1958, "q": "The stage between two meiotic divisions is called:", "o": ["Interkinesis", "Interphase", "Cytokinesis", "Karyokinesis"], "a": "Interkinesis"},
    {"id": 1959, "q": "Interkinesis is generally short lived and there is:", "o": ["NO replication of DNA", "Replication of DNA", "Protein synthesis only", "Cell growth"], "a": "NO replication of DNA"},

    # --- MEIOSIS II ---
    {"id": 1960, "q": "Meiosis II resembles:", "o": ["Mitosis", "Meiosis I", "Amitosis", "Fission"], "a": "Mitosis"},
    {"id": 1961, "q": "In Anaphase II, splitting of the centromere occurs allowing:", "o": ["Sister chromatids to move to opposite poles", "Homologous chromosomes to separate", "Crossing over", "Synapsis"], "a": "Sister chromatids to move to opposite poles"},
    {"id": 1962, "q": "Meiosis results in the formation of:", "o": ["Four haploid cells", "Two diploid cells", "Four diploid cells", "Two haploid cells"], "a": "Four haploid cells"},
    {"id": 1963, "q": "Significance of Meiosis: It increases:", "o": ["Genetic variability", "Cell size", "Organelle number", "DNA content"], "a": "Genetic variability"},
    
    # --- PROPHASE ---
    {"id": 1920, "q": "The first stage of karyokinesis is:", "o": ["Prophase", "Metaphase", "Anaphase", "Telophase"], "a": "Prophase"},
    {"id": 1921, "q": "Prophase is marked by the:", "o": ["Initiation of condensation of chromosomal material", "Splitting of centromere", "Alignment of chromosomes", "Formation of nuclear membrane"], "a": "Initiation of condensation of chromosomal material"},
    {"id": 1922, "q": "The centrosome, which had duplicated during S phase, begins to move towards:", "o": ["Opposite poles of the cell", "Center of the cell", "Nucleus", "Membrane"], "a": "Opposite poles of the cell"},
    {"id": 1923, "q": "Two asters together with spindle fibres form the:", "o": ["Mitotic apparatus", "Centrosome", "Kinetochore", "Cytoskeleton"], "a": "Mitotic apparatus"},
    {"id": 1924, "q": "Cells at the end of prophase, when viewed under microscope, do NOT show:", "o": ["Golgi, ER, Nucleolus and Nuclear envelope", "Chromosomes", "Centrioles", "Spindle fibres"], "a": "Golgi, ER, Nucleolus and Nuclear envelope"},

    # --- METAPHASE ---
    {"id": 1925, "q": "The complete disintegration of the nuclear envelope marks the start of:", "o": ["Metaphase", "Prophase", "Anaphase", "Telophase"], "a": "Metaphase"},
    {"id": 1926, "q": "Condensation of chromosomes is completed and they can be observed clearly under microscope in:", "o": ["Metaphase", "Prophase", "Anaphase", "Telophase"], "a": "Metaphase"},
    {"id": 1927, "q": "Which stage is best to study the morphology of chromosomes?", "o": ["Metaphase", "Prophase", "Anaphase", "Telophase"], "a": "Metaphase"},
    {"id": 1928, "q": "Small disc-shaped structures at the surface of the centromeres are called:", "o": ["Kinetochores", "Satellites", "Telomeres", "Chromatids"], "a": "Kinetochores"},
    {"id": 1929, "q": "The plane of alignment of the chromosomes at metaphase is referred to as the:", "o": ["Metaphase plate", "Cell plate", "Cleavage furrow", "Equator"], "a": "Metaphase plate"},

    # --- ANAPHASE ---
    {"id": 1930, "q": "The splitting of the centromere occurs during:", "o": ["Anaphase", "Metaphase", "Telophase", "Prophase"], "a": "Anaphase"},
    {"id": 1931, "q": "During Anaphase, chromatids move to opposite poles. The centromere leads towards:", "o": ["The pole (leading edge)", "The equator", "The center", "Random direction"], "a": "The pole (leading edge)"},
    {"id": 1932, "q": "The arms of the chromosome trail behind the centromere. This happens in:", "o": ["Anaphase", "Metaphase", "Prophase", "Telophase"], "a": "Anaphase"},

    # --- TELOPHASE & CYTOKINESIS ---
    {"id": 1933, "q": "The final stage of karyokinesis is:", "o": ["Telophase", "Anaphase", "Metaphase", "Prophase"], "a": "Telophase"},
    {"id": 1934, "q": "In Telophase, the chromosomes:", "o": ["Decondense and lose their individuality", "Condense further", "Split", "Align"], "a": "Decondense and lose their individuality"},
    {"id": 1935, "q": "Nuclear envelope reassembles around the chromosome clusters in:", "o": ["Telophase", "Anaphase", "Metaphase", "Prophase"], "a": "Telophase"},
    {"id": 1936, "q": "In animal cells, cytokinesis is achieved by the appearance of a:", "o": ["Furrow in the plasma membrane", "Cell plate", "Middle lamella", "Spindle"], "a": "Furrow in the plasma membrane"},
    {"id": 1937, "q": "In plant cells, cytokinesis starts with the formation of a:", "o": ["Cell plate", "Furrow", "Centriole", "Aster"], "a": "Cell plate"},
    {"id": 1938, "q": "The Cell Plate represents the:", "o": ["Middle lamella", "Primary wall", "Secondary wall", "Plasma membrane"], "a": "Middle lamella"},
    {"id": 1939, "q": "In some organisms, karyokinesis is not followed by cytokinesis, leading to a multinucleate condition called:", "o": ["Syncytium", "Coenocytic", "Polyploidy", "Aneuploidy"], "a": "Syncytium"},
    {"id": 1940, "q": "Example of Syncytium is:", "o": ["Liquid endosperm in coconut", "Root tip", "Leaf cell", "Bacteria"], "a": "Liquid endosperm in coconut"},
    
    # --- BASIC PHASES ---
    {"id": 1901, "q": "The sequence of events by which a cell duplicates its genome, synthesizes other constituents and eventually divides is:", "o": ["Cell Cycle", "Cell Division", "Karyokinesis", "Cytokinesis"], "a": "Cell Cycle"},
    {"id": 1902, "q": "The correct sequence of phases in Cell Cycle is:", "o": ["G1 -> S -> G2 -> M", "G1 -> G2 -> S -> M", "M -> G1 -> G2 -> S", "S -> G1 -> G2 -> M"], "a": "G1 -> S -> G2 -> M"},
    {"id": 1903, "q": "Human cells in culture divide approximately every:", "o": ["24 hours", "90 minutes", "20 minutes", "1 hour"], "a": "24 hours"},
    {"id": 1904, "q": "Yeast cells can complete the cell cycle in about:", "o": ["90 minutes", "24 hours", "20 minutes", "12 hours"], "a": "90 minutes"},
    {"id": 1905, "q": "Interphase lasts for more than ______ of the duration of the cell cycle.", "o": ["95%", "50%", "5%", "10%"], "a": "95%"},
    {"id": 1906, "q": "M Phase starts with ______ and ends with ______.", "o": ["Nuclear division; Cytoplasm division", "Cytoplasm division; Nuclear division", "G1; G2", "S phase; G1"], "a": "Nuclear division; Cytoplasm division"},

    # --- G1, S, G2 PHASES (THE TRICKY PART) ---
    {"id": 1907, "q": "The interval between mitosis and initiation of DNA replication is:", "o": ["G1 Phase", "G2 Phase", "S Phase", "M Phase"], "a": "G1 Phase"},
    {"id": 1908, "q": "In which phase is the cell metabolically active and continuously grows but does NOT replicate DNA?", "o": ["G1 Phase", "S Phase", "G2 Phase", "M Phase"], "a": "G1 Phase"},
    {"id": 1909, "q": "DNA replication (synthesis) takes place in:", "o": ["S Phase", "G1 Phase", "G2 Phase", "M Phase"], "a": "S Phase"},
    {"id": 1910, "q": "If the initial amount of DNA is 2C, what is the amount after S phase?", "o": ["4C", "2C", "1C", "8C"], "a": "4C"},
    {"id": 1911, "q": "If the cell has 2n chromosomes at G1, how many chromosomes will it have after S phase?", "o": ["2n", "4n", "n", "8n"], "a": "2n"},
    {"id": 1912, "q": "In animal cells, during S phase, DNA replication begins in the nucleus, and the ______ duplicates in the cytoplasm.", "o": ["Centriole", "Mitochondria", "Golgi", "Lysosome"], "a": "Centriole"},
    {"id": 1913, "q": "Proteins needed for mitosis are synthesized in:", "o": ["G2 Phase", "G1 Phase", "S Phase", "M Phase"], "a": "G2 Phase"},

    # --- G0 PHASE (QUIESCENT STAGE) ---
    {"id": 1914, "q": "Cells that do not divide further exit G1 phase to enter an inactive stage called:", "o": ["Quiescent stage (G0)", "S phase", "G2 phase", "M phase"], "a": "Quiescent stage (G0)"},
    {"id": 1915, "q": "Cells in G0 stage are:", "o": ["Metabolically active but do not proliferate", "Metabolically inactive", "Dead", "Dividing rapidly"], "a": "Metabolically active but do not proliferate"},
    {"id": 1916, "q": "Heart cells generally do not divide. They are likely in:", "o": ["G0 Phase", "G1 Phase", "S Phase", "M Phase"], "a": "G0 Phase"},

    # --- MITOSIS BASICS ---
    {"id": 1917, "q": "Mitosis is usually restricted to ______ cells in animals.", "o": ["Diploid somatic", "Haploid germ", "Gametes", "None"], "a": "Diploid somatic"},
    {"id": 1918, "q": "In plants, mitotic division is seen in:", "o": ["Both haploid and diploid cells", "Only diploid cells", "Only haploid cells", "Only roots"], "a": "Both haploid and diploid cells"},
    {"id": 1919, "q": "Which phase involves the reorganization of virtually all cell components?", "o": ["M Phase", "Interphase", "S Phase", "G0 Phase"], "a": "M Phase"},
    
    # --- ENZYME KINETICS & KM VALUE (ADVANCED) ---
    {"id": 1859, "q": "Km (Michaelis constant) represents the substrate concentration at which:", "o": ["Reaction velocity is half of Vmax", "Velocity is Vmax", "Reaction stops", "Enzyme is denatured"], "a": "Reaction velocity is half of Vmax"},
    {"id": 1860, "q": "A lower Km value indicates:", "o": ["Higher affinity of enzyme for substrate", "Lower affinity", "Slower reaction", "Less active site"], "a": "Higher affinity of enzyme for substrate"}, # (Rank Booster Concept)
    {"id": 1861, "q": "Competitive inhibition can be reversed by:", "o": ["Increasing substrate concentration", "Increasing inhibitor", "Decreasing temperature", "Removing enzyme"], "a": "Increasing substrate concentration"},
    
    # --- TRICKY NCERT STATEMENTS ---
    {"id": 1862, "q": "Statement: All organic compounds in a living tissue are biomolecules.", "o": ["True", "False", "Only polymers", "Only soluble ones"], "a": "True"},
    {"id": 1863, "q": "Statement: Living systems are at equilibrium.", "o": ["False (Systems at equilibrium cannot perform work)", "True", "Partially true", "Only in death"], "a": "False (Systems at equilibrium cannot perform work)"},
    {"id": 1864, "q": "Statement: The living state is a non-equilibrium steady state to be able to perform work.", "o": ["True", "False", "It is equilibrium", "It is static"], "a": "True"},
    {"id": 1865, "q": "Statement: Starch holds I2 molecules in the helical portion. Cellulose does not contain complex helices and cannot hold I2.", "o": ["True", "False", "Both hold I2", "Neither holds I2"], "a": "True"},
    {"id": 1866, "q": "Adult human hemoglobin has:", "o": ["2 alpha and 2 beta chains", "4 alpha chains", "2 alpha and 2 delta chains", "4 beta chains"], "a": "2 alpha and 2 beta chains"},
    {"id": 1867, "q": "Fetal hemoglobin (HbF) has higher affinity for oxygen than Adult hemoglobin (HbA).", "o": ["True", "False", "Same affinity", "No affinity"], "a": "True"}, # (Connected concept)
    
    # --- MOLECULAR WEIGHT & POOL LOGIC ---
    {"id": 1868, "q": "Molecular weight of amino acids/sugars is roughly:", "o": ["18 to 800 Daltons", "10,000 Daltons", ">1000 Daltons", "1 Million Daltons"], "a": "18 to 800 Daltons"},
    {"id": 1869, "q": "The acid insoluble fraction has only four types of organic compounds. Which one is the exception regarding molecular weight?", "o": ["Lipids (Small MW but insoluble)", "Proteins", "Nucleic acids", "Polysaccharides"], "a": "Lipids (Small MW but insoluble)"},
    {"id": 1870, "q": "Lipids have a molecular weight not exceeding:", "o": ["800 Da", "10,000 Da", "50 Da", "2000 Da"], "a": "800 Da"},
    
    # --- BOND REVISION MATCHING ---
    {"id": 1871, "q": "Bond in Polysaccharides:", "o": ["Glycosidic", "Peptide", "Phosphodiester", "Ester"], "a": "Glycosidic"},
    {"id": 1872, "q": "Bond in Proteins:", "o": ["Peptide", "Glycosidic", "Hydrogen only", "Ionic only"], "a": "Peptide"},
    {"id": 1873, "q": "Bond in Fats (Triglycerides):", "o": ["Ester", "Ether", "Peptide", "Glycosidic"], "a": "Ester"},
    {"id": 1874, "q": "Bond in Nucleic Acid backbone:", "o": ["Phosphodiester", "Peptide", "Glycosidic", "Hydrogen"], "a": "Phosphodiester"},
    {"id": 1875, "q": "Bond between Nitrogenous base and Pentose sugar:", "o": ["N-glycosidic", "O-glycosidic", "Peptide", "Ester"], "a": "N-glycosidic"},

    # --- FINAL BOSS QUESTIONS ---
    {"id": 1876, "q": "Which enzyme class catalyzes the interconversion of optical, geometric or positional isomers?", "o": ["Isomerases", "Ligases", "Lyases", "Transferases"], "a": "Isomerases"},
    {"id": 1877, "q": "Which enzyme class catalyzes the removal of groups from substrates by mechanisms other than hydrolysis leaving double bonds?", "o": ["Lyases", "Ligases", "Hydrolases", "Transferases"], "a": "Lyases"},
    {"id": 1878, "q": "Zinc is a cofactor for Carboxypeptidase. It is attached to the enzyme by:", "o": ["Coordination bonds", "Covalent bonds", "Hydrogen bonds", "Peptide bonds"], "a": "Coordination bonds"},
    {"id": 1879, "q": "Niacin (Vitamin) is a component of:", "o": ["NAD and NADP", "FAD", "Coenzyme A", "ATP"], "a": "NAD and NADP"},
    {"id": 1880, "q": "A non-protein constituent called cofactor is bound to the enzyme to make it:", "o": ["Catalytically active", "Inactive", "Stable", "Soluble"], "a": "Catalytically active"},
    
    # --- SECONDARY METABOLITES TABLE (RATTA MARO PART) ---
    {"id": 1836, "q": "Match the category: Pigments", "o": ["Carotenoids, Anthocyanins", "Morphine, Codeine", "Monoterpenes", "Vinblastine"], "a": "Carotenoids, Anthocyanins"},
    {"id": 1837, "q": "Match the category: Alkaloids", "o": ["Morphine, Codeine", "Abrin, Ricin", "Lemon grass oil", "Gums"], "a": "Morphine, Codeine"},
    {"id": 1838, "q": "Match the category: Terpenoids", "o": ["Monoterpenes, Diterpenes", "Curcumin", "Concanavalin A", "Rubber"], "a": "Monoterpenes, Diterpenes"},
    {"id": 1839, "q": "Match the category: Essential Oils", "o": ["Lemon grass oil", "Gingelly oil", "Castor oil", "Mustard oil"], "a": "Lemon grass oil"},
    {"id": 1840, "q": "Match the category: Toxins", "o": ["Abrin, Ricin", "Vinblastine, Curcumin", "Morphine", "Cellulose"], "a": "Abrin, Ricin"},
    {"id": 1841, "q": "Match the category: Lectins", "o": ["Concanavalin A", "Curcumin", "Codeine", "Ricin"], "a": "Concanavalin A"},
    {"id": 1842, "q": "Match the category: Drugs", "o": ["Vinblastine, Curcumin", "Morphine, Codeine", "Abrin, Ricin", "Gums"], "a": "Vinblastine, Curcumin"},
    {"id": 1843, "q": "Match the category: Polymeric substances", "o": ["Rubber, Gums, Cellulose", "Starch, Protein", "DNA, RNA", "Lipids"], "a": "Rubber, Gums, Cellulose"},

    # --- METABOLIC BASIS FOR LIVING (CONCEPTUAL) ---
    {"id": 1844, "q": "Metabolic pathways can be:", "o": ["Linear or Circular", "Only Linear", "Only Circular", "Random"], "a": "Linear or Circular"},
    {"id": 1845, "q": "Metabolites flow in a dynamic state. This flow is called:", "o": ["Metabolic flux", "Equilibrium flow", "Static flow", "Passive flow"], "a": "Metabolic flux"},
    {"id": 1846, "q": "In living systems, there is ______ uncatalyzed metabolic conversion.", "o": ["NO", "Some", "Mostly", "Always"], "a": "NO"},
    {"id": 1847, "q": "Even the dissolving of CO2 in water is a:", "o": ["Catalyzed reaction in living systems", "Physical process", "Chemical equilibrium", "Passive process"], "a": "Catalyzed reaction in living systems"},
    {"id": 1848, "q": "Anabolic pathways are ______; Catabolic pathways are ______.", "o": ["Biosynthetic (consume energy); Degradation (release energy)", "Degradation; Biosynthetic", "Exothermic; Endothermic", "Fast; Slow"], "a": "Biosynthetic (consume energy); Degradation (release energy)"},
    {"id": 1849, "q": "Example of Anabolic pathway:", "o": ["Acetic acid -> Cholesterol", "Glucose -> Lactic acid", "Glucose -> CO2", "Protein -> Amino acid"], "a": "Acetic acid -> Cholesterol"},
    {"id": 1850, "q": "Example of Catabolic pathway:", "o": ["Glucose -> Lactic acid (Glycolysis)", "Amino acids -> Protein", "Sugar -> Polysaccharide", "CO2 -> Glucose"], "a": "Glucose -> Lactic acid (Glycolysis)"},
    {"id": 1851, "q": "The energy currency in living systems is:", "o": ["ATP (Adenosine Triphosphate)", "ADP", "DNA", "Glucose"], "a": "ATP (Adenosine Triphosphate)"},
    {"id": 1852, "q": "The bond energy in ATP is stored in:", "o": ["High energy phosphate bonds", "Hydrogen bonds", "Glycosidic bonds", "Peptide bonds"], "a": "High energy phosphate bonds"},
    {"id": 1853, "q": "Blood concentration of hormones is measured in:", "o": ["Nanograms/mL", "Mols/L", "Grams/L", "Kg/L"], "a": "Nanograms/mL"},
    
    # --- DEEP STRUCTURE & BONDS ---
    {"id": 1854, "q": "Peptide bond (-CO-NH-) is formed between:", "o": ["Carboxyl group of one AA and Amino group of next AA", "Amino group of one and Amino group of next", "Carboxyl of one and Carboxyl of next", "R group and R group"], "a": "Carboxyl group of one AA and Amino group of next AA"},
    {"id": 1855, "q": "Formation of a peptide bond involves the elimination of:", "o": ["Water moiety (Dehydration)", "CO2", "Ammonia", "Oxygen"], "a": "Water moiety (Dehydration)"},
    {"id": 1856, "q": "Glycosidic bond is formed between two carbon atoms of adjacent monosaccharides by:", "o": ["Dehydration", "Hydration", "Oxidation", "Reduction"], "a": "Dehydration"},
    {"id": 1857, "q": "In a nucleic acid, a phosphate moiety links the 3'-carbon of one sugar of one nucleotide to the 5'-carbon of the sugar of the succeeding nucleotide. This bond is:", "o": ["Phosphodiester bond", "Phosphoester bond", "Glycosidic bond", "Hydrogen bond"], "a": "Phosphodiester bond"},
    {"id": 1858, "q": "Why is it called Phospho-DI-ester bond?", "o": ["Because there is one ester bond on each side of the phosphate (Two total)", "Because it has 2 phosphates", "Because it connects 2 sugars", "Because it is double strength"], "a": "Because there is one ester bond on each side of the phosphate (Two total)"},
    
    # --- ENZYME BASICS ---
    {"id": 1796, "q": "Almost all enzymes are:", "o": ["Proteins", "Lipids", "Carbohydrates", "Vitamins"], "a": "Proteins"},
    {"id": 1797, "q": "Nucleic acids that behave like enzymes are called:", "o": ["Ribozymes", "Apoenzymes", "Coenzymes", "Prosthetic groups"], "a": "Ribozymes"},
    {"id": 1798, "q": "An active site of an enzyme is a:", "o": ["Crevice or pocket into which the substrate fits", "Linear chain", "Outer surface", "Lipid layer"], "a": "Crevice or pocket into which the substrate fits"},
    {"id": 1799, "q": "Inorganic catalysts work efficiently at high temperatures, whereas enzymes:", "o": ["Get damaged at high temperatures (>40Â°C)", "Work better at 100Â°C", "Are unaffected", "Freeze"], "a": "Get damaged at high temperatures (>40Â°C)"},
    {"id": 1800, "q": "Enzymes isolated from thermophilic organisms (like Taq polymerase) are:", "o": ["Thermally stable", "Unstable", "Inactive", "Denatured easily"], "a": "Thermally stable"},

    # --- CHEMICAL REACTIONS & RATES ---
    {"id": 1801, "q": "Rate of a reaction is defined as:", "o": ["Amount of product formed per unit time", "Amount of substrate used", "Temperature change", "Energy released"], "a": "Amount of product formed per unit time"},
    {"id": 1802, "q": "Rule of thumb: Rate doubles or decreases by half for every:", "o": ["10Â°C change in temperature", "1Â°C change", "50Â°C change", "100Â°C change"], "a": "10Â°C change in temperature"},
    {"id": 1803, "q": "Carbonic anhydrase accelerates the reaction of CO2 and H2O by:", "o": ["10 million times", "100 times", "1000 times", "2 times"], "a": "10 million times"},
    {"id": 1804, "q": "Without Carbonic anhydrase, only ______ molecules of H2CO3 are formed per hour. With it, ______ molecules per second.", "o": ["200; 600,000", "600; 200", "100; 1000", "50; 500"], "a": "200; 600,000"},
    {"id": 1805, "q": "A multistep chemical reaction where each step is catalyzed by the same or different enzymes is called a:", "o": ["Metabolic pathway", "Catabolic pathway", "Anabolic pathway", "Turnover"], "a": "Metabolic pathway"},

    # --- ENZYME MECHANISM ---
    {"id": 1806, "q": "The substrate binds to the enzyme at the:", "o": ["Active site", "Allosteric site", "C-terminal", "N-terminal"], "a": "Active site"},
    {"id": 1807, "q": "Formation of the Enzyme-Substrate (ES) complex is:", "o": ["Transient and unstable", "Permanent", "Stable", "Slow"], "a": "Transient and unstable"},
    {"id": 1808, "q": "The energy difference between average energy of substrate and transition state is called:", "o": ["Activation energy", "Potential energy", "Kinetic energy", "Free energy"], "a": "Activation energy"},
    {"id": 1809, "q": "Enzymes catalyze reactions by:", "o": ["Lowering the activation energy", "Increasing activation energy", "Increasing temperature", "Changing equilibrium"], "a": "Lowering the activation energy"},
    {"id": 1810, "q": "The essential concept of the 'Induced Fit' theory is that binding of substrate:", "o": ["Induces the enzyme to alter its shape to fit tightly", "Is rigid like a lock and key", "Does not change shape", "Breaks the enzyme"], "a": "Induces the enzyme to alter its shape to fit tightly"},

    # --- FACTORS AFFECTING ACTIVITY ---
    {"id": 1811, "q": "Enzymes show highest activity at a specific temperature and pH called:", "o": ["Optimum temperature/pH", "Maximum limit", "Minimum limit", "Transition point"], "a": "Optimum temperature/pH"},
    {"id": 1812, "q": "Low temperature preserves the enzyme in a:", "o": ["Temporarily inactive state", "Denatured state", "Destroyed state", "Hyperactive state"], "a": "Temporarily inactive state"},
    {"id": 1813, "q": "High temperature causes:", "o": ["Denaturation (destruction of structure)", "Inactivation", "Preservation", "Activation"], "a": "Denaturation (destruction of structure)"},
    {"id": 1814, "q": "With the increase in substrate concentration, the velocity of the enzymatic reaction:", "o": ["Increases at first then reaches a maximum (Vmax)", "Decreases", "Remains constant", "Increases indefinitely"], "a": "Increases at first then reaches a maximum (Vmax)"},
    {"id": 1815, "q": "The reaction reaches Vmax when:", "o": ["All enzyme molecules are saturated with substrate", "Substrate is finished", "Temperature is high", "pH is low"], "a": "All enzyme molecules are saturated with substrate"},
    
    # --- INHIBITION (VERY IMP) ---
    {"id": 1816, "q": "When the inhibitor closely resembles the substrate and competes for the active site, it is called:", "o": ["Competitive inhibition", "Non-competitive inhibition", "Allosteric inhibition", "Feedback inhibition"], "a": "Competitive inhibition"},
    {"id": 1817, "q": "Inhibition of Succinic dehydrogenase by Malonate is an example of:", "o": ["Competitive inhibition", "Non-competitive inhibition", "Allosteric inhibition", "Permanent inhibition"], "a": "Competitive inhibition"},
    {"id": 1818, "q": "Malonate closely resembles the substrate:", "o": ["Succinate", "Fumarate", "Citrate", "Malate"], "a": "Succinate"},
    {"id": 1819, "q": "Competitive inhibitors are often used in the control of:", "o": ["Bacterial pathogens", "Viral infections", "Fungal growth", "Plant growth"], "a": "Bacterial pathogens"},
    {"id": 1820, "q": "In Competitive inhibition, Km ______ and Vmax ______.", "o": ["Increases; Remains same", "Remains same; Decreases", "Decreases; Increases", "Both decrease"], "a": "Increases; Remains same"}, # (Deep Concept)

    # --- CLASSIFICATION & COFACTORS ---
    {"id": 1821, "q": "Enzymes are divided into how many classes?", "o": ["6", "4", "10", "5"], "a": "6"},
    {"id": 1822, "q": "Oxidoreductases/Dehydrogenases catalyze:", "o": ["Oxidoreduction between two substrates", "Transfer of a group", "Hydrolysis", "Joining of bonds"], "a": "Oxidoreduction between two substrates"},
    {"id": 1823, "q": "Transferases catalyze:", "o": ["Transfer of a group (other than hydrogen)", "Splitting of bonds", "Isomerization", "Oxidation"], "a": "Transfer of a group (other than hydrogen)"},
    {"id": 1824, "q": "Hydrolases catalyze:", "o": ["Hydrolysis of ester, ether, peptide, glycosidic bonds", "Removal of groups", "Joining of bonds", "Transfer of H"], "a": "Hydrolysis of ester, ether, peptide, glycosidic bonds"},
    {"id": 1825, "q": "Lyases catalyze:", "o": ["Removal of groups leaving double bonds", "Hydrolysis", "Joining bonds", "Isomerization"], "a": "Removal of groups leaving double bonds"},
    {"id": 1826, "q": "Isomerases catalyze:", "o": ["Inter-conversion of optical, geometric or positional isomers", "Joining bonds", "Breaking bonds", "Oxidation"], "a": "Inter-conversion of optical, geometric or positional isomers"},
    {"id": 1827, "q": "Ligases catalyze:", "o": ["Linking together of two compounds (C-O, C-S, C-N, P-O bonds)", "Breaking bonds", "Hydrolysis", "Transfer"], "a": "Linking together of two compounds (C-O, C-S, C-N, P-O bonds)"},
    {"id": 1828, "q": "The protein part of the enzyme is called:", "o": ["Apoenzyme", "Cofactor", "Holoenzyme", "Prosthetic group"], "a": "Apoenzyme"},
    {"id": 1829, "q": "Holoenzyme =", "o": ["Apoenzyme + Cofactor", "Apoenzyme + Substrate", "Cofactor + Product", "Protein only"], "a": "Apoenzyme + Cofactor"},
    {"id": 1830, "q": "Prosthetic groups are organic compounds that are:", "o": ["Tightly bound to the apoenzyme", "Loosely bound", "Metal ions", "Transient"], "a": "Tightly bound to the apoenzyme"},
    {"id": 1831, "q": "Haem is the prosthetic group in:", "o": ["Peroxidase and Catalase", "Carboxypeptidase", "Hexokinase", "Lipase"], "a": "Peroxidase and Catalase"},
    {"id": 1832, "q": "Co-enzymes are organic compounds whose association with the apoenzyme is:", "o": ["Transient (only during catalysis)", "Permanent", "Tightly bound", "Covalent"], "a": "Transient (only during catalysis)"},
    {"id": 1833, "q": "Essential chemical components of many coenzymes are:", "o": ["Vitamins", "Proteins", "Fats", "Minerals"], "a": "Vitamins"},
    {"id": 1834, "q": "NAD and NADP contain the vitamin:", "o": ["Niacin", "Riboflavin", "Thiamine", "Vitamin A"], "a": "Niacin"},
    {"id": 1835, "q": "Zinc is a cofactor for the proteolytic enzyme:", "o": ["Carboxypeptidase", "Peroxidase", "Catalase", "Amylase"], "a": "Carboxypeptidase"},

    # --- NUCLEOTIDES BASICS ---
    {"id": 1772, "q": "A nucleotide has three components: A nitrogenous base, a pentose sugar and:", "o": ["A phosphate group", "A lipid", "An amino acid", "A sulfate group"], "a": "A phosphate group"},
    {"id": 1773, "q": "A nucleoside consists of:", "o": ["Sugar + Nitrogenous base", "Sugar + Phosphate", "Base + Phosphate", "Sugar only"], "a": "Sugar + Nitrogenous base"},
    {"id": 1774, "q": "The nitrogenous base is linked to the pentose sugar by which bond?", "o": ["N-glycosidic linkage", "Phosphodiester linkage", "Peptide bond", "Hydrogen bond"], "a": "N-glycosidic linkage"},
    {"id": 1775, "q": "The phosphate group is linked to the 5' OH of a nucleoside by which bond?", "o": ["Phosphoester linkage", "Phosphodiester linkage", "Glycosidic bond", "Hydrogen bond"], "a": "Phosphoester linkage"},
    {"id": 1776, "q": "Two nucleotides are linked through 3'-5' ______ linkage to form a dinucleotide.", "o": ["Phosphodiester", "Phosphoester", "Glycosidic", "Peptide"], "a": "Phosphodiester"},
    {"id": 1777, "q": "Adenine and Guanine are:", "o": ["Purines (Double ring)", "Pyrimidines (Single ring)", "Sugars", "Acids"], "a": "Purines (Double ring)"},
    {"id": 1778, "q": "Cytosine, Uracil and Thymine are:", "o": ["Pyrimidines (Single ring)", "Purines", "Sugars", "Proteins"], "a": "Pyrimidines (Single ring)"},
    {"id": 1779, "q": "Uracil is found in RNA, whereas Thymine is found in:", "o": ["DNA only", "Both DNA and RNA", "Proteins", "Lipids"], "a": "DNA only"},
    {"id": 1780, "q": "Thymine is chemically known as:", "o": ["5-methyl uracil", "5-ethyl uracil", "3-methyl cytosine", "Demethylated uracil"], "a": "5-methyl uracil"},
    {"id": 1781, "q": "The sugar found in DNA is ______ and in RNA is ______.", "o": ["Deoxyribose; Ribose", "Ribose; Deoxyribose", "Glucose; Fructose", "Ribose; Glucose"], "a": "Deoxyribose; Ribose"},

    # --- DNA STRUCTURE (WATSON & CRICK) ---
    {"id": 1782, "q": "Who proposed the famous Double Helix model of DNA?", "o": ["Watson and Crick (1953)", "Wilkins and Franklin", "Chargaff", "Meselson and Stahl"], "a": "Watson and Crick (1953)"},
    {"id": 1783, "q": "The backbone of the DNA strand is formed by:", "o": ["Sugar-Phosphate", "Nitrogenous bases", "Hydrogen bonds", "Only Sugar"], "a": "Sugar-Phosphate"},
    {"id": 1784, "q": "The two chains of DNA have anti-parallel polarity. If one is 5'->3', the other is:", "o": ["3'->5'", "5'->3'", "Parallel", "Random"], "a": "3'->5'"},
    {"id": 1785, "q": "Adenine pairs with Thymine with how many Hydrogen bonds?", "o": ["2", "3", "1", "4"], "a": "2"},
    {"id": 1786, "q": "Guanine pairs with Cytosine with how many Hydrogen bonds?", "o": ["3", "2", "4", "1"], "a": "3"},
    {"id": 1787, "q": "According to Erwin Chargaff, in double-stranded DNA:", "o": ["The ratio of A:T and G:C is constant and equals one", "A+T = G+C", "A+G = T+C is false", "Purines are not equal to Pyrimidines"], "a": "The ratio of A:T and G:C is constant and equals one"},
    
    # --- B-DNA DATA (VERY IMP FOR NEET) ---
    {"id": 1788, "q": "The DNA model described by Watson and Crick is:", "o": ["B-DNA", "A-DNA", "Z-DNA", "C-DNA"], "a": "B-DNA"},
    {"id": 1789, "q": "At each step of ascent in the B-DNA helix, the strand turns:", "o": ["36 degrees", "20 degrees", "45 degrees", "90 degrees"], "a": "36 degrees"},
    {"id": 1790, "q": "One full turn of the helical strand involves how many base pairs?", "o": ["10 bp", "12 bp", "8 bp", "20 bp"], "a": "10 bp"},
    {"id": 1791, "q": "The pitch of the B-DNA helix (length of one turn) is:", "o": ["34 Angstrom (3.4 nm)", "3.4 Angstrom", "20 Angstrom", "10 Angstrom"], "a": "34 Angstrom (3.4 nm)"},
    {"id": 1792, "q": "The rise per base pair (distance between adjacent bp) is:", "o": ["3.4 Angstrom (0.34 nm)", "34 Angstrom", "10 Angstrom", "20 Angstrom"], "a": "3.4 Angstrom (0.34 nm)"},
    
    # --- DYNAMIC STATE ---
    {"id": 1793, "q": "The biomolecules are present in specific concentrations (e.g., Blood glucose 4.2-6.1 mmol/L). This state is:", "o": ["Dynamic state", "Static state", "Equilibrium state", "Dead state"], "a": "Dynamic state"},
    {"id": 1794, "q": "Living state is a:", "o": ["Non-equilibrium steady state to be able to perform work", "Equilibrium state", "Static state", "Reversible state"], "a": "Non-equilibrium steady state to be able to perform work"},
    {"id": 1795, "q": "Living process is a constant effort to prevent falling into:", "o": ["Equilibrium", "Non-equilibrium", "Steady state", "Metabolism"], "a": "Equilibrium"},
    
    # --- AMINO ACIDS ---
    {"id": 1737, "q": "Amino acids are substituted methanes. The four substituent groups occupy the valency positions of:", "o": ["Alpha-carbon", "Beta-carbon", "Carboxyl carbon", "Nitrogen"], "a": "Alpha-carbon"},
    {"id": 1738, "q": "The simplest amino acid is:", "o": ["Glycine", "Alanine", "Serine", "Valine"], "a": "Glycine"},
    {"id": 1739, "q": "In Glycine, the R-group is:", "o": ["Hydrogen", "Methyl group", "Hydroxymethyl", "Ethyl"], "a": "Hydrogen"},
    {"id": 1740, "q": "In Alanine, the R-group is:", "o": ["Methyl group", "Hydrogen", "Hydroxymethyl", "Phenyl"], "a": "Methyl group"},
    {"id": 1741, "q": "In Serine, the R-group is:", "o": ["Hydroxymethyl (-CH2OH)", "Methyl", "Hydrogen", "Acidic"], "a": "Hydroxymethyl (-CH2OH)"},
    {"id": 1742, "q": "Which of the following is an Acidic amino acid?", "o": ["Glutamic acid", "Lysine", "Valine", "Tyrosine"], "a": "Glutamic acid"},
    {"id": 1743, "q": "Which of the following is a Basic amino acid?", "o": ["Lysine", "Glutamic acid", "Valine", "Tryptophan"], "a": "Lysine"},
    {"id": 1744, "q": "Which of the following is a Neutral amino acid?", "o": ["Valine", "Lysine", "Glutamic acid", "Arginine"], "a": "Valine"},
    {"id": 1745, "q": "Which of the following is an Aromatic amino acid?", "o": ["Tyrosine, Phenylalanine, Tryptophan", "Valine, Serine", "Lysine, Arginine", "Glycine"], "a": "Tyrosine, Phenylalanine, Tryptophan"},
    {"id": 1746, "q": "A particular property of amino acids is the ionizable nature of -NH2 and -COOH groups. At a specific pH, the amino acid carries both positive and negative charges. This form is called:", "o": ["Zwitterionic form", "Cationic form", "Anionic form", "Neutral form"], "a": "Zwitterionic form"},

    # --- PROTEINS STRUCTURE ---
    {"id": 1747, "q": "Proteins are:", "o": ["Heteropolymers", "Homopolymers", "Monomers", "Lipids"], "a": "Heteropolymers"},
    {"id": 1748, "q": "Proteins are chains of amino acids linked by:", "o": ["Peptide bonds", "Glycosidic bonds", "Ester bonds", "Hydrogen bonds only"], "a": "Peptide bonds"},
    {"id": 1749, "q": "Collagen is the most abundant protein in:", "o": ["Animal world", "Whole biosphere", "Plants", "Bacteria"], "a": "Animal world"},
    {"id": 1750, "q": "RuBisCO is the most abundant protein in:", "o": ["Whole biosphere", "Animal world", "Fungi", "Viruses"], "a": "Whole biosphere"},
    {"id": 1751, "q": "Primary structure of protein gives:", "o": ["Positional information (Sequence of amino acids)", "3D shape", "Helical structure", "Folding"], "a": "Positional information (Sequence of amino acids)"},
    {"id": 1752, "q": "In a polypeptide chain, the first amino acid is called ______ and the last is called ______.", "o": ["N-terminal; C-terminal", "C-terminal; N-terminal", "Left; Right", "Alpha; Beta"], "a": "N-terminal; C-terminal"},
    {"id": 1753, "q": "Secondary structure includes:", "o": ["Alpha-helix and Beta-pleated sheet", "Only sequence", "3D folding", "Hemoglobin structure"], "a": "Alpha-helix and Beta-pleated sheet"},
    {"id": 1754, "q": "In proteins, only ______ helices are observed.", "o": ["Right-handed", "Left-handed", "Double", "Triple"], "a": "Right-handed"},
    {"id": 1755, "q": "The tertiary structure is necessary for:", "o": ["Many biological activities of proteins", "Just sequence", "Stability only", "Color"], "a": "Many biological activities of proteins"},
    {"id": 1756, "q": "Tertiary structure involves folding into a:", "o": ["Hollow woolen ball like structure", "Linear chain", "Sheet", "Helix"], "a": "Hollow woolen ball like structure"},
    {"id": 1757, "q": "Quaternary structure is exhibited by:", "o": ["Proteins with more than one polypeptide subunit", "All proteins", "Myoglobin", "Insulin only"], "a": "Proteins with more than one polypeptide subunit"},
    {"id": 1758, "q": "Hemoglobin consists of 4 subunits:", "o": ["Two alpha and two beta", "Four alpha", "Four beta", "Three alpha one beta"], "a": "Two alpha and two beta"},

    # --- PROTEIN FUNCTIONS ---
    {"id": 1759, "q": "Function of Collagen:", "o": ["Intercellular ground substance", "Enzyme", "Hormone", "Transport"], "a": "Intercellular ground substance"},
    {"id": 1760, "q": "Function of Trypsin:", "o": ["Enzyme", "Hormone", "Fight infection", "Transport glucose"], "a": "Enzyme"},
    {"id": 1761, "q": "Function of Insulin:", "o": ["Hormone", "Enzyme", "Sensory reception", "Structure"], "a": "Hormone"},
    {"id": 1762, "q": "Function of Antibody:", "o": ["Fights infectious agents", "Digestion", "Oxygen transport", "Hormone"], "a": "Fights infectious agents"},
    {"id": 1763, "q": "Function of GLUT-4:", "o": ["Enables glucose transport into cells", "Digests glucose", "Stores glucose", "Makes glucose"], "a": "Enables glucose transport into cells"},
    {"id": 1764, "q": "Receptors (for smell, taste, hormones) are made of:", "o": ["Protein", "Lipid", "DNA", "Carbohydrate"], "a": "Protein"},

    # --- METABOLITES ---
    {"id": 1765, "q": "Primary metabolites have:", "o": ["Identifiable functions in normal physiological processes", "No known function", "Role in defense only", "Ecological importance only"], "a": "Identifiable functions in normal physiological processes"},
    {"id": 1766, "q": "Which of the following is a Secondary Metabolite?", "o": ["Alkaloids, Flavonoids, Rubber", "Glucose", "Amino acid", "ATP"], "a": "Alkaloids, Flavonoids, Rubber"},
    {"id": 1767, "q": "Morphine and Codeine are:", "o": ["Alkaloids", "Terpenoids", "Toxins", "Lectins"], "a": "Alkaloids"},
    {"id": 1768, "q": "Abrin and Ricin are:", "o": ["Toxins", "Alkaloids", "Drugs", "Pigments"], "a": "Toxins"},
    {"id": 1769, "q": "Vinblastine and Curcumin are:", "o": ["Drugs", "Toxins", "Spices", "Essential oils"], "a": "Drugs"},
    {"id": 1770, "q": "Concanavalin A is a:", "o": ["Lectin", "Pigment", "Alkaloid", "Toxin"], "a": "Lectin"},
    {"id": 1771, "q": "Monoterpenes and Diterpenes are:", "o": ["Terpenoids", "Alkaloids", "Pigments", "Drugs"], "a": "Terpenoids"},
    
    # --- CHEMICAL ANALYSIS & POOLS ---
    {"id": 1701, "q": "To analyze the chemical composition of living tissue, we grind it in:", "o": ["Trichloroacetic acid (Cl3CCOOH)", "Sulphuric acid", "Nitric acid", "Hydrochloric acid"], "a": "Trichloroacetic acid (Cl3CCOOH)"},
    {"id": 1702, "q": "The acid-soluble pool roughly represents the:", "o": ["Cytoplasmic composition", "Cell wall composition", "Membrane composition", "Organelles"], "a": "Cytoplasmic composition"},
    {"id": 1703, "q": "The acid-insoluble fraction (Retentate) contains:", "o": ["Proteins, Nucleic acids, Polysaccharides, Lipids", "Only Proteins", "Amino acids and Sugars", "Only DNA"], "a": "Proteins, Nucleic acids, Polysaccharides, Lipids"},
    {"id": 1704, "q": "Which of the following is NOT a polymer but is found in the acid-insoluble fraction?", "o": ["Lipids", "Proteins", "DNA", "Cellulose"], "a": "Lipids"},
    {"id": 1705, "q": "Lipids are found in the retentate because:", "o": ["They form vesicles upon grinding and are not water soluble", "They are very large polymers", "They bind to DNA", "They are proteins"], "a": "They form vesicles upon grinding and are not water soluble"},
    {"id": 1706, "q": "Biomicromolecules generally have a molecular weight of:", "o": ["Less than 1000 Dalton (18-800 Da)", "More than 10,000 Da", "Above 5000 Da", "Exactly 100 Da"], "a": "Less than 1000 Dalton (18-800 Da)"},
    {"id": 1707, "q": "Biomacromolecules generally have molecular weights:", "o": ["10,000 Daltons and above", "Less than 1000 Da", "18-800 Da", "500 Da"], "a": "10,000 Daltons and above"},
    {"id": 1708, "q": "Ash analysis of tissue is done to identify:", "o": ["Inorganic elements (Ca, Mg, etc.)", "Organic compounds", "Proteins", "Vitamins"], "a": "Inorganic elements (Ca, Mg, etc.)"},
    {"id": 1709, "q": "Which is the most abundant element in living matter?", "o": ["Oxygen", "Carbon", "Hydrogen", "Nitrogen"], "a": "Oxygen"},
    {"id": 1710, "q": "Which is the most abundant chemical in living organisms?", "o": ["Water (70-90%)", "Protein", "Carbohydrate", "Nucleic Acid"], "a": "Water (70-90%)"},

    # --- CARBOHYDRATES ---
    {"id": 1711, "q": "Sugars are chemically:", "o": ["Polyhydroxy aldehydes or ketones", "Proteins", "Lipids", "Acids"], "a": "Polyhydroxy aldehydes or ketones"},
    {"id": 1712, "q": "The bond connecting two monosaccharides is called:", "o": ["Glycosidic bond", "Peptide bond", "Ester bond", "Phosphodiester bond"], "a": "Glycosidic bond"},
    {"id": 1713, "q": "Glycosidic bond is formed by:", "o": ["Dehydration (loss of water)", "Hydration", "Oxidation", "Reduction"], "a": "Dehydration (loss of water)"},
    {"id": 1714, "q": "Glycogen is a polymer of:", "o": ["Glucose", "Fructose", "Galactose", "Ribose"], "a": "Glucose"},
    {"id": 1715, "q": "In Glycogen, the right end is ______ and the left end is ______.", "o": ["Reducing; Non-reducing", "Non-reducing; Reducing", "Reducing; Reducing", "Non-reducing; Non-reducing"], "a": "Reducing; Non-reducing"},
    {"id": 1716, "q": "Starch consists of two components:", "o": ["Amylose and Amylopectin", "Glucose and Fructose", "Maltose and Lactose", "Cellulose and Pectin"], "a": "Amylose and Amylopectin"},
    {"id": 1717, "q": "Why does starch give blue color with Iodine?", "o": ["I2 is trapped in the helical portion of starch", "I2 reacts with glucose", "Starch is blue", "I2 oxidizes starch"], "a": "I2 is trapped in the helical portion of starch"},
    {"id": 1718, "q": "Cellulose does NOT give blue color with Iodine because:", "o": ["It does not contain complex helices", "It is made of fructose", "It is too small", "It is a lipid"], "a": "It does not contain complex helices"},
    {"id": 1719, "q": "Cellulose is a polymer of:", "o": ["Beta-glucose", "Alpha-glucose", "Fructose", "Ribose"], "a": "Beta-glucose"},
    {"id": 1720, "q": "Inulin is a polymer of:", "o": ["Fructose", "Glucose", "Galactose", "Mannose"], "a": "Fructose"},
    {"id": 1721, "q": "The exoskeleton of arthropods is made of a complex polysaccharide called:", "o": ["Chitin", "Cellulose", "Starch", "Glycogen"], "a": "Chitin"},
    {"id": 1722, "q": "Chitin is a polymer of:", "o": ["N-acetyl glucosamine (NAG)", "N-acetyl muramic acid", "Glucose", "Fructose"], "a": "N-acetyl glucosamine (NAG)"},
    {"id": 1723, "q": "Cotton fibre is essentially:", "o": ["Cellulose", "Protein", "Starch", "Chitin"], "a": "Cellulose"},
    {"id": 1724, "q": "Paper made from plant pulp is:", "o": ["Cellulose", "Protein", "Starch", "Pectin"], "a": "Cellulose"},

    # --- LIPIDS ---
    {"id": 1725, "q": "Lipids are generally:", "o": ["Water insoluble", "Water soluble", "Polymers", "Proteins"], "a": "Water insoluble"},
    {"id": 1726, "q": "A fatty acid has a carboxyl group attached to an R group. Palmitic acid has how many carbons?", "o": ["16 (including carboxyl carbon)", "15", "20", "18"], "a": "16 (including carboxyl carbon)"},
    {"id": 1727, "q": "Arachidonic acid has ______ carbon atoms.", "o": ["20", "16", "18", "22"], "a": "20"},
    {"id": 1728, "q": "Saturated fatty acids have:", "o": ["No double bonds", "One double bond", "Multiple double bonds", "Triple bonds"], "a": "No double bonds"},
    {"id": 1729, "q": "Unsaturated fatty acids have:", "o": ["One or more double bonds", "No double bonds", "Only single bonds", "No carbon"], "a": "One or more double bonds"},
    {"id": 1730, "q": "Glycerol is chemically:", "o": ["Trihydroxy propane", "Dihydroxy propane", "Trihydroxy butane", "Fatty acid"], "a": "Trihydroxy propane"},
    {"id": 1731, "q": "Fats and oils are:", "o": ["Esters of fatty acids and glycerol", "Ethers", "Polymers of glucose", "Proteins"], "a": "Esters of fatty acids and glycerol"},
    {"id": 1732, "q": "Triglycerides contain:", "o": ["3 fatty acids + 1 glycerol", "1 fatty acid + 3 glycerol", "3 fatty acids + 3 glycerol", "Only fatty acids"], "a": "3 fatty acids + 1 glycerol"},
    {"id": 1733, "q": "Oils have a ______ melting point compared to fats.", "o": ["Lower (e.g., Gingelly oil)", "Higher", "Same", "Variable"], "a": "Lower (e.g., Gingelly oil)"},
    {"id": 1734, "q": "Phospholipids are found in:", "o": ["Cell membranes", "Cell wall", "DNA", "Ribosomes"], "a": "Cell membranes"},
    {"id": 1735, "q": "Lecithin is an example of a:", "o": ["Phospholipid", "Glycolipid", "Simple lipid", "Steroid"], "a": "Phospholipid"},
    {"id": 1736, "q": "The most complex lipid structure mentioned in NCERT with a ring structure is:", "o": ["Cholesterol", "Lecithin", "Palmitic acid", "Glycerol"], "a": "Cholesterol"},
    
    # --- CHROMOSOME SHAPES & CENTROMERE (VERY TRICKY) ---
    {"id": 1626, "q": "During Anaphase, Metacentric chromosomes appear as:", "o": ["V-shaped", "L-shaped", "J-shaped", "I-shaped"], "a": "V-shaped"},
    {"id": 1627, "q": "During Anaphase, Sub-metacentric chromosomes appear as:", "o": ["L-shaped", "V-shaped", "J-shaped", "I-shaped"], "a": "L-shaped"},
    {"id": 1628, "q": "During Anaphase, Acrocentric chromosomes appear as:", "o": ["J-shaped", "V-shaped", "L-shaped", "I-shaped"], "a": "J-shaped"},
    {"id": 1629, "q": "During Anaphase, Telocentric chromosomes appear as:", "o": ["I-shaped", "V-shaped", "L-shaped", "J-shaped"], "a": "I-shaped"},
    {"id": 1630, "q": "The kinetochores constitute the actual site of:", "o": ["Attachment of spindle fibres", "DNA replication", "Protein synthesis", "Crossing over"], "a": "Attachment of spindle fibres"},
    {"id": 1631, "q": "Satellite bodies are formed by:", "o": ["Secondary constrictions", "Primary constrictions", "Telomeres", "Centromeres"], "a": "Secondary constrictions"},

    # --- SCIENTISTS & STATEMENTS (NCERT DEEP LINES) ---
    {"id": 1632, "q": "Who concluded that the presence of a cell wall is a unique character of plant cells?", "o": ["Theodore Schwann", "Matthias Schleiden", "Robert Hooke", "Virchow"], "a": "Theodore Schwann"},
    {"id": 1633, "q": "Schleiden (1838) observed that all plants are composed of different kinds of cells which form the:", "o": ["Tissues of the plant", "Organs of the plant", "Seeds of the plant", "Fruits"], "a": "Tissues of the plant"},
    {"id": 1634, "q": "The cell theory as understood today is:", "o": ["All living organisms are composed of cells AND cells arise from pre-existing cells", "Only cells arise from pre-existing cells", "Cells are building blocks only", "DNA is genetic material"], "a": "All living organisms are composed of cells AND cells arise from pre-existing cells"},
    
    # --- MEMBRANE & TRANSPORT NUANCES ---
    {"id": 1635, "q": "The tail of the phospholipid molecule is:", "o": ["Saturated hydrocarbon and non-polar", "Unsaturated and polar", "Proteinaceous", "Hydrophilic"], "a": "Saturated hydrocarbon and non-polar"},
    {"id": 1636, "q": "The head of the phospholipid molecule is:", "o": ["Polar and Hydrophilic", "Non-polar and Hydrophobic", "Neutral", "Made of sugar"], "a": "Polar and Hydrophilic"},
    {"id": 1637, "q": "Why is the tail protected from the aqueous environment?", "o": ["Because it is hydrophobic", "Because it is hydrophilic", "Because it is polar", "Because it is enzymatic"], "a": "Because it is hydrophobic"},
    {"id": 1638, "q": "Neutral solutes may move across the membrane by the process of:", "o": ["Simple diffusion", "Active transport", "Osmosis", "Endocytosis"], "a": "Simple diffusion"},
    {"id": 1639, "q": "Water moves across the membrane from:", "o": ["High concentration to low concentration (Osmosis)", "Low to high concentration", "Randomly", "Using ATP"], "a": "High concentration to low concentration (Osmosis)"},
    {"id": 1640, "q": "Polar molecules cannot pass through the non-polar lipid bilayer, so they require:", "o": ["Carrier proteins", "ATP always", "DNA", "RNA"], "a": "Carrier proteins"},

    # --- ORGANELLE CONNECTIONS (CONCEPTUAL) ---
    {"id": 1641, "q": "The Golgi apparatus remains in close association with the:", "o": ["Endoplasmic Reticulum", "Mitochondria", "Nucleus only", "Lysosomes"], "a": "Endoplasmic Reticulum"},
    {"id": 1642, "q": "Materials to be packaged in the form of vesicles from the ER fuse with the ______ face of the Golgi apparatus.", "o": ["cis (forming)", "trans (maturing)", "lateral", "dorsal"], "a": "cis (forming)"},
    {"id": 1643, "q": "Vesicles move towards the ______ face of Golgi for release.", "o": ["trans (maturing)", "cis (forming)", "inner", "outer"], "a": "trans (maturing)"},
    {"id": 1644, "q": "Which organelle is responsible for Glycosylation of proteins?", "o": ["Golgi apparatus", "ER", "Lysosome", "Ribosome"], "a": "Golgi apparatus"},
    {"id": 1645, "q": "Formation of Glycoproteins and Glycolipids is the main function of:", "o": ["Golgi apparatus", "SER", "RER", "Mitochondria"], "a": "Golgi apparatus"},

    # --- PROKARYOTE vs EUKARYOTE (THE FINAL CHECK) ---
    {"id": 1646, "q": "Which structure is common to both Prokaryotic and Eukaryotic cells?", "o": ["Ribosomes and Plasma Membrane", "Mitochondria", "Nuclear Membrane", "Lysosomes"], "a": "Ribosomes and Plasma Membrane"},
    {"id": 1647, "q": "Plasmids are:", "o": ["Small circular DNA outside genomic DNA", "Main genomic DNA", "RNA molecules", "Viral DNA"], "a": "Small circular DNA outside genomic DNA"},
    {"id": 1648, "q": "The membrane of the Erythrocyte (RBC) has:", "o": ["52% Protein, 40% Lipid", "50% Protein, 50% Lipid", "40% Protein, 52% Lipid", "90% Lipid"], "a": "52% Protein, 40% Lipid"},
    {"id": 1649, "q": "Gram staining distinguishes bacteria based on:", "o": ["Cell envelope composition", "Size", "Shape", "Reproduction"], "a": "Cell envelope composition"},
    {"id": 1650, "q": "Mesosomes are analogous to which eukaryotic organelle in terms of respiration?", "o": ["Mitochondria", "Golgi", "Lysosome", "Chloroplast"], "a": "Mitochondria"},

    # --- MISCELLANEOUS HIDDEN GEMS ---
    {"id": 1651, "q": "The cytoskeleton consists of:", "o": ["Microtubules, Microfilaments, Intermediate filaments", "Actin and Myosin", "Spindle fibres only", "Cilia"], "a": "Microtubules, Microfilaments, Intermediate filaments"},
    {"id": 1652, "q": "Plasmodesmata are:", "o": ["Cytoplasmic bridges between adjacent plant cells", "Pores in nuclear membrane", "Connections between animal cells", "Pores in cell membrane"], "a": "Cytoplasmic bridges between adjacent plant cells"},
    {"id": 1653, "q": "Middle lamella is mainly made of:", "o": ["Calcium pectate", "Magnesium pectate", "Cellulose", "Lignin"], "a": "Calcium pectate"},
    {"id": 1654, "q": "The primary cell wall is capable of:", "o": ["Growth", "Secretion only", "Reproduction", "Nothing"], "a": "Growth"},
    {"id": 1655, "q": "Ribosomes are attached to the ER by their:", "o": ["Larger subunit (60S)", "Smaller subunit (40S)", "Both subunits", "RNA strand"], "a": "Larger subunit (60S)"}, # (Extra Deep)
    {"id": 1656, "q": "Tonoplast is:", "o": ["Differentially permeable", "Impermeable", "Freely permeable", "Dead"], "a": "Differentially permeable"},
    {"id": 1657, "q": "Contractile vacuole in Amoeba helps in:", "o": ["Excretion", "Digestion", "Reproduction", "Respiration"], "a": "Excretion"},
    {"id": 1658, "q": "Eukaryotic ribosomes are 80S. 'S' stands for:", "o": ["Svedberg Unit (Sedimentation coefficient)", "Size", "Surface area", "Synthesis rate"], "a": "Svedberg Unit (Sedimentation coefficient)"},
    {"id": 1659, "q": "Identify the non-membrane bound organelles:", "o": ["Ribosomes, Centrioles, Nucleolus", "Lysosomes, Vacuoles", "ER, Golgi", "Mitochondria, Chloroplast"], "a": "Ribosomes, Centrioles, Nucleolus"},
    {"id": 1660, "q": "The diameter of B-DNA helix is:", "o": ["20 Angstrom (2 nm)", "34 Angstrom", "10 Angstrom", "3.4 Angstrom"], "a": "20 Angstrom (2 nm)"}, # (Link to Biomolecules)
    {"id": 1661, "q": "How many base pairs are present in one turn of the helix?", "o": ["10", "12", "20", "5"], "a": "10"}, # (Link to Biomolecules)
    {"id": 1662, "q": "Carotenoids are:", "o": ["Fat soluble pigments", "Water soluble pigments", "Proteins", "Carbohydrates"], "a": "Fat soluble pigments"},
    {"id": 1663, "q": "Anthocyanins (giving purple color) are:", "o": ["Water soluble pigments stored in vacuoles", "Fat soluble pigments", "Found in chloroplasts", "Proteins"], "a": "Water soluble pigments stored in vacuoles"}, # (Rank Booster)
    {"id": 1664, "q": "Microbodies include:", "o": ["Peroxisomes and Glyoxysomes", "Lysosomes", "Ribosomes", "Centrioles"], "a": "Peroxisomes and Glyoxysomes"},
    {"id": 1665, "q": "Peroxisomes are involved in:", "o": ["Photorespiration and lipid metabolism", "ATP synthesis", "Protein packaging", "DNA synthesis"], "a": "Photorespiration and lipid metabolism"},
    # --- DEEP DIVE: NUCLEUS & CHROMOSOMES ---
    {"id": 1583, "q": "The interphase nucleus has highly extended and elaborate nucleoprotein fibres called:", "o": ["Chromatin", "Chromosome", "Centromere", "Aster"], "a": "Chromatin"},
    {"id": 1584, "q": "The perinuclear space (space between two nuclear membranes) is about:", "o": ["10 to 50 nm", "100 to 200 nm", "1 to 2 nm", "0.1 to 0.5 microns"], "a": "10 to 50 nm"},
    {"id": 1585, "q": "The nuclear matrix or nucleoplasm contains:", "o": ["Nucleolus and Chromatin", "Only DNA", "Ribosomes only", "Mitochondria"], "a": "Nucleolus and Chromatin"},
    {"id": 1586, "q": "Is the Nucleolus membrane-bound?", "o": ["No, it is non-membrane bound", "Yes, single membrane", "Yes, double membrane", "Yes, triple membrane"], "a": "No, it is non-membrane bound"},
    {"id": 1587, "q": "Why is the content of the nucleolus continuous with the rest of the nucleoplasm?", "o": ["Because it lacks a membrane", "Because of nuclear pores", "Because it is liquid", "Because of active transport"], "a": "Because it lacks a membrane"},
    {"id": 1588, "q": "Larger and more numerous nucleoli are present in cells actively carrying out:", "o": ["Protein synthesis", "Lipid synthesis", "Photosynthesis", "Division"], "a": "Protein synthesis"},
    {"id": 1589, "q": "Non-histone Chromosomal (NHC) proteins act as:", "o": ["Packaging proteins for higher level packaging", "Enzymes", "Structural support only", "Pigments"], "a": "Packaging proteins for higher level packaging"},
    {"id": 1590, "q": "A single human cell has approximately how much DNA thread distributed among its 46 chromosomes?", "o": ["2 meters", "1 meter", "2 centimeters", "2 millimeters"], "a": "2 meters"},
    {"id": 1591, "q": "Sometimes a few chromosomes have non-staining secondary constrictions at a constant location. This gives the appearance of a small fragment called:", "o": ["Satellite", "Telomere", "Kinetochore", "Centromere"], "a": "Satellite"},
    {"id": 1592, "q": "Kinetochores are:", "o": ["Disc-shaped structures on sides of centromere", "The ends of chromosomes", "The primary constriction", "Secondary constriction"], "a": "Disc-shaped structures on sides of centromere"},

    # --- DEEP DIVE: CYTOSKELETON & CENTRIOLES ---
    {"id": 1593, "q": "The central part of the proximal region of the centriole is called the ______ which is connected with tubules of the peripheral triplets by radial spokes.", "o": ["Hub", "Axoneme", "Basal plate", "Hook"], "a": "Hub"},
    {"id": 1594, "q": "The radial spokes in centrioles are made of:", "o": ["Protein", "Lipid", "DNA", "Carbohydrate"], "a": "Protein"},
    {"id": 1595, "q": "Cilia and Flagella work like:", "o": ["Oars (causing movement of cell or fluid)", "Propellers", "Suction pumps", "Anchors"], "a": "Oars (causing movement of cell or fluid)"},
    {"id": 1596, "q": "The peripheral doublets in cilia/flagella are interconnected by:", "o": ["Linkers", "Radial spokes", "Central sheath", "Plasma membrane"], "a": "Linkers"},

    # --- DEEP DIVE: CELL WALL & MEMBRANE ---
    {"id": 1597, "q": "In the Fluid Mosaic Model, the quasi-fluid nature of lipid enables lateral movement of proteins. This ability to move is measured as:", "o": ["Fluidity", "Permeability", "Transport", "Osmosis"], "a": "Fluidity"},
    {"id": 1598, "q": "One of the most important functions of the plasma membrane is:", "o": ["Transport of molecules", "Protein synthesis", "DNA storage", "Energy production"], "a": "Transport of molecules"},
    {"id": 1599, "q": "Algae cell wall is made of:", "o": ["Cellulose, Galactans, Mannans, Minerals", "Cellulose, Hemicellulose, Pectins", "Chitin", "Peptidoglycan"], "a": "Cellulose, Galactans, Mannans, Minerals"},
    {"id": 1600, "q": "Plant cell wall is made of:", "o": ["Cellulose, Hemicellulose, Pectins, Proteins", "Cellulose only", "Chitin", "Galactans"], "a": "Cellulose, Hemicellulose, Pectins, Proteins"},
    {"id": 1601, "q": "The primary wall of a plant cell gradually diminishes as the cell matures and the ______ is formed on the inner side.", "o": ["Secondary wall", "Tertiary wall", "Middle lamella", "Plasmodesmata"], "a": "Secondary wall"},

    # --- DEEP DIVE: PROKARYOTES ---
    {"id": 1602, "q": "Which of the following bacteria are likely to have Gas Vacuoles?", "o": ["Blue green and Purple/Green photosynthetic bacteria", "All bacteria", "Pathogenic bacteria", "Mycoplasma"], "a": "Blue green and Purple/Green photosynthetic bacteria"},
    {"id": 1603, "q": "Polyribosomes (Polysomes) translate mRNA into:", "o": ["Proteins", "DNA", "rRNA", "Lipids"], "a": "Proteins"},
    {"id": 1604, "q": "Resistance to antibiotics in bacteria is conferred by:", "o": ["Plasmid DNA", "Genomic DNA", "Mesosomes", "Ribosomes"], "a": "Plasmid DNA"},
    {"id": 1605, "q": "The term 'Glycocalyx' refers to:", "o": ["The outermost layer of the cell envelope", "The cell wall", "The plasma membrane", "The mesosome"], "a": "The outermost layer of the cell envelope"},
    {"id": 1606, "q": "Pili and Fimbriae play a role in:", "o": ["Attachment (not motility)", "Motility", "Reproduction only", "Respiration"], "a": "Attachment (not motility)"},

    # --- SCIENTIFIC YEARS & DATA (MATCHING) ---
    {"id": 1607, "q": "Year of discovery: Nucleus by Robert Brown?", "o": ["1831", "1855", "1972", "1953"], "a": "1831"},
    {"id": 1608, "q": "Year of proposal: Cell Theory by Schleiden and Schwann?", "o": ["1838-1839", "1855", "1900", "1665"], "a": "1838-1839"},
    {"id": 1609, "q": "Year: 'Omnis cellula-e cellula' by Rudolf Virchow?", "o": ["1855", "1838", "1953", "1898"], "a": "1855"},
    {"id": 1610, "q": "Year: Ribosome observation by George Palade?", "o": ["1953", "1831", "1855", "1972"], "a": "1953"},
    {"id": 1611, "q": "Year: Fluid Mosaic Model by Singer and Nicolson?", "o": ["1972", "1953", "1839", "1855"], "a": "1972"},
    {"id": 1612, "q": "Year: Golgi body observation by Camillo Golgi?", "o": ["1898", "1953", "1831", "1972"], "a": "1898"},

    # --- ADVANCED LOGIC & EXCEPTIONS ---
    {"id": 1613, "q": "The arrangement of axonemal microtubules in cilia is referred to as:", "o": ["9 + 2", "9 + 0", "9 + 1", "8 + 2"], "a": "9 + 2"},
    {"id": 1614, "q": "The arrangement of microtubules in centrioles is:", "o": ["9 + 0", "9 + 2", "9 + 1", "8 + 0"], "a": "9 + 0"},
    {"id": 1615, "q": "Mitochondria divide by fission, but chloroplasts?", "o": ["Also divide by fission (similar to bacteria)", "Budding", "Fusion", "De novo synthesis"], "a": "Also divide by fission (similar to bacteria)"},
    {"id": 1616, "q": "Which organelle is responsible for the formation of the acrosome in sperm?", "o": ["Golgi apparatus", "Lysosome", "ER", "Mitochondria"], "a": "Golgi apparatus"},
    {"id": 1617, "q": "Steroidal hormones are synthesized in animal cells by:", "o": ["Smooth Endoplasmic Reticulum (SER)", "Rough Endoplasmic Reticulum (RER)", "Golgi", "Mitochondria"], "a": "Smooth Endoplasmic Reticulum (SER)"},
    {"id": 1618, "q": "A number of proteins synthesized by ribosomes on the ER are modified in the ______ of the Golgi apparatus before they are released.", "o": ["Cisternae", "Tubules", "Vesicles", "Lumen"], "a": "Cisternae"},
    {"id": 1619, "q": "The cis and trans faces of the Golgi apparatus are:", "o": ["Entirely different but interconnected", "Identical and disconnected", "Identical and interconnected", "Different and disconnected"], "a": "Entirely different but interconnected"},
    {"id": 1620, "q": "Lysosomes are capable of digesting:", "o": ["Carbohydrates, Proteins, Lipids and Nucleic acids", "Only Proteins", "Only Fats", "Only Starch"], "a": "Carbohydrates, Proteins, Lipids and Nucleic acids"},
    {"id": 1621, "q": "Vacuoles in plants facilitate transport of ions:", "o": ["Against concentration gradient", "Along concentration gradient", "By simple diffusion", "By osmosis only"], "a": "Against concentration gradient"},
    {"id": 1622, "q": "Which of the following is true for the outer membrane of mitochondria?", "o": ["It is continuous and permeable", "It forms cristae", "It has ATP synthase", "It is impermeable"], "a": "It is continuous and permeable"},
    {"id": 1623, "q": "The stroma of chloroplasts contains enzymes required for the synthesis of:", "o": ["Carbohydrates and Proteins", "Fats and Oils", "DNA only", "ATP only"], "a": "Carbohydrates and Proteins"},
    {"id": 1624, "q": "Ribosomes are composed of RNA and proteins and are:", "o": ["Not surrounded by any membrane", "Surrounded by single membrane", "Surrounded by double membrane", "Surrounded by triple membrane"], "a": "Not surrounded by any membrane"},
    {"id": 1625, "q": "The cytoskeleton is involved in:", "o": ["Mechanical support, motility, maintenance of shape", "Protein synthesis", "DNA replication", "Digestion"], "a": "Mechanical support, motility, maintenance of shape"},
    
    # --- PLANT VS ANIMAL CELLS ---
    {"id": 1547, "q": "Which of the following is present in animal cells but absent in plant cells?", "o": ["Centriole", "Plastids", "Large central vacuole", "Cell wall"], "a": "Centriole"},
    {"id": 1548, "q": "Which of the following is present in plant cells but absent in animal cells?", "o": ["Plastids and Cell Wall", "Mitochondria", "Ribosomes", "Nucleus"], "a": "Plastids and Cell Wall"},
    {"id": 1549, "q": "In plant cells, the large central vacuole facilitates:", "o": ["Turgidity and rigidity", "Movement", "Reproduction", "Protein synthesis"], "a": "Turgidity and rigidity"},
    {"id": 1550, "q": "The core of cilia and flagella is called:", "o": ["Axoneme", "Centrosome", "Basal body", "Microvilli"], "a": "Axoneme"},
    {"id": 1551, "q": "Plant cells lack centrioles but still form spindle fibres during division. This is called:", "o": ["Anastral mitosis", "Amphiastral mitosis", "Free nuclear division", "Amitosis"], "a": "Anastral mitosis"}, # (Deep concept)

    # --- CHROMOSOMES & GENETICS BASICS ---
    {"id": 1552, "q": "The primary constriction on a chromosome is called:", "o": ["Centromere", "Kinetochore", "Telomere", "Satellite"], "a": "Centromere"},
    {"id": 1553, "q": "Proteinaceous discs on the surface of the centromere where spindle fibres attach are:", "o": ["Kinetochores", "Satellites", "Chromomeres", "Telomeres"], "a": "Kinetochores"},
    {"id": 1554, "q": "A chromosome with the centromere at the extreme tip is:", "o": ["Telocentric", "Acrocentric", "Metacentric", "Sub-metacentric"], "a": "Telocentric"},
    {"id": 1555, "q": "Satellite DNA is associated with:", "o": ["Secondary constriction", "Primary constriction", "Telomere", "Kinetochore"], "a": "Secondary constriction"},
    {"id": 1556, "q": "Chromosomes are best studied during:", "o": ["Metaphase", "Interphase", "Telophase", "Anaphase"], "a": "Metaphase"},
    {"id": 1557, "q": "The terminal ends of chromosomes that prevent fusion are called:", "o": ["Telomeres", "Centromeres", "Satellites", "Chromomeres"], "a": "Telomeres"},

    # --- SCIENTISTS & DISCOVERIES (REVISION) ---
    {"id": 1558, "q": "Who proposed the 'Fluid Mosaic Model'?", "o": ["Singer and Nicolson", "Schleiden and Schwann", "Watson and Crick", "Robert Brown"], "a": "Singer and Nicolson"},
    {"id": 1559, "q": "Who discovered the Nucleus?", "o": ["Robert Brown", "Robert Hooke", "Camillo Golgi", "Flemming"], "a": "Robert Brown"},
    {"id": 1560, "q": "Who first explained that cells divide and new cells are formed from pre-existing cells?", "o": ["Rudolf Virchow", "Schleiden", "Schwann", "Hooke"], "a": "Rudolf Virchow"},
    {"id": 1561, "q": "Golgi bodies were first observed by:", "o": ["Camillo Golgi", "George Palade", "Robert Brown", "Singer"], "a": "Camillo Golgi"},
    {"id": 1562, "q": "Ribosomes were discovered by:", "o": ["George Palade", "Camillo Golgi", "Robert Brown", "Schwann"], "a": "George Palade"},

    # --- STATEMENT BASED / TRICKY MATCHING ---
    {"id": 1563, "q": "Which of the following is NOT part of the Endomembrane system?", "o": ["Peroxisome", "Lysosome", "Vacuole", "Golgi complex"], "a": "Peroxisome"},
    {"id": 1564, "q": "Identify the MISMATCHED pair:", "o": ["Lysosome - Protein synthesis", "Ribosome - Protein synthesis", "Mitochondria - Respiration", "Chloroplast - Photosynthesis"], "a": "Lysosome - Protein synthesis"},
    {"id": 1565, "q": "Select the correct statement regarding Mitochondria:", "o": ["Inner membrane forms cristae", "Outer membrane forms cristae", "Matrix contains 80S ribosomes", "It is single membrane bound"], "a": "Inner membrane forms cristae"},
    {"id": 1566, "q": "Which organelle is non-membrane bound?", "o": ["Ribosome and Centriole", "Lysosome", "Vacuole", "ER"], "a": "Ribosome and Centriole"},
    {"id": 1567, "q": "The arrangement of microtubules in Cilia/Flagella is ______ and in Centrioles is ______.", "o": ["9+2 ; 9+0", "9+0 ; 9+2", "9+2 ; 9+2", "9+0 ; 9+0"], "a": "9+2 ; 9+0"},
    {"id": 1568, "q": "Select the correct path of protein transport:", "o": ["RER -> Golgi (Cis) -> Golgi (Trans) -> Vesicles", "Golgi -> RER -> Lysosome", "SER -> Golgi -> Nucleus", "Ribosome -> Nucleus -> Golgi"], "a": "RER -> Golgi (Cis) -> Golgi (Trans) -> Vesicles"},
    {"id": 1569, "q": "Hydrolytic enzymes of lysosomes function at:", "o": ["Acidic pH", "Basic pH", "Neutral pH", "High temperature"], "a": "Acidic pH"},
    {"id": 1570, "q": "Acrosome of sperm is derived from:", "o": ["Golgi apparatus", "ER", "Lysosome", "Mitochondria"], "a": "Golgi apparatus"}, # (Applied Biology)
    {"id": 1571, "q": "Middle piece of sperm contains:", "o": ["Mitochondria", "Golgi", "Nucleus", "Ribosomes"], "a": "Mitochondria"}, # (Applied Biology)

    # --- CYTOSKELETON & MICROBODIES ---
    {"id": 1572, "q": "The structural protein of Microtubules is:", "o": ["Tubulin", "Actin", "Myosin", "Flagellin"], "a": "Tubulin"},
    {"id": 1573, "q": "The structural protein of Microfilaments is:", "o": ["Actin", "Tubulin", "Keratin", "Dynein"], "a": "Actin"},
    {"id": 1574, "q": "Peroxisomes are involved in:", "o": ["Photorespiration and lipid metabolism", "ATP synthesis", "Protein synthesis", "DNA replication"], "a": "Photorespiration and lipid metabolism"},
    {"id": 1575, "q": "Which organelle helps in synthesis of Steroidal Hormones in animal cells?", "o": ["SER (Smooth ER)", "RER", "Golgi", "Mitochondria"], "a": "SER (Smooth ER)"},

    # --- FINAL WRAP UP ---
    {"id": 1576, "q": "70S ribosomes are found in:", "o": ["Prokaryotes, Mitochondria and Chloroplasts", "Only Prokaryotes", "Eukaryotic cytoplasm", "Nucleus"], "a": "Prokaryotes, Mitochondria and Chloroplasts"},
    {"id": 1577, "q": "Polyribosomes (Polysomes) are strings of ribosomes attached to:", "o": ["mRNA", "rRNA", "tRNA", "DNA"], "a": "mRNA"},
    {"id": 1578, "q": "The main arena of various types of cellular activities is:", "o": ["Cytoplasm", "Nucleus", "Plasma membrane", "Mitochondria"], "a": "Cytoplasm"},
    {"id": 1579, "q": "Glycocalyx in bacteria can be a loose sheath called ______ or a thick layer called ______.", "o": ["Slime layer; Capsule", "Capsule; Slime layer", "Cell wall; Membrane", "Capsule; Wall"], "a": "Slime layer; Capsule"},
    {"id": 1580, "q": "Bacterial flagella are made of:", "o": ["Flagellin protein", "Tubulin", "Actin", "Chitin"], "a": "Flagellin protein"},
    {"id": 1581, "q": "Which of the following contains its own DNA?", "o": ["Mitochondria and Chloroplast", "Lysosome and Vacuole", "Golgi and ER", "Ribosome"], "a": "Mitochondria and Chloroplast"},
    {"id": 1582, "q": "The barrier between the cytoplasm and the nucleus is:", "o": ["Nuclear envelope", "Plasma membrane", "Tonoplast", "Cell wall"], "a": "Nuclear envelope"},
    
    # --- MITOCHONDRIA (POWERHOUSE) ---
    {"id": 1481, "q": "Mitochondria are not easily visible under the microscope unless:", "o": ["Stained", "Heated", "Frozen", "Dried"], "a": "Stained"},
    {"id": 1482, "q": "The typical shape of mitochondria is:", "o": ["Sausage-shaped or cylindrical", "Spherical", "Disc-shaped", "Irregular"], "a": "Sausage-shaped or cylindrical"},
    {"id": 1483, "q": "Mitochondria is a double membrane-bound structure. The inner compartment is called:", "o": ["Matrix", "Stroma", "Cristae", "Lumen"], "a": "Matrix"},
    {"id": 1484, "q": "The inner membrane forms a number of infoldings towards the matrix called:", "o": ["Cristae", "Cisternae", "Thylakoids", "Tubules"], "a": "Cristae"},
    {"id": 1485, "q": "The function of Cristae is to:", "o": ["Increase surface area", "Decrease surface area", "Protect DNA", "Store food"], "a": "Increase surface area"},
    {"id": 1486, "q": "Mitochondria are the sites of:", "o": ["Aerobic respiration", "Anaerobic respiration", "Photosynthesis", "Digestion"], "a": "Aerobic respiration"},
    {"id": 1487, "q": "Mitochondria are called 'Powerhouses' because they produce:", "o": ["Cellular energy in the form of ATP", "Glucose", "Protein", "DNA"], "a": "Cellular energy in the form of ATP"},
    {"id": 1488, "q": "The matrix of mitochondria possesses:", "o": ["Single circular DNA, RNA, 70S ribosomes", "Linear DNA, 80S ribosomes", "No DNA", "Only enzymes"], "a": "Single circular DNA, RNA, 70S ribosomes"},
    {"id": 1489, "q": "Mitochondria divide by:", "o": ["Fission", "Mitosis", "Budding", "Fusion"], "a": "Fission"},

    # --- PLASTIDS (CHLOROPLASTS & OTHERS) ---
    {"id": 1490, "q": "Plastids are found in:", "o": ["All plant cells and euglenoides", "Animals and plants", "Fungi and plants", "Bacteria"], "a": "All plant cells and euglenoides"},
    {"id": 1491, "q": "Based on the type of pigments, plastids can be classified into:", "o": ["Chloroplasts, Chromoplasts, Leucoplasts", "Chloroplasts and Mitochondria", "Amyloplasts only", "Elaioplasts only"], "a": "Chloroplasts, Chromoplasts, Leucoplasts"},
    {"id": 1492, "q": "Chloroplasts contain chlorophyll and carotenoid pigments responsible for:", "o": ["Trapping light energy for photosynthesis", "Storing starch", "Giving color to flowers", "Respiration"], "a": "Trapping light energy for photosynthesis"},
    {"id": 1493, "q": "Chromoplasts contain fat-soluble carotenoid pigments like:", "o": ["Carotene, Xanthophylls", "Chlorophyll", "Hemoglobin", "Melanin"], "a": "Carotene, Xanthophylls"},
    {"id": 1494, "q": "Leucoplasts are:", "o": ["Colorless plastids of varied shapes storing nutrients", "Green plastids", "Red plastids", "Blue plastids"], "a": "Colorless plastids of varied shapes storing nutrients"},
    {"id": 1495, "q": "Amyloplasts store:", "o": ["Carbohydrates (Starch)", "Oils and Fats", "Proteins", "Water"], "a": "Carbohydrates (Starch)"},
    {"id": 1496, "q": "Elaioplasts store:", "o": ["Oils and Fats", "Starch", "Proteins", "Vitamins"], "a": "Oils and Fats"},
    {"id": 1497, "q": "Aleuroplasts store:", "o": ["Proteins", "Starch", "Fats", "Sugar"], "a": "Proteins"},
    {"id": 1498, "q": "Chloroplasts are double membrane bound. The inner membrane is:", "o": ["Relatively less permeable", "More permeable", "Absent", "Thicker"], "a": "Relatively less permeable"},
    {"id": 1499, "q": "The space limited by the inner membrane of the chloroplast is called:", "o": ["Stroma", "Matrix", "Lumen", "Cristae"], "a": "Stroma"},
    {"id": 1500, "q": "Flattened membranous sacs present in the stroma are called:", "o": ["Thylakoids", "Cristae", "Cisternae", "Tubules"], "a": "Thylakoids"},
    {"id": 1501, "q": "Thylakoids are arranged in stacks called:", "o": ["Grana", "Stroma", "Matrix", "Lamellae"], "a": "Grana"},
    {"id": 1502, "q": "Flat membranous tubules connecting the thylakoids of different grana are:", "o": ["Stroma lamellae", "Cristae", "Tubules", "Middle lamella"], "a": "Stroma lamellae"},
    {"id": 1503, "q": "The membrane of the thylakoid encloses a space called:", "o": ["Lumen", "Matrix", "Stroma", "Pore"], "a": "Lumen"},
    {"id": 1504, "q": "The stroma of chloroplast contains enzymes required for synthesis of:", "o": ["Carbohydrates and proteins", "Lipids only", "ATP only", "DNA only"], "a": "Carbohydrates and proteins"},
    {"id": 1505, "q": "Chloroplasts contain:", "o": ["Small double-stranded circular DNA and ribosomes", "Linear DNA", "No DNA", "80S ribosomes"], "a": "Small double-stranded circular DNA and ribosomes"},
    {"id": 1506, "q": "Ribosomes of chloroplasts are:", "o": ["70S (smaller)", "80S (larger)", "50S", "60S"], "a": "70S (smaller)"},
    {"id": 1507, "q": "Cytoplasmic ribosomes are:", "o": ["80S", "70S", "50S", "30S"], "a": "80S"},

    # --- RIBOSOMES & CYTOSKELETON ---
    {"id": 1508, "q": "Ribosomes were first observed by:", "o": ["George Palade (1953)", "Robert Brown", "Camillo Golgi", "Singer"], "a": "George Palade (1953)"},
    {"id": 1509, "q": "Ribosomes are composed of:", "o": ["RNA and proteins", "DNA and proteins", "Lipids and proteins", "Carbohydrates and RNA"], "a": "RNA and proteins"},
    {"id": 1510, "q": "Are ribosomes surrounded by a membrane?", "o": ["No, they are non-membrane bound", "Yes, single membrane", "Yes, double membrane", "Sometimes"], "a": "No, they are non-membrane bound"},
    {"id": 1511, "q": "In 80S ribosomes, 'S' stands for:", "o": ["Svedberg's unit (Sedimentation coefficient)", "Size", "Shape", "Synthesis"], "a": "Svedberg's unit (Sedimentation coefficient)"},
    {"id": 1512, "q": "Svedberg's unit is indirectly a measure of:", "o": ["Density and Size", "Volume", "Weight only", "Length"], "a": "Density and Size"},
    {"id": 1513, "q": "The 80S ribosome consists of subunits:", "o": ["60S and 40S", "50S and 30S", "60S and 30S", "50S and 40S"], "a": "60S and 40S"},
    {"id": 1514, "q": "An elaborate network of filamentous proteinaceous structures in the cytoplasm is called:", "o": ["Cytoskeleton", "Endomembrane system", "Cytoplasm", "Nucleoplasm"], "a": "Cytoskeleton"},
    {"id": 1515, "q": "Functions of cytoskeleton include:", "o": ["Mechanical support, motility, maintenance of shape", "Protein synthesis", "DNA replication", "ATP production"], "a": "Mechanical support, motility, maintenance of shape"},
    {"id": 1516, "q": "Cytoskeleton consists of:", "o": ["Microtubules, Microfilaments, Intermediate filaments", "ER and Golgi", "Cilia and Flagella", "Actin and Myosin only"], "a": "Microtubules, Microfilaments, Intermediate filaments"},

    # --- CILIA, FLAGELLA & CENTROSOME ---
    {"id": 1517, "q": "Cilia and Flagella are hair-like outgrowths of the:", "o": ["Cell membrane", "Cell wall", "Nuclear membrane", "ER"], "a": "Cell membrane"},
    {"id": 1518, "q": "Which structure causes movement of surrounding fluid or the cell itself?", "o": ["Cilia", "Microvilli", "Pili", "Fimbriae"], "a": "Cilia"},
    {"id": 1519, "q": "Compared to cilia, flagella are:", "o": ["Longer", "Shorter", "Same size", "Thicker"], "a": "Longer"},
    {"id": 1520, "q": "The core of the cilium/flagellum is called:", "o": ["Axoneme", "Centriole", "Basal body", "Hub"], "a": "Axoneme"},
    {"id": 1521, "q": "The Axoneme possesses a number of microtubules running parallel to the long axis in an arrangement of:", "o": ["9 + 2", "9 + 0", "9 + 1", "8 + 2"], "a": "9 + 2"},
    {"id": 1522, "q": "The 9+2 arrangement means:", "o": ["9 doublets of radial microtubules and one central pair", "9 singlets and 2 central", "9 central and 2 radial", "9 triplets and 2 central"], "a": "9 doublets of radial microtubules and one central pair"},
    {"id": 1523, "q": "The central tubules are connected by bridges and enclosed by a:", "o": ["Central sheath", "Plasma membrane", "Nuclear envelope", "Capsule"], "a": "Central sheath"},
    {"id": 1524, "q": "Both cilium and flagellum emerge from a centriole-like structure called:", "o": ["Basal body", "Centrosome", "Axoneme", "Kinetochore"], "a": "Basal body"},
    {"id": 1525, "q": "Centrosome is an organelle usually containing two cylindrical structures called:", "o": ["Centrioles", "Chromatids", "Centromeres", "Arms"], "a": "Centrioles"},
    {"id": 1526, "q": "The two centrioles in a centrosome lie:", "o": ["Perpendicular to each other", "Parallel to each other", "Randomly", "End to end"], "a": "Perpendicular to each other"},
    {"id": 1527, "q": "Centrioles have an organization like the:", "o": ["Cartwheel", "Ladder", "Spiral", "Star"], "a": "Cartwheel"},
    {"id": 1528, "q": "Centrioles are made up of nine evenly spaced peripheral fibrils of:", "o": ["Tubulin protein", "Actin", "Myosin", "Flagellin"], "a": "Tubulin protein"},
    {"id": 1529, "q": "The arrangement of microtubules in Centrioles is:", "o": ["9 + 0", "9 + 2", "9 + 1", "8 + 2"], "a": "9 + 0"},
    {"id": 1530, "q": "The central part of the proximal region of the centriole is proteinaceous and called the:", "o": ["Hub", "Axoneme", "Spoke", "Core"], "a": "Hub"},
    {"id": 1531, "q": "Centrioles form the:", "o": ["Basal body of cilia/flagella and Spindle fibres", "Nucleolus", "Cell plate", "Ribosomes"], "a": "Basal body of cilia/flagella and Spindle fibres"},

    # --- NUCLEUS & CHROMOSOMES ---
    {"id": 1532, "q": "Nucleus was first described by:", "o": ["Robert Brown (1831)", "Flemming", "Hooke", "Virchow"], "a": "Robert Brown (1831)"},
    {"id": 1533, "q": "The material of the nucleus stained by basic dyes was given the name 'Chromatin' by:", "o": ["Flemming", "Brown", "Schleiden", "Strasburger"], "a": "Flemming"},
    {"id": 1534, "q": "The space between the two nuclear membranes is called:", "o": ["Perinuclear space", "Intermembrane space", "Matrix", "Lumen"], "a": "Perinuclear space"},
    {"id": 1535, "q": "Nuclear pores are passages through which movement of ______ takes place.", "o": ["RNA and protein molecules", "DNA only", "Lipids", "Ribosomes only"], "a": "RNA and protein molecules"},
    {"id": 1536, "q": "Cells that lack a nucleus (Erythrocytes of mammals) are:", "o": ["Living but cannot divide", "Dead", "Able to divide", "Prokaryotic"], "a": "Living but cannot divide"},
    {"id": 1537, "q": "Nucleolus is a site for active synthesis of:", "o": ["Ribosomal RNA (rRNA)", "mRNA", "tRNA", "DNA"], "a": "Ribosomal RNA (rRNA)"},
    {"id": 1538, "q": "Chromatin contains:", "o": ["DNA, Histones, Non-histone proteins and RNA", "Only DNA", "DNA and Lipids", "DNA and Histones only"], "a": "DNA, Histones, Non-histone proteins and RNA"},
    {"id": 1539, "q": "Every chromosome essentially has a primary constriction called the:", "o": ["Centromere", "Telomere", "Satellite", "Kinetochore"], "a": "Centromere"},
    {"id": 1540, "q": "Disc shaped structures present on the sides of the centromere are called:", "o": ["Kinetochores", "Satellites", "Chromatids", "Arms"], "a": "Kinetochores"},
    {"id": 1541, "q": "Metacentric chromosome has:", "o": ["Middle centromere forming two equal arms", "Sub-terminal centromere", "Terminal centromere", "No centromere"], "a": "Middle centromere forming two equal arms"},
    {"id": 1542, "q": "Sub-metacentric chromosome has:", "o": ["Centromere slightly away from middle (one shorter, one longer arm)", "Middle centromere", "Terminal centromere", "Centromere at tip"], "a": "Centromere slightly away from middle (one shorter, one longer arm)"},
    {"id": 1543, "q": "Acrocentric chromosome has:", "o": ["Centromere close to end (one extremely short, one very long arm)", "Middle centromere", "Terminal centromere", "Equal arms"], "a": "Centromere close to end (one extremely short, one very long arm)"},
    {"id": 1544, "q": "Telocentric chromosome has:", "o": ["Terminal centromere", "Middle centromere", "No centromere", "Two centromeres"], "a": "Terminal centromere"},
    {"id": 1545, "q": "A small fragment appearing due to a secondary constriction on a chromosome is called:", "o": ["Satellite", "Kinetochore", "Telomere", "Centromere"], "a": "Satellite"},
    {"id": 1546, "q": "Microbodies are:", "o": ["Membrane bound minute vesicles containing enzymes", "Non-membrane bound", "Part of nucleus", "Ribosomes"], "a": "Membrane bound minute vesicles containing enzymes"},

    # --- CELL THEORY & OVERVIEW ---
    {"id": 1401, "q": "Who first saw and described a live cell?", "o": ["Robert Hooke", "Anton Von Leeuwenhoek", "Robert Brown", "Schleiden"], "a": "Anton Von Leeuwenhoek"},
    {"id": 1402, "q": "Robert Brown discovered the:", "o": ["Cell", "Nucleus", "Cell wall", "Mitochondria"], "a": "Nucleus"},
    {"id": 1403, "q": "Matthias Schleiden was a:", "o": ["German Botanist", "British Zoologist", "German Zoologist", "British Botanist"], "a": "German Botanist"},
    {"id": 1404, "q": "The presence of a cell wall is a unique character of plant cells. This was concluded by:", "o": ["Schleiden", "Schwann", "Virchow", "Hooke"], "a": "Schwann"},
    {"id": 1405, "q": "Who modified the cell theory by adding 'Omnis cellula-e cellula'?", "o": ["Rudolf Virchow", "Schleiden", "Schwann", "Robert Brown"], "a": "Rudolf Virchow"},
    {"id": 1406, "q": "'Omnis cellula-e cellula' means:", "o": ["All cells die", "All cells arise from pre-existing cells", "Cells are the basic unit", "Cells contain DNA"], "a": "All cells arise from pre-existing cells"},
    {"id": 1407, "q": "The largest isolated single cell is the egg of an:", "o": ["Ostrich", "Hen", "Duck", "Human"], "a": "Ostrich"},
    {"id": 1408, "q": "Which of the following is the longest cell in the human body?", "o": ["RBC", "Nerve cell", "Muscle cell", "WBC"], "a": "Nerve cell"},
    {"id": 1409, "q": "Mycoplasma, the smallest cells, are only ______ in length.", "o": ["0.3 Âµm", "3 Âµm", "0.1 Âµm", "10 Âµm"], "a": "0.3 Âµm"},
    {"id": 1410, "q": "Bacteria could be ______ in length.", "o": ["3 to 5 Âµm", "0.3 to 0.5 Âµm", "10 to 20 Âµm", "100 Âµm"], "a": "3 to 5 Âµm"},
    {"id": 1411, "q": "Human RBCs are about ______ in diameter.", "o": ["7.0 Âµm", "0.7 Âµm", "70 Âµm", "0.07 Âµm"], "a": "7.0 Âµm"},
    {"id": 1412, "q": "The shape of RBCs is generally:", "o": ["Round and biconcave", "Amoeboid", "Long and narrow", "Branched"], "a": "Round and biconcave"},
    {"id": 1413, "q": "The genomic DNA in prokaryotes is:", "o": ["Circular, single chromosome", "Linear, multiple chromosomes", "Circular, multiple chromosomes", "Linear, single chromosome"], "a": "Circular, single chromosome"},
    {"id": 1414, "q": "Many bacteria have small circular DNA outside the genomic DNA called:", "o": ["Plasmids", "Mesosomes", "Ribosomes", "Inclusion bodies"], "a": "Plasmids"},
    {"id": 1415, "q": "Plasmids confer unique phenotypic characters such as:", "o": ["Resistance to antibiotics", "Color", "Size", "Motility"], "a": "Resistance to antibiotics"},

    # --- PROKARYOTIC CELL ENVELOPE ---
    {"id": 1416, "q": "The cell envelope of bacteria consists of a tightly bound three-layered structure. The order from outer to inner is:", "o": ["Glycocalyx -> Cell wall -> Plasma membrane", "Cell wall -> Glycocalyx -> Plasma membrane", "Plasma membrane -> Cell wall -> Glycocalyx", "Glycocalyx -> Plasma membrane -> Cell wall"], "a": "Glycocalyx -> Cell wall -> Plasma membrane"},
    {"id": 1417, "q": "Bacteria are classified into Gram positive and Gram negative based on:", "o": [" Differences in cell envelopes and response to Gram staining", "Shape only", "Size only", "Reproduction"], "a": " Differences in cell envelopes and response to Gram staining"},
    {"id": 1418, "q": "If the Glycocalyx is loose sheath, it is called ______; if it is thick and tough, it is called ______.", "o": ["Slime layer; Capsule", "Capsule; Slime layer", "Cell wall; Capsule", "Slime layer; Cell wall"], "a": "Slime layer; Capsule"},
    {"id": 1419, "q": "The bacterial cell wall is made of:", "o": ["Peptidoglycan", "Cellulose", "Chitin", "Lipids only"], "a": "Peptidoglycan"},
    {"id": 1420, "q": "Which structure in prokaryotes is structurally similar to that of eukaryotes?", "o": ["Plasma membrane", "Ribosomes", "Cell wall", "Nuclear membrane"], "a": "Plasma membrane"},
    {"id": 1421, "q": "A special membranous structure formed by the extensions of plasma membrane into the cell is:", "o": ["Mesosome", "Ribosome", "Polysome", "Plasmid"], "a": "Mesosome"},
    {"id": 1422, "q": "Mesosomes can be in the form of:", "o": ["Vesicles, tubules and lamellae", "Cilia and flagella", "Pili and fimbriae", "Ribosomes"], "a": "Vesicles, tubules and lamellae"},
    {"id": 1423, "q": "Functions of Mesosomes include:", "o": ["Cell wall formation, DNA replication, respiration, secretion", "Protein synthesis only", "Photosynthesis only", "Motility"], "a": "Cell wall formation, DNA replication, respiration, secretion"},
    {"id": 1424, "q": "In Cyanobacteria, membranous extensions into the cytoplasm containing pigments are called:", "o": ["Chromatophores", "Mesosomes", "Chloroplasts", "Leucoplasts"], "a": "Chromatophores"},
    {"id": 1425, "q": "Bacterial flagellum is composed of three parts:", "o": ["Filament, Hook, Basal body", "Cilia, Hook, Basal body", "Filament, Tubule, Hook", "Head, Neck, Tail"], "a": "Filament, Hook, Basal body"},
    {"id": 1426, "q": "The longest portion of the bacterial flagellum is:", "o": ["Filament", "Hook", "Basal body", "Pilus"], "a": "Filament"},
    {"id": 1427, "q": "Pili are:", "o": ["Elongated tubular structures made of special protein", "Small bristle like fibers", "Whip like structures", "Infoldings of membrane"], "a": "Elongated tubular structures made of special protein"},
    {"id": 1428, "q": "Fimbriae are small bristle-like fibers that help in:", "o": ["Attaching bacteria to rocks/hosts", "Motility", "DNA transfer", "Respiration"], "a": "Attaching bacteria to rocks/hosts"},
    
    # --- PROKARYOTIC RIBOSOMES & INCLUSIONS ---
    {"id": 1429, "q": "In prokaryotes, ribosomes are associated with the:", "o": ["Plasma membrane", "Nucleus", "Cell wall", "Golgi"], "a": "Plasma membrane"},
    {"id": 1430, "q": "The size of prokaryotic ribosomes is:", "o": ["15 nm by 20 nm", "50 nm by 80 nm", "0.1 micron", "100 nm"], "a": "15 nm by 20 nm"},
    {"id": 1431, "q": "Prokaryotic ribosomes are 70S, made of two subunits:", "o": ["50S and 30S", "60S and 40S", "50S and 40S", "40S and 30S"], "a": "50S and 30S"},
    {"id": 1432, "q": "Several ribosomes attach to a single mRNA chain to form a:", "o": ["Polyribosome or Polysome", "Polypeptide", "Polymer", "Inclusion body"], "a": "Polyribosome or Polysome"},
    {"id": 1433, "q": "The function of polysomes is to translate:", "o": ["mRNA into proteins", "DNA into RNA", "Proteins into RNA", "Lipids into proteins"], "a": "mRNA into proteins"},
    {"id": 1434, "q": "Reserve material in prokaryotic cells is stored as:", "o": ["Inclusion bodies", "Vacuoles", "Lysosomes", "Golgi"], "a": "Inclusion bodies"},
    {"id": 1435, "q": "Inclusion bodies are:", "o": ["Not bound by any membrane and lie free in cytoplasm", "Bound by single membrane", "Bound by double membrane", "Attached to plasma membrane"], "a": "Not bound by any membrane and lie free in cytoplasm"},
    {"id": 1436, "q": "Examples of inclusion bodies include:", "o": ["Phosphate granules, Cyanophycean granules, Glycogen granules", "Ribosomes, Lysosomes", "Vacuoles, Plastids", "DNA, RNA"], "a": "Phosphate granules, Cyanophycean granules, Glycogen granules"},
    {"id": 1437, "q": "Gas vacuoles are found in:", "o": ["Blue-green and purple/green photosynthetic bacteria", "All bacteria", "Mycoplasma", "Fungi"], "a": "Blue-green and purple/green photosynthetic bacteria"},

    # --- EUKARYOTIC CELL MEMBRANE ---
    {"id": 1438, "q": "The detailed structure of the membrane was studied only after the advent of the:", "o": ["Electron microscope in 1950s", "Light microscope", "Phase contrast microscope", "X-ray crystallography"], "a": "Electron microscope in 1950s"},
    {"id": 1439, "q": "Chemical studies on human RBCs show the membrane consists of:", "o": ["Lipids and Proteins", "Lipids and DNA", "Proteins and RNA", "Cellulose"], "a": "Lipids and Proteins"},
    {"id": 1440, "q": "The major lipids in cell membrane are:", "o": ["Phospholipids", "Glycolipids", "Sterols", "Fatty acids"], "a": "Phospholipids"},
    {"id": 1441, "q": "Lipids are arranged in a:", "o": ["Bilayer", "Monolayer", "Trilayer", "Random manner"], "a": "Bilayer"},
    {"id": 1442, "q": "The lipid molecules are arranged with:", "o": ["Polar heads towards outer sides and hydrophobic tails towards inner part", "Hydrophobic heads outer, polar tails inner", "Random arrangement", "Heads and tails mixed"], "a": "Polar heads towards outer sides and hydrophobic tails towards inner part"},
    {"id": 1443, "q": "The membrane of human RBC has approximately:", "o": ["52% protein and 40% lipid", "40% protein and 52% lipid", "50% protein and 50% lipid", "60% protein and 40% lipid"], "a": "52% protein and 40% lipid"},
    {"id": 1444, "q": "Integral proteins are:", "o": ["Partially or totally buried in the membrane", "Lie on the surface", "Loosely attached", "Absent in animals"], "a": "Partially or totally buried in the membrane"},
    {"id": 1445, "q": "Peripheral proteins lie:", "o": ["On the surface of the membrane", "Buried inside", "In the nucleus", "In the cytoplasm"], "a": "On the surface of the membrane"},
    {"id": 1446, "q": "The Fluid Mosaic Model was proposed by:", "o": ["Singer and Nicolson (1972)", "Schleiden and Schwann", "Robert Brown", "Camillo Golgi"], "a": "Singer and Nicolson (1972)"},
    {"id": 1447, "q": "The 'fluid' nature of the membrane is mainly due to:", "o": ["Lipids", "Proteins", "Carbohydrates", "Water"], "a": "Lipids"},
    {"id": 1448, "q": "The quasi-fluid nature of lipids enables lateral movement of:", "o": ["Proteins within the bilayer", "DNA", "Ribosomes", "Cell wall"], "a": "Proteins within the bilayer"},
    {"id": 1449, "q": "Fluidity of membrane is important for:", "o": ["Cell growth, secretion, endocytosis, cell division", "Protection only", "Rigidity", "Color"], "a": "Cell growth, secretion, endocytosis, cell division"},
    {"id": 1450, "q": "Movement of water across the membrane by diffusion is called:", "o": ["Osmosis", "Active transport", "Endocytosis", "Pinocytosis"], "a": "Osmosis"},
    {"id": 1451, "q": "Na+/K+ pump is an example of:", "o": ["Active transport", "Passive transport", "Osmosis", "Facilitated diffusion"], "a": "Active transport"},
    {"id": 1452, "q": "Active transport requires energy in the form of:", "o": ["ATP", "GTP", "Sunlight", "Heat"], "a": "ATP"},

    # --- CELL WALL ---
    {"id": 1453, "q": "Cell wall is a non-living rigid structure present in:", "o": ["Fungi and Plants", "Animals only", "Mycoplasma", "Animals and Plants"], "a": "Fungi and Plants"},
    {"id": 1454, "q": "Algae have a cell wall made of:", "o": ["Cellulose, Galactans, Mannans and Minerals (CaCO3)", "Cellulose, Hemicellulose, Pectins", "Chitin", "Peptidoglycan"], "a": "Cellulose, Galactans, Mannans and Minerals (CaCO3)"},
    {"id": 1455, "q": "In higher plants, the cell wall consists of:", "o": ["Cellulose, Hemicellulose, Pectins and Proteins", "Galactans and Mannans", "Chitin", "Peptidoglycan"], "a": "Cellulose, Hemicellulose, Pectins and Proteins"},
    {"id": 1456, "q": "The Primary wall of a young plant cell is:", "o": ["Capable of growth", "Rigid and dead", "Impermeable", "Absent"], "a": "Capable of growth"},
    {"id": 1457, "q": "The Secondary wall is formed on the:", "o": ["Inner side (towards membrane) of the cell", "Outer side of the cell", "Middle of the wall", "Outside cuticle"], "a": "Inner side (towards membrane) of the cell"},
    {"id": 1458, "q": "Middle lamella is a layer mainly composed of:", "o": ["Calcium pectate", "Magnesium chloride", "Cellulose", "Lignin"], "a": "Calcium pectate"},
    {"id": 1459, "q": "Middle lamella performs the function of:", "o": ["Holding different neighboring cells together", "Photosynthesis", "Respiration", "Protection"], "a": "Holding different neighboring cells together"},
    {"id": 1460, "q": "Plasmodesmata connect the:", "o": ["Cytoplasm of neighboring cells", "Nuclei of cells", "Vacuoles", "Mitochondria"], "a": "Cytoplasm of neighboring cells"},

    # --- ENDOMEMBRANE SYSTEM (ER & GOLGI) ---
    {"id": 1461, "q": "The endomembrane system includes:", "o": ["ER, Golgi complex, Lysosomes and Vacuoles", "Mitochondria, Chloroplast, Peroxisomes", "Nucleus, ER, Ribosomes", "All organelles"], "a": "ER, Golgi complex, Lysosomes and Vacuoles"},
    {"id": 1462, "q": "Mitochondria and Peroxisomes are NOT part of the endomembrane system because:", "o": ["Their functions are not coordinated with the others", "They are double membrane bound", "They have DNA", "They are larger"], "a": "Their functions are not coordinated with the others"},
    {"id": 1463, "q": "Endoplasmic Reticulum divides the intracellular space into two compartments:", "o": ["Luminal (inside ER) and Extra-luminal (cytoplasm)", "Outer and Inner", "Matrix and Stroma", "Cis and Trans"], "a": "Luminal (inside ER) and Extra-luminal (cytoplasm)"},
    {"id": 1464, "q": "RER (Rough Endoplasmic Reticulum) has:", "o": ["Ribosomes on its surface", "No ribosomes", "Mesosomes", "Pili"], "a": "Ribosomes on its surface"},
    {"id": 1465, "q": "RER is frequently observed in cells actively involved in:", "o": ["Protein synthesis and secretion", "Lipid synthesis", "Steroid synthesis", "Digestion"], "a": "Protein synthesis and secretion"},
    {"id": 1466, "q": "SER (Smooth Endoplasmic Reticulum) is the major site for synthesis of:", "o": ["Lipids", "Proteins", "RNA", "DNA"], "a": "Lipids"},
    {"id": 1467, "q": "In animal cells, lipid-like steroidal hormones are synthesized in:", "o": ["SER", "RER", "Golgi", "Lysosomes"], "a": "SER"},
    {"id": 1468, "q": "Camillo Golgi observed densely stained reticular structures near the:", "o": ["Nucleus", "Plasma membrane", "Mitochondria", "Ribosome"], "a": "Nucleus"},
    {"id": 1469, "q": "Golgi cisternae are concentrically arranged with two faces:", "o": ["Convex Cis (forming) and Concave Trans (maturing)", "Concave Cis and Convex Trans", "Flat Cis and Round Trans", "Both Convex"], "a": "Convex Cis (forming) and Concave Trans (maturing)"},
    {"id": 1470, "q": "The main function of Golgi apparatus is:", "o": ["Packaging materials for delivery", "Protein synthesis", "DNA replication", "ATP production"], "a": "Packaging materials for delivery"},
    {"id": 1471, "q": "Proteins synthesized by ribosomes on ER are modified in the:", "o": ["Cisternae of Golgi apparatus", "Lysosomes", "Vacuoles", "Nucleus"], "a": "Cisternae of Golgi apparatus"},
    {"id": 1472, "q": "Golgi apparatus is the important site of formation of:", "o": ["Glycoproteins and Glycolipids", "Proteins and DNA", "Starch and Fat", "RNA and Ribosomes"], "a": "Glycoproteins and Glycolipids"},
    
    # --- LYSOSOMES & VACUOLES ---
    {"id": 1473, "q": "Lysosomes are membrane-bound vesicular structures formed by the process of packaging in:", "o": ["Golgi apparatus", "ER", "Nucleus", "Mitochondria"], "a": "Golgi apparatus"},
    {"id": 1474, "q": "Lysosomal vesicles are very rich in:", "o": ["Hydrolytic enzymes (Hydrolases)", "Oxidizing enzymes", "Synthesizing enzymes", "Hormones"], "a": "Hydrolytic enzymes (Hydrolases)"},
    {"id": 1475, "q": "Lysosomal enzymes (Lipases, Proteases, Carbohydrases) are optimally active at:", "o": ["Acidic pH", "Basic pH", "Neutral pH", "High temperature"], "a": "Acidic pH"},
    {"id": 1476, "q": "The vacuole is bound by a single membrane called:", "o": ["Tonoplast", "Plasmalemma", "Cell wall", "Capsule"], "a": "Tonoplast"},
    {"id": 1477, "q": "In plant cells, the vacuole can occupy up to ______ of the volume of the cell.", "o": ["90%", "50%", "20%", "10%"], "a": "90%"},
    {"id": 1478, "q": "The tonoplast facilitates the transport of ions:", "o": ["Against the concentration gradient into the vacuole", "Along the gradient", "Into the cytoplasm", "Out of the cell"], "a": "Against the concentration gradient into the vacuole"},
    {"id": 1479, "q": "In Amoeba, the contractile vacuole is important for:", "o": ["Osmoregulation and excretion", "Digestion", "Reproduction", "Movement"], "a": "Osmoregulation and excretion"},
    {"id": 1480, "q": "In Protists, food vacuoles are formed by:", "o": ["Engulfing the food particles", "Secreting food", "Photosynthesis", "Chemosynthesis"], "a": "Engulfing the food particles"},
    
    # --- TISSUES: DEEP DIVE ---
    {"id": 1338, "q": "Which cells in loose connective tissue secrete fibres?", "o": ["Fibroblasts", "Macrophages", "Mast cells", "Adipocytes"], "a": "Fibroblasts"},
    {"id": 1339, "q": "Mast cells in areolar tissue secrete:", "o": ["Histamine, Serotonin and Heparin", "Collagen only", "Antibodies", "Insulin"], "a": "Histamine, Serotonin and Heparin"},
    {"id": 1340, "q": "Macrophages function as:", "o": ["Phagocytic cells (eaters)", "Secretory cells", "Storage cells", "Structural support"], "a": "Phagocytic cells (eaters)"},
    {"id": 1341, "q": "The ground substance of connective tissue is made up of:", "o": ["Modified polysaccharides", "Lipids", "Nucleic acids", "Simple sugars"], "a": "Modified polysaccharides"},
    {"id": 1342, "q": "Dense regular connective tissue is found in:", "o": ["Tendons and Ligaments", "Skin", "Blood", "Bone marrow"], "a": "Tendons and Ligaments"},
    {"id": 1343, "q": "Which tissue lacks blood vessels (Avascular)?", "o": ["Epithelial tissue", "Connective tissue", "Muscular tissue", "Neural tissue"], "a": "Epithelial tissue"},
    {"id": 1344, "q": "Transitional epithelium (Urothelium) is found in:", "o": ["Urinary bladder and Ureters", "Skin", "Stomach", "Trachea"], "a": "Urinary bladder and Ureters"},
    {"id": 1345, "q": "The inner lining of ducts of salivary glands and pancreatic ducts is made of:", "o": ["Compound epithelium", "Simple squamous", "Ciliated columnar", "Glandular"], "a": "Compound epithelium"},
    {"id": 1346, "q": "Identify the incorrect pair:", "o": ["Salivary gland - Endocrine", "Goblet cell - Unicellular gland", "Blood - Fluid connective tissue", "Cartilage - Specialized connective tissue"], "a": "Salivary gland - Endocrine"},
    {"id": 1347, "q": "Which muscle tissue shows 'Branching'?", "o": ["Cardiac muscle", "Skeletal muscle", "Smooth muscle", "All of these"], "a": "Cardiac muscle"},
    {"id": 1348, "q": "Which muscle tissue is 'Fusiform' (tapering at ends)?", "o": ["Smooth muscle", "Skeletal muscle", "Cardiac muscle", "Striated muscle"], "a": "Smooth muscle"},
    {"id": 1349, "q": "Neuroglia make up how much of the neural tissue volume?", "o": ["More than one-half", "Less than 10%", "Exactly 20%", "90%"], "a": "More than one-half"},
    {"id": 1350, "q": "Canaliculi are found in:", "o": ["Bone", "Cartilage", "Blood", "Muscle"], "a": "Bone"},
    {"id": 1351, "q": "The mineral matter in bone is mainly:", "o": ["Calcium phosphate", "Sodium chloride", "Magnesium carbonate", "Iron"], "a": "Calcium phosphate"},

    # --- COCKROACH: SPECIFICS ---
    {"id": 1352, "q": "In male cockroach, the genital pouch contains:", "o": ["Dorsal anus, ventral male genital pore and gonapophysis", "Only anus", "Spermatheca", "Ovaries"], "a": "Dorsal anus, ventral male genital pore and gonapophysis"},
    {"id": 1353, "q": "In female cockroach, the brood pouch is formed by:", "o": ["7th, 8th and 9th sternites", "7th sternite only", "8th and 9th tergites", "6th sternite"], "a": "7th, 8th and 9th sternites"},
    {"id": 1354, "q": "Spermatheca in female cockroach is present in:", "o": ["6th segment", "4th segment", "9th segment", "3rd segment"], "a": "6th segment"},
    {"id": 1355, "q": "Collaterial glands are present in:", "o": ["Female cockroach", "Male cockroach", "Both", "Nymphs"], "a": "Female cockroach"},
    {"id": 1356, "q": "The function of Collaterial glands is:", "o": ["Formation of ootheca case", "Digestion", "Excretion", "Attracting males"], "a": "Formation of ootheca case"},
    {"id": 1357, "q": "A female cockroach produces on average ______ oothecae, each containing ______ eggs.", "o": ["9-10; 14-16", "1-2; 50", "20; 5", "5-6; 10-12"], "a": "9-10; 14-16"},
    {"id": 1358, "q": "Titillator and Pseudopenis are parts of:", "o": ["External genitalia of male cockroach (Phallomere)", "Female brood pouch", "Mouth parts", "Legs"], "a": "External genitalia of male cockroach (Phallomere)"},
    {"id": 1359, "q": "Spiracles in cockroach are arranged as:", "o": ["2 pairs thoracic, 8 pairs abdominal", "10 pairs thoracic", "2 pairs abdominal, 8 pairs thoracic", "5 pairs each"], "a": "2 pairs thoracic, 8 pairs abdominal"},
    {"id": 1360, "q": "Exchange of gases is regulated by:", "o": ["Sphincters", "Valves", "Operculum", "Cilia"], "a": "Sphincters"},
    {"id": 1361, "q": "Alary muscles are associated with:", "o": ["Heart circulation", "Respiration", "Digestion", "Leg movement"], "a": "Heart circulation"},
    {"id": 1362, "q": "How many pairs of Alary muscles are present?", "o": ["12 pairs", "10 pairs", "13 pairs", "6 pairs"], "a": "12 pairs"},
    {"id": 1363, "q": "The chitinous teeth in Gizzard are used for:", "o": ["Crushing the food", "Storing food", "Mixing enzymes", "Tasting food"], "a": "Crushing the food"},
    {"id": 1364, "q": "Antennae have sensory receptors that help in:", "o": ["Monitoring the environment", "Flying", "Eating", "Breathing"], "a": "Monitoring the environment"},
    {"id": 1365, "q": "Which leg part is the longest?", "o": ["Tibia", "Coxa", "Trochanter", "Femur"], "a": "Tibia"},

    # --- FROG: SYSTEM SPECIFICS ---
    {"id": 1366, "q": "Bidder's canal is found in:", "o": ["Kidney of male frog", "Kidney of female frog", "Liver of frog", "Testes of cockroach"], "a": "Kidney of male frog"},
    {"id": 1367, "q": "Function of Bidder's canal is to transport:", "o": ["Sperms", "Urine only", "Blood", "Lymph"], "a": "Sperms"},
    {"id": 1368, "q": "Vasa efferentia arise from testes and enter the kidney of their side. They open into:", "o": ["Bidder's canal", "Ureter", "Cloaca", "Rectum"], "a": "Bidder's canal"},
    {"id": 1369, "q": "Which portal system is present in Frog?", "o": ["Both Hepatic and Renal portal systems", "Only Hepatic", "Only Renal", "Hypophyseal portal system only"], "a": "Both Hepatic and Renal portal systems"},
    {"id": 1370, "q": "In Frog's heart, the Sinus Venosus receives deoxygenated blood from:", "o": ["Vena cava", "Pulmonary vein", "Aorta", "Ventricle"], "a": "Vena cava"},
    {"id": 1371, "q": "The walls of the ventricle are ______ than the auricles.", "o": ["Thicker", "Thinner", "Same thickness", "Absent"], "a": "Thicker"},
    {"id": 1372, "q": "The skull of frog is:", "o": ["Dicondylic", "Monocondylic", "Tricondylic", "Polycondylic"], "a": "Dicondylic"},
    {"id": 1373, "q": "How many vertebrae are present in a frog?", "o": ["10", "33", "26", "9"], "a": "10"}, # Actually 9+Urostyle, often cited as 10 total elements or 9 vertebrae. NCERT says "Vertebral column is short...". Basic knowledge: 9 vertebrae + Urostyle.
    {"id": 1374, "q": "The 9th vertebra in frog is called:", "o": ["Sacral vertebra", "Atlas", "Axis", "Urostyle"], "a": "Sacral vertebra"},
    {"id": 1375, "q": "The last unsegmented bone in the vertebral column of frog is:", "o": ["Urostyle", "Sacrum", "Coccyx", "Sternum"], "a": "Urostyle"},
    {"id": 1376, "q": "In frog, the thyroid gland produces:", "o": ["Thyroxine", "Insulin", "Adrenaline", "Growth hormone"], "a": "Thyroxine"},
    {"id": 1377, "q": "Thyroxine is essential for:", "o": ["Metamorphosis of tadpole", "Digestion", "Respiration", "Circulation"], "a": "Metamorphosis of tadpole"},
    {"id": 1378, "q": "If thyroid gland is removed from a tadpole, it will:", "o": ["Remain a tadpole forever (Neoteny)", "Die immediately", "Grow into a giant frog", "Become a female"], "a": "Remain a tadpole forever (Neoteny)"},
    {"id": 1379, "q": "Optic lobes in frog are located in:", "o": ["Midbrain", "Forebrain", "Hindbrain", "Spinal cord"], "a": "Midbrain"},
    {"id": 1380, "q": "Ventricles of the brain are filled with:", "o": ["Cerebrospinal fluid (CSF)", "Blood", "Lymph", "Water"], "a": "Cerebrospinal fluid (CSF)"},
    {"id": 1381, "q": "Sensory papillae in frogs are found in:", "o": ["Touch and Taste organs", "Eyes", "Ears", "Nose"], "a": "Touch and Taste organs"},
    {"id": 1382, "q": "The nictitating membrane in frog protects the eye:", "o": ["While in water", "From bright light", "During sleep", "From dust on land"], "a": "While in water"},
    {"id": 1383, "q": "Ear of frog acts as:", "o": ["Hearing and Balancing organ", "Only hearing", "Only balancing", "Respiration"], "a": "Hearing and Balancing organ"},
    {"id": 1384, "q": "The jelly coat around frog eggs helps in:", "o": ["Protection and holding eggs together", "Fertilization", "Respiration", "Digestion"], "a": "Protection and holding eggs together"},
    {"id": 1385, "q": "Which hormone allows the frog to change color?", "o": ["MSH (Melanocyte Stimulating Hormone)", "TSH", "ACTH", "ADH"], "a": "MSH (Melanocyte Stimulating Hormone)"},

    # --- FINAL STATEMENT CHECK ---
    {"id": 1386, "q": "Statement: In cockroach, blood vessels are poorly developed and open into haemocoel.", "o": ["True", "False", "Partially true", "Only in males"], "a": "True"},
    {"id": 1387, "q": "Statement: Frogs do not drink water but absorb it through the skin.", "o": ["True", "False", "They drink only in summer", "They drink via mouth"], "a": "True"},
    
    # --- FROG MORPHOLOGY ---
    {"id": 1289, "q": "The most common species of frog found in India is:", "o": ["Rana tigrina", "Rana pipiens", "Bufo melanostictus", "Hyla"], "a": "Rana tigrina"},
    {"id": 1290, "q": "Frogs are Poikilotherms, which means:", "o": ["Cold blooded (Body temp varies with environment)", "Warm blooded", "Constant body temp", "They live in ice"], "a": "Cold blooded (Body temp varies with environment)"},
    {"id": 1291, "q": "Ability to change color to hide from enemies is called:", "o": ["Camouflage (Mimicry)", "Metagenesis", "Hibernation", "Aestivation"], "a": "Camouflage (Mimicry)"},
    {"id": 1292, "q": "Summer sleep is called ______ and Winter sleep is called ______.", "o": ["Aestivation, Hibernation", "Hibernation, Aestivation", "Migration, Suspension", "Diapause, Dormancy"], "a": "Aestivation, Hibernation"},
    {"id": 1293, "q": "The skin of frog is smooth and slippery due to:", "o": ["Mucus", "Scales", "Oil", "Sweat"], "a": "Mucus"},
    {"id": 1294, "q": "Does the skin of frog usually absorb water?", "o": ["Yes", "No, it drinks water", "Only in winter", "Never"], "a": "Yes"},
    {"id": 1295, "q": "The body of frog is divisible into:", "o": ["Head and Trunk", "Head, Neck and Trunk", "Head, Thorax, Abdomen", "Head and Tail"], "a": "Head and Trunk"},
    {"id": 1296, "q": "In frogs, a neck and tail are:", "o": ["Absent", "Present", "Present only in larva", "Present only in males"], "a": "Absent"},
    {"id": 1297, "q": "Membranous ______ receives sound signals in frogs.", "o": ["Tympanum", "Pinna", "Cochlea", "Operculum"], "a": "Tympanum"},
    {"id": 1298, "q": "Forelimbs end in ______ digits and Hindlimbs end in ______ digits.", "o": ["4, 5", "5, 5", "5, 4", "4, 4"], "a": "4, 5"},
    {"id": 1299, "q": "The feet of frogs have webbed digits which help in:", "o": ["Swimming", "Digging", "Jumping", "Holding prey"], "a": "Swimming"},
    {"id": 1300, "q": "Frogs exhibit sexual dimorphism. Males can be distinguished by:", "o": ["Sound producing vocal sacs and copulatory pad", "Larger size", "Brighter color", "Longer legs"], "a": "Sound producing vocal sacs and copulatory pad"},
    {"id": 1301, "q": "Copulatory pad in male frogs is present on the:", "o": ["First digit of forelimbs", "Second digit of forelimbs", "Hind limbs", "Thorax"], "a": "First digit of forelimbs"},

    # --- FROG ANATOMY (DIGESTIVE & RESPIRATORY) ---
    {"id": 1302, "q": "The alimentary canal of frog is short because:", "o": ["Frogs are carnivores", "Frogs are herbivores", "They don't eat much", "They lack a stomach"], "a": "Frogs are carnivores"},
    {"id": 1303, "q": "The tongue of a frog is:", "o": ["Bilobed", "Trilobed", "Pointed", "Absent"], "a": "Bilobed"},
    {"id": 1304, "q": "Food is captured by the:", "o": ["Bilobed tongue", "Teeth", "Forelimbs", "Lips"], "a": "Bilobed tongue"},
    {"id": 1305, "q": "Digestion of food takes place by the action of:", "o": ["HCl and gastric juices", "Only saliva", "Bile only", "Water"], "a": "HCl and gastric juices"},
    {"id": 1306, "q": "Partially digested food called Chyme passes from stomach to:", "o": ["Duodenum", "Ileum", "Rectum", "Cloaca"], "a": "Duodenum"},
    {"id": 1307, "q": "The duodenum receives bile from gall bladder and pancreatic juice from pancreas through a common duct called:", "o": ["Hepato-pancreatic duct", "Bile duct", "Pancreatic duct", "Cystic duct"], "a": "Hepato-pancreatic duct"},
    {"id": 1308, "q": "Bile emulsifies ______ and pancreatic juice digests ______.", "o": ["Fats; Carbohydrates and proteins", "Proteins; Fats", "Carbohydrates; Fats", "Fats; Fats"], "a": "Fats; Carbohydrates and proteins"},
    {"id": 1309, "q": "Digested food is absorbed by the numerous finger-like folds in the inner wall of intestine called:", "o": ["Villi and Microvilli", "Rugae", "Cilia", "Flagella"], "a": "Villi and Microvilli"},
    {"id": 1310, "q": "The common chamber for digestive, excretory and reproductive tracts is:", "o": ["Cloaca", "Anus", "Rectum", "Urethra"], "a": "Cloaca"},
    {"id": 1311, "q": "In water, skin acts as an aquatic respiratory organ. This is called:", "o": ["Cutaneous respiration", "Pulmonary respiration", "Buccal respiration", "Branchial respiration"], "a": "Cutaneous respiration"},
    {"id": 1312, "q": "Respiration on land occurs via:", "o": ["Buccal cavity, skin and lungs", "Gills", "Skin only", "Lungs only"], "a": "Buccal cavity, skin and lungs"},
    {"id": 1313, "q": "Respiration by lungs is called:", "o": ["Pulmonary respiration", "Cutaneous respiration", "Branchial respiration", "Tracheal respiration"], "a": "Pulmonary respiration"},
    {"id": 1314, "q": "During aestivation and hibernation, gaseous exchange takes place through:", "o": ["Skin", "Lungs", "Buccal cavity", "Gills"], "a": "Skin"},

    # --- FROG CIRCULATORY & EXCRETORY SYSTEM ---
    {"id": 1315, "q": "The vascular system of frog is:", "o": ["Closed type", "Open type", "Absent", "Like cockroach"], "a": "Closed type"},
    {"id": 1316, "q": "Frogs have a lymphatic system consisting of:", "o": ["Lymph, lymph channels and lymph nodes", "Blood and heart", "Only lymph", "Closed vessels"], "a": "Lymph, lymph channels and lymph nodes"},
    {"id": 1317, "q": "The heart of a frog is:", "o": ["3 chambered (2 atria, 1 ventricle)", "4 chambered", "2 chambered", "1 chambered"], "a": "3 chambered (2 atria, 1 ventricle)"},
    {"id": 1318, "q": "A triangular structure called ______ joins the right atrium.", "o": ["Sinus venosus", "Truncus arteriosus", "Vena cava", "Aorta"], "a": "Sinus venosus"},
    {"id": 1319, "q": "The ventricle opens into a sac-like structure on the ventral side called:", "o": ["Conus arteriosus", "Sinus venosus", "Aorta", "Vena cava"], "a": "Conus arteriosus"},
    {"id": 1320, "q": "Special venous connection between liver and intestine is called:", "o": ["Hepatic portal system", "Renal portal system", "Pulmonary system", "Cardiac system"], "a": "Hepatic portal system"},
    {"id": 1321, "q": "Special venous connection between kidney and lower parts of body is called:", "o": ["Renal portal system", "Hepatic portal system", "Lymphatic system", "Systemic arch"], "a": "Renal portal system"},
    {"id": 1322, "q": "RBCs in frogs are:", "o": ["Nucleated and oval", "Enucleated and biconcave", "Circular", "Irregular"], "a": "Nucleated and oval"},
    {"id": 1323, "q": "The excretory system consists of:", "o": ["A pair of kidneys, ureters, cloaca and urinary bladder", "Malpighian tubules", "Nephridia", "Flame cells"], "a": "A pair of kidneys, ureters, cloaca and urinary bladder"},
    {"id": 1324, "q": "The frog excretes ______ and is a ______ animal.", "o": ["Urea, Ureotelic", "Uric acid, Uricotelic", "Ammonia, Ammonotelic", "Guanine, Guanotelic"], "a": "Urea, Ureotelic"},
    {"id": 1325, "q": "In male frogs, the ureters act as:", "o": ["Urinogenital duct", "Only urinary duct", "Only sperm duct", "Hepatic duct"], "a": "Urinogenital duct"},
    {"id": 1326, "q": "In female frogs, the ureters and oviduct open:", "o": ["Separately into the cloaca", "Together into cloaca", "Into the bladder", "Into the uterus"], "a": "Separately into the cloaca"},

    # --- FROG NERVOUS & REPRODUCTIVE SYSTEM ---
    {"id": 1327, "q": "The brain is divided into forebrain, midbrain and hindbrain. The midbrain is characterized by:", "o": ["A pair of optic lobes", "Olfactory lobes", "Cerebellum", "Medulla"], "a": "A pair of optic lobes"},
    {"id": 1328, "q": "Hind brain consists of:", "o": ["Cerebellum and Medulla oblongata", "Cerebrum", "Optic lobes", "Olfactory lobes"], "a": "Cerebellum and Medulla oblongata"},
    {"id": 1329, "q": "Medulla oblongata passes out through the foramen magnum and continues into the:", "o": ["Spinal cord", "Vertebral column", "Brain stem", "Nerves"], "a": "Spinal cord"},
    {"id": 1330, "q": "How many pairs of cranial nerves are present in frog?", "o": ["10 pairs", "12 pairs", "8 pairs", "20 pairs"], "a": "10 pairs"},
    {"id": 1331, "q": "Male reproductive organs consist of a pair of yellowish ovoid testes adhered to the:", "o": ["Upper part of kidneys", "Liver", "Intestine", "Lungs"], "a": "Upper part of kidneys"},
    {"id": 1332, "q": "Vasa efferentia (10-12 in number) enter the kidneys and open into:", "o": ["Bidder's canal", "Ureter", "Cloaca", "Urinary bladder"], "a": "Bidder's canal"},
    {"id": 1333, "q": "A female frog can lay how many eggs at a time?", "o": ["2500 to 3000", "100 to 200", "1 to 2", "10,000"], "a": "2500 to 3000"},
    {"id": 1334, "q": "Fertilization in frogs is:", "o": ["External (in water)", "Internal", "In uterus", "In cloaca"], "a": "External (in water)"},
    {"id": 1335, "q": "Larval stage of frog is called:", "o": ["Tadpole", "Nymph", "Maggot", "Caterpillar"], "a": "Tadpole"},
    {"id": 1336, "q": "Tadpoles undergo ______ to form adults.", "o": ["Metamorphosis", "Moulting", "Growth", "Differentiation"], "a": "Metamorphosis"},
    {"id": 1337, "q": "Frogs are beneficial for mankind because they:", "o": ["Eat insects and protect crops", "Produce honey", "Provide wool", "Are pests"], "a": "Eat insects and protect crops"},
    
    # --- COCKROACH MORPHOLOGY ---
    {"id": 1246, "q": "The scientific name of the common cockroach is:", "o": ["Periplaneta americana", "Rana tigrina", "Pheretima posthuma", "Musca domestica"], "a": "Periplaneta americana"},
    {"id": 1247, "q": "The body of the cockroach is covered by a hard exoskeleton made of:", "o": ["Chitin", "Calcium", "Cellulose", "Keratin"], "a": "Chitin"},
    {"id": 1248, "q": "In each segment, the exoskeleton has hardened plates called:", "o": ["Sclerites", "Tergites", "Sternites", "Pleura"], "a": "Sclerites"},
    {"id": 1249, "q": "Dorsal sclerites are called ______ and ventral sclerites are called ______.", "o": ["Tergites, Sternites", "Sternites, Tergites", "Pleurites, Tergites", "Tergites, Pleurites"], "a": "Tergites, Sternites"},
    {"id": 1250, "q": "The head of the cockroach is triangular and formed by the fusion of:", "o": ["6 segments", "3 segments", "10 segments", "4 segments"], "a": "6 segments"},
    {"id": 1251, "q": "The head is connected to the thorax by a short extension of the prothorax known as:", "o": ["Neck", "Collar", "Isthmus", "Pedicel"], "a": "Neck"},
    {"id": 1252, "q": "The mouthparts of the cockroach are of:", "o": ["Biting and chewing type", "Piercing and sucking type", "Siphoning type", "Sponging type"], "a": "Biting and chewing type"},
    {"id": 1253, "q": "In cockroach mouthparts, Labrum is:", "o": ["Upper lip", "Lower lip", "Tongue", "Jaw"], "a": "Upper lip"},
    {"id": 1254, "q": "In cockroach mouthparts, Labium is:", "o": ["Lower lip", "Upper lip", "Tongue", "Mandible"], "a": "Lower lip"},
    {"id": 1255, "q": "The organ acting as a tongue in cockroach is:", "o": ["Hypopharynx", "Labrum", "Labium", "Maxilla"], "a": "Hypopharynx"},
    {"id": 1256, "q": "The thorax consists of three parts: Prothorax, Mesothorax and:", "o": ["Metathorax", "Cephalothorax", "Postthorax", "Telothorax"], "a": "Metathorax"},
    {"id": 1257, "q": "The first pair of wings (Tegmina) arises from:", "o": ["Mesothorax", "Prothorax", "Metathorax", "Abdomen"], "a": "Mesothorax"},
    {"id": 1258, "q": "Tegmina (forewings) are:", "o": ["Opaque, dark and leathery", "Transparent and membranous", "Used for flight", "Short"], "a": "Opaque, dark and leathery"},
    {"id": 1259, "q": "Hind wings arise from Metathorax and are:", "o": ["Transparent, membranous and used for flight", "Opaque and leathery", "Protective", "Absent"], "a": "Transparent, membranous and used for flight"},
    {"id": 1260, "q": "The abdomen in both males and females consists of:", "o": ["10 segments", "8 segments", "12 segments", "6 segments"], "a": "10 segments"},
    {"id": 1261, "q": "In females, the 7th sternite is boat-shaped and forms the:", "o": ["Brood or genital pouch", "Anal style", "Anal cercus", "Ootheca"], "a": "Brood or genital pouch"},
    {"id": 1262, "q": "Anal styles are present in:", "o": ["Males only", "Females only", "Both sexes", "Nymphs only"], "a": "Males only"},
    {"id": 1263, "q": "Anal cerci are present in:", "o": ["Both males and females", "Males only", "Females only", "Adults only"], "a": "Both males and females"},

    # --- COCKROACH ANATOMY ---
    {"id": 1264, "q": "The foregut of cockroach consists of mouth, pharynx, oesophagus, crop and:", "o": ["Gizzard", "Mesenteron", "Ileum", "Colon"], "a": "Gizzard"},
    {"id": 1265, "q": "Crop is used for:", "o": ["Storing food", "Grinding food", "Digesting food", "Absorbing food"], "a": "Storing food"},
    {"id": 1266, "q": "Gizzard (Proventriculus) has an outer layer of thick circular muscles and thick inner cuticle forming:", "o": ["Six chitinous plates (teeth)", "Four teeth", "Eight teeth", "No teeth"], "a": "Six chitinous plates (teeth)"},
    {"id": 1267, "q": "Hepatic or gastric caeca are present at the junction of foregut and midgut. They secrete:", "o": ["Digestive juice", "Excretory waste", "Hormones", "Saliva"], "a": "Digestive juice"},
    {"id": 1268, "q": "Malpighian tubules are present at the junction of:", "o": ["Midgut and Hindgut", "Foregut and Midgut", "Pharynx and Oesophagus", "Crop and Gizzard"], "a": "Midgut and Hindgut"},
    {"id": 1269, "q": "Malpighian tubules help in:", "o": ["Removal of excretory products", "Digestion", "Respiration", "Reproduction"], "a": "Removal of excretory products"},
    {"id": 1270, "q": "Blood vascular system of cockroach is:", "o": ["Open type", "Closed type", "Absent", "Double circulation"], "a": "Open type"},
    {"id": 1271, "q": "Visceral organs are located in the haemocoel and bathed in blood called:", "o": ["Haemolymph", "Plasma", "Lymph", "Serum"], "a": "Haemolymph"},
    {"id": 1272, "q": "The heart of cockroach consists of:", "o": ["13 chambers", "4 chambers", "2 chambers", "10 chambers"], "a": "13 chambers"},
    {"id": 1273, "q": "Blood enters the heart through openings called:", "o": ["Ostia", "Spiracles", "Valves", "Pores"], "a": "Ostia"},
    {"id": 1274, "q": "Respiratory system consists of a network of trachea that open through 10 pairs of:", "o": ["Spiracles", "Ostia", "Alveoli", "Gills"], "a": "Spiracles"},
    {"id": 1275, "q": "Exchange of gases takes place at the tracheoles by:", "o": ["Diffusion", "Active transport", "Osmosis", "Filtration"], "a": "Diffusion"},
    {"id": 1276, "q": "Cockroach is Uricotelic, meaning it excretes:", "o": ["Uric acid", "Urea", "Ammonia", "Guanine"], "a": "Uric acid"},
    {"id": 1277, "q": "In addition to Malpighian tubules, excretion is assisted by:", "o": ["Fat body, Nephrocytes and Urecose glands", "Liver", "Kidney", "Skin"], "a": "Fat body, Nephrocytes and Urecose glands"},
    {"id": 1278, "q": "The brain of cockroach is represented by:", "o": ["Supra-oesophageal ganglion", "Sub-oesophageal ganglion", "Ventral nerve cord", "Dorsal nerve cord"], "a": "Supra-oesophageal ganglion"},
    {"id": 1279, "q": "The compound eyes consist of about 2000 hexagonal:", "o": ["Ommatidia", "Ocelli", "Retina", "Lens"], "a": "Ommatidia"},
    {"id": 1280, "q": "Vision in cockroach is Mosaic vision, which has:", "o": ["More sensitivity but less resolution", "Less sensitivity and more resolution", "High resolution", "Monocular"], "a": "More sensitivity but less resolution"},
    {"id": 1281, "q": "Male reproductive system consists of a pair of testes in the:", "o": ["4th - 6th abdominal segments", "2nd - 6th segments", "6th - 7th segments", "8th - 9th segments"], "a": "4th - 6th abdominal segments"},
    {"id": 1282, "q": "Mushroom gland is a characteristic of:", "o": ["Male reproductive system (6th-7th segments)", "Female reproductive system", "Digestive system", "Excretory system"], "a": "Male reproductive system (6th-7th segments)"},
    {"id": 1283, "q": "Sperms are stored in the:", "o": ["Seminal vesicles", "Testes", "Vas deferens", "Ejaculatory duct"], "a": "Seminal vesicles"},
    {"id": 1284, "q": "Female reproductive system consists of two ovaries in the:", "o": ["2nd - 6th abdominal segments", "4th - 6th segments", "6th - 7th segments", "1st - 2nd segments"], "a": "2nd - 6th abdominal segments"},
    {"id": 1285, "q": "Fertilized eggs are encased in capsules called:", "o": ["Oothecae", "Cocoons", "Cysts", "Spores"], "a": "Oothecae"},
    {"id": 1286, "q": "Development of P. americana is Paurometabolous, meaning:", "o": ["Development through nymphal stage", "Direct development", "Complete metamorphosis", "Larval stage present"], "a": "Development through nymphal stage"},
    {"id": 1287, "q": "The nymph grows by moulting about:", "o": ["13 times", "5 times", "10 times", "2 times"], "a": "13 times"},
    {"id": 1288, "q": "The next to last nymphal stage has:", "o": ["Wing pads but only adult has wings", "Full wings", "No wings", "Functional wings"], "a": "Wing pads but only adult has wings"},
    
    # --- EPITHELIAL TISSUE ---
    {"id": 1201, "q": "The tissue which has a free surface facing either a body fluid or the outside environment is:", "o": ["Epithelial tissue", "Connective tissue", "Muscular tissue", "Neural tissue"], "a": "Epithelial tissue"},
    {"id": 1202, "q": "Cells are compactly packed with little intercellular matrix in:", "o": ["Epithelial tissue", "Connective tissue", "Areolar tissue", "Adipose tissue"], "a": "Epithelial tissue"},
    {"id": 1203, "q": "Squamous epithelium is found in:", "o": ["Walls of blood vessels and air sacs of lungs", "Ducts of glands", "Lining of stomach", "Skin"], "a": "Walls of blood vessels and air sacs of lungs"},
    {"id": 1204, "q": "The main function of Squamous epithelium is:", "o": ["Forming a diffusion boundary", "Secretion", "Absorption", "Protection"], "a": "Forming a diffusion boundary"},
    {"id": 1205, "q": "Cuboidal epithelium is commonly found in:", "o": ["Ducts of glands and tubular parts of nephrons", "Lining of intestine", "Skin surface", "Fallopian tubes"], "a": "Ducts of glands and tubular parts of nephrons"},
    {"id": 1206, "q": "The epithelium of Proximal Convoluted Tubule (PCT) of nephron has:", "o": ["Microvilli", "Cilia", "Flagella", "Goblet cells"], "a": "Microvilli"},
    {"id": 1207, "q": "Columnar epithelium is found in the lining of:", "o": ["Stomach and intestine", "Lung alveoli", "Blood vessels", "Kidney tubules"], "a": "Stomach and intestine"},
    {"id": 1208, "q": "If columnar or cuboidal cells bear cilia on their free surface, they are called:", "o": ["Ciliated epithelium", "Glandular epithelium", "Compound epithelium", "Squamous epithelium"], "a": "Ciliated epithelium"},
    {"id": 1209, "q": "The function of Ciliated epithelium is to move particles or mucus in a specific direction. It is found in:", "o": ["Bronchioles and Fallopian tubes", "Intestine", "Stomach", "Blood vessels"], "a": "Bronchioles and Fallopian tubes"},
    {"id": 1210, "q": "Goblet cells of the alimentary canal are modified:", "o": ["Columnar or cuboidal cells", "Squamous cells", "Connective tissue cells", "Neural cells"], "a": "Columnar or cuboidal cells"},
    {"id": 1211, "q": "Exocrine glands secrete:", "o": ["Mucus, saliva, earwax, oil, milk, digestive enzymes", "Hormones only", "Blood", "Lymph"], "a": "Mucus, saliva, earwax, oil, milk, digestive enzymes"},
    {"id": 1212, "q": "Endocrine glands do not have ducts. Their products are called:", "o": ["Hormones", "Enzymes", "Saliva", "Mucus"], "a": "Hormones"},
    {"id": 1213, "q": "Compound epithelium has a limited role in secretion and absorption. Its main function is:", "o": ["Protection against chemical and mechanical stresses", "Diffusion", "Filtration", "Gamete formation"], "a": "Protection against chemical and mechanical stresses"},
    {"id": 1214, "q": "Compound epithelium covers:", "o": ["Dry surface of skin, moist surface of buccal cavity, pharynx", "Lining of stomach", "Lining of alveoli", "PCT of nephron"], "a": "Dry surface of skin, moist surface of buccal cavity, pharynx"},
    {"id": 1215, "q": "Which junction helps to stop substances from leaking across a tissue?", "o": ["Tight junction", "Adhering junction", "Gap junction", "Synapse"], "a": "Tight junction"},
    {"id": 1216, "q": "Which junction performs cementing to keep neighboring cells together?", "o": ["Adhering junction", "Tight junction", "Gap junction", "Desmosomes"], "a": "Adhering junction"},
    {"id": 1217, "q": "Gap junctions facilitate the cells to communicate with each other by connecting the:", "o": ["Cytoplasm of adjoining cells", "Nucleus of adjoining cells", "Cell walls", "Mitochondria"], "a": "Cytoplasm of adjoining cells"},

    # --- CONNECTIVE TISSUE ---
    {"id": 1218, "q": "Which is the most abundant and widely distributed tissue in the body of complex animals?", "o": ["Connective tissue", "Epithelial tissue", "Muscular tissue", "Neural tissue"], "a": "Connective tissue"},
    {"id": 1219, "q": "In all connective tissues except blood, the cells secrete fibers of structural proteins called:", "o": ["Collagen or Elastin", "Actin or Myosin", "Fibrinogen", "Albumin"], "a": "Collagen or Elastin"},
    {"id": 1220, "q": "Areolar tissue is present:", "o": ["Beneath the skin", "Inside bones", "Inside heart", "Around brain"], "a": "Beneath the skin"},
    {"id": 1221, "q": "Areolar tissue serves as a:", "o": ["Support framework for epithelium", "Storage of fat", "Hard skeleton", "Fluid transport system"], "a": "Support framework for epithelium"},
    {"id": 1222, "q": "Adipose tissue is a modified:", "o": ["Loose connective tissue", "Dense connective tissue", "Epithelial tissue", "Specialized connective tissue"], "a": "Loose connective tissue"},
    {"id": 1223, "q": "The main function of Adipose tissue is:", "o": ["Storage of fats", "Production of blood", "Movement", "Secretion of hormones"], "a": "Storage of fats"},
    {"id": 1224, "q": "Tendons connect:", "o": ["Skeletal muscle to bone", "Bone to bone", "Muscle to muscle", "Skin to muscle"], "a": "Skeletal muscle to bone"},
    {"id": 1225, "q": "Ligaments connect:", "o": ["Bone to bone", "Muscle to bone", "Skin to bone", "Nerve to muscle"], "a": "Bone to bone"},
    {"id": 1226, "q": "Tendons and Ligaments are examples of:", "o": ["Dense regular connective tissue", "Dense irregular connective tissue", "Loose connective tissue", "Specialized connective tissue"], "a": "Dense regular connective tissue"},
    {"id": 1227, "q": "Dense irregular connective tissue is present in the:", "o": ["Skin", "Tendons", "Ligaments", "Blood"], "a": "Skin"},
    {"id": 1228, "q": "Cartilage cells are known as:", "o": ["Chondrocytes", "Osteocytes", "Fibroblasts", "Adipocytes"], "a": "Chondrocytes"},
    {"id": 1229, "q": "Cartilage is found in:", "o": ["Tip of nose, outer ear joints, between adjacent vertebrae", "Blood vessels", "Stomach lining", "Skin"], "a": "Tip of nose, outer ear joints, between adjacent vertebrae"},
    {"id": 1230, "q": "Bones have a hard and non-pliable ground substance rich in:", "o": ["Calcium salts and collagen fibers", "Magnesium and elastin", "Sodium and fibrin", "Potassium and reticulin"], "a": "Calcium salts and collagen fibers"},
    {"id": 1231, "q": "Bone cells are called:", "o": ["Osteocytes", "Chondrocytes", "Mast cells", "Macrophages"], "a": "Osteocytes"},
    {"id": 1232, "q": "Osteocytes are present in spaces called:", "o": ["Lacunae", "Lamellae", "Canaliculi", "Haversian canals"], "a": "Lacunae"},
    {"id": 1233, "q": "Which bones produce blood cells (Haemopoiesis)?", "o": ["Long bones (Bone marrow)", "Small bones", "Cartilage", "Skull bones"], "a": "Long bones (Bone marrow)"},
    {"id": 1234, "q": "Blood is a fluid connective tissue containing:", "o": ["Plasma, RBC, WBC and Platelets", "Only RBC and Plasma", "Collagen fibers", "Fibroblasts"], "a": "Plasma, RBC, WBC and Platelets"},
    {"id": 1235, "q": "Which connective tissue lacks fibers?", "o": ["Blood", "Bone", "Cartilage", "Areolar"], "a": "Blood"},
    
    # --- MUSCLE & NEURAL TISSUE ---
    {"id": 1236, "q": "Skeletal muscle is:", "o": ["Striated and Voluntary", "Non-striated and Involuntary", "Striated and Involuntary", "Smooth and Voluntary"], "a": "Striated and Voluntary"},
    {"id": 1237, "q": "Smooth muscle fibers taper at both ends (fusiform) and are:", "o": ["Non-striated and Involuntary", "Striated and Voluntary", "Striated and Involuntary", "Multinucleate"], "a": "Non-striated and Involuntary"},
    {"id": 1238, "q": "Smooth muscles are found in:", "o": ["Wall of blood vessels, stomach and intestine", "Biceps", "Heart", "Legs"], "a": "Wall of blood vessels, stomach and intestine"},
    {"id": 1239, "q": "Cardiac muscle tissue is found only in the:", "o": ["Heart", "Lungs", "Brain", "Liver"], "a": "Heart"},
    {"id": 1240, "q": "Communication junctions (Intercalated discs) at some fusion points allow cells to contract as a unit. This is seen in:", "o": ["Cardiac muscle", "Skeletal muscle", "Smooth muscle", "Cartilage"], "a": "Cardiac muscle"},
    {"id": 1241, "q": "The unit of Neural system is:", "o": ["Neuron", "Nephron", "Axon", "Dendrite"], "a": "Neuron"},
    {"id": 1242, "q": "Cells that make up more than one-half the volume of neural tissue and protect/support neurons are:", "o": ["Neuroglial cells", "Mast cells", "Fibroblasts", "Macrophages"], "a": "Neuroglial cells"},
    {"id": 1243, "q": "Neurons are:", "o": ["Excitable cells", "Contractile cells", "Secretory cells", "Storage cells"], "a": "Excitable cells"},
    {"id": 1244, "q": "When a neuron is stimulated, an electrical disturbance is generated which travels along its:", "o": ["Plasma membrane", "Nucleus", "Mitochondria", "Ribosome"], "a": "Plasma membrane"},
    {"id": 1245, "q": "Skeletal muscles are closely attached to:", "o": ["Skeletal bones", "Skin", "Organs", "Nerves"], "a": "Skeletal bones"},
    
    # --- TISSUE SYSTEMS (GROUND & VASCULAR) ---
    {"id": 1151, "q": "Root hairs are:", "o": ["Unicellular elongations", "Multicellular elongations", "Branches of root", "Outgrowths of cortex"], "a": "Unicellular elongations"},
    {"id": 1152, "q": "Trichomes on the stem are usually:", "o": ["Multicellular", "Unicellular", "Absent", "Dead"], "a": "Multicellular"},
    {"id": 1153, "q": "All tissues except epidermis and vascular bundles constitute the:", "o": ["Ground tissue", "Dermal tissue", "Vascular tissue", "Secondary tissue"], "a": "Ground tissue"},
    {"id": 1154, "q": "In leaves, the ground tissue consists of thin-walled chloroplast-containing cells called:", "o": ["Mesophyll", "Cortex", "Pith", "Endodermis"], "a": "Mesophyll"},
    {"id": 1155, "q": "Xylem and Phloem together constitute:", "o": ["Vascular bundles", "Ground tissue", "Stele", "Cortex"], "a": "Vascular bundles"},
    {"id": 1156, "q": "In Dicots, cambium is present between phloem and xylem. Such bundles are called:", "o": ["Open vascular bundles", "Closed vascular bundles", "Radial bundles", "Concentric bundles"], "a": "Open vascular bundles"},
    {"id": 1157, "q": "In Monocots, cambium is absent. Hence vascular bundles are:", "o": ["Closed", "Open", "Radial", "Secondary"], "a": "Closed"},
    {"id": 1158, "q": "When xylem and phloem are arranged in an alternate manner on different radii (as in roots), the arrangement is:", "o": ["Radial", "Conjoint", "Collateral", "Bicollateral"], "a": "Radial"},
    {"id": 1159, "q": "In stems and leaves, xylem and phloem are situated at the same radius. This is:", "o": ["Conjoint", "Radial", "Exarch", "Endarch"], "a": "Conjoint"},

    # --- ANATOMY OF DICOT ROOT ---
    {"id": 1160, "q": "The innermost layer of the cortex in Dicot root is:", "o": ["Endodermis", "Pericycle", "Hypodermis", "Epidermis"], "a": "Endodermis"},
    {"id": 1161, "q": "The cells of endodermis have water-impermeable waxy material called:", "o": ["Casparian strips (Suberin)", "Lignin", "Cutin", "Pectin"], "a": "Casparian strips (Suberin)"},
    {"id": 1162, "q": "Next to endodermis lies a few layers of thick-walled parenchymatous cells called:", "o": ["Pericycle", "Pith", "Cortex", "Cambium"], "a": "Pericycle"},
    {"id": 1163, "q": "Initiation of lateral roots and vascular cambium during secondary growth takes place in:", "o": ["Pericycle", "Endodermis", "Cortex", "Epidermis"], "a": "Pericycle"},
    {"id": 1164, "q": "In Dicot root, the pith is:", "o": ["Small or inconspicuous", "Large and well developed", "Absent", "Sclerenchymatous"], "a": "Small or inconspicuous"},
    {"id": 1165, "q": "The number of xylem and phloem patches in Dicot root is usually:", "o": ["2 to 4", "More than 6 (Polyarch)", "1", "Absent"], "a": "2 to 4"},
    {"id": 1166, "q": "All tissues on the inner side of the endodermis (Pericycle, V.B., Pith) constitute the:", "o": ["Stele", "Cortex", "Epidermis", "Hypodermis"], "a": "Stele"},

    # --- ANATOMY OF MONOCOT ROOT ---
    {"id": 1167, "q": "Compared to Dicot root, Monocot root has:", "o": ["More than 6 xylem bundles (Polyarch)", "2-4 xylem bundles", "Cambium", "Secondary growth"], "a": "More than 6 xylem bundles (Polyarch)"},
    {"id": 1168, "q": "Pith in Monocot root is:", "o": ["Large and well developed", "Small", "Absent", "Dead"], "a": "Large and well developed"},
    {"id": 1169, "q": "Monocot roots do NOT undergo:", "o": ["Secondary growth", "Primary growth", "Absorption", "Elongation"], "a": "Secondary growth"},

    # --- ANATOMY OF DICOT STEM ---
    {"id": 1170, "q": "In Dicot stem, the Hypodermis (below epidermis) consists of:", "o": ["Collenchyma", "Sclerenchyma", "Parenchyma", "Chlorenchyma"], "a": "Collenchyma"},
    {"id": 1171, "q": "The 'Starch Sheath' in Dicot stem refers to the:", "o": ["Endodermis", "Pericycle", "Hypodermis", "Pith"], "a": "Endodermis"},
    {"id": 1172, "q": "Pericycle in Dicot stem is present as semilunar patches of:", "o": ["Sclerenchyma", "Collenchyma", "Parenchyma", "Meristem"], "a": "Sclerenchyma"},
    {"id": 1173, "q": "Vascular bundles in Dicot stem are arranged in a:", "o": ["Ring", "Scattered manner", "Radial manner", "Linear row"], "a": "Ring"},
    {"id": 1174, "q": "Each vascular bundle in Dicot stem is:", "o": ["Conjoint, open, with endarch protoxylem", "Conjoint, closed, with exarch protoxylem", "Radial", "Scattered"], "a": "Conjoint, open, with endarch protoxylem"},

    # --- ANATOMY OF MONOCOT STEM ---
    {"id": 1175, "q": "In Monocot stem, the Hypodermis is made of:", "o": ["Sclerenchyma", "Collenchyma", "Parenchyma", "Chlorenchyma"], "a": "Sclerenchyma"},
    {"id": 1176, "q": "Vascular bundles in Monocot stem are:", "o": ["Scattered, conjoint and closed", "Arranged in a ring", "Radial", "Open"], "a": "Scattered, conjoint and closed"},
    {"id": 1177, "q": "In Monocot stem, peripheral vascular bundles are generally:", "o": ["Smaller than centrally located ones", "Larger than central ones", "Same size", "Absent"], "a": "Smaller than centrally located ones"},
    {"id": 1178, "q": "Phloem parenchyma is ____ in Monocot stem vascular bundles.", "o": ["Absent", "Present", "Abundant", "Living"], "a": "Absent"},
    {"id": 1179, "q": "Water-containing cavities are present within the vascular bundles of:", "o": ["Monocot stem", "Dicot stem", "Dicot root", "Monocot root"], "a": "Monocot stem"},

    # --- ANATOMY OF DICOT LEAF (DORSIVENTRAL) ---
    {"id": 1180, "q": "In Dicot leaf, stomata are usually:", "o": ["More on the lower epidermis (abaxial)", "More on the upper epidermis (adaxial)", "Equal on both sides", "Absent"], "a": "More on the lower epidermis (abaxial)"},
    {"id": 1181, "q": "The mesophyll in Dicot leaf is differentiated into:", "o": ["Palisade and Spongy parenchyma", "Only Palisade", "Only Spongy", "Collenchyma and Sclerenchyma"], "a": "Palisade and Spongy parenchyma"},
    {"id": 1182, "q": "Palisade parenchyma is placed:", "o": ["Adaxially (Upper side)", "Abaxially (Lower side)", "In the middle", "Near veins"], "a": "Adaxially (Upper side)"},
    {"id": 1183, "q": "Vascular bundles in Dicot leaf are surrounded by a layer of thick-walled:", "o": ["Bundle sheath cells", "Endodermis", "Pericycle", "Mesophyll"], "a": "Bundle sheath cells"},
    {"id": 1184, "q": "The size of vascular bundles in Dicot leaf varies due to:", "o": ["Reticulate venation", "Parallel venation", "Thickness of leaf", "Stomata"], "a": "Reticulate venation"},

    # --- ANATOMY OF MONOCOT LEAF (ISOBILATERAL) ---
    {"id": 1185, "q": "In Monocot leaf, stomata are:", "o": ["Present on both surfaces", "Only on upper surface", "Only on lower surface", "Absent"], "a": "Present on both surfaces"},
    {"id": 1186, "q": "The mesophyll in Monocot leaf is:", "o": ["Not differentiated into palisade and spongy parenchyma", "Differentiated", "Made of Collenchyma", "Absent"], "a": "Not differentiated into palisade and spongy parenchyma"},
    {"id": 1187, "q": "In Grasses, certain adaxial epidermal cells modify into large, empty, colorless cells called:", "o": ["Bulliform cells", "Guard cells", "Subsidiary cells", "Trichomes"], "a": "Bulliform cells"},
    {"id": 1188, "q": "When Bulliform cells absorb water and are turgid, the leaf:", "o": ["Exposes the surface", "Curls inwards", "Withers", "Falls off"], "a": "Exposes the surface"},
    {"id": 1189, "q": "When Bulliform cells are flaccid due to water stress, the leaf:", "o": ["Curls inwards to minimize water loss", "Expands", "Photosynthesizes more", "Opens stomata"], "a": "Curls inwards to minimize water loss"},
    {"id": 1190, "q": "In Monocot leaf, vascular bundles are nearly similar in size (except in main veins) due to:", "o": ["Parallel venation", "Reticulate venation", "Absence of midrib", "Thick cuticle"], "a": "Parallel venation"},

    # --- COMPARATIVE / RANK BOOSTERS ---
    {"id": 1191, "q": "Casparian strips are made of:", "o": ["Suberin", "Lignin", "Cutin", "Cellulose"], "a": "Suberin"},
    {"id": 1192, "q": "Vascular bundles in roots are always:", "o": ["Radial and Exarch", "Conjoint and Endarch", "Radial and Endarch", "Conjoint and Exarch"], "a": "Radial and Exarch"},
    {"id": 1193, "q": "Vascular bundles in stems are always:", "o": ["Conjoint and Endarch", "Radial and Exarch", "Radial and Endarch", "Conjoint and Exarch"], "a": "Conjoint and Endarch"},
    {"id": 1194, "q": "Ring arrangement of vascular bundles is a characteristic of:", "o": ["Dicot stem", "Monocot stem", "Dicot root", "Monocot root"], "a": "Dicot stem"},
    {"id": 1195, "q": "Water cavity in vascular bundles is found in:", "o": ["Maize stem (Monocot)", "Sunflower stem (Dicot)", "Gram root", "Pea leaf"], "a": "Maize stem (Monocot)"},
    {"id": 1196, "q": "Secondary growth is absent in:", "o": ["Monocots", "Dicots", "Gymnosperms", "All Angiosperms"], "a": "Monocots"},
    {"id": 1197, "q": "Which tissue provides tensile strength to young dicot stems?", "o": ["Collenchyma", "Sclerenchyma", "Parenchyma", "Xylem"], "a": "Collenchyma"},
    {"id": 1198, "q": "Which tissue provides mechanical strength to Monocot stems (Hypodermis)?", "o": ["Sclerenchyma", "Collenchyma", "Parenchyma", "Aerenchyma"], "a": "Sclerenchyma"},
    {"id": 1199, "q": "Lateral roots arise from:", "o": ["Pericycle", "Endodermis", "Cortex", "Epidermis"], "a": "Pericycle"},
    {"id": 1200, "q": "Stele includes all EXCEPT:", "o": ["Endodermis", "Pericycle", "Vascular bundles", "Pith"], "a": "Endodermis"},
    
    # --- THE TISSUES: MERISTEMATIC ---
    {"id": 1101, "q": "A tissue is a group of cells having a common origin and performing a:", "o": ["Common function", "Different function", "No function", "Reproductive function"], "a": "Common function"},
    {"id": 1102, "q": "Tissues are classified into two main groups based on capability of division:", "o": ["Meristematic and Permanent", "Simple and Complex", "Xylem and Phloem", "Parenchyma and Collenchyma"], "a": "Meristematic and Permanent"},
    {"id": 1103, "q": "Meristems which occur at the tips of roots and shoots are called:", "o": ["Apical meristems", "Intercalary meristems", "Lateral meristems", "Secondary meristems"], "a": "Apical meristems"},
    {"id": 1104, "q": "Root apical meristem occupies the:", "o": ["Tip of the root", "Base of the root", "Middle of the root", "Root hair zone"], "a": "Tip of the root"},
    {"id": 1105, "q": "The meristem which occurs between mature tissues is known as:", "o": ["Intercalary meristem", "Apical meristem", "Lateral meristem", "Promeristem"], "a": "Intercalary meristem"},
    {"id": 1106, "q": "Intercalary meristems are responsible for:", "o": ["Regenerating parts removed by grazing herbivores", "Increasing girth", "Producing wood", "Secondary growth"], "a": "Regenerating parts removed by grazing herbivores"},
    {"id": 1107, "q": "Apical and Intercalary meristems are examples of:", "o": ["Primary meristems", "Secondary meristems", "Lateral meristems", "Permanent tissues"], "a": "Primary meristems"},
    {"id": 1108, "q": "The meristem that occurs in the mature regions of roots and shoots and produces woody axis (Secondary Growth) is:", "o": ["Lateral meristem", "Apical meristem", "Intercalary meristem", "Primary meristem"], "a": "Lateral meristem"},
    {"id": 1109, "q": "Which of the following is an example of Lateral Meristem?", "o": ["Fascicular vascular cambium and Cork cambium", "Root apical meristem", "Shoot apical meristem", "Intercalary meristem"], "a": "Fascicular vascular cambium and Cork cambium"},
    {"id": 1110, "q": "Axillary buds are capable of forming a branch or a flower. They are left behind from:", "o": ["Shoot apical meristem", "Root apical meristem", "Intercalary meristem", "Lateral meristem"], "a": "Shoot apical meristem"},

    # --- SIMPLE PERMANENT TISSUES ---
    {"id": 1111, "q": "Simple tissues are made of:", "o": ["Only one type of cells", "More than one type of cells", "Dead cells only", "Vascular bundles"], "a": "Only one type of cells"},
    {"id": 1112, "q": "Which simple tissue forms the major component within organs?", "o": ["Parenchyma", "Collenchyma", "Sclerenchyma", "Xylem"], "a": "Parenchyma"},
    {"id": 1113, "q": "The cells of Parenchyma are generally isodiametric and their walls are made of:", "o": ["Cellulose", "Lignin", "Pectin", "Suberin"], "a": "Cellulose"},
    {"id": 1114, "q": "Functions of Parenchyma include:", "o": ["Photosynthesis, storage, secretion", "Mechanical support only", "Water conduction only", "Protection only"], "a": "Photosynthesis, storage, secretion"},
    {"id": 1115, "q": "Collenchyma occurs in layers below the epidermis in:", "o": ["Dicot stems", "Monocot stems", "Roots", "Monocot leaves"], "a": "Dicot stems"},
    {"id": 1116, "q": "The corners of Collenchyma cells are thickened due to deposition of:", "o": ["Cellulose, hemicellulose and pectin", "Lignin and suberin", "Only cellulose", "Only lignin"], "a": "Cellulose, hemicellulose and pectin"},
    {"id": 1117, "q": "Intercellular spaces are generally absent in:", "o": ["Collenchyma", "Parenchyma", "Aerenchyma", "Chlorenchyma"], "a": "Collenchyma"},
    {"id": 1118, "q": "Collenchyma provides mechanical support to:", "o": ["Growing parts like young stem and petiole", "Woody axis", "Roots", "Fruits"], "a": "Growing parts like young stem and petiole"},
    {"id": 1119, "q": "Sclerenchyma consists of long, narrow cells with thick and:", "o": ["Lignified cell walls", "Pectic cell walls", "Cellulosic cell walls", "Suberized cell walls"], "a": "Lignified cell walls"},
    {"id": 1120, "q": "Sclerenchyma cells are usually:", "o": ["Dead and without protoplasts", "Living with protoplasts", "Meristematic", "Thin walled"], "a": "Dead and without protoplasts"},
    {"id": 1121, "q": "Sclereids (Stone cells) are found in:", "o": ["Fruit walls of nuts, pulp of guava/pear/sapota", "Young stems", "Petiole of leaf", "Root tips"], "a": "Fruit walls of nuts, pulp of guava/pear/sapota"},
    {"id": 1122, "q": "The main function of Sclerenchyma is:", "o": ["Mechanical support to organs", "Photosynthesis", "Storage", "Secretion"], "a": "Mechanical support to organs"},

    # --- COMPLEX TISSUES (XYLEM & PHLOEM) ---
    {"id": 1123, "q": "Xylem functions as a conducting tissue for:", "o": ["Water and minerals", "Food materials", "Hormones only", "Air"], "a": "Water and minerals"},
    {"id": 1124, "q": "The four elements of Xylem are:", "o": ["Tracheids, Vessels, Xylem fibers, Xylem parenchyma", "Sieve tubes, Companion cells, Phloem fibers, Phloem parenchyma", "Tracheids, Vessels, Sieve tubes, Companion cells", "Vessels, Fibers, Parenchyma, Collenchyma"], "a": "Tracheids, Vessels, Xylem fibers, Xylem parenchyma"},
    {"id": 1125, "q": "Which of the following Xylem elements is living?", "o": ["Xylem parenchyma", "Tracheids", "Vessels", "Xylem fibers"], "a": "Xylem parenchyma"},
    {"id": 1126, "q": "In Gymnosperms, which xylem element is lacking?", "o": ["Vessels", "Tracheids", "Xylem parenchyma", "Xylem fibers"], "a": "Vessels"},
    {"id": 1127, "q": "Vessels are characteristic of:", "o": ["Angiosperms", "Gymnosperms", "Pteridophytes", "Bryophytes"], "a": "Angiosperms"},
    {"id": 1128, "q": "The presence of vessels is a characteristic feature of Angiosperms. A vessel is multicellular with:", "o": ["Perforated end walls (plates)", "Thick lignified walls and no perforation", "Living protoplasm", "Thin cellulosic walls"], "a": "Perforated end walls (plates)"},
    {"id": 1129, "q": "Xylem fibers have:", "o": ["Obliterated central lumens", "Large lumens", "Living protoplasm", "Thin walls"], "a": "Obliterated central lumens"},
    {"id": 1130, "q": "Xylem parenchyma stores food in the form of starch or fat and substances like:", "o": ["Tannins", "Resins", "Latex", "Gums"], "a": "Tannins"},
    {"id": 1131, "q": "In stems, the Protoxylem lies towards the center and Metaxylem towards the periphery. This arrangement is:", "o": ["Endarch", "Exarch", "Mesarch", "Centrarch"], "a": "Endarch"},
    {"id": 1132, "q": "In roots, the Protoxylem lies towards the periphery and Metaxylem towards the center. This arrangement is:", "o": ["Exarch", "Endarch", "Mesarch", "Centrarch"], "a": "Exarch"},
    {"id": 1133, "q": "Phloem transports:", "o": ["Food materials", "Water only", "Minerals only", "Air"], "a": "Food materials"},
    {"id": 1134, "q": "Gymnosperms lack Sieve tubes and Companion cells. Instead, they have:", "o": ["Albuminous cells and Sieve cells", "Vessels and Tracheids", "Sieve plates and Pores", "Xylem parenchyma"], "a": "Albuminous cells and Sieve cells"},
    {"id": 1135, "q": "Sieve tube elements are long, tube-like structures arranged longitudinally and associated with:", "o": ["Companion cells", "Xylem vessels", "Phloem fibers", "Tracheids"], "a": "Companion cells"},
    {"id": 1136, "q": "The end walls of sieve tubes are perforated to form:", "o": ["Sieve plates", "Vessel plates", "Pits", "Plasmodesmata"], "a": "Sieve plates"},
    {"id": 1137, "q": "A mature sieve element possesses a peripheral cytoplasm and a large vacuole but lacks a:", "o": ["Nucleus", "Cell wall", "Plasma membrane", "Mitochondria"], "a": "Nucleus"},
    {"id": 1138, "q": "The functions of sieve tubes are controlled by the nucleus of:", "o": ["Companion cells", "Phloem parenchyma", "Albuminous cells", "Xylem parenchyma"], "a": "Companion cells"},
    {"id": 1139, "q": "Phloem parenchyma is absent in most of the:", "o": ["Monocotyledons", "Dicotyledons", "Gymnosperms", "Pteridophytes"], "a": "Monocotyledons"},
    {"id": 1140, "q": "Phloem fibers (Bast fibers) are made of:", "o": ["Sclerenchymatous cells", "Parenchymatous cells", "Collenchymatous cells", "Meristematic cells"], "a": "Sclerenchymatous cells"},
    {"id": 1141, "q": "Phloem fibers are generally absent in:", "o": ["Primary phloem", "Secondary phloem", "Roots", "Stems"], "a": "Primary phloem"},
    {"id": 1142, "q": "Phloem fibers of Jute, Flax, and Hemp are used commercially. These fibers are:", "o": ["Dead", "Living", "Collenchymatous", "Parenchymatous"], "a": "Dead"},

    # --- TISSUE SYSTEMS (EPIDERMAL) ---
    {"id": 1143, "q": "The outermost layer of the primary plant body is:", "o": ["Epidermis", "Cortex", "Endodermis", "Pericycle"], "a": "Epidermis"},
    {"id": 1144, "q": "Epidermis is usually:", "o": ["Single layered", "Multi layered", "Absent in roots", "Made of Sclerenchyma"], "a": "Single layered"},
    {"id": 1145, "q": "The outside of the epidermis is often covered by a waxy thick layer called:", "o": ["Cuticle", "Bark", "Cortex", "Suberin"], "a": "Cuticle"},
    {"id": 1146, "q": "Cuticle is absent in:", "o": ["Roots", "Stems", "Leaves", "Fruits"], "a": "Roots"},
    {"id": 1147, "q": "Stomata are structures present in the epidermis of leaves for:", "o": ["Transpiration and gas exchange", "Water absorption", "Protection", "Photosynthesis only"], "a": "Transpiration and gas exchange"},
    {"id": 1148, "q": "The bean-shaped cells bordering the stomatal pore are called:", "o": ["Guard cells", "Subsidiary cells", "Bulliform cells", "Mesophyll cells"], "a": "Guard cells"},
    {"id": 1149, "q": "In grasses (Monocots), the guard cells are:", "o": ["Dumb-bell shaped", "Bean shaped", "Kidney shaped", "Round"], "a": "Dumb-bell shaped"},
    {"id": 1150, "q": "The epidermal hairs on the root are called:", "o": ["Root hairs", "Trichomes", "Prickles", "Spines"], "a": "Root hairs"},
    
    # --- AESTIVATION & PLACENTATION EXAMPLES ---
    {"id": 1051, "q": "Sepals or petals in a whorl just touch one another at the margin, without overlapping. This is:", "o": ["Valvate", "Twisted", "Imbricate", "Vexillary"], "a": "Valvate"},
    {"id": 1052, "q": "One margin of the appendage overlaps that of the next one and so on. This is:", "o": ["Twisted", "Valvate", "Imbricate", "Vexillary"], "a": "Twisted"},
    {"id": 1053, "q": "Margins overlap one another but not in any particular direction. This is:", "o": ["Imbricate", "Twisted", "Valvate", "Vexillary"], "a": "Imbricate"},
    {"id": 1054, "q": "Example of Twisted aestivation:", "o": ["China rose, Lady's finger, Cotton", "Calotropis", "Cassia, Gulmohur", "Pea, Bean"], "a": "China rose, Lady's finger, Cotton"},
    {"id": 1055, "q": "Example of Valvate aestivation:", "o": ["Calotropis", "China rose", "Pea", "Cassia"], "a": "Calotropis"},
    {"id": 1056, "q": "Example of Imbricate aestivation:", "o": ["Cassia and Gulmohur", "Cotton and China rose", "Pea and Bean", "Calotropis"], "a": "Cassia and Gulmohur"},
    {"id": 1057, "q": "The arrangement of ovules within the ovary is known as:", "o": ["Placentation", "Aestivation", "Inflorescence", "Phyllotaxy"], "a": "Placentation"},
    {"id": 1058, "q": "In Marginal placentation, the placenta forms a ridge along the:", "o": ["Ventral suture of the ovary", "Dorsal suture", "Base of ovary", "Central axis"], "a": "Ventral suture of the ovary"},
    {"id": 1059, "q": "Example of Axile placentation:", "o": ["Tomato, Lemon, China rose", "Pea", "Mustard, Argemone", "Sunflower"], "a": "Tomato, Lemon, China rose"},
    {"id": 1060, "q": "In Parietal placentation, the ovules develop on:", "o": ["The inner wall of the ovary", "The central axis", "The base of ovary", "The ridge"], "a": "The inner wall of the ovary"},
    {"id": 1061, "q": "Ovary is one-chambered but becomes two-chambered due to the formation of a false septum (Replum) in:", "o": ["Mustard and Argemone", "Pea and Bean", "Tomato and Lemon", "Dianthus"], "a": "Mustard and Argemone"},
    {"id": 1062, "q": "Free Central placentation is found in:", "o": ["Dianthus and Primrose", "Mustard and Argemone", "Pea and Bean", "Sunflower"], "a": "Dianthus and Primrose"},
    {"id": 1063, "q": "Basal placentation is characteristic of:", "o": ["Sunflower and Marigold", "Pea and Bean", "Mustard", "Tomato"], "a": "Sunflower and Marigold"},

    # --- FRUIT & SEED ANATOMY ---
    {"id": 1064, "q": "The fruit wall is called:", "o": ["Pericarp", "Epicarp", "Mesocarp", "Endocarp"], "a": "Pericarp"},
    {"id": 1065, "q": "In dry fruits (like Groundnut, Mustard), the pericarp is:", "o": ["Not differentiated into epi/meso/endocarp", "Thick and fleshy", "Absent", "Edible"], "a": "Not differentiated into epi/meso/endocarp"},
    {"id": 1066, "q": "In Mango and Coconut, the fruit is a:", "o": ["Drupe", "Berry", "Pepo", "Hesperidium"], "a": "Drupe"},
    {"id": 1067, "q": "Drupe develops from:", "o": ["Monocarpellary superior ovaries", "Multicarpellary inferior ovaries", "Bicarpellary syncarpous", "Apocarpous ovaries"], "a": "Monocarpellary superior ovaries"},
    {"id": 1068, "q": "The edible part of Coconut is:", "o": ["Endosperm", "Mesocarp", "Epicarp", "Endocarp"], "a": "Endosperm"},
    {"id": 1069, "q": "The seed coat has two layers. The outer is Testa and the inner is:", "o": ["Tegmen", "Hilum", "Micropyle", "Raphe"], "a": "Tegmen"},
    {"id": 1070, "q": "The scar on the seed coat through which the developing seeds were attached to the fruit is:", "o": ["Hilum", "Micropyle", "Raphe", "Chalaza"], "a": "Hilum"},
    {"id": 1071, "q": "Non-albuminous (Non-endospermic) seeds are found in:", "o": ["Pea, Gram, Bean", "Castor, Maize", "Wheat, Barley", "Coconut"], "a": "Pea, Gram, Bean"},
    {"id": 1072, "q": "Albuminous (Endospermic) seeds are typically found in:", "o": ["Monocots (Wheat, Maize) and Castor", "Pea and Gram", "Bean and Groundnut", "Orchids"], "a": "Monocots (Wheat, Maize) and Castor"},
    {"id": 1073, "q": "Perisperm is the persistent remnant of:", "o": ["Nucellus", "Endosperm", "Embryo", "Integument"], "a": "Nucellus"},
    {"id": 1074, "q": "Perisperm is found in:", "o": ["Black pepper and Beet", "Pea and Gram", "Maize and Wheat", "Castor"], "a": "Black pepper and Beet"},
    {"id": 1075, "q": "The proteinaceous layer separating the embryo from the endosperm in monocot seeds is:", "o": ["Aleurone layer", "Scutellum", "Epithelium", "Tegmen"], "a": "Aleurone layer"},
    {"id": 1076, "q": "In Maize grain, the single large shield-shaped cotyledon is called:", "o": ["Scutellum", "Coleoptile", "Coleorhiza", "Epiblast"], "a": "Scutellum"},
    {"id": 1077, "q": "The plumule and radicle in monocot seeds are enclosed in sheaths called:", "o": ["Coleoptile and Coleorhiza respectively", "Coleorhiza and Coleoptile respectively", "Scutellum and Aleurone", "Testa and Tegmen"], "a": "Coleoptile and Coleorhiza respectively"},

    # --- FAMILY SPECIFIC FEATURES ---
    {"id": 1078, "q": "Epipetalous stamens are a defining feature of:", "o": ["Solanaceae", "Liliaceae", "Fabaceae", "Brassicaceae"], "a": "Solanaceae"},
    {"id": 1079, "q": "Epiphyllous stamens (attached to Tepals) are found in:", "o": ["Liliaceae", "Solanaceae", "Fabaceae", "Brassicaceae"], "a": "Liliaceae"},
    {"id": 1080, "q": "Diadelphous stamens [(9)+1] are found in:", "o": ["Fabaceae", "Solanaceae", "Liliaceae", "Poaceae"], "a": "Fabaceae"},
    {"id": 1081, "q": "Six stamens arranged in two whorls (3+3) is a feature of:", "o": ["Liliaceae", "Solanaceae", "Fabaceae", "Brassicaceae"], "a": "Liliaceae"},
    {"id": 1082, "q": "Tetradynamous stamens (2+4) are found in:", "o": ["Brassicaceae (Mustard)", "Liliaceae", "Solanaceae", "Fabaceae"], "a": "Brassicaceae (Mustard)"},
    {"id": 1083, "q": "Swollen placenta with many ovules is characteristic of:", "o": ["Solanaceae", "Fabaceae", "Liliaceae", "Brassicaceae"], "a": "Solanaceae"},
    {"id": 1084, "q": "Marginal placentation is unique to:", "o": ["Fabaceae", "Solanaceae", "Liliaceae", "Brassicaceae"], "a": "Fabaceae"},
    {"id": 1085, "q": "Fruit type 'Legume' is found in:", "o": ["Fabaceae", "Solanaceae", "Liliaceae", "Poaceae"], "a": "Fabaceae"},
    {"id": 1086, "q": "Fruit type 'Berry or Capsule' is found in:", "o": ["Solanaceae", "Fabaceae", "Poaceae", "Asteraceae"], "a": "Solanaceae"},
    {"id": 1087, "q": "Colchicum autumnale (source of Colchicine) belongs to:", "o": ["Liliaceae", "Solanaceae", "Fabaceae", "Asteraceae"], "a": "Liliaceae"},
    {"id": 1088, "q": "Which family provides 'Fumigatory' agents like Tobacco?", "o": ["Solanaceae", "Fabaceae", "Liliaceae", "Brassicaceae"], "a": "Solanaceae"},
    {"id": 1089, "q": "Which family includes 'Pulses' like Gram, Arhar, Sem, Moong?", "o": ["Fabaceae", "Solanaceae", "Liliaceae", "Poaceae"], "a": "Fabaceae"},
    {"id": 1090, "q": "The botanical name of 'Makoi' is:", "o": ["Solanum nigrum", "Solanum tuberosum", "Solanum melongena", "Lycopersicum esculentum"], "a": "Solanum nigrum"},

    # --- GENERAL MORPHOLOGY WRAP-UP ---
    {"id": 1091, "q": "Primary root is short lived and replaced by adventitious roots in:", "o": ["Monocots", "Dicots", "Gymnosperms", "Pteridophytes"], "a": "Monocots"},
    {"id": 1092, "q": "Stem helps in vegetative propagation in:", "o": ["Potato, Ginger, Zaminkand", "Wheat", "Maize", "Pea"], "a": "Potato, Ginger, Zaminkand"},
    {"id": 1093, "q": "When leaflets are attached at the tip of the petiole, it is:", "o": ["Palmately compound", "Pinnately compound", "Simple leaf", "Whorled"], "a": "Palmately compound"},
    {"id": 1094, "q": "In Smilax and Peas, leaves are modified into:", "o": ["Tendrils", "Spines", "Phyllodes", "Bulbs"], "a": "Tendrils"},
    {"id": 1095, "q": "The arrangement of veins and veinlets in the lamina is:", "o": ["Venation", "Phyllotaxy", "Inflorescence", "Aestivation"], "a": "Venation"},
    {"id": 1096, "q": "Radial symmetry is equivalent to:", "o": ["Actinomorphic", "Zygomorphic", "Asymmetric", "Bilateral"], "a": "Actinomorphic"},
    {"id": 1097, "q": "Bilateral symmetry is equivalent to:", "o": ["Zygomorphic", "Actinomorphic", "Radial", "Irregular"], "a": "Zygomorphic"},
    {"id": 1098, "q": "Inferior ovary means the flower is:", "o": ["Epigynous", "Hypogynous", "Perigynous", "Agynous"], "a": "Epigynous"},
    {"id": 1099, "q": "Superior ovary means the flower is:", "o": ["Hypogynous", "Epigynous", "Perigynous", "Agynous"], "a": "Hypogynous"},
    {"id": 1100, "q": "Which part of the flower attracts insects for pollination?", "o": ["Corolla (Petals)", "Calyx (Sepals)", "Androecium", "Gynoecium"], "a": "Corolla (Petals)"},
    
    # --- FLORAL FORMULA & FAMILIES LOGIC ---
    {"id": 1001, "q": "The floral formula 'âŠ• âš¥ K(5) C(5) A5 G(2)' corresponds to:", "o": ["Solanaceae", "Liliaceae", "Fabaceae", "Brassicaceae"], "a": "Solanaceae"},
    {"id": 1002, "q": "The floral formula '% âš¥ K(5) C1+2+(2) A(9)+1 G1' corresponds to:", "o": ["Fabaceae", "Solanaceae", "Liliaceae", "Poaceae"], "a": "Fabaceae"},
    {"id": 1003, "q": "The floral formula 'Br âŠ• âš¥ P(3+3) A3+3 G(3)' corresponds to:", "o": ["Liliaceae", "Solanaceae", "Fabaceae", "Brassicaceae"], "a": "Liliaceae"},
    {"id": 1004, "q": "In the floral formula of Fabaceae, '%', refers to:", "o": ["Zygomorphic symmetry", "Actinomorphic symmetry", "Bisexual", "Superior Ovary"], "a": "Zygomorphic symmetry"},
    {"id": 1005, "q": "In Solanaceae formula, 'K(5)' indicates:", "o": ["Gamosepalous (United sepals)", "Polysepalous (Free sepals)", "Epipetalous", "5 distinct sepals"], "a": "Gamosepalous (United sepals)"},
    {"id": 1006, "q": "The symbol 'G' with a line below it (G_) indicates:", "o": ["Superior Ovary", "Inferior Ovary", "Half-inferior Ovary", "Gynoecium absent"], "a": "Superior Ovary"},
    {"id": 1007, "q": "The symbol 'G' with a line above it (â€¾G) indicates:", "o": ["Inferior Ovary", "Superior Ovary", "Male flower", "Sterile pistil"], "a": "Inferior Ovary"},
    {"id": 1008, "q": "The symbol 'P' in floral formula stands for:", "o": ["Perianth (Tepals)", "Petals", "Polyadelphous", "Pistil"], "a": "Perianth (Tepals)"},
    {"id": 1009, "q": "Fusion of stamens with petals (Epipetalous) is represented by an arch connecting:", "o": ["C and A", "K and C", "P and A", "A and G"], "a": "C and A"},
    {"id": 1010, "q": "Fusion of stamens with tepals (Epiphyllous) is represented by an arch connecting:", "o": ["P and A", "C and A", "K and A", "K and C"], "a": "P and A"},
    
    # --- IN-DEPTH ROOT & STEM MODIFICATIONS ---
    {"id": 1011, "q": "Which of the following is NOT a root modification?", "o": ["Potato tuber", "Sweet potato", "Turnip", "Carrot"], "a": "Potato tuber"},
    {"id": 1012, "q": "Which of the following is an underground stem?", "o": ["Zaminkand", "Sweet Potato", "Radish", "Turnip"], "a": "Zaminkand"},
    {"id": 1013, "q": "Organ of perennation to tide over conditions unfavorable for growth is:", "o": ["Underground stems", "Roots", "Leaves", "Flowers"], "a": "Underground stems"},
    {"id": 1014, "q": "Stem tendrils in Grapevines develop from:", "o": ["Axillary buds", "Terminal buds", "Leaves", "Roots"], "a": "Axillary buds"},
    {"id": 1015, "q": "Thorns in Citrus and Bougainvillea are modified:", "o": ["Axillary buds", "Leaves", "Stipules", "Roots"], "a": "Axillary buds"},
    {"id": 1016, "q": "In Opuntia, the spine is a modification of:", "o": ["Leaf", "Stem", "Root", "Flower"], "a": "Leaf"},
    {"id": 1017, "q": "In Opuntia, the green photosynthetic part is a modification of:", "o": ["Stem", "Leaf", "Root", "Petiole"], "a": "Stem"},
    {"id": 1018, "q": "In Australian Acacia, the green photosynthetic part is a modification of:", "o": ["Petiole", "Lamina", "Stem", "Stipule"], "a": "Petiole"},
    {"id": 1019, "q": "The 'eyes' of the potato tuber are:", "o": ["Axillary buds", "Root buds", "Flower buds", "Shoot apices"], "a": "Axillary buds"},
    {"id": 1020, "q": "Ginger reproduces vegetatively by:", "o": ["Rhizome", "Tuber", "Offset", "Bulb"], "a": "Rhizome"},
    {"id": 1021, "q": "Which plant has a 'Bulb' as a modified stem?", "o": ["Onion", "Ginger", "Potato", "Colocasia"], "a": "Onion"},
    {"id": 1022, "q": "A lateral branch with short internodes and each node bearing a rosette of leaves is found in:", "o": ["Eichhornia (Water hyacinth)", "Grass", "Mint", "Banana"], "a": "Eichhornia (Water hyacinth)"},
    {"id": 1023, "q": "Sub-aerial stem modification 'Runner' is found in:", "o": ["Oxalis and Grasses", "Mint and Jasmine", "Pistia", "Banana"], "a": "Oxalis and Grasses"},
    {"id": 1024, "q": "Sub-aerial stem modification 'Sucker' is found in:", "o": ["Banana, Pineapple, Chrysanthemum", "Grass, Strawberry", "Mint, Jasmine", "Pistia, Eichhornia"], "a": "Banana, Pineapple, Chrysanthemum"},

    # --- LEAF PHYLLOTAXY & TYPES ---
    {"id": 1025, "q": "Leaves originate from:", "o": ["Shoot apical meristem", "Root apical meristem", "Lateral meristem", "Intercalary meristem"], "a": "Shoot apical meristem"},
    {"id": 1026, "q": "Leaves are arranged in:", "o": ["Acropetal order", "Basipetal order", "Random order", "Whorled order"], "a": "Acropetal order"},
    {"id": 1027, "q": "The leaf base may become swollen (pulvinus) in:", "o": ["Legumes", "Cereals", "Palms", "Solanaceae"], "a": "Legumes"},
    {"id": 1028, "q": "The leaf base expands into a sheath covering the stem partially or wholly in:", "o": ["Monocots", "Dicots", "Gymnosperms", "Pteridophytes"], "a": "Monocots"},
    {"id": 1029, "q": "Stipules are lateral small leaf-like structures found at:", "o": ["The base of the leaf", "The tip of the leaf", "The axil of the leaf", "The midrib"], "a": "The base of the leaf"},
    {"id": 1030, "q": "Veins provide rigidity to the leaf blade and act as channels for:", "o": ["Transport of water, minerals and food", "Photosynthesis only", "Respiration", "Transpiration"], "a": "Transport of water, minerals and food"},
    {"id": 1031, "q": "When the incision of the lamina reach the midrib breaking it into a number of leaflets, the leaf is:", "o": ["Compound", "Simple", "Sessile", "Petiolate"], "a": "Compound"},
    {"id": 1032, "q": "In Palmately compound leaves, leaflets are attached at:", "o": ["A common point (tip of petiole)", "A common axis (rachis)", "The stem directly", "The base of the petiole"], "a": "A common point (tip of petiole)"},
    {"id": 1033, "q": "Example of a Palmately compound leaf is:", "o": ["Silk Cotton", "Neem", "Rose", "Pea"], "a": "Silk Cotton"},
    {"id": 1034, "q": "Example of a Pinnately compound leaf is:", "o": ["Neem", "Silk Cotton", "Cucumber", "Guava"], "a": "Neem"},
    {"id": 1035, "q": "Whorled phyllotaxy (leaves in a circle at one node) is seen in:", "o": ["Alstonia", "Sunflower", "Mustard", "Calotropis"], "a": "Alstonia"},
    {"id": 1036, "q": "Opposite phyllotaxy is seen in:", "o": ["Calotropis and Guava", "China rose and Mustard", "Sunflower and Maize", "Alstonia"], "a": "Calotropis and Guava"},
    {"id": 1037, "q": "Leaf tendrils are found in:", "o": ["Pea", "Cucumber", "Grapevine", "Pumpkin"], "a": "Pea"},
    {"id": 1038, "q": "Which part of the plant is modified into spines in Cactus?", "o": ["Leaves", "Stem", "Root", "Flower"], "a": "Leaves"},
    {"id": 1039, "q": "Fleshy leaves of Onion store:", "o": ["Food", "Water", "Air", "Latex"], "a": "Food"},
    
    # --- INFLORESCENCE & FLOWER DETAILS ---
    {"id": 1040, "q": "In Racemose, the flowers are arranged in:", "o": ["Acropetal succession", "Basipetal succession", "Centrifugal manner", "Random manner"], "a": "Acropetal succession"},
    {"id": 1041, "q": "In Cymose, the flowers are arranged in:", "o": ["Basipetal succession", "Acropetal succession", "Centripetal manner", "Spiral manner"], "a": "Basipetal succession"},
    {"id": 1042, "q": "The main axis terminates in a flower in:", "o": ["Cymose", "Racemose", "Spike", "Catkin"], "a": "Cymose"},
    {"id": 1043, "q": "A flower which can be divided into two equal radial halves in any radial plane is:", "o": ["Actinomorphic", "Zygomorphic", "Asymmetric", "Irregular"], "a": "Actinomorphic"},
    {"id": 1044, "q": "A flower which can be divided into two similar halves only in one particular vertical plane is:", "o": ["Zygomorphic", "Actinomorphic", "Regular", "Radial"], "a": "Zygomorphic"},
    {"id": 1045, "q": "Example of Actinomorphic flower:", "o": ["Mustard, Datura, Chilli", "Pea, Bean, Gulmohur", "Cassia, Canna", "Salvia"], "a": "Mustard, Datura, Chilli"},
    {"id": 1046, "q": "Example of Zygomorphic flower:", "o": ["Pea, Gulmohur, Bean, Cassia", "Mustard, Datura", "Chilli, Tomato", "Canna"], "a": "Pea, Gulmohur, Bean, Cassia"},
    {"id": 1047, "q": "A flower is asymmetric (irregular) if it cannot be divided into two similar halves. Example:", "o": ["Canna", "Pea", "Datura", "Mustard"], "a": "Canna"},
    {"id": 1048, "q": "In Hypogynous flowers, the ovary is:", "o": ["Superior", "Inferior", "Half-inferior", "Half-superior"], "a": "Superior"},
    {"id": 1049, "q": "In Epigynous flowers, the ovary is:", "o": ["Inferior", "Superior", "Half-inferior", "Half-superior"], "a": "Inferior"},
    {"id": 1050, "q": "In Perigynous flowers (like Rose, Plum, Peach), the ovary is:", "o": ["Half-inferior", "Superior", "Inferior", "Absent"], "a": "Half-inferior"},
    
    # --- THE FLOWER ---
    {"id": 944, "q": "A flower with both androecium and gynoecium is called:", "o": ["Bisexual", "Unisexual", "Staminate", "Pistillate"], "a": "Bisexual"},
    {"id": 945, "q": "Actinomorphic (Radial symmetry) flowers are found in:", "o": ["Mustard, Datura, Chilli", "Pea, Gulmohur, Bean, Cassia", "Canna", "Orchids"], "a": "Mustard, Datura, Chilli"},
    {"id": 946, "q": "Zygomorphic (Bilateral symmetry) flowers are found in:", "o": ["Pea, Gulmohur, Bean, Cassia", "Mustard, Datura, Chilli", "Canna", "Tomato"], "a": "Pea, Gulmohur, Bean, Cassia"},
    {"id": 947, "q": "Asymmetric (Irregular) flowers are found in:", "o": ["Canna", "Pea", "Mustard", "Datura"], "a": "Canna"},
    {"id": 948, "q": "Hypogynous flower (Superior Ovary) is seen in:", "o": ["Mustard, China rose, Brinjal", "Plum, Rose, Peach", "Guava, Cucumber", "Ray florets of Sunflower"], "a": "Mustard, China rose, Brinjal"},
    {"id": 949, "q": "Perigynous flower (Half Inferior Ovary) is seen in:", "o": ["Plum, Rose, Peach", "Mustard, China rose", "Guava, Cucumber", "Brinjal"], "a": "Plum, Rose, Peach"},
    {"id": 950, "q": "Epigynous flower (Inferior Ovary) is seen in:", "o": ["Guava, Cucumber, Ray florets of Sunflower", "Mustard, China rose", "Plum, Rose", "Pea"], "a": "Guava, Cucumber, Ray florets of Sunflower"},
    {"id": 951, "q": "Gamosepalous means:", "o": ["Sepals united", "Sepals free", "Petals united", "Petals free"], "a": "Sepals united"},
    {"id": 952, "q": "Valvate aestivation (sepals/petals just touch) is seen in:", "o": ["Calotropis", "China rose", "Cassia", "Pea"], "a": "Calotropis"},
    {"id": 953, "q": "Twisted aestivation (one margin overlaps next) is seen in:", "o": ["China rose, Lady's finger, Cotton", "Calotropis", "Cassia, Gulmohur", "Pea, Bean"], "a": "China rose, Lady's finger, Cotton"},
    {"id": 954, "q": "Imbricate aestivation (overlapping irregular) is seen in:", "o": ["Cassia and Gulmohur", "China rose", "Calotropis", "Pea"], "a": "Cassia and Gulmohur"},
    {"id": 955, "q": "Vexillary or Papilionaceous aestivation is characteristic of:", "o": ["Pea and Bean (Fabaceae)", "China rose", "Calotropis", "Cassia"], "a": "Pea and Bean (Fabaceae)"},
    {"id": 956, "q": "In Vexillary aestivation, the largest petal is called:", "o": ["Standard or Vexillum", "Wing or Alae", "Keel or Carina", "Sepal"], "a": "Standard or Vexillum"},
    {"id": 957, "q": "Staminode is a:", "o": ["Sterile stamen", "Fertile stamen", "Fused stamen", "Petal"], "a": "Sterile stamen"},
    {"id": 958, "q": "Epipetalous stamens (attached to petals) are found in:", "o": ["Brinjal", "Lily", "Mustard", "China rose"], "a": "Brinjal"},
    {"id": 959, "q": "Epiphyllous stamens (attached to perianth) are found in:", "o": ["Lily", "Brinjal", "Mustard", "Pea"], "a": "Lily"},
    {"id": 960, "q": "Monoadelphous stamens (one bunch) are found in:", "o": ["China rose", "Pea", "Citrus", "Salvia"], "a": "China rose"},
    {"id": 961, "q": "Diadelphous stamens (two bunches) are found in:", "o": ["Pea", "China rose", "Citrus", "Mustard"], "a": "Pea"},
    {"id": 962, "q": "Polyadelphous stamens (more than two bundles) are found in:", "o": ["Citrus", "Pea", "China rose", "Tomato"], "a": "Citrus"},
    {"id": 963, "q": "Variation in the length of filaments is seen in:", "o": ["Salvia and Mustard", "Pea and Bean", "China rose", "Citrus"], "a": "Salvia and Mustard"},
    {"id": 964, "q": "Apocarpous (carpels free) gynoecium is seen in:", "o": ["Lotus and Rose", "Mustard and Tomato", "Pea", "Hibiscus"], "a": "Lotus and Rose"},
    {"id": 965, "q": "Syncarpous (carpels fused) gynoecium is seen in:", "o": ["Mustard and Tomato", "Lotus and Rose", "Michelias", "None"], "a": "Mustard and Tomato"},
    {"id": 966, "q": "Marginal placentation is characteristic of:", "o": ["Pea", "China rose", "Argemone", "Dianthus"], "a": "Pea"},
    {"id": 967, "q": "Axile placentation is seen in:", "o": ["China rose, Tomato, Lemon", "Pea", "Mustard, Argemone", "Dianthus, Primrose"], "a": "China rose, Tomato, Lemon"},
    {"id": 968, "q": "Parietal placentation is seen in:", "o": ["Mustard and Argemone", "Pea", "China rose", "Dianthus"], "a": "Mustard and Argemone"},
    {"id": 969, "q": "Free central placentation is seen in:", "o": ["Dianthus and Primrose", "Mustard", "Pea", "Sunflower"], "a": "Dianthus and Primrose"},
    {"id": 970, "q": "Basal placentation is seen in:", "o": ["Sunflower and Marigold", "Pea", "Mustard", "Lemon"], "a": "Sunflower and Marigold"},

    # --- FRUIT AND SEED ---
    {"id": 971, "q": "A fruit formed without fertilization of the ovary is called:", "o": ["Parthenocarpic fruit", "False fruit", "True fruit", "Drupe"], "a": "Parthenocarpic fruit"},
    {"id": 972, "q": "Parthenocarpic fruit example:", "o": ["Banana", "Apple", "Mango", "Strawberry"], "a": "Banana"},
    {"id": 973, "q": "In Mango and Coconut, the fruit is known as a:", "o": ["Drupe", "Berry", "Pepo", "Pome"], "a": "Drupe"},
    {"id": 974, "q": "Drupes develop from:", "o": ["Monocarpellary superior ovaries", "Multicarpellary inferior ovaries", "Monocarpellary inferior ovaries", "Bicarpellary superior ovaries"], "a": "Monocarpellary superior ovaries"},
    {"id": 975, "q": "In Coconut, the mesocarp is:", "o": ["Fibrous", "Fleshy and edible", "Stony", "Absent"], "a": "Fibrous"},
    {"id": 976, "q": "In Mango, the edible part is:", "o": ["Fleshy mesocarp", "Epicarp", "Stony Endocarp", "Seed"], "a": "Fleshy mesocarp"},
    {"id": 977, "q": "Aleurone layer in monocot seeds is:", "o": ["Proteinaceous", "Starchy", "Lipid rich", "Cellulosic"], "a": "Proteinaceous"},
    {"id": 978, "q": "The shield-shaped cotyledon in maize grain is called:", "o": ["Scutellum", "Coleoptile", "Coleorhiza", "Plumule"], "a": "Scutellum"},

    # --- FAMILIES (FABACEAE, SOLANACEAE, LILIACEAE) ---
    {"id": 979, "q": "Which family is characterized by Pulvinate leaf base, Vexillary aestivation and Diadelphous stamens?", "o": ["Fabaceae", "Solanaceae", "Liliaceae", "Brassicaceae"], "a": "Fabaceae"},
    {"id": 980, "q": "Examples of pulses belonging to Fabaceae are:", "o": ["Gram, Arhar, Sem, Moong, Soyabean", "Tomato, Brinjal", "Tulip, Gloriosa", "Mustard"], "a": "Gram, Arhar, Sem, Moong, Soyabean"},
    {"id": 981, "q": "Edible oil yielding plants of Fabaceae:", "o": ["Soyabean, Groundnut", "Mustard", "Coconut", "Castor"], "a": "Soyabean, Groundnut"},
    {"id": 982, "q": "Dye 'Indigofera' belongs to:", "o": ["Fabaceae", "Solanaceae", "Liliaceae", "Malvaceae"], "a": "Fabaceae"},
    {"id": 983, "q": "Fodder plants 'Sesbania and Trifolium' belong to:", "o": ["Fabaceae", "Solanaceae", "Liliaceae", "Poaceae"], "a": "Fabaceae"},
    {"id": 984, "q": "Which family is commonly called the 'Potato family'?", "o": ["Solanaceae", "Fabaceae", "Liliaceae", "Brassicaceae"], "a": "Solanaceae"},
    {"id": 985, "q": "Persistent Calyx and Swollen Placenta are characteristic features of:", "o": ["Solanaceae", "Fabaceae", "Liliaceae", "Brassicaceae"], "a": "Solanaceae"},
    {"id": 986, "q": "Obliquely placed ovary is found in:", "o": ["Solanaceae", "Fabaceae", "Liliaceae", "Brassicaceae"], "a": "Solanaceae"},
    {"id": 987, "q": "Important food plants of Solanaceae:", "o": ["Tomato, Brinjal, Potato", "Pea, Bean", "Onion, Garlic", "Mustard"], "a": "Tomato, Brinjal, Potato"},
    {"id": 988, "q": "Medicinal plants 'Belladonna' and 'Ashwagandha' belong to:", "o": ["Solanaceae", "Fabaceae", "Liliaceae", "Poaceae"], "a": "Solanaceae"},
    {"id": 989, "q": "Tobacco (Fumigatory) belongs to:", "o": ["Solanaceae", "Fabaceae", "Liliaceae", "Malvaceae"], "a": "Solanaceae"},
    {"id": 990, "q": "Which family is characterized by Perianth (Tepals) and Epiphyllous stamens?", "o": ["Liliaceae", "Solanaceae", "Fabaceae", "Brassicaceae"], "a": "Liliaceae"},
    {"id": 991, "q": "Tricarpellary, syncarpous, superior ovary with axile placentation is found in:", "o": ["Liliaceae", "Solanaceae", "Fabaceae", "Brassicaceae"], "a": "Liliaceae"},
    {"id": 992, "q": "Colchicine (used to double chromosome number) is obtained from Colchicum autumnale, belonging to:", "o": ["Liliaceae", "Solanaceae", "Fabaceae", "Poaceae"], "a": "Liliaceae"},
    {"id": 993, "q": "Aloe (Medicine), Asparagus (Vegetable), and Tulip (Ornamental) belong to:", "o": ["Liliaceae", "Solanaceae", "Fabaceae", "Brassicaceae"], "a": "Liliaceae"},
    {"id": 994, "q": "Cruciform corolla and Tetradynamous stamens (2+4) are characteristic of:", "o": ["Brassicaceae (Mustard)", "Fabaceae", "Solanaceae", "Liliaceae"], "a": "Brassicaceae (Mustard)"},
    {"id": 995, "q": "Replum (False septum) is found in the ovary of:", "o": ["Mustard and Argemone", "Pea", "Tomato", "Lemon"], "a": "Mustard and Argemone"},
    {"id": 996, "q": "Siliqua fruit is characteristic of:", "o": ["Brassicaceae", "Fabaceae", "Solanaceae", "Liliaceae"], "a": "Brassicaceae"},
    {"id": 997, "q": "Marginal placentation, Monocarpellary ovary, Pod fruit. Identify the family:", "o": ["Fabaceae", "Solanaceae", "Liliaceae", "Brassicaceae"], "a": "Fabaceae"},
    {"id": 998, "q": "Flower is Zygomorphic in:", "o": ["Fabaceae", "Solanaceae (Actinomorphic)", "Liliaceae (Actinomorphic)", "Brassicaceae (Actinomorphic usually)"], "a": "Fabaceae"},
    {"id": 999, "q": "Sunhemp (Fibre) belongs to:", "o": ["Fabaceae", "Solanaceae", "Liliaceae", "Malvaceae"], "a": "Fabaceae"},
    {"id": 1000, "q": "Petunia (Ornamental) belongs to:", "o": ["Solanaceae", "Fabaceae", "Liliaceae", "Brassicaceae"], "a": "Solanaceae"},
    
    # --- THE ROOT ---
    {"id": 901, "q": "The primary root and its branches constitute the:", "o": ["Tap root system", "Fibrous root system", "Adventitious root system", "Prop root system"], "a": "Tap root system"},
    {"id": 902, "q": "Tap root system is seen in:", "o": ["Mustard plant (Dicot)", "Wheat plant (Monocot)", "Monstera", "Grass"], "a": "Mustard plant (Dicot)"},
    {"id": 903, "q": "In monocotyledonous plants, the primary root is short-lived and replaced by a large number of roots originating from the base of the stem. This is:", "o": ["Fibrous root system", "Tap root system", "Adventitious root system", "Stilt roots"], "a": "Fibrous root system"},
    {"id": 904, "q": "Roots arising from parts of the plant other than the radicle are called:", "o": ["Adventitious roots", "Tap roots", "Fibrous roots", "Primary roots"], "a": "Adventitious roots"},
    {"id": 905, "q": "Examples of Adventitious roots are:", "o": ["Grass, Monstera and Banyan tree", "Mustard and Gram", "Wheat and Maize", "Carrot and Turnip"], "a": "Grass, Monstera and Banyan tree"},
    {"id": 906, "q": "Swollen roots for food storage are found in:", "o": ["Carrot, Turnip, Sweet Potato", "Potato, Ginger, Turmeric", "Onion, Garlic", "Wheat, Maize"], "a": "Carrot, Turnip, Sweet Potato"},
    {"id": 907, "q": "Sweet potato is a modified:", "o": ["Adventitious root", "Tap root", "Stem", "Leaf"], "a": "Adventitious root"},
    {"id": 908, "q": "Turnip and Carrot are modified:", "o": ["Tap roots", "Adventitious roots", "Stems", "Rhizomes"], "a": "Tap roots"},
    {"id": 909, "q": "Prop roots are hanging structures that support the tree. They are found in:", "o": ["Banyan tree", "Maize", "Sugarcane", "Rhizophora"], "a": "Banyan tree"},
    {"id": 910, "q": "Stilt roots arise from the lower nodes of the stem to support the plant. They are seen in:", "o": ["Maize and Sugarcane", "Banyan and Peepal", "Carrot and Turnip", "Potato"], "a": "Maize and Sugarcane"},
    {"id": 911, "q": "Pneumatophores are respiratory roots found in plants growing in swampy areas, such as:", "o": ["Rhizophora", "Banyan", "Maize", "Pistia"], "a": "Rhizophora"},
    {"id": 912, "q": "Pneumatophores help in:", "o": ["Getting oxygen for respiration", "Photosynthesis", "Absorption of water", "Anchorage only"], "a": "Getting oxygen for respiration"},

    # --- THE STEM (MODIFICATIONS) ---
    {"id": 913, "q": "Underground stems of potato, ginger, turmeric, zaminkand, and colocasia are modified to:", "o": ["Store food", "Photosynthesize", "Absorb water", "Support leaves"], "a": "Store food"},
    {"id": 914, "q": "Stem tendrils which develop from axillary buds are found in:", "o": ["Gourds (cucumber, pumpkins, watermelon) and Grapevines", "Pea and Beans", "Citrus and Bougainvillea", "Opuntia"], "a": "Gourds (cucumber, pumpkins, watermelon) and Grapevines"},
    {"id": 915, "q": "Thorns are woody, straight and pointed structures developed from axillary buds. They are found in:", "o": ["Citrus and Bougainvillea", "Pea and Bean", "Cucumber and Pumpkin", "Opuntia and Euphorbia"], "a": "Citrus and Bougainvillea"},
    {"id": 916, "q": "Thorns protect plants from:", "o": ["Browsing animals", "Excess heat", "Cold", "Insects"], "a": "Browsing animals"},
    {"id": 917, "q": "Flattened stem (Phylloclade) performing photosynthesis is found in:", "o": ["Opuntia", "Euphorbia", "Bougainvillea", "Citrus"], "a": "Opuntia"},
    {"id": 918, "q": "Cylindrical fleshy stem (Phylloclade) performing photosynthesis is found in:", "o": ["Euphorbia", "Opuntia", "Cactus", "Acacia"], "a": "Euphorbia"},
    {"id": 919, "q": "Underground stems of some plants spread to new niches and when older parts die, new plants are formed. Examples are:", "o": ["Grass and Strawberry", "Mint and Jasmine", "Pistia and Eichhornia", "Banana and Pineapple"], "a": "Grass and Strawberry"},
    {"id": 920, "q": "In Mint and Jasmine, a slender lateral branch arises from the base of the main axis and grows aerially for some time before arching downwards to touch the ground. This is called:", "o": ["Stolon", "Runner", "Offset", "Sucker"], "a": "Stolon"},
    {"id": 921, "q": "A lateral branch with short internodes and each node bearing a rosette of leaves and a tuft of roots is found in aquatic plants like:", "o": ["Pistia and Eichhornia", "Grass and Strawberry", "Mint and Jasmine", "Banana and Pineapple"], "a": "Pistia and Eichhornia"},
    {"id": 922, "q": "In Banana, Pineapple and Chrysanthemum, the lateral branches originate from the basal underground portion of the main stem and grow obliquely upward. This is called:", "o": ["Sucker", "Stolon", "Runner", "Offset"], "a": "Sucker"},

    # --- THE LEAF ---
    {"id": 923, "q": "The green expanded part of the leaf with veins and veinlets is known as:", "o": ["Lamina or Leaf blade", "Petiole", "Stipule", "Pulvinus"], "a": "Lamina or Leaf blade"},
    {"id": 924, "q": "A swollen leaf base (Pulvinus) is found in:", "o": ["Leguminous plants", "Monocots", "Grasses", "Mustard"], "a": "Leguminous plants"},
    {"id": 925, "q": "Reticulate venation is generally a characteristic of:", "o": ["Dicots", "Monocots", "Gymnosperms", "Pteridophytes"], "a": "Dicots"},
    {"id": 926, "q": "Parallel venation is generally a characteristic of:", "o": ["Monocots", "Dicots", "Ferns", "Mosses"], "a": "Monocots"},
    {"id": 927, "q": "In a pinnately compound leaf, a number of leaflets are present on a common axis called:", "o": ["Rachis", "Petiole", "Midrib", "Vein"], "a": "Rachis"},
    {"id": 928, "q": "Neem is an example of:", "o": ["Pinnately compound leaf", "Palmately compound leaf", "Simple leaf", "Whorled leaf"], "a": "Pinnately compound leaf"},
    {"id": 929, "q": "Silk Cotton (Bombax) is an example of:", "o": ["Palmately compound leaf", "Pinnately compound leaf", "Simple leaf", "Alternate phyllotaxy"], "a": "Palmately compound leaf"},
    {"id": 930, "q": "Alternate phyllotaxy (single leaf at each node) is seen in:", "o": ["China rose, Mustard, Sun flower", "Calotropis and Guava", "Alstonia", "Neem"], "a": "China rose, Mustard, Sun flower"},
    {"id": 931, "q": "Opposite phyllotaxy (pair of leaves at each node) is seen in:", "o": ["Calotropis and Guava", "China rose and Mustard", "Alstonia", "Sunflower"], "a": "Calotropis and Guava"},
    {"id": 932, "q": "Whorled phyllotaxy (more than two leaves at a node) is seen in:", "o": ["Alstonia", "Calotropis", "China rose", "Guava"], "a": "Alstonia"},
    {"id": 933, "q": "Leaves are modified into tendrils for climbing in:", "o": ["Peas", "Cactus", "Onion", "Australian Acacia"], "a": "Peas"},
    {"id": 934, "q": "Leaves are modified into spines for defense in:", "o": ["Cacti", "Peas", "Onion", "Garlic"], "a": "Cacti"},
    {"id": 935, "q": "Fleshy leaves store food in:", "o": ["Onion and Garlic", "Pea and Bean", "Cactus and Acacia", "Rose and Jasmine"], "a": "Onion and Garlic"},
    {"id": 936, "q": "In Australian Acacia, the leaves are small and short-lived. The ______ expands, becomes green and synthesizes food.", "o": ["Petiole (Phyllode)", "Stipule", "Stem", "Rachis"], "a": "Petiole (Phyllode)"},
    {"id": 937, "q": "Pitcher plant and Venus-fly trap are examples of:", "o": ["Insectivorous plants (modified leaves)", "Parasitic plants", "Symbiotic plants", "Saprophytic plants"], "a": "Insectivorous plants (modified leaves)"},

    # --- INFLORESCENCE ---
    {"id": 938, "q": "The arrangement of flowers on the floral axis is termed as:", "o": ["Inflorescence", "Phyllotaxy", "Placentation", "Aestivation"], "a": "Inflorescence"},
    {"id": 939, "q": "In Racemose inflorescence, the main axis:", "o": ["Continues to grow", "Terminates in a flower", "Stops growing", "Becomes a thorn"], "a": "Continues to grow"},
    {"id": 940, "q": "In Racemose inflorescence, flowers are borne in:", "o": ["Acropetal succession", "Basipetal succession", "Random order", "Whorls"], "a": "Acropetal succession"},
    {"id": 941, "q": "In Cymose inflorescence, the main axis:", "o": ["Terminates in a flower", "Continues to grow", "Forms a tendril", "Forms a leaf"], "a": "Terminates in a flower"},
    {"id": 942, "q": "In Cymose inflorescence, flowers are borne in:", "o": ["Basipetal order", "Acropetal order", "Zig-zag order", "Spiral order"], "a": "Basipetal order"},
    {"id": 943, "q": "Solanum (Potato genus) shows which type of inflorescence?", "o": ["Cymose", "Racemose", "Spadix", "Verticillaster"], "a": "Cymose"},
    
    # --- COMPARATIVE PHYSIOLOGY (VERY IMPORTANT) ---
    {"id": 817, "q": "Which of the following animals has a 4-chambered heart despite being a reptile?", "o": ["Crocodile", "Turtle", "Lizard", "Snake"], "a": "Crocodile"},
    {"id": 818, "q": "Three-chambered heart is found in:", "o": ["Amphibians and Reptiles (except crocodiles)", "Birds and Mammals", "Fish and Amphibians", "Only Reptiles"], "a": "Amphibians and Reptiles (except crocodiles)"},
    {"id": 819, "q": "Two-chambered heart occurs in:", "o": ["Fishes", "Amphibians", "Birds", "Reptiles"], "a": "Fishes"},
    {"id": 820, "q": "Which of the following phyla has a closed circulatory system?", "o": ["Annelida and Chordata", "Arthropoda and Mollusca", "Hemichordata and Echinodermata", "Platyhelminthes"], "a": "Annelida and Chordata"},
    {"id": 821, "q": "Open circulatory system is present in:", "o": ["Arthropoda, Mollusca, Hemichordata", "Annelida, Chordata", "Cephalopods", "Vertebrates"], "a": "Arthropoda, Mollusca, Hemichordata"},
    {"id": 822, "q": "Malpighian tubules are the excretory organs in:", "o": ["Insects (Arthropods)", "Annelids", "Flatworms", "Crustaceans"], "a": "Insects (Arthropods)"},
    {"id": 823, "q": "Flame cells (Solenocytes) are excretory structures of:", "o": ["Platyhelminthes", "Aschelminthes", "Annelida", "Mollusca"], "a": "Platyhelminthes"},
    {"id": 824, "q": "Nephridia help in excretion and osmoregulation in:", "o": ["Annelida", "Arthropoda", "Porifera", "Cnidaria"], "a": "Annelida"},
    {"id": 825, "q": "Green glands (Antennal glands) perform excretion in:", "o": ["Crustaceans (Prawns)", "Insects", "Arachnids", "Molluscs"], "a": "Crustaceans (Prawns)"},
    {"id": 826, "q": "Proboscis gland is the excretory organ of:", "o": ["Hemichordata", "Urochordata", "Cephalochordata", "Vertebrata"], "a": "Hemichordata"},
    {"id": 827, "q": "Which of the following is Homeothermic (Warm-blooded)?", "o": ["Corvus (Crow)", "Testudo", "Rana", "Scoliodon"], "a": "Corvus (Crow)"},
    {"id": 828, "q": "Which of the following is Poikilothermic (Cold-blooded)?", "o": ["Cobra", "Penguin", "Whale", "Bat"], "a": "Cobra"},
    {"id": 829, "q": "Which animal group is entirely marine?", "o": ["Echinodermata, Ctenophora, Hemichordata", "Porifera, Cnidaria", "Mollusca, Arthropoda", "Chordata"], "a": "Echinodermata, Ctenophora, Hemichordata"},

    # --- SPECIFIC EXAMPLES & COMMON NAMES (RAPID FIRE) ---
    {"id": 830, "q": "Clarias is commonly known as:", "o": ["Magur", "Rohu", "Katla", "Singhi"], "a": "Magur"},
    {"id": 831, "q": "Betta is:", "o": ["Fighting fish", "Angel fish", "Flying fish", "Dog fish"], "a": "Fighting fish"},
    {"id": 832, "q": "Pterophyllum is:", "o": ["Angel fish", "Fighting fish", "Saw fish", "Sucker fish"], "a": "Angel fish"},
    {"id": 833, "q": "Ascidia, Salpa, and Doliolum belong to:", "o": ["Urochordata", "Cephalochordata", "Hemichordata", "Vertebrata"], "a": "Urochordata"},
    {"id": 834, "q": "Physalia is called Portuguese man-of-war because:", "o": ["It resembles a warship", "It is found in Portugal", "It fights with other animals", "It has a gun-like organ"], "a": "It resembles a warship"},
    {"id": 835, "q": "Pennatula is:", "o": ["Sea Pen", "Sea Fan", "Sea Hare", "Sea Lily"], "a": "Sea Pen"},
    {"id": 836, "q": "Gorgonia is:", "o": ["Sea Fan", "Sea Pen", "Brain Coral", "Red Coral"], "a": "Sea Fan"},
    {"id": 837, "q": "Meandrina is:", "o": ["Brain Coral", "Organ Pipe Coral", "Blue Coral", "Red Coral"], "a": "Brain Coral"},
    {"id": 838, "q": "Limulus is:", "o": ["King Crab (Living Fossil)", "Locust", "Lobster", "Crab"], "a": "King Crab (Living Fossil)"},
    {"id": 839, "q": "Locusta is a:", "o": ["Gregarious Pest", "Vector", "Useful insect", "Pollinator"], "a": "Gregarious Pest"},
    {"id": 840, "q": "Bombyx mori produces:", "o": ["Silk", "Lac", "Honey", "Wax"], "a": "Silk"},
    {"id": 841, "q": "Laccifer produces:", "o": ["Lac", "Silk", "Honey", "Pearl"], "a": "Lac"},
    {"id": 842, "q": "Aplysia is:", "o": ["Sea Hare", "Sea Lemon", "Sea Cow", "Sea Horse"], "a": "Sea Hare"},
    {"id": 843, "q": "Dentalium is:", "o": ["Tusk Shell", "Pearl Oyster", "Cuttle fish", "Squid"], "a": "Tusk Shell"},
    {"id": 844, "q": "Chaetopleura is:", "o": ["Chiton", "Dentalium", "Pila", "Unio"], "a": "Chiton"},
    {"id": 845, "q": "Sepia is:", "o": ["Cuttlefish", "Squid", "Octopus", "Oyster"], "a": "Cuttlefish"},
    {"id": 846, "q": "Loligo is:", "o": ["Squid", "Cuttlefish", "Snail", "Slug"], "a": "Squid"},
    {"id": 847, "q": "Ophiura is:", "o": ["Brittle Star", "Star Fish", "Sea Lily", "Sea Urchin"], "a": "Brittle Star"},
    {"id": 848, "q": "Antedon is:", "o": ["Sea Lily", "Sea Fan", "Sea Pen", "Sea Cucumber"], "a": "Sea Lily"},
    {"id": 849, "q": "Echinus is:", "o": ["Sea Urchin", "Sea Mouse", "Sea Hare", "Sea Lion"], "a": "Sea Urchin"},
    {"id": 850, "q": "Cucumaria is:", "o": ["Sea Cucumber", "Sea Squash", "Sea Melon", "Sea Gourd"], "a": "Sea Cucumber"},

    # --- UNIQUE FEATURES & EXCEPTIONS ---
    {"id": 851, "q": "Which mammal is Oviparous (Egg-laying)?", "o": ["Platypus (Ornithorhynchus)", "Kangaroo", "Whale", "Bat"], "a": "Platypus (Ornithorhynchus)"},
    {"id": 852, "q": "Which of the following is a flightless bird?", "o": ["Struthio (Ostrich)", "Psittacula", "Pavo", "Neophron"], "a": "Struthio (Ostrich)"},
    {"id": 853, "q": "Pneumatic bones (hollow bones) are an adaptation for:", "o": ["Flight", "Swimming", "Running", "Burrowing"], "a": "Flight"},
    {"id": 854, "q": "Which fish has a cartilaginous skeleton but a terminal mouth? (Trick question, usually bony have terminal)", "o": ["None (Exception check)", "Labeo", "Catla", "Clarias"], "a": "Labeo"}, # Usually Bony fish have terminal mouth.
    {"id": 855, "q": "In which group does the Notochord extend from head to tail and persist throughout life?", "o": ["Cephalochordata", "Urochordata", "Vertebrata", "Hemichordata"], "a": "Cephalochordata"},
    {"id": 856, "q": "Retrogressive metamorphosis (Larva is more advanced than adult) is seen in:", "o": ["Urochordata (Ascidia)", "Cephalochordata", "Amphibians", "Cyclostomes"], "a": "Urochordata (Ascidia)"},
    {"id": 857, "q": "Radula (rasping organ) is present in Molluscs but absent in:", "o": ["Bivalves (like Oysters)", "Snails", "Squids", "Octopus"], "a": "Bivalves (like Oysters)"},
    {"id": 858, "q": "A water vascular system is characteristic of:", "o": ["Echinodermata", "Porifera", "Cnidaria", "Mollusca"], "a": "Echinodermata"},
    {"id": 859, "q": "A water canal system is characteristic of:", "o": ["Porifera", "Echinodermata", "Coelenterata", "Platyhelminthes"], "a": "Porifera"},
    {"id": 860, "q": "Metagenesis (Alternation of generation) is shown by:", "o": ["Obelia", "Hydra", "Aurelia", "Adamsia"], "a": "Obelia"},
    {"id": 861, "q": "Bioluminescence is well marked in:", "o": ["Ctenoplana", "Physalia", "Fasciola", "Nereis"], "a": "Ctenoplana"},
    {"id": 862, "q": "Which of the following is a 'Living Fossil'?", "o": ["Limulus", "Locusta", "Bombyx", "Apis"], "a": "Limulus"},
    {"id": 863, "q": "Which sponge lives in fresh water?", "o": ["Spongilla", "Sycon", "Euspongia", "Leucosolenia"], "a": "Spongilla"},
    {"id": 864, "q": "Which organism has both plant and animal-like characteristics?", "o": ["Euglena", "Paramecium", "Amoeba", "Plasmodium"], "a": "Euglena"},
    
    # --- ANATOMY & SYSTEMS ---
    {"id": 865, "q": "Direct development (No larval stage) is found in:", "o": ["Humans, Earthworm", "Frogs, Insects", "Silkworm, Butterfly", "Obelia"], "a": "Humans, Earthworm"},
    {"id": 866, "q": "Indirect development involves:", "o": ["Larval stages", "No larva", "Direct growth", "Vivipary"], "a": "Larval stages"},
    {"id": 867, "q": "Body is covered by dry and cornified skin with scales in:", "o": ["Reptiles", "Amphibians", "Fish", "Birds"], "a": "Reptiles"},
    {"id": 868, "q": "Air sacs connected to lungs mainly supplement:", "o": ["Respiration in Birds", "Buoyancy in Fish", "Digestion in Mammals", "Excretion in Reptiles"], "a": "Respiration in Birds"},
    {"id": 869, "q": "Mammary glands are modified:", "o": ["Sweat glands", "Sebaceous glands", "Scent glands", "Endocrine glands"], "a": "Sweat glands"},
    {"id": 870, "q": "Diaphragm is a characteristic feature of:", "o": ["Mammals", "Birds", "Reptiles", "Amphibians"], "a": "Mammals"},
    {"id": 871, "q": "The sound-producing organ in birds is called:", "o": ["Syrinx", "Larynx", "Pharynx", "Trachea"], "a": "Syrinx"},
    {"id": 872, "q": "Cloaca is found in:", "o": ["Amphibians, Reptiles, Birds", "Only Mammals", "Only Fish", "Only Birds"], "a": "Amphibians, Reptiles, Birds"},
    {"id": 873, "q": "Pinna (external ear) is absent in:", "o": ["Reptiles, Amphibians, Birds", "Mammals", "Humans", "Bats"], "a": "Reptiles, Amphibians, Birds"},
    {"id": 874, "q": "Crop and Gizzard are found in the digestive system of:", "o": ["Birds and Cockroaches", "Humans", "Frogs", "Fish"], "a": "Birds and Cockroaches"},
    {"id": 875, "q": "Which of the following is a cold-blooded animal?", "o": ["Shark", "Whale", "Dolphin", "Camel"], "a": "Shark"},

    # --- MATCHING LOGIC (CONVERTED TO MCQ) ---
    {"id": 876, "q": "Select the correct match: Petromyzon -> ?", "o": ["Ectoparasite", "Endoparasite", "Symbiont", "Commensal"], "a": "Ectoparasite"},
    {"id": 877, "q": "Select the correct match: Adamsia -> ?", "o": ["Sea anemone", "Sea pen", "Sea fan", "Brain coral"], "a": "Sea anemone"},
    {"id": 878, "q": "Select the correct match: Radula -> ?", "o": ["Mollusca", "Arthropoda", "Annelida", "Echinodermata"], "a": "Mollusca"},
    {"id": 879, "q": "Select the correct match: Air Bladder -> ?", "o": ["Osteichthyes", "Chondrichthyes", "Cyclostomata", "Amphibia"], "a": "Osteichthyes"},
    {"id": 880, "q": "Select the correct match: Notochord persists throughout life -> ?", "o": ["Cephalochordata", "Urochordata", "Vertebrata", "Hemichordata"], "a": "Cephalochordata"},

    # --- ADVANCED / TRICKY ONES ---
    {"id": 881, "q": "Ichthyophis belongs to Amphibia but looks like:", "o": ["A worm/Snake", "A frog", "A lizard", "A fish"], "a": "A worm/Snake"},
    {"id": 882, "q": "Which shark is known as the Great White Shark?", "o": ["Carcharodon", "Scoliodon", "Pristis", "Trygon"], "a": "Carcharodon"},
    {"id": 883, "q": "The poisonous sting in Trygon (Sting ray) is a modification of:", "o": ["Dorsal fin", "Pelvic fin", "Pectoral fin", "Tail"], "a": "Dorsal fin"}, # Note: Often associated with tail base
    {"id": 884, "q": "Which bird cannot fly?", "o": ["Aptenodytes (Penguin)", "Corvus", "Psittacula", "Pavo"], "a": "Aptenodytes (Penguin)"},
    {"id": 885, "q": "Identify the mammal that lives in water:", "o": ["Balaenoptera (Blue Whale)", "Macropus", "Felis", "Elephas"], "a": "Balaenoptera (Blue Whale)"},
    {"id": 886, "q": "Which of the following is NOT a true fish?", "o": ["Silver fish (Insect)", "Dog fish", "Saw fish", "Flying fish"], "a": "Silver fish (Insect)"},
    {"id": 887, "q": "Which of the following is NOT a true fish?", "o": ["Jelly fish (Cnidaria)", "Sea horse", "Fighting fish", "Rohu"], "a": "Jelly fish (Cnidaria)"},
    {"id": 888, "q": "Which of the following is NOT a true fish?", "o": ["Star fish (Echinoderm)", "Electric ray", "Sting ray", "Magur"], "a": "Star fish (Echinoderm)"},
    {"id": 889, "q": "Which of the following is NOT a true fish?", "o": ["Cuttle fish (Mollusc)", "Shark", "Eel", "Salmon"], "a": "Cuttle fish (Mollusc)"},
    {"id": 890, "q": "Which of the following is a true fish?", "o": ["Sea horse", "Jelly fish", "Star fish", "Silver fish"], "a": "Sea horse"},
    
    # --- FINAL WRAP UP ---
    {"id": 891, "q": "Presence of a post-anal tail is a characteristic of:", "o": ["Chordates", "Non-chordates", "All animals", "Invertebrates"], "a": "Chordates"},
    {"id": 892, "q": "Bilateral symmetry, Triploblastic, Coelomate and Segmented body is seen in:", "o": ["Annelida, Arthropoda, Chordata", "Platyhelminthes", "Aschelminthes", "Cnidaria"], "a": "Annelida, Arthropoda, Chordata"},
    {"id": 893, "q": "Which phylum is exclusively marine?", "o": ["Echinodermata", "Mollusca", "Arthropoda", "Annelida"], "a": "Echinodermata"},
    {"id": 894, "q": "External fertilization and indirect development is characteristic of:", "o": ["Ctenophora and Echinodermata", "Mammals", "Birds", "Reptiles"], "a": "Ctenophora and Echinodermata"},
    {"id": 895, "q": "Internal fertilization is seen in:", "o": ["Porifera, Platyhelminthes, Aschelminthes", "Ctenophora", "Echinodermata", "All Algae"], "a": "Porifera, Platyhelminthes, Aschelminthes"},
    {"id": 896, "q": "Which is the correct evolutionary sequence?", "o": ["Porifera -> Cnidaria -> Platyhelminthes -> Aschelminthes", "Cnidaria -> Porifera -> Annelida", "Arthropoda -> Annelida -> Mollusca", "Chordata -> Hemichordata -> Echinodermata"], "a": "Porifera -> Cnidaria -> Platyhelminthes -> Aschelminthes"},
    {"id": 897, "q": "Ventral nerve cord is characteristic of:", "o": ["Non-chordates", "Chordates", "Vertebrates", "Humans"], "a": "Non-chordates"},
    {"id": 898, "q": "Notochord is ectodermal in origin. This statement is:", "o": ["False (It is Mesodermal)", "True", "Partially true", "Valid for Urochordates"], "a": "False (It is Mesodermal)"},
    {"id": 899, "q": "Which organism has a beak but no teeth?", "o": ["Birds", "Reptiles", "Mammals", "Amphibians"], "a": "Birds"},
    {"id": 900, "q": "The most successful parasites are:", "o": ["Platyhelminthes and Aschelminthes", "Porifera", "Cnidaria", "Mollusca"], "a": "Platyhelminthes and Aschelminthes"},
    # --- PHYLUM CHORDATA (BASICS) ---
    {"id": 716, "q": "The fundamental character of Chordata is the presence of:", "o": ["Notochord, Dorsal hollow nerve cord, Pharyngeal gill slits", "Ventral nerve cord, Solid notochord", "Diploblastic body", "Chitinous exoskeleton"], "a": "Notochord, Dorsal hollow nerve cord, Pharyngeal gill slits"},
    {"id": 717, "q": "In Chordates, the Central Nervous System (CNS) is:", "o": ["Dorsal, hollow and single", "Ventral, solid and double", "Dorsal, solid and double", "Ventral, hollow and single"], "a": "Dorsal, hollow and single"},
    {"id": 718, "q": "In Non-chordates (like Earthworm), the CNS is:", "o": ["Ventral, solid and double", "Dorsal, hollow and single", "Ventral, hollow and single", "Absent"], "a": "Ventral, solid and double"},
    {"id": 719, "q": "Phylum Chordata is divided into three subphyla: Urochordata, Cephalochordata and:", "o": ["Vertebrata", "Hemichordata", "Protochordata", "Gnathostomata"], "a": "Vertebrata"},
    {"id": 720, "q": "Urochordata and Cephalochordata are often referred to as:", "o": ["Protochordates", "Vertebrates", "Invertebrates", "Agnatha"], "a": "Protochordates"},
    {"id": 721, "q": "In Urochordata (Tunicata), the notochord is present:", "o": ["Only in larval tail", "Throughout life from head to tail", "In adults only", "Absent"], "a": "Only in larval tail"},
    {"id": 722, "q": "In Cephalochordata, the notochord extends:", "o": ["From head to tail region and persists throughout life", "Only in tail", "Only in larva", "Disappears in adult"], "a": "From head to tail region and persists throughout life"},
    {"id": 723, "q": "Examples of Urochordata include:", "o": ["Ascidia, Salpa, Doliolum", "Branchiostoma", "Petromyzon", "Myxine"], "a": "Ascidia, Salpa, Doliolum"},
    {"id": 724, "q": "Branchiostoma (Amphioxus or Lancelet) belongs to:", "o": ["Cephalochordata", "Urochordata", "Vertebrata", "Hemichordata"], "a": "Cephalochordata"},
    {"id": 725, "q": "The members of subphylum Vertebrata possess notochord during:", "o": ["Embryonic period only", "Adult period only", "Throughout life", "Never"], "a": "Embryonic period only"},
    {"id": 726, "q": "In adult vertebrates, the notochord is replaced by:", "o": ["Cartilaginous or bony vertebral column", "Nerve cord", "Gills", "Sternum"], "a": "Cartilaginous or bony vertebral column"},
    {"id": 727, "q": "All vertebrates are chordates but all chordates are not vertebrates. This statement is:", "o": ["True", "False", "Partially true", "Valid only for mammals"], "a": "True"},

    # --- CLASS CYCLOSTOMATA (JAWLESS FISH) ---
    {"id": 728, "q": "Cyclostomes are:", "o": ["Ectoparasites on some fishes", "Endoparasites", "Free living herbivores", "Symbionts"], "a": "Ectoparasites on some fishes"},
    {"id": 729, "q": "The body of Cyclostomes is devoid of:", "o": ["Scales and paired fins", "Gills", "Cranium", "Vertebral column"], "a": "Scales and paired fins"},
    {"id": 730, "q": "Cyclostomes have a sucking and circular mouth without:", "o": ["Jaws", "Teeth", "Tongue", "Muscles"], "a": "Jaws"},
    {"id": 731, "q": "How many pairs of gill slits are present in Cyclostomes for respiration?", "o": ["6-15 pairs", "2-4 pairs", "1 pair", "50-100 pairs"], "a": "6-15 pairs"},
    {"id": 732, "q": "Cyclostomes are marine but migrate for spawning to:", "o": ["Fresh water", "Deep ocean", "Brackish water", "Land"], "a": "Fresh water"},
    {"id": 733, "q": "After spawning, the adult Cyclostome:", "o": ["Dies", "Returns to ocean", "Becomes dormant", "Grows larger"], "a": "Dies"},
    {"id": 734, "q": "Petromyzon is commonly known as:", "o": ["Lamprey", "Hagfish", "Dogfish", "Sawfish"], "a": "Lamprey"},
    {"id": 735, "q": "Myxine is commonly known as:", "o": ["Hagfish", "Lamprey", "Electric ray", "Sucker fish"], "a": "Hagfish"},

    # --- CLASS CHONDRICHTHYES (CARTILAGINOUS FISH) ---
    {"id": 736, "q": "Chondrichthyes are marine animals with a:", "o": ["Streamlined body", "Flat body", "Round body", "Segmented body"], "a": "Streamlined body"},
    {"id": 737, "q": "They have an endoskeleton made of:", "o": ["Cartilage", "Bone", "Chitin", "Silica"], "a": "Cartilage"},
    {"id": 738, "q": "The mouth in Chondrichthyes is located:", "o": ["Ventrally", "Terminally", "Dorsally", "Laterally"], "a": "Ventrally"},
    {"id": 739, "q": "The Notochord in Chondrichthyes is:", "o": ["Persistent throughout life", "Absent in adults", "Replaced by bone", "Present only in tail"], "a": "Persistent throughout life"},
    {"id": 740, "q": "Gill slits are separate and without:", "o": ["Operculum (gill cover)", "Blood supply", "Filaments", "Arches"], "a": "Operculum (gill cover)"},
    {"id": 741, "q": "The skin is tough, containing minute:", "o": ["Placoid scales", "Cycloid scales", "Ctenoid scales", "Ganoid scales"], "a": "Placoid scales"},
    {"id": 742, "q": "Teeth in sharks are modified:", "o": ["Placoid scales which are backwardly directed", "Cycloid scales", "Bones", "Cartilage"], "a": "Placoid scales which are backwardly directed"},
    {"id": 743, "q": "Due to the absence of air bladder, they have to:", "o": ["Swim constantly to avoid sinking", "Float passively", "Live on surface", "Live in burrows"], "a": "Swim constantly to avoid sinking"},
    {"id": 744, "q": "Heart in fishes is:", "o": ["Two-chambered (one auricle, one ventricle)", "Three-chambered", "Four-chambered", "One-chambered"], "a": "Two-chambered (one auricle, one ventricle)"},
    {"id": 745, "q": "Which of the following possess electric organs?", "o": ["Torpedo", "Trygon", "Scoliodon", "Pristis"], "a": "Torpedo"},
    {"id": 746, "q": "Which of the following possesses a poison sting?", "o": ["Trygon", "Torpedo", "Carcharodon", "Pristis"], "a": "Trygon"},
    {"id": 747, "q": "Chondrichthyes are:", "o": ["Poikilothermous (Cold-blooded)", "Homoiothermous (Warm-blooded)", "Both", "None"], "a": "Poikilothermous (Cold-blooded)"},
    {"id": 748, "q": "In male sharks, pelvic fins bear:", "o": ["Claspers", "Spines", "Stings", "Tentacles"], "a": "Claspers"},
    {"id": 749, "q": "Fertilization in Chondrichthyes is generally:", "o": ["Internal", "External", "Absent", "In mouth"], "a": "Internal"},
    {"id": 750, "q": "Many of them are Viviparous. Example of Dog fish is:", "o": ["Scoliodon", "Pristis", "Carcharodon", "Trygon"], "a": "Scoliodon"},
    {"id": 751, "q": "Pristis is commonly known as:", "o": ["Saw fish", "Dog fish", "Great white shark", "Sting ray"], "a": "Saw fish"},
    {"id": 752, "q": "Carcharodon is:", "o": ["Great white shark", "Hammerhead shark", "Whale shark", "Tiger shark"], "a": "Great white shark"},

    # --- CLASS OSTEICHTHYES (BONY FISH) ---
    {"id": 753, "q": "Osteichthyes includes both marine and fresh water fishes with:", "o": ["Bony endoskeleton", "Cartilaginous endoskeleton", "Chitinous exoskeleton", "No skeleton"], "a": "Bony endoskeleton"},
    {"id": 754, "q": "The mouth in Osteichthyes is mostly:", "o": ["Terminal", "Ventral", "Dorsal", "Lateral"], "a": "Terminal"},
    {"id": 755, "q": "They have 4 pairs of gills which are covered by:", "o": ["Operculum on each side", "Skin flap", "Scales", "Nothing"], "a": "Operculum on each side"},
    {"id": 756, "q": "Skin is covered with:", "o": ["Cycloid/Ctenoid scales", "Placoid scales", "Hair", "Feathers"], "a": "Cycloid/Ctenoid scales"},
    {"id": 757, "q": "Air bladder is present which regulates:", "o": ["Buoyancy", "Digestion", "Reproduction", "Excretion"], "a": "Buoyancy"},
    {"id": 758, "q": "Fertilization in bony fishes is usually:", "o": ["External", "Internal", "In uterus", "In air bladder"], "a": "External"},
    {"id": 759, "q": "Exocoetus is commonly known as:", "o": ["Flying fish", "Sea horse", "Fighting fish", "Angel fish"], "a": "Flying fish"},
    {"id": 760, "q": "Hippocampus is known as:", "o": ["Sea horse", "Sea cow", "Sea lion", "River horse"], "a": "Sea horse"},
    {"id": 761, "q": "Freshwater bony fishes include:", "o": ["Labeo (Rohu), Catla (Katla), Clarias (Magur)", "Scoliodon, Pristis", "Exocoetus, Hippocampus", "Betta, Pterophyllum"], "a": "Labeo (Rohu), Catla (Katla), Clarias (Magur)"},
    {"id": 762, "q": "Aquarium fishes include:", "o": ["Betta (Fighting fish), Pterophyllum (Angel fish)", "Labeo, Catla", "Scoliodon, Trygon", "Magur, Rohu"], "a": "Betta (Fighting fish), Pterophyllum (Angel fish)"},

    # --- CLASS AMPHIBIA ---
    {"id": 763, "q": "Amphibians can live in:", "o": ["Aquatic as well as terrestrial habitats", "Only water", "Only land", "Air"], "a": "Aquatic as well as terrestrial habitats"},
    {"id": 764, "q": "Body of amphibians is divisible into:", "o": ["Head and Trunk", "Head, Thorax, Abdomen", "Cephalothorax and Abdomen", "Head and Tail only"], "a": "Head and Trunk"},
    {"id": 765, "q": "The amphibian skin is:", "o": ["Moist and without scales", "Dry and scaly", "Covered with hair", "Covered with feathers"], "a": "Moist and without scales"},
    {"id": 766, "q": "Which structure represents the ear in amphibians?", "o": ["Tympanum", "Pinna", "Cochlea", "Operculum"], "a": "Tympanum"},
    {"id": 767, "q": "The alimentary canal, urinary and reproductive tracts open into a common chamber called:", "o": ["Cloaca", "Anus", "Rectum", "Urethra"], "a": "Cloaca"},
    {"id": 768, "q": "Respiration in amphibians is by:", "o": ["Gills, lungs and skin", "Lungs only", "Skin only", "Gills only"], "a": "Gills, lungs and skin"},
    {"id": 769, "q": "Heart in amphibians is:", "o": ["Three-chambered (2 auricles, 1 ventricle)", "Two-chambered", "Four-chambered", "One-chambered"], "a": "Three-chambered (2 auricles, 1 ventricle)"},
    {"id": 770, "q": "Fertilization in amphibians is:", "o": ["External", "Internal", "In uterus", "Absent"], "a": "External"},
    {"id": 771, "q": "Bufo is:", "o": ["Toad", "Frog", "Tree frog", "Salamander"], "a": "Toad"},
    {"id": 772, "q": "Rana is:", "o": ["Frog", "Toad", "Tree frog", "Limbless amphibia"], "a": "Frog"},
    {"id": 773, "q": "Hyla is:", "o": ["Tree frog", "Toad", "Mud puppy", "Blind worm"], "a": "Tree frog"},
    {"id": 774, "q": "Salamandra is:", "o": ["Salamander", "Lizard", "Frog", "Snake"], "a": "Salamander"},
    {"id": 775, "q": "Ichthyophis is a:", "o": ["Limbless amphibia", "Lizard", "Snake", "Fish"], "a": "Limbless amphibia"},

    # --- CLASS REPTILIA ---
    {"id": 776, "q": "The class name Reptilia refers to their:", "o": ["Creeping or crawling mode of locomotion", "Scaly skin", "Hard shell", "Water life"], "a": "Creeping or crawling mode of locomotion"},
    {"id": 777, "q": "Reptiles are mostly terrestrial and their body is covered by:", "o": ["Dry and cornified skin, epidermal scales or scutes", "Moist skin", "Hair", "Feathers"], "a": "Dry and cornified skin, epidermal scales or scutes"},
    {"id": 778, "q": "Do reptiles have external ear openings?", "o": ["No, Tympanum represents ear", "Yes, Pinna is present", "Yes, large ears", "No ear at all"], "a": "No, Tympanum represents ear"},
    {"id": 779, "q": "Heart in reptiles is usually three-chambered, but four-chambered in:", "o": ["Crocodiles", "Snakes", "Lizards", "Turtles"], "a": "Crocodiles"},
    {"id": 780, "q": "Reptiles are Poikilotherms. Snakes and lizards shed their scales as:", "o": ["Skin cast", "Feathers", "Fur", "Horn"], "a": "Skin cast"},
    {"id": 781, "q": "Chelone is:", "o": ["Turtle", "Tortoise", "Tree lizard", "Garden lizard"], "a": "Turtle"},
    {"id": 782, "q": "Testudo is:", "o": ["Tortoise", "Turtle", "Wall lizard", "Viper"], "a": "Tortoise"},
    {"id": 783, "q": "Chameleon is:", "o": ["Tree lizard", "Garden lizard", "Wall lizard", "Monitor lizard"], "a": "Tree lizard"},
    {"id": 784, "q": "Calotes is:", "o": ["Garden lizard", "Tree lizard", "Wall lizard", "Crocodile"], "a": "Garden lizard"},
    {"id": 785, "q": "Hemidactylus is:", "o": ["Wall lizard", "Tree lizard", "Garden lizard", "Snake"], "a": "Wall lizard"},
    {"id": 786, "q": "Poisonous snakes include:", "o": ["Naja (Cobra), Bangarus (Krait), Vipera (Viper)", "Python, Rat snake", "Tree snake, Water snake", "Anaconda"], "a": "Naja (Cobra), Bangarus (Krait), Vipera (Viper)"},

    # --- CLASS AVES (BIRDS) ---
    {"id": 787, "q": "The characteristic feature of Aves is the presence of:", "o": ["Feathers", "Hair", "Scales only", "Gills"], "a": "Feathers"},
    {"id": 788, "q": "The forelimbs in birds are modified into:", "o": ["Wings", "Legs", "Hands", "Fins"], "a": "Wings"},
    {"id": 789, "q": "The hind limbs generally have scales and are modified for:", "o": ["Walking, swimming or clasping", "Flying", "Eating", "Grasping"], "a": "Walking, swimming or clasping"},
    {"id": 790, "q": "Skin of birds is dry without glands except the oil gland at the:", "o": ["Base of the tail", "Base of the neck", "Under wings", "On the beak"], "a": "Base of the tail"},
    {"id": 791, "q": "Endoskeleton is fully ossified (bony) and long bones are hollow with air cavities called:", "o": ["Pneumatic bones", "Compact bones", "Cartilage bones", "Spongy bones"], "a": "Pneumatic bones"},
    {"id": 792, "q": "The digestive tract of birds has additional chambers called:", "o": ["Crop and Gizzard", "Rumen and Reticulum", "Stomach and Intestine", "Liver and Pancreas"], "a": "Crop and Gizzard"},
    {"id": 793, "q": "Heart in Aves is:", "o": ["Completely four-chambered", "Three-chambered", "Two-chambered", "Incomplete four-chambered"], "a": "Completely four-chambered"},
    {"id": 794, "q": "Birds are Homoiothermous, which means:", "o": ["They can maintain a constant body temperature", "Their temperature changes with environment", "They are cold blooded", "They hibernate"], "a": "They can maintain a constant body temperature"},
    {"id": 795, "q": "Respiration in birds is by:", "o": ["Lungs with air sacs connected to them", "Gills", "Skin", "Trachea"], "a": "Lungs with air sacs connected to them"},
    {"id": 796, "q": "Corvus is:", "o": ["Crow", "Pigeon", "Parrot", "Peacock"], "a": "Crow"},
    {"id": 797, "q": "Columba is:", "o": ["Pigeon", "Crow", "Parrot", "Penguin"], "a": "Pigeon"},
    {"id": 798, "q": "Psittacula is:", "o": ["Parrot", "Peacock", "Vulture", "Ostrich"], "a": "Parrot"},
    {"id": 799, "q": "Struthio is:", "o": ["Ostrich", "Penguin", "Peacock", "Kiwi"], "a": "Ostrich"},
    {"id": 800, "q": "Pavo is:", "o": ["Peacock", "Parrot", "Pigeon", "Crow"], "a": "Peacock"},
    {"id": 801, "q": "Aptenodytes is:", "o": ["Penguin", "Ostrich", "Vulture", "Kiwi"], "a": "Penguin"},
    {"id": 802, "q": "Neophron is:", "o": ["Vulture", "Eagle", "Hawk", "Kite"], "a": "Vulture"},

    # --- CLASS MAMMALIA ---
    {"id": 803, "q": "The most unique mammalian characteristic is the presence of:", "o": ["Milk producing glands (Mammary glands)", "Hair", "Pinna", "Four chambered heart"], "a": "Milk producing glands (Mammary glands)"},
    {"id": 804, "q": "Skin of mammals is unique in possessing:", "o": ["Hair", "Feathers", "Scales", "Scutes"], "a": "Hair"},
    {"id": 805, "q": "External ears or _____ are present in mammals.", "o": ["Pinnae", "Tympanum", "Operculum", "Cochlea"], "a": "Pinnae"},
    {"id": 806, "q": "Different types of teeth are present in the jaw. This condition is:", "o": ["Heterodont", "Homodont", "Polyphyodont", "Acrodont"], "a": "Heterodont"},
    {"id": 807, "q": "Heart in mammals is:", "o": ["Four-chambered", "Three-chambered", "Two-chambered", "One-chambered"], "a": "Four-chambered"},
    {"id": 808, "q": "Mammals are Viviparous with one exception. The Oviparous mammal is:", "o": ["Ornithorhynchus (Platypus)", "Macropus (Kangaroo)", "Pteropus (Flying fox)", "Balaenoptera (Blue whale)"], "a": "Ornithorhynchus (Platypus)"},
    {"id": 809, "q": "Macropus is:", "o": ["Kangaroo", "Flying fox", "Monkey", "Camel"], "a": "Kangaroo"},
    {"id": 810, "q": "Pteropus is:", "o": ["Flying fox", "Bat", "Kangaroo", "Monkey"], "a": "Flying fox"},
    {"id": 811, "q": "Camelus is Camel, Macaca is:", "o": ["Monkey", "Rat", "Dog", "Cat"], "a": "Monkey"},
    {"id": 812, "q": "Rattus is Rat, Canis is:", "o": ["Dog", "Cat", "Lion", "Tiger"], "a": "Dog"},
    {"id": 813, "q": "Felis is Cat, Elephas is:", "o": ["Elephant", "Horse", "Tiger", "Lion"], "a": "Elephant"},
    {"id": 814, "q": "Equus is:", "o": ["Horse", "Donkey", "Zebra", "Elephant"], "a": "Horse"},
    {"id": 815, "q": "Delphinus is Common Dolphin, Balaenoptera is:", "o": ["Blue whale", "Shark", "Seal", "Walrus"], "a": "Blue whale"},
    {"id": 816, "q": "Panthera tigris is Tiger, Panthera leo is:", "o": ["Lion", "Leopard", "Cat", "Dog"], "a": "Lion"},
    
    # --- BASIS OF CLASSIFICATION ---
    {"id": 601, "q": "Which level of organization is found in Sponges?", "o": ["Cellular level", "Tissue level", "Organ level", "Organ-system level"], "a": "Cellular level"},
    {"id": 602, "q": "Tissue level of organization is exhibited by:", "o": ["Porifera", "Cnidaria and Ctenophora", "Platyhelminthes", "Annelida"], "a": "Cnidaria and Ctenophora"},
    {"id": 603, "q": "Organ level of organization is first seen in:", "o": ["Platyhelminthes", "Aschelminthes", "Annelida", "Arthropoda"], "a": "Platyhelminthes"},
    {"id": 604, "q": "When any plane passing through the central axis of the body divides the organism into two identical halves, it is called:", "o": ["Radial symmetry", "Bilateral symmetry", "Asymmetry", "Biradial symmetry"], "a": "Radial symmetry"},
    {"id": 605, "q": "Radial symmetry is found in:", "o": ["Coelenterates, Ctenophores and Echinoderms (Adults)", "Platyhelminthes", "Arthropods", "Molluscs"], "a": "Coelenterates, Ctenophores and Echinoderms (Adults)"},
    {"id": 606, "q": "Bilateral symmetry is a characteristic of:", "o": ["Sponges", "Ctenophores", "Annelids and Arthropods", "Adult Echinoderms"], "a": "Annelids and Arthropods"},
    {"id": 607, "q": "Animals in which the cells are arranged in two embryonic layers (External Ectoderm and Internal Endoderm) are called:", "o": ["Diploblastic", "Triploblastic", "Monoblastic", "Tetrablastic"], "a": "Diploblastic"},
    {"id": 608, "q": "An undifferentiated layer present between ectoderm and endoderm in diploblastic animals is:", "o": ["Mesoderm", "Mesoglea", "Mesenchyme", "Mesothelium"], "a": "Mesoglea"},
    {"id": 609, "q": "Triploblastic organization is found in:", "o": ["Porifera to Cnidaria", "Platyhelminthes to Chordata", "Ctenophora only", "Protozoa"], "a": "Platyhelminthes to Chordata"},
    {"id": 610, "q": "The body cavity, which is lined by mesoderm is called:", "o": ["Coelom", "Pseudocoelom", "Haemocoel", "Blastocoel"], "a": "Coelom"},
    {"id": 611, "q": "Pseudocoelom (mesoderm present as scattered pouches) is a characteristic feature of:", "o": ["Platyhelminthes", "Aschelminthes", "Annelida", "Mollusca"], "a": "Aschelminthes"},
    {"id": 612, "q": "Animals in which the body cavity is absent (Acoelomates) are:", "o": ["Platyhelminthes", "Aschelminthes", "Annelids", "Arthropods"], "a": "Platyhelminthes"},
    {"id": 613, "q": "Metamerism (True Segmentation) is characteristic of:", "o": ["Platyhelminthes", "Mollusca", "Annelida", "Echinodermata"], "a": "Annelida"},
    {"id": 614, "q": "Notochord is derived from which embryonic layer?", "o": ["Ectoderm", "Endoderm", "Mesoderm", "Ecto-mesoderm"], "a": "Mesoderm"},
    {"id": 615, "q": "Animals which possess notochord are called:", "o": ["Non-chordates", "Chordates", "Hemichordates", "Vertebrates"], "a": "Chordates"},

    # --- PHYLUM PORIFERA (SPONGES) ---
    {"id": 616, "q": "Members of phylum Porifera are commonly known as:", "o": ["Sponges", "Corals", "Roundworms", "Flatworms"], "a": "Sponges"},
    {"id": 617, "q": "Sponges are mostly:", "o": ["Freshwater and symmetrical", "Marine and asymmetrical", "Terrestrial and radial", "Marine and bilateral"], "a": "Marine and asymmetrical"},
    {"id": 618, "q": "Water enters the sponge body through minute pores called:", "o": ["Osculum", "Ostia", "Spiracles", "Hypostome"], "a": "Ostia"},
    {"id": 619, "q": "Water leaves the sponge body through a large opening called:", "o": ["Ostia", "Osculum", "Mouth", "Anus"], "a": "Osculum"},
    {"id": 620, "q": "The central cavity of sponges is known as:", "o": ["Coelom", "Spongocoel", "Gastro-vascular cavity", "Enteron"], "a": "Spongocoel"},
    {"id": 621, "q": "The specialized cells lining the Spongocoel and canals are:", "o": ["Cnidoblasts", "Choanocytes (Collar cells)", "Flame cells", "Nephridia"], "a": "Choanocytes (Collar cells)"},
    {"id": 622, "q": "Digestion in sponges is:", "o": ["Extracellular", "Intracellular", "Both", "Absent"], "a": "Intracellular"},
    {"id": 623, "q": "The skeleton of sponges is made up of:", "o": ["Chitin", "Spicules or Spongin fibers", "Calcium carbonate shell", "Cartilage"], "a": "Spicules or Spongin fibers"},
    {"id": 624, "q": "Sponges are hermaphrodites, which means:", "o": ["Sexes are separate", "Eggs and sperms are produced by the same individual", "They reproduce only asexually", "They are sterile"], "a": "Eggs and sperms are produced by the same individual"},
    {"id": 625, "q": "Asexual reproduction in sponges occurs by:", "o": ["Fragmentation", "Gemmule formation", "Both A and B", "Binary fission"], "a": "Both A and B"},
    {"id": 626, "q": "Fertilization in sponges is:", "o": ["External", "Internal", "Absent", "In water current"], "a": "Internal"},
    {"id": 627, "q": "Identify the fresh water sponge:", "o": ["Sycon", "Euspongia", "Spongilla", "Leucosolenia"], "a": "Spongilla"},
    {"id": 628, "q": "Euspongia is commonly known as:", "o": ["Bath sponge", "Fresh water sponge", "Scypha", "Brain sponge"], "a": "Bath sponge"},
    {"id": 629, "q": "Sycon is scientifically known as:", "o": ["Scypha", "Spongilla", "Euspongia", "Hyalonema"], "a": "Scypha"},

    # --- PHYLUM COELENTERATA (CNIDARIA) ---
    {"id": 630, "q": "Cnidarians are mostly:", "o": ["Marine, sessile or free-swimming", "Freshwater and terrestrial", "Parasitic", "Terrestrial only"], "a": "Marine, sessile or free-swimming"},
    {"id": 631, "q": "The name Cnidaria is derived from:", "o": ["Cnidoblasts or Cnidocytes", "Coelom", "Comb plates", "Choanocytes"], "a": "Cnidoblasts or Cnidocytes"},
    {"id": 632, "q": "Cnidoblasts are used for:", "o": ["Anchorage", "Defense", "Capture of prey", "All of the above"], "a": "All of the above"},
    {"id": 633, "q": "Cnidarians exhibit which level of organization?", "o": ["Cellular", "Tissue", "Organ", "Organ-system"], "a": "Tissue"},
    {"id": 634, "q": "The central gastro-vascular cavity in Cnidaria has a single opening called:", "o": ["Osculum", "Hypostome (Mouth)", "Anus", "Ostia"], "a": "Hypostome (Mouth)"},
    {"id": 635, "q": "Digestion in Cnidarians is:", "o": ["Only intracellular", "Only extracellular", "Both extracellular and intracellular", "Absent"], "a": "Both extracellular and intracellular"},
    {"id": 636, "q": "Corals have a skeleton composed of:", "o": ["Chitin", "Calcium carbonate", "Silica", "Spongin"], "a": "Calcium carbonate"},
    {"id": 637, "q": "The sessile and cylindrical body form of Cnidarians is called:", "o": ["Medusa", "Polyp", "Cyst", "Spore"], "a": "Polyp"},
    {"id": 638, "q": "The umbrella-shaped and free-swimming body form is called:", "o": ["Polyp", "Medusa", "Larva", "Pupa"], "a": "Medusa"},
    {"id": 639, "q": "Which of the following exhibits the Polyp form?", "o": ["Aurelia", "Hydra and Adamsia", "Jellyfish", "Obelia (Medusa stage)"], "a": "Hydra and Adamsia"},
    {"id": 640, "q": "Which of the following exhibits the Medusa form?", "o": ["Hydra", "Adamsia", "Aurelia (Jelly fish)", "Sea Anemone"], "a": "Aurelia (Jelly fish)"},
    {"id": 641, "q": "Alternation of generation (Metagenesis) is exhibited by:", "o": ["Hydra", "Adamsia", "Obelia", "Aurelia"], "a": "Obelia"},
    {"id": 642, "q": "In Obelia, Polyps produce Medusae:", "o": ["Sexually", "Asexually", "By fragmentation", "By conjugation"], "a": "Asexually"},
    {"id": 643, "q": "In Obelia, Medusae form Polyps:", "o": ["Asexually", "Sexually", "Vegetatively", "Spontaneously"], "a": "Sexually"},
    {"id": 644, "q": "Physalia is commonly known as:", "o": ["Portuguese man-of-war", "Sea Anemone", "Sea Pen", "Brain Coral"], "a": "Portuguese man-of-war"},
    {"id": 645, "q": "Adamsia is commonly known as:", "o": ["Sea Anemone", "Sea Fan", "Sea Pen", "Jelly fish"], "a": "Sea Anemone"},
    {"id": 646, "q": "Pennatula is commonly known as:", "o": ["Sea Pen", "Sea Fan", "Sea Hare", "Sea Lily"], "a": "Sea Pen"},
    {"id": 647, "q": "Gorgonia is commonly known as:", "o": ["Sea Fan", "Sea Pen", "Brain Coral", "Star fish"], "a": "Sea Fan"},
    {"id": 648, "q": "Meandrina is commonly known as:", "o": ["Brain Coral", "Red Coral", "Organ pipe Coral", "Blue Coral"], "a": "Brain Coral"},

    # --- PHYLUM CTENOPHORA (SEA WALNUTS) ---
    {"id": 649, "q": "Ctenophores are commonly known as:", "o": ["Sea walnuts or Comb jellies", "Jelly fish", "Flatworms", "Sponges"], "a": "Sea walnuts or Comb jellies"},
    {"id": 650, "q": "Ctenophores possess how many external rows of ciliated comb plates?", "o": ["4", "6", "8", "10"], "a": "8"},
    {"id": 651, "q": "The function of Comb plates is:", "o": ["Digestion", "Locomotion", "Reproduction", "Defense"], "a": "Locomotion"},
    {"id": 652, "q": "Bioluminescence is well-marked in:", "o": ["Porifera", "Cnidaria", "Ctenophora", "Platyhelminthes"], "a": "Ctenophora"},
    {"id": 653, "q": "Reproduction in Ctenophores takes place:", "o": ["Only by sexual means", "Only asexually", "By both means", "By fragmentation"], "a": "Only by sexual means"},
    {"id": 654, "q": "Examples of Ctenophora are:", "o": ["Pleurobrachia and Ctenoplana", "Sycon and Hydra", "Fasciola and Taenia", "Nereis and Pheretima"], "a": "Pleurobrachia and Ctenoplana"},

    # --- PHYLUM PLATYHELMINTHES (FLATWORMS) ---
    {"id": 655, "q": "Platyhelminthes are called Flatworms because:", "o": ["They live in flat areas", "They have a dorsiventrally flattened body", "They have flat cells", "They are transparent"], "a": "They have a dorsiventrally flattened body"},
    {"id": 656, "q": "Flatworms are mostly:", "o": ["Free-living", "Endoparasites", "Ectoparasites", "Symbionts"], "a": "Endoparasites"},
    {"id": 657, "q": "Flame cells in Platyhelminthes help in:", "o": ["Digestion", "Respiration", "Osmoregulation and Excretion", "Reproduction"], "a": "Osmoregulation and Excretion"},
    {"id": 658, "q": "Hooks and suckers are present in:", "o": ["Free-living forms", "Parasitic forms", "All flatworms", "None"], "a": "Parasitic forms"},
    {"id": 659, "q": "Planaria possesses high capacity of:", "o": ["Bioluminescence", "Regeneration", "Metagenesis", "Metamerism"], "a": "Regeneration"},
    {"id": 660, "q": "Taenia is commonly known as:", "o": ["Tapeworm", "Liver fluke", "Roundworm", "Hookworm"], "a": "Tapeworm"},
    {"id": 661, "q": "Fasciola is commonly known as:", "o": ["Liver fluke", "Blood fluke", "Tapeworm", "Pinworm"], "a": "Liver fluke"},

    # --- PHYLUM ASCHELMINTHES (ROUNDWORMS) ---
    {"id": 662, "q": "The body of Aschelminthes is circular in cross-section, hence the name:", "o": ["Flatworms", "Roundworms", "Ringworms", "Tapeworms"], "a": "Roundworms"},
    {"id": 663, "q": "Alimentary canal in Aschelminthes is complete with a well-developed:", "o": ["Muscular pharynx", "Stomach", "Liver", "Intestine"], "a": "Muscular pharynx"},
    {"id": 664, "q": "An excretory tube removes body wastes from the body cavity through the:", "o": ["Excretory pore", "Anus", "Mouth", "Skin"], "a": "Excretory pore"},
    {"id": 665, "q": "In Aschelminthes, sexes are separate (Dioecious), and:", "o": ["Males are longer than females", "Females are longer than males", "Both are equal length", "Males are absent"], "a": "Females are longer than males"},
    {"id": 666, "q": "Ascaris is commonly known as:", "o": ["Roundworm", "Hookworm", "Filaria worm", "Tapeworm"], "a": "Roundworm"},
    {"id": 667, "q": "Wuchereria is known as:", "o": ["Filaria worm", "Hookworm", "Roundworm", "Pinworm"], "a": "Filaria worm"},
    {"id": 668, "q": "Ancylostoma is known as:", "o": ["Hookworm", "Roundworm", "Filaria worm", "Eye worm"], "a": "Hookworm"},

    # --- PHYLUM ANNELIDA ---
    {"id": 669, "q": "The name Annelida is derived from Latin 'annulus' meaning:", "o": ["Little ring", "Flat", "Segment", "Jointed"], "a": "Little ring"},
    {"id": 670, "q": "Annelids possess longitudinal and circular muscles which help in:", "o": ["Digestion", "Locomotion", "Respiration", "Excretion"], "a": "Locomotion"},
    {"id": 671, "q": "Aquatic annelids like Nereis possess lateral appendages for swimming called:", "o": ["Setae", "Parapodia", "Tentacles", "Fins"], "a": "Parapodia"},
    {"id": 672, "q": "A closed circulatory system is present in:", "o": ["Arthropoda", "Annelida", "Mollusca", "Hemichordata"], "a": "Annelida"},
    {"id": 673, "q": "Nephridia in Annelids help in:", "o": ["Respiration", "Osmoregulation and excretion", "Digestion", "Reproduction"], "a": "Osmoregulation and excretion"},
    {"id": 674, "q": "Neural system in Annelids consists of paired ganglia connected by:", "o": ["Single ventral nerve cord", "Double ventral nerve cord", "Double dorsal nerve cord", "Single dorsal nerve cord"], "a": "Double ventral nerve cord"},
    {"id": 675, "q": "Nereis is:", "o": ["Dioecious (Aquatic)", "Monoecious (Terrestrial)", "Hermaphrodite", "Asexual"], "a": "Dioecious (Aquatic)"},
    {"id": 676, "q": "Earthworms and Leeches are:", "o": ["Dioecious", "Monoecious (Hermaphrodite)", "Sterile", "Unisexual"], "a": "Monoecious (Hermaphrodite)"},
    {"id": 677, "q": "Hirudinaria is commonly known as:", "o": ["Blood sucking leech", "Earthworm", "Sandworm", "Ragworm"], "a": "Blood sucking leech"},

    # --- PHYLUM ARTHROPODA (LARGEST PHYLUM) ---
    {"id": 678, "q": "The largest phylum of Animalia which includes insects is:", "o": ["Mollusca", "Arthropoda", "Chordata", "Annelida"], "a": "Arthropoda"},
    {"id": 679, "q": "The body of Arthropods is covered by:", "o": ["Calcareous shell", "Chitinous exoskeleton", "Mucus", "Scales"], "a": "Chitinous exoskeleton"},
    {"id": 680, "q": "The body of Arthropods consists of:", "o": ["Head and Trunk", "Head, Thorax and Abdomen", "Cephalothorax and Abdomen", "Head and Tail"], "a": "Head, Thorax and Abdomen"},
    {"id": 681, "q": "Arthropods have jointed appendages. 'Arthros' means Joint, 'Podos' means:", "o": ["Body", "Appendages/Foot", "Head", "Skin"], "a": "Appendages/Foot"},
    {"id": 682, "q": "Respiratory organs in Arthropods include:", "o": ["Gills, book gills, book lungs, tracheal system", "Lungs only", "Skin only", "Ctenidia"], "a": "Gills, book gills, book lungs, tracheal system"},
    {"id": 683, "q": "Excretion in Arthropods takes place through:", "o": ["Nephridia", "Malpighian tubules", "Flame cells", "Kidneys"], "a": "Malpighian tubules"},
    {"id": 684, "q": "In Arthropods, the circulatory system is:", "o": ["Closed type", "Open type", "Absent", "Double circulation"], "a": "Open type"},
    {"id": 685, "q": "Statocysts or balancing organs are present in:", "o": ["Annelids", "Arthropods", "Aschelminthes", "Porifera"], "a": "Arthropods"},
    {"id": 686, "q": "Economically important insects include:", "o": ["Apis, Bombyx, Laccifer", "Anopheles, Culex", "Locusta", "Limulus"], "a": "Apis, Bombyx, Laccifer"},
    {"id": 687, "q": "Apis is Honey bee, Bombyx is Silkworm, Laccifer is:", "o": ["Lac insect", "Mosquito", "Locust", "King Crab"], "a": "Lac insect"},
    {"id": 688, "q": "Vectors for diseases include:", "o": ["Anopheles, Culex and Aedes", "Apis and Bombyx", "Locusta", "Limulus"], "a": "Anopheles, Culex and Aedes"},
    {"id": 689, "q": "Which of the following is a gregarious pest?", "o": ["Locusta (Locust)", "Limulus", "Bombyx", "Apis"], "a": "Locusta (Locust)"},
    {"id": 690, "q": "Living fossil is:", "o": ["Limulus (King crab)", "Locusta", "Laccifer", "Prawn"], "a": "Limulus (King crab)"},

    # --- PHYLUM MOLLUSCA (SECOND LARGEST) ---
    {"id": 691, "q": "The second largest animal phylum is:", "o": ["Arthropoda", "Mollusca", "Annelida", "Chordata"], "a": "Mollusca"},
    {"id": 692, "q": "Body of molluscs is covered by a calcareous shell and is unsegmented with:", "o": ["Head, muscular foot and visceral hump", "Head, thorax and abdomen", "Proboscis, collar and trunk", "Head and tail"], "a": "Head, muscular foot and visceral hump"},
    {"id": 693, "q": "The soft and spongy layer of skin forming a mantle is over the:", "o": ["Muscular foot", "Visceral hump", "Head", "Shell"], "a": "Visceral hump"},
    {"id": 694, "q": "The space between the hump and the mantle is called:", "o": ["Coelom", "Mantle cavity", "Visceral cavity", "Haemocoel"], "a": "Mantle cavity"},
    {"id": 695, "q": "Feather-like gills in the mantle cavity have:", "o": ["Respiratory and excretory functions", "Digestion function", "Sensory function", "Reproductive function"], "a": "Respiratory and excretory functions"},
    {"id": 696, "q": "The mouth contains a file-like rasping organ for feeding, called:", "o": ["Radula", "Mandible", "Tentacle", "Proboscis"], "a": "Radula"},
    {"id": 697, "q": "Pila is commonly known as:", "o": ["Apple snail", "Pearl oyster", "Cuttlefish", "Squid"], "a": "Apple snail"},
    {"id": 698, "q": "Pinctada is:", "o": ["Pearl oyster", "Apple snail", "Devil fish", "Sea hare"], "a": "Pearl oyster"},
    {"id": 699, "q": "Sepia is Cuttlefish, Loligo is Squid, Octopus is:", "o": ["Devil fish", "Tusk shell", "Chiton", "Sea hare"], "a": "Devil fish"},
    {"id": 700, "q": "Aplysia is:", "o": ["Sea hare", "Sea lemon", "Sea lily", "Sea fan"], "a": "Sea hare"},

    # --- PHYLUM ECHINODERMATA (SPINY SKINNED) ---
    {"id": 701, "q": "Echinoderms have an endoskeleton of:", "o": ["Chitin", "Calcareous ossicles", "Silica", "Cartilage"], "a": "Calcareous ossicles"},
    {"id": 702, "q": "Adult Echinoderms are:", "o": ["Radially symmetrical", "Bilaterally symmetrical", "Asymmetrical", "Biradial"], "a": "Radially symmetrical"},
    {"id": 703, "q": "Larvae of Echinoderms are:", "o": ["Radially symmetrical", "Bilaterally symmetrical", "Asymmetrical", "Spherical"], "a": "Bilaterally symmetrical"},
    {"id": 704, "q": "The most distinctive feature of Echinoderms is the presence of:", "o": ["Water vascular system", "Canal system", "Tracheal system", "Haemocoel"], "a": "Water vascular system"},
    {"id": 705, "q": "Water vascular system helps in:", "o": ["Locomotion, capture/transport of food and respiration", "Excretion only", "Reproduction only", "Digestion only"], "a": "Locomotion, capture/transport of food and respiration"},
    {"id": 706, "q": "Excretory system in Echinoderms is:", "o": ["Well developed", "Absent", "Through flame cells", "Through nephridia"], "a": "Absent"},
    {"id": 707, "q": "Asterias is:", "o": ["Star fish", "Sea urchin", "Sea lily", "Sea cucumber"], "a": "Star fish"},
    {"id": 708, "q": "Echinus is:", "o": ["Sea urchin", "Sea lily", "Star fish", "Brittle star"], "a": "Sea urchin"},
    {"id": 709, "q": "Antedon is Sea Lily, Cucumaria is Sea Cucumber, Ophiura is:", "o": ["Brittle star", "Star fish", "Sea urchin", "Sea hare"], "a": "Brittle star"},

    # --- PHYLUM HEMICHORDATA ---
    {"id": 710, "q": "Hemichordata was earlier considered a sub-phylum under Chordata but is now a separate phylum of:", "o": ["Non-chordates", "Vertebrates", "Protochordates", "Tunicates"], "a": "Non-chordates"},
    {"id": 711, "q": "Hemichordates consist of a small group of worm-like marine animals with:", "o": ["Organ-system level organization", "Tissue level", "Cellular level", "Protoplasmic level"], "a": "Organ-system level organization"},
    {"id": 712, "q": "The body of Hemichordates is cylindrical and composed of:", "o": ["Anterior proboscis, a collar and a long trunk", "Head, thorax, abdomen", "Head, foot, visceral hump", "Cephalothorax and abdomen"], "a": "Anterior proboscis, a collar and a long trunk"},
    {"id": 713, "q": "Excretory organ in Hemichordata is:", "o": ["Proboscis gland", "Nephridia", "Flame cells", "Kidney"], "a": "Proboscis gland"},
    {"id": 714, "q": "Respiration in Hemichordata takes place through:", "o": ["Gills", "Lungs", "Skin", "Trachea"], "a": "Gills"},
    {"id": 715, "q": "Examples of Hemichordata are:", "o": ["Balanoglossus and Saccoglossus", "Nereis and Hirudinaria", "Ascidia and Salpa", "Branchiostoma"], "a": "Balanoglossus and Saccoglossus"},

    # --- LIFE CYCLES & ALTERNATION OF GENERATIONS ---
    {"id": 497, "q": "In Haplontic life cycle, the dominant, photosynthetic phase is:", "o": ["Free-living gametophyte", "Sporophyte", "Zygote", "Seed"], "a": "Free-living gametophyte"},
    {"id": 498, "q": "In Haplontic life cycle, the sporophytic generation is represented only by:", "o": ["One-celled Zygote", "Multicellular embryo", "Sporangium", "Protonema"], "a": "One-celled Zygote"},
    {"id": 499, "q": "Haplontic life cycle is found in:", "o": ["Volvox, Spirogyra, Chlamydomonas", "Fucus", "Ectocarpus", "Gymnosperms"], "a": "Volvox, Spirogyra, Chlamydomonas"},
    {"id": 500, "q": "In Diplontic life cycle, the dominant phase is:", "o": ["Diploid Sporophyte", "Haploid Gametophyte", "Zygote", "Gamete"], "a": "Diploid Sporophyte"},
    {"id": 501, "q": "Diplontic life cycle is found in:", "o": ["All seed-bearing plants (Gymnos & Angios)", "Volvox", "Spirogyra", "Mosses"], "a": "All seed-bearing plants (Gymnos & Angios)"},
    {"id": 502, "q": "Which Alga exhibits a Diplontic life cycle?", "o": ["Fucus", "Volvox", "Polysiphonia", "Ectocarpus"], "a": "Fucus"},
    {"id": 503, "q": "Haplo-diplontic life cycle is exhibited by:", "o": ["Bryophytes and Pteridophytes", "Volvox and Spirogyra", "Fucus and Gymnosperms", "Angiosperms"], "a": "Bryophytes and Pteridophytes"},
    {"id": 504, "q": "Which Algae exhibit Haplo-diplontic life cycle?", "o": ["Ectocarpus, Polysiphonia, Kelps", "Volvox, Spirogyra", "Fucus", "Chlamydomonas"], "a": "Ectocarpus, Polysiphonia, Kelps"},
    {"id": 505, "q": "In Bryophytes, the dominant phase is:", "o": ["Haploid Gametophyte", "Diploid Sporophyte", "Zygote", "Prothallus"], "a": "Haploid Gametophyte"},
    {"id": 506, "q": "In Pteridophytes, the dominant phase is:", "o": ["Diploid Sporophyte", "Haploid Gametophyte", "Protonema", "Gamete"], "a": "Diploid Sporophyte"},

    # --- PTERIDOPHYTES (ANATOMY & EXAMPLES) ---
    {"id": 536, "q": "In Pteridophytes, the main plant body is a sporophyte which is differentiated into:", "o": ["True root, stem and leaves", "True root, stem and flowers", "Thallus and rhizoids", "Holdfast, stipe and frond"], "a": "True root, stem and leaves"},
    {"id": 537, "q": "The leaves in Selaginella are:", "o": ["Microphylls (Small)", "Macrophylls (Large)", "Absent", "Needle-like"], "a": "Microphylls (Small)"},
    {"id": 538, "q": "The leaves in Ferns are:", "o": ["Macrophylls (Large)", "Microphylls (Small)", "Scale leaves", "Absent"], "a": "Macrophylls (Large)"},
    {"id": 539, "q": "Strobili or cones are found in:", "o": ["Selaginella and Equisetum", "Ferns and Mosses", "Marchantia and Riccia", "Funaria"], "a": "Selaginella and Equisetum"},
    {"id": 540, "q": "In Pteridophytes, the gametophyte (Prothallus) is:", "o": ["Inconspicuous, small, multicellular, free-living", "Large, unicellular, parasitic", "Dominant phase", "Dependent on sporophyte"], "a": "Inconspicuous, small, multicellular, free-living"},
    {"id": 541, "q": "Prothallus is:", "o": ["Monoecious (usually)", "Dioecious always", "Asexual", "Triploid"], "a": "Monoecious (usually)"},
    {"id": 542, "q": "Water is required for transfer of antherozoids to the mouth of archegonium. This requirement restricts the spread of:", "o": ["Pteridophytes and Bryophytes", "Gymnosperms", "Angiosperms", "Algae only"], "a": "Pteridophytes and Bryophytes"},
    {"id": 543, "q": "Zygote produces a multicellular well-differentiated sporophyte which is the dominant phase in:", "o": ["Pteridophytes", "Bryophytes", "Algae", "Fungi"], "a": "Pteridophytes"},
    {"id": 544, "q": "Heterospory (producing two kinds of spores) is a characteristic of:", "o": ["Selaginella and Salvinia", "Dryopteris and Pteris", "Equisetum and Adiantum", "Lycopodium"], "a": "Selaginella and Salvinia"},
    {"id": 545, "q": "In heterosporous plants, the female gametophyte is retained on the parent sporophyte for variable periods. This event is a precursor to:", "o": ["Seed habit", "Fruit formation", "Flower formation", "Double fertilization"], "a": "Seed habit"},
    {"id": 546, "q": "Equisetum is commonly known as:", "o": ["Horsetail", "Club moss", "Walking fern", "Maidenhair fern"], "a": "Horsetail"},
    {"id": 547, "q": "Adiantum is commonly called:", "o": ["Walking fern", "Horsetail", "Club moss", "Water fern"], "a": "Walking fern"},
    {"id": 548, "q": "Which class does Dryopteris belong to?", "o": ["Pteropsida", "Lycopsida", "Sphenopsida", "Psilopsida"], "a": "Pteropsida"},

    # --- GYMNOSPERMS (ROOTS, STEMS & LEAVES) ---
    {"id": 549, "q": "The roots of Gymnosperms are generally:", "o": ["Tap roots", "Fibrous roots", "Adventitious roots", "Prop roots"], "a": "Tap roots"},
    {"id": 550, "q": "Cycas has specialized roots called:", "o": ["Coralloid roots", "Mycorrhiza", "Stilt roots", "Pneumatophores"], "a": "Coralloid roots"},
    {"id": 551, "q": "Coralloid roots are associated with:", "o": ["N2-fixing Cyanobacteria", "Fungi", "Algae", "Viruses"], "a": "N2-fixing Cyanobacteria"},
    {"id": 552, "q": "The stem is unbranched in:", "o": ["Cycas", "Pinus", "Cedrus", "Sequoia"], "a": "Cycas"},
    {"id": 553, "q": "The stem is branched in:", "o": ["Pinus and Cedrus", "Cycas", "Ferns", "Mosses"], "a": "Pinus and Cedrus"},
    {"id": 554, "q": "In Cycas, the pinnate leaves persist for:", "o": ["A few years", "A few days", "A few months", "Forever"], "a": "A few years"},
    {"id": 555, "q": "Leaves in Gymnosperms are well-adapted to withstand:", "o": ["Extreme temperature, humidity and wind", "Only water logging", "Only shade", "Herbivores"], "a": "Extreme temperature, humidity and wind"},
    {"id": 556, "q": "Sunken stomata are a characteristic feature of:", "o": ["Conifers (Gymnosperms)", "Hydrophytes", "Mesophytes", "Algae"], "a": "Conifers (Gymnosperms)"},
    {"id": 557, "q": "In Gymnosperms, the microspores develop into a male gametophyte which is highly reduced and confined to only a limited number of cells. This reduced gametophyte is:", "o": ["Pollen grain", "Seed", "Ovule", "Cone"], "a": "Pollen grain"},
    {"id": 558, "q": "The development of pollen grains takes place within the:", "o": ["Microsporangia", "Megasporangia", "Nucellus", "Archegonium"], "a": "Microsporangia"},
    {"id": 559, "q": "In Cycas, male cones and megasporophylls are borne on:", "o": ["Different trees", "Same tree", "Same branch", "Roots"], "a": "Different trees"},
    {"id": 560, "q": "In Pinus, male and female cones are borne on:", "o": ["The same tree", "Different trees", "Different soil types", "Roots"], "a": "The same tree"},
    {"id": 561, "q": "The nucellus is protected by envelopes and the composite structure is called an:", "o": ["Ovule", "Seed", "Fruit", "Cone"], "a": "Ovule"},
    {"id": 562, "q": "In Gymnosperms, the megaspore mother cell is differentiated from one of the cells of the:", "o": ["Nucellus", "Endosperm", "Pollen", "Embryo"], "a": "Nucellus"},
    {"id": 563, "q": "The multicellular female gametophyte in Gymnosperms is also retained within:", "o": ["Megasporangium", "Microsporangium", "Soil", "Water"], "a": "Megasporangium"},
    {"id": 564, "q": "Unlike Bryophytes and Pteridophytes, in Gymnosperms:", "o": ["Male and female gametophytes do not have an independent free-living existence", "Gametophytes are dominant", "Water is essential for fertilization", "Spores are homosporous"], "a": "Male and female gametophytes do not have an independent free-living existence"},
    
    # --- LIFE CYCLE & EXCEPTIONS ---
    {"id": 565, "q": "Fucus is an alga but its life cycle is:", "o": ["Diplontic", "Haplontic", "Haplo-diplontic", "Triplontic"], "a": "Diplontic"},
    {"id": 566, "q": "Kelps, Polysiphonia and Ectocarpus show which life cycle?", "o": ["Haplo-diplontic", "Diplontic", "Haplontic", "None"], "a": "Haplo-diplontic"},
    {"id": 567, "q": "Volvox and Spirogyra show which life cycle?", "o": ["Haplontic", "Diplontic", "Haplo-diplontic", "Vegetative"], "a": "Haplontic"},
    {"id": 568, "q": "The diploid sporophyte is represented by a dominant, independent, photosynthetic, vascular plant body in:", "o": ["Pteridophytes", "Bryophytes", "Algae", "Fungi"], "a": "Pteridophytes"},
    {"id": 569, "q": "Seed habit is linked to:", "o": ["Heterospory", "Homospory", "Isogamy", "External fertilization"], "a": "Heterospory"},
    {"id": 570, "q": "Which of the following has 'vessels' in their xylem? (Advanced question/Gnetales)", "o": ["Gnetum", "Pinus", "Cycas", "Cedrus"], "a": "Gnetum"}, # Note: NCERT mentions Gnetales briefly, Gnetum has vessels unlike other Gymnos.
    {"id": 571, "q": "The tallest tree species is:", "o": ["Sequoia (Redwood)", "Eucalyptus", "Banyan", "Peepal"], "a": "Sequoia (Redwood)"},
    # --- ALGAE (CHLOROPLASTS & FLAGELLA DEEP DIVE) ---
    {"id": 507, "q": "In Chlorophyceae, the chloroplasts may be discoid, plate-like, reticulate, cup-shaped, spiral or ribbon-shaped in different species. This statement is:", "o": ["True", "False", "Partially True", "Only discoid is found"], "a": "True"},
    {"id": 508, "q": "Pyrenoids are located within:", "o": ["Chloroplasts", "Cytoplasm", "Nucleus", "Mitochondria"], "a": "Chloroplasts"},
    {"id": 509, "q": "Some green algae may store food in the form of oil droplets. This is seen in:", "o": ["Chlamydomonas", "Volvox", "Spirogyra", "Some specific species"], "a": "Some specific species"},
    {"id": 510, "q": "The inner wall of Green Algae is made of Cellulose and the outer layer is made of:", "o": ["Pectose", "Algin", "Carrageen", "Chitin"], "a": "Pectose"},
    {"id": 511, "q": "In Phaeophyceae (Brown Algae), the flagella are:", "o": ["Two, unequal and laterally attached", "Two, equal and apical", "Eight, equal and apical", "Absent"], "a": "Two, unequal and laterally attached"},
    {"id": 512, "q": "In Chlorophyceae (Green Algae), the flagella are:", "o": ["2-8, equal and apical", "2, unequal and lateral", "Absent", "Many, all over body"], "a": "2-8, equal and apical"},
    {"id": 513, "q": "In Rhodophyceae (Red Algae), the flagella are:", "o": ["Absent", "2, equal apical", "2, unequal lateral", "Present only in gametes"], "a": "Absent"},
    {"id": 514, "q": "Which chemical constitutes the cell wall of Brown Algae?", "o": ["Cellulose and Algin", "Cellulose and Pectose", "Cellulose, Pectin and Polysulphate esters", "Chitin"], "a": "Cellulose and Algin"},
    {"id": 515, "q": "Which chemical constitutes the cell wall of Red Algae?", "o": ["Cellulose, pectin and polysulphate esters", "Cellulose and Algin", "Cellulose and Pectose", "Chitin"], "a": "Cellulose, pectin and polysulphate esters"},
    {"id": 516, "q": "The reserve food 'Laminarin' is a complex carbohydrate which is a form of:", "o": ["Starch", "Glucose", "Fructose", "Alcohol"], "a": "Starch"},
    {"id": 517, "q": "Which alga forms massive plant bodies that can reach heights of 100 meters?", "o": ["Kelps (Brown Algae)", "Volvox (Green Algae)", "Polysiphonia (Red Algae)", "Chara"], "a": "Kelps (Brown Algae)"},
    {"id": 518, "q": "Air bladders are seen in:", "o": ["Fucus", "Laminaria", "Ectocarpus", "Dictyota"], "a": "Fucus"},
    {"id": 519, "q": "In which alga is the food stored as Floridean starch which is very similar to Amylopectin and Glycogen?", "o": ["Polysiphonia", "Laminaria", "Sargassum", "Volvox"], "a": "Polysiphonia"},
    {"id": 520, "q": "Chara (Stonewort) belongs to:", "o": ["Green Algae", "Brown Algae", "Red Algae", "Blue-green Algae"], "a": "Green Algae"},

    # --- BRYOPHYTES (LIVERWORTS & MOSSES DETAILS) ---
    {"id": 521, "q": "The thallus of Marchantia is:", "o": ["Dorsiventral and closely appressed to the substrate", "Upright and cylindrical", "Filamentous", "Differentated into roots and shoots"], "a": "Dorsiventral and closely appressed to the substrate"},
    {"id": 522, "q": "Asexual reproduction in liverworts takes place by:", "o": ["Fragmentation of thalli or formation of Gemmae", "Only spores", "Only budding", "Fusion of gametes"], "a": "Fragmentation of thalli or formation of Gemmae"},
    {"id": 523, "q": "Gemmae develop in small receptacles called gemma cups located on:", "o": ["The thalli", "The rhizoids", "The sporophyte", "The capsule"], "a": "The thalli"},
    {"id": 524, "q": "Gemmae detach from the parent body and germinate to form:", "o": ["New individuals", "Spores", "Gametes", "Zygotes"], "a": "New individuals"},
    {"id": 525, "q": "In Marchantia, male and female sex organs are produced:", "o": ["On different thalli (Dioecious)", "On the same thallus (Monoecious)", "Inside the capsule", "On the protonema"], "a": "On different thalli (Dioecious)"},
    {"id": 526, "q": "The sporophyte in Liverworts is differentiated into:", "o": ["Foot, seta and capsule", "Root, stem and leaf", "Holdfast, stipe and frond", "Protonema and capsule"], "a": "Foot, seta and capsule"},
    {"id": 527, "q": "After meiosis, spores are produced within the:", "o": ["Capsule", "Seta", "Foot", "Gemma cup"], "a": "Capsule"},
    {"id": 528, "q": "In Mosses, the protonema stage is:", "o": ["Creeping, green, branched and filamentous", "Upright, non-green and woody", "Unicellular and colorless", "Parasitic"], "a": "Creeping, green, branched and filamentous"},
    {"id": 529, "q": "The leafy stage of mosses consists of:", "o": ["Upright, slender axes bearing spirally arranged leaves", "Dorsiventral thallus", "Prostrate branches", "Simple thallus"], "a": "Upright, slender axes bearing spirally arranged leaves"},
    {"id": 530, "q": "Rhizoids in mosses are:", "o": ["Multicellular and branched", "Unicellular and unbranched", "Absent", "True roots"], "a": "Multicellular and branched"},
    {"id": 531, "q": "Sporophyte in mosses is more elaborate than that in:", "o": ["Liverworts", "Pteridophytes", "Gymnosperms", "Angiosperms"], "a": "Liverworts"},
    {"id": 532, "q": "Which of the following has an elaborate mechanism of spore dispersal?", "o": ["Mosses (Funaria)", "Liverworts (Riccia)", "Algae", "Fungi"], "a": "Mosses (Funaria)"},
    {"id": 533, "q": "Sphagnum is also known as:", "o": ["Peat Moss / Bog Moss", "Club Moss", "Horse tail", "Sea lettuce"], "a": "Peat Moss / Bog Moss"},
    {"id": 534, "q": "Because of its capacity to hold water, Sphagnum is used for:", "o": ["Trans-shipment of living material", "Building houses", "Food for humans", "Making paper"], "a": "Trans-shipment of living material"},
    {"id": 535, "q": "Mosses along with Lichens are the first organisms to colonize rocks. This is of great:", "o": ["Ecological importance", "Economic importance", "Medicinal importance", "Industrial importance"], "a": "Ecological importance"},
    
    # --- PTERIDOPHYTES ---
    {"id": 457, "q": "Pteridophytes are the first terrestrial plants to possess:", "o": ["Vascular tissues (Xylem & Phloem)", "Seeds", "Fruits", "Flowers"], "a": "Vascular tissues (Xylem & Phloem)"},
    {"id": 458, "q": "In Pteridophytes, the dominant phase in the life cycle is:", "o": ["Sporophyte", "Gametophyte", "Protonema", "Haploid thallus"], "a": "Sporophyte"},
    {"id": 459, "q": "The leaves in Pteridophytes are small (microphylls) in:", "o": ["Selaginella", "Ferns", "Cycas", "Pinus"], "a": "Selaginella"},
    {"id": 460, "q": "Large leaves (macrophylls) are found in:", "o": ["Ferns", "Selaginella", "Equisetum", "Mosses"], "a": "Ferns"},
    {"id": 461, "q": "Sporophytes bear sporangia that are subtended by leaf-like appendages called:", "o": ["Sporophylls", "Prothallus", "Sori", "Indusium"], "a": "Sporophylls"},
    {"id": 462, "q": "In Selaginella and Equisetum, sporophylls form compact structures called:", "o": ["Strobili or Cones", "Flowers", "Fruits", "Sori"], "a": "Strobili or Cones"},
    {"id": 463, "q": "The spores germinate to give rise to a small, multicellular, free-living, photosynthetic gametophyte called:", "o": ["Prothallus", "Protonema", "Sporophyte", "Embryo"], "a": "Prothallus"},
    {"id": 464, "q": "Prothallus requires what kind of conditions to grow?", "o": ["Cool, damp, shady places", "Hot and dry", "Direct sunlight", "Deep water"], "a": "Cool, damp, shady places"},
    {"id": 465, "q": "Majority of the Pteridophytes are 'Homosporous', meaning they produce:", "o": ["Only one kind of spores", "Two kinds of spores", "No spores", "Seeds"], "a": "Only one kind of spores"},
    {"id": 466, "q": "Which of the following genera are Heterosporous?", "o": ["Selaginella and Salvinia", "Equisetum and Pteris", "Dryopteris and Adiantum", "Lycopodium"], "a": "Selaginella and Salvinia"},
    {"id": 467, "q": "In heterosporous plants, the megaspores and microspores germinate to give rise to:", "o": ["Female and male gametophytes respectively", "Male and female gametophytes respectively", "Sporophytes directly", "Seeds"], "a": "Female and male gametophytes respectively"},
    {"id": 468, "q": "The event which is a precursor to the seed habit is:", "o": ["Retention of female gametophyte on the parent sporophyte", "Homospory", "Free living gametophyte", "Development of prothallus"], "a": "Retention of female gametophyte on the parent sporophyte"},
    {"id": 469, "q": "Equisetum belongs to the class:", "o": ["Sphenopsida", "Lycopsida", "Psilopsida", "Pteropsida"], "a": "Sphenopsida"},
    {"id": 470, "q": "Adiantum, Pteris and Dryopteris belong to:", "o": ["Pteropsida", "Lycopsida", "Sphenopsida", "Psilopsida"], "a": "Pteropsida"},
    {"id": 471, "q": "Psilotum belongs to:", "o": ["Psilopsida", "Lycopsida", "Sphenopsida", "Pteropsida"], "a": "Psilopsida"},
    {"id": 472, "q": "Selaginella and Lycopodium belong to:", "o": ["Lycopsida", "Psilopsida", "Sphenopsida", "Pteropsida"], "a": "Lycopsida"},
    
    # --- CLASSIFICATION SYSTEMS ---
    {"id": 401, "q": "Artificial systems of classification were based upon:", "o": ["Vegetative characters or structure of androecium", "Ultrastructure and anatomy", "Phytochemistry", "Embryology"], "a": "Vegetative characters or structure of androecium"},
    {"id": 402, "q": "Who gave the Artificial system of classification?", "o": ["Linnaeus", "Bentham and Hooker", "Aristotle", "Whittaker"], "a": "Linnaeus"},
    {"id": 403, "q": "Natural classification systems considered:", "o": ["Only external features", "External and internal features (ultrastructure, anatomy, embryology)", "Only evolutionary history", "Only floral characters"], "a": "External and internal features (ultrastructure, anatomy, embryology)"},
    {"id": 404, "q": "Who proposed the Natural system of classification for flowering plants?", "o": ["George Bentham and Joseph Dalton Hooker", "Linnaeus", "Hutchinson", "Engler and Prantl"], "a": "George Bentham and Joseph Dalton Hooker"},
    {"id": 405, "q": "Phylogenetic classification systems are based on:", "o": ["Evolutionary relationships", "Morphological characters", "Chemical constituents", "Cytological information"], "a": "Evolutionary relationships"},
    {"id": 406, "q": "Taxonomy based on chromosome number, structure, and behavior is called:", "o": ["Chemotaxonomy", "Cytotaxonomy", "Numerical Taxonomy", "Alpha Taxonomy"], "a": "Cytotaxonomy"},
    {"id": 407, "q": "Numerical Taxonomy involves:", "o": ["Using computers to process all observable characteristics", "Studying chemical constituents", "Studying fossils", "Studying cell structure"], "a": "Using computers to process all observable characteristics"},

    # --- ALGAE (GENERAL) ---
    {"id": 408, "q": "Algae are largely:", "o": ["Aquatic (freshwater and marine)", "Terrestrial", "Parasitic", "Epiphytic"], "a": "Aquatic (freshwater and marine)"},
    {"id": 409, "q": "Which of the following is a colonial alga?", "o": ["Volvox", "Ulothrix", "Spirogyra", "Kelps"], "a": "Volvox"},
    {"id": 410, "q": "Which of the following is a filamentous alga?", "o": ["Ulothrix and Spirogyra", "Volvox", "Chlamydomonas", "Kelps"], "a": "Ulothrix and Spirogyra"},
    {"id": 411, "q": "The massive plant bodies in algae are formed by:", "o": ["Kelps", "Volvox", "Chlamydomonas", "Spirogyra"], "a": "Kelps"},
    {"id": 412, "q": "Asexual reproduction in algae is by the production of different types of spores, the most common being:", "o": ["Aplanospores", "Zoospores", "Akinetes", "Endospores"], "a": "Zoospores"},
    {"id": 413, "q": "Zoospores are:", "o": ["Flagellated and motile", "Non-flagellated and non-motile", "Thick-walled", "Sexual spores"], "a": "Flagellated and motile"},
    {"id": 414, "q": "Isogamous reproduction with flagellated gametes is found in:", "o": ["Ulothrix", "Spirogyra", "Volvox", "Fucus"], "a": "Ulothrix"},
    {"id": 415, "q": "Isogamous reproduction with non-flagellated gametes is found in:", "o": ["Spirogyra", "Ulothrix", "Volvox", "Fucus"], "a": "Spirogyra"},
    {"id": 416, "q": "Fusion between one large, non-motile female gamete and a smaller, motile male gamete is called:", "o": ["Isogamous", "Anisogamous", "Oogamous", "Zygotic"], "a": "Oogamous"},
    {"id": 417, "q": "Oogamous reproduction is found in:", "o": ["Volvox and Fucus", "Spirogyra and Ulothrix", "Chlamydomonas", "Ectocarpus"], "a": "Volvox and Fucus"},
    {"id": 418, "q": "At least half of the total carbon dioxide fixation on earth is carried out by:", "o": ["Algae", "Gymnosperms", "Angiosperms", "Bryophytes"], "a": "Algae"},
    {"id": 419, "q": "Agar, used to grow microbes and in ice-creams/jellies, is obtained from:", "o": ["Gelidium and Gracilaria", "Chara and Volvox", "Laminaria and Sargassum", "Fucus"], "a": "Gelidium and Gracilaria"},
    {"id": 420, "q": "Which algae are used as food supplements by space travelers?", "o": ["Chlorella and Spirullina", "Gelidium", "Laminaria", "Porphyra"], "a": "Chlorella and Spirullina"},
    {"id": 421, "q": "Algin (water holding substance) is produced by:", "o": ["Brown algae", "Red algae", "Green algae", "Blue-green algae"], "a": "Brown algae"},
    {"id": 422, "q": "Carrageen is produced by:", "o": ["Red algae", "Brown algae", "Green algae", "Fungi"], "a": "Red algae"},

    # --- CHLOROPHYCEAE (GREEN ALGAE) ---
    {"id": 423, "q": "The major pigments in Chlorophyceae are:", "o": ["Chlorophyll a and b", "Chlorophyll a and c", "Chlorophyll a and d", "Chlorophyll a and fucoxanthin"], "a": "Chlorophyll a and b"},
    {"id": 424, "q": "The stored food in Green Algae is:", "o": ["Starch", "Mannitol", "Floridean Starch", "Laminarin"], "a": "Starch"},
    {"id": 425, "q": "Pyrenoids in green algae contain:", "o": ["Protein besides starch", "Oil droplets", "Only protein", "Only starch"], "a": "Protein besides starch"},
    {"id": 426, "q": "The cell wall of Green Algae is made of:", "o": ["Inner cellulose and outer pectose", "Inner pectose and outer cellulose", "Cellulose and algin", "Cellulose and polysulphate esters"], "a": "Inner cellulose and outer pectose"},
    {"id": 427, "q": "Vegetative reproduction in Green Algae usually takes place by:", "o": ["Fragmentation", "Budding", "Fission", "Gemmae"], "a": "Fragmentation"},
    {"id": 428, "q": "Which of the following is NOT a Green Alga?", "o": ["Laminaria", "Chlamydomonas", "Volvox", "Chara"], "a": "Laminaria"},

    # --- PHAEOPHYCEAE (BROWN ALGAE) ---
    {"id": 429, "q": "Brown algae are primarily found in:", "o": ["Marine habitats", "Freshwater", "Terrestrial soil", "Hot springs"], "a": "Marine habitats"},
    {"id": 430, "q": "The characteristic pigment of Brown Algae causing their color variation is:", "o": ["Fucoxanthin", "Phycoerythrin", "Haemoglobin", "Phycocyanin"], "a": "Fucoxanthin"},
    {"id": 431, "q": "Food is stored in Brown Algae as:", "o": ["Laminarin or Mannitol", "Starch", "Floridean Starch", "Glycogen"], "a": "Laminarin or Mannitol"},
    {"id": 432, "q": "The plant body of brown algae is attached to the substratum by:", "o": ["Holdfast", "Stipe", "Frond", "Root"], "a": "Holdfast"},
    {"id": 433, "q": "The leaf-like photosynthetic organ in brown algae is called:", "o": ["Frond", "Stipe", "Holdfast", "Lamina"], "a": "Frond"},
    {"id": 434, "q": "Asexual reproduction in brown algae is by:", "o": ["Biflagellate zoospores (pear-shaped)", "Non-motile spores", "Quadriflagellate zoospores", "Aplanospores"], "a": "Biflagellate zoospores (pear-shaped)"},
    {"id": 435, "q": "The flagella in Brown Algae are:", "o": ["2, unequal, lateral", "2-8, equal, apical", "Absent", "Many, equal"], "a": "2, unequal, lateral"},
    {"id": 436, "q": "Ectocarpus, Dictyota, Laminaria, Sargassum, and Fucus belong to:", "o": ["Phaeophyceae", "Chlorophyceae", "Rhodophyceae", "Cyanophyceae"], "a": "Phaeophyceae"},

    # --- RHODOPHYCEAE (RED ALGAE) ---
    {"id": 437, "q": "The red color of Red Algae is due to:", "o": ["r-phycoerythrin", "r-phycocyanin", "Fucoxanthin", "Chlorophyll c"], "a": "r-phycoerythrin"},
    {"id": 438, "q": "Stored food in Red Algae is:", "o": ["Floridean Starch", "Mannitol", "Laminarin", "Starch"], "a": "Floridean Starch"},
    {"id": 439, "q": "Floridean starch is structurally similar to:", "o": ["Amylopectin and glycogen", "Amylose and pectin", "Mannitol and algin", "Cellulose"], "a": "Amylopectin and glycogen"},
    {"id": 440, "q": "Red algae reproduce asexually and sexually by:", "o": ["Non-motile spores and gametes", "Motile spores and gametes", "Motile spores and non-motile gametes", "Non-motile spores and motile gametes"], "a": "Non-motile spores and gametes"},
    {"id": 441, "q": "Polysiphonia, Porphyra, Gracilaria and Gelidium belong to:", "o": ["Rhodophyceae", "Phaeophyceae", "Chlorophyceae", "Gymnosperms"], "a": "Rhodophyceae"},
    
    # --- TOPIC: TRICKY & ASSERTION TYPE ---
    {"id": 141, "q": "In case of plants, classes with a few similar characters are assigned to a higher category called:", "o": ["Phylum", "Division", "Order", "Family"], "a": "Division"},
    {"id": 142, "q": "Three different species 'tuberosum', 'nigrum', and 'melongena' belong to which Genus?", "o": ["Datura", "Petunia", "Solanum", "Mangifera"], "a": "Solanum"},
    {"id": 143, "q": "Which taxonomic aid serves as a quick referral system? (Old syllabus check, but valid logic)", "o": ["Herbarium", "Flora", "Key", "Museum"], "a": "Herbarium"}, 
    # Note: Even though removed, sometimes basics are asked. But for 2025, focus on below:
    {"id": 144, "q": "Each different kind of plant, animal or organism that you see, represents a:", "o": ["Genus", "Species", "Family", "Taxon"], "a": "Species"},
    {"id": 145, "q": "The scientific term for any category/unit of classification is:", "o": ["Rank", "Taxon", "Grade", "Group"], "a": "Taxon"},
    {"id": 146, "q": "Panthera pardus is the scientific name of:", "o": ["Lion", "Tiger", "Leopard", "Cat"], "a": "Leopard"},
    {"id": 147, "q": "Canis aureus (Jackal) and Canis lupus (Wolf) share the same:", "o": ["Species", "Genus", "Sub-species", "None"], "a": "Genus"},
    {"id": 148, "q": "Taxonomic studies consider a group of individual organisms with fundamental similarities as a:", "o": ["Genus", "Species", "Order", "Family"], "a": "Species"},
    {"id": 149, "q": "Which of the following is NOT a correct statement?", "o": ["Botanical gardens have collections of living plants", "Museum has collection of photographs of plants and animals", "Key is a taxonomic aid for identification", "Herbarium houses dried, pressed plant specimens"], "a": "Museum has collection of photographs of plants and animals"},
    {"id": 150, "q": "The word 'Systematics' takes into account:", "o": ["Evolutionary relationships between organisms", "Only identification", "Only nomenclature", "Only classification"], "a": "Evolutionary relationships between organisms"},
    {"id": 3, "q": "The term 'Polyadelphous' is related to:", "o": ["Gynoecium", "Androecium", "Corolla", "Calyx"], "a": "Androecium"},
    {"id": 4, "q": "Which of the following immunoglobulins does constitute the largest percentage in human milk?", "o": ["IgA", "IgG", "IgD", "IgM"], "a": "IgA"},
    {"id": 5, "q": "Gause's principle of competitive exclusion states that:", "o": ["No two species can occupy the same niche indefinitely", "Larger organisms exclude smaller ones", "More abundant species will exclude the less abundant", "Competition for the same resources excludes species having different food preferences"], "a": "No two species can occupy the same niche indefinitely"},
    {"id": 6, "q": "Which of the following is a hormone releasing IUD?", "o": ["Multiload 375", "LNG-20", "Lippes loop", "Cu7"], "a": "LNG-20"},
    {"id": 7, "q": "Which part of the brain is responsible for thermoregulation?", "o": ["Medulla oblongata", "Cerebrum", "Hypothalamus", "Corpus callosum"], "a": "Hypothalamus"},
    {"id": 8, "q": "A gene showing codominance has:", "o": ["Alleles that are recessive to each other", "Both alleles independently expressed in the heterozygote", "One allele dominant on the other", "Alleles tightly linked on the same chromosome"], "a": "Both alleles independently expressed in the heterozygote"},
    {"id": 9, "q": "Which of the following is commonly used as a vector for introducing a DNA fragment in human lymphocytes?", "o": ["Retrovirus", "Ti plasmid", "Î» phage", "pBR322"], "a": "Retrovirus"},
    {"id": 10, "q": "The motile bacteria are able to move by:", "o": ["Fimbriae", "Flagella", "Cilia", "Pili"], "a": "Flagella"},
    {"id": 11, "q": "Which enzyme helps in opening of DNA helix during transcription?", "o": ["DNA ligase", "DNA helicase", "RNA polymerase", "DNA polymerase"], "a": "RNA polymerase"},
    {"id": 12, "q": "In which disease does mosquito transmitted pathogen cause chronic inflammation of lymphatic vessels?", "o": ["Elephantiasis", "Ascariasis", "Ringworm disease", "Amoebiasis"], "a": "Elephantiasis"},
    {"id": 13, "q": "Which of the following features is not present in the Phylum Arthropoda?", "o": ["Chitinous exoskeleton", "Metameric segmentation", "Parapodia", "Jointed appendages"], "a": "Parapodia"},
    {"id": 14, "q": "The body of the ovule is fused within the funicle at:", "o": ["Hilum", "Micropyle", "Nucellus", "Chalaza"], "a": "Hilum"},
    {"id": 15, "q": "Oxygen is not produced during photosynthesis by:", "o": ["Green sulphur bacteria", "Nostoc", "Cycas", "Chara"], "a": "Green sulphur bacteria"}
]

import discord
from discord import app_commands
import random
import asyncio

# (Make sure this exists at the top of your file)
# USER_USED_QUESTIONS = {} 

# ==============================================================================
# ğŸ§¬ NEET BIOLOGY EXAM (ULTRA-PREMIUM + SMART BANKING)
# ==============================================================================

class NeetBioView(discord.ui.View):
    def __init__(self, player: discord.Member, message: discord.Message, game_questions: list):
        super().__init__(timeout=15.0) # âš¡ 15 Seconds Strict Timer
        self.player = player
        self.message = message # ğŸ› ï¸ FIX: Storing message for safe timeout edits
        self.questions = game_questions 
        self.current_index = 0
        self.game_ended = False
        self.prize_pool = 500000 # $500k
        
        self.load_question()

    def load_question(self):
        self.clear_items()
        
        current_q_data = self.questions[self.current_index]
        self.correct_ans = current_q_data["a"]
        self.q_id = current_q_data["id"]
        
        # Shuffle Options safely
        self.options = current_q_data["o"][:]
        random.shuffle(self.options)
        
        # Create Buttons (Safe Length)
        labels = ["A", "B", "C", "D"]
        for i, opt in enumerate(self.options):
            label_text = f"{labels[i]}: {opt}"[:80] # Discord limit 80 chars
            btn = discord.ui.Button(label=label_text, style=discord.ButtonStyle.secondary, custom_id=opt)
            btn.callback = self.answer_callback
            self.add_item(btn)

    async def on_timeout(self):
        """ âš ï¸ AFK LOGIC: Patient Died! """
        if self.game_ended: return 

        self.game_ended = True
        for item in self.children: item.disabled = True
        
        # --- ğŸ›¡ï¸ APPLY PUNISHMENT ---
        punish_msg = await self.apply_punishment("Too Slow")
        
        embed = discord.Embed(title="âŒ› TIME'S UP! (PATIENT FLATLINED)", color=0x8B0000)
        embed.description = (
            f"### ğŸŒ TOO SLOW, DOCTOR!\n"
            f"**{self.player.mention}**, your 15 seconds ran out!\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ“‰ **Eliminated At:** `Question {self.current_index + 1}/10`\n"
            f" â”— ğŸ¥ **Status:** `{punish_msg}`\n"
        )
        embed.set_thumbnail(url=self.player.display_avatar.url)
        embed.set_image(url="https://media.tenor.com/2147kZ75wW8AAAAC/squid-game-card.gif")
        
        # ğŸ› ï¸ FIX: Safe edit using stored message
        try: await self.message.edit(embed=embed, view=None)
        except: pass

    async def answer_callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.player.id:
            return await interaction.response.send_message("âŒ **Invigilator:** Apni degree khud lo, cheating allow nahi hai!", ephemeral=True)

        if self.game_ended: return
        
        await interaction.response.defer() # ğŸ› ï¸ INSTANT DEFER
        selected_ans = interaction.data["custom_id"]
        
        # ==========================================
        # âŒ WRONG ANSWER CHECK
        # ==========================================
        if selected_ans != self.correct_ans:
            self.game_ended = True
            
            # Highlight buttons
            for item in self.children:
                item.disabled = True
                if item.custom_id == selected_ans: item.style = discord.ButtonStyle.danger
                if item.custom_id == self.correct_ans: item.style = discord.ButtonStyle.success

            punish_msg = await self.apply_punishment("Wrong Answer")
            
            embed = discord.Embed(title="ğŸš« INCORRECT DIAGNOSIS!", color=0xe74c3c)
            embed.description = (
                f"### âŒ WRONG ANSWER!\n"
                f"**Correct Answer:** `{self.correct_ans}`\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ“‰ **Dream Shattered At:** `Q{self.current_index + 1}/10`\n"
                f" â”— ğŸ¥ **Status:** `{punish_msg}`\n"
            )
            embed.set_thumbnail(url=self.player.display_avatar.url)
            embed.set_image(url="https://media.tenor.com/2147kZ75wW8AAAAC/squid-game-card.gif")
            
            await interaction.edit_original_response(embed=embed, view=self)
            self.stop() 
            return

        # ğŸ—‚ï¸ MARK QUESTION AS USED
        if self.player.id not in USER_USED_QUESTIONS:
            USER_USED_QUESTIONS[self.player.id] = []
        USER_USED_QUESTIONS[self.player.id].append(self.q_id)

        # ==========================================
        # âœ… CORRECT ANSWER CHECK
        # ==========================================
        if self.current_index == 9: # 10th Question Cleared!
            self.game_ended = True
            
            # ğŸ† JACKPOT REWARD
            await smart_reward(self.player.id, self.prize_pool)
            
            for item in self.children:
                item.disabled = True
                if item.custom_id == selected_ans: item.style = discord.ButtonStyle.success

            embed = discord.Embed(title="ğŸ©º DR. STRANGE LEVEL UNLOCKED!", color=0xFFD700) # Gold
            embed.description = (
                f"### ğŸ‰ FLAWLESS MEDICAL EXPERTISE!\n"
                f"**{self.player.mention}** cleared all 10 brutal NCERT questions!\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ“ **Degree Status:** `MBBS Confirmed`\n"
                f" â”— ğŸ’° **Scholarship Rewarded:** `${self.prize_pool:,}`\n"
            )
            embed.set_image(url="https://media.tenor.com/p7a8o1r5c8cAAAAC/money-rain.gif")
            
            await interaction.edit_original_response(embed=embed, view=self)
            self.stop() 
        
        else:
            # ğŸ”„ NEXT QUESTION
            self.current_index += 1
            self.load_question()
            
            q_text = self.questions[self.current_index]["q"]
            
            embed = discord.Embed(title=f"ğŸ§¬ NEET BIO: STAGE {self.current_index + 1} / 10", color=0x3498db) # Blue
            embed.description = (
                f"ğŸ‘¤ **Student:** {self.player.mention}\n"
                f"ğŸ† **Goal:** `${self.prize_pool:,}`\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f"â“ **{q_text}**\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f"> âš¡ **15 SECONDS LEFT! THINK FAST!**"
            )
            embed.set_footer(text="Galti ki toh naam 'Unpad' rakh diya jayega!", icon_url=self.player.display_avatar.url)
            
            await interaction.edit_original_response(embed=embed, view=self)

    async def apply_punishment(self, reason):
        """ ğŸ“› PREMIUM RENAMING LOGIC (NO TIMEOUT) """
        is_safe = False
        punish_status = ""
        
        # ğŸ—„ï¸ SAFE DB CHECK
        try:
            res = await db_call(lambda: supabase.table("economy").select("inventory").eq("user_id", str(self.player.id)).execute())
            if res and res.data:
                inv = res.data[0].get("inventory", {})
                if inv.get("life", 0) > 0:
                    inv["life"] -= 1
                    await db_call(lambda: supabase.table("economy").update({"inventory": inv}).eq("user_id", str(self.player.id)).execute())
                    is_safe = True
                    punish_status = "ğŸ’– Extra Life Consumed (Honor Saved)"
        except Exception as e:
            print(f"NEET DB Error: {e}")

        if not is_safe:
            # ğŸ“› APPLY HUMILIATION
            shame_names = ["Unpad Gawar", "Jhola Chhap", "Compounder", "Bio Fail", "MBBS Reject"]
            new_nick = f"{random.choice(shame_names)} {self.player.name[:10]}"
            
            try:
                bot_member = self.player.guild.me
                if self.player.top_role < bot_member.top_role and self.player.id != self.player.guild.owner_id:
                    await self.player.edit(nick=new_nick)
                    punish_status = f"Renamed to `{new_nick}`"
                else:
                    punish_status = "Admin Shield (Cannot Rename)"
            except:
                punish_status = "Bot lacks Manage Nicknames permission"

        # Note: No timeout applied here, just as you requested!
        return punish_status


# ==============================================================================
# ğŸ’» MAIN COMMAND
# ==============================================================================
@bot.tree.command(name="neet_biology", description="ğŸ§¬ Answer 10 NCERT Biology questions non-stop to win $500k!")
@check_seized()
async def neet_biology(i: discord.Interaction):
    await i.response.defer() # â³ Instant Defer
    
    if 'BIO_QUESTIONS' not in globals():
         return await i.followup.send("âŒ **System Error:** 'BIO_QUESTIONS' database not found!", ephemeral=True)
         
    if not i.guild.me.guild_permissions.manage_nicknames:
        return await i.followup.send("âŒ **System Error:** Bot needs `Manage Nicknames` permission to punish failures!", ephemeral=True)
    
    user_id = i.user.id
    
    # Check used questions
    used_ids = USER_USED_QUESTIONS.get(user_id, [])
    available_qs = [q for q in BIO_QUESTIONS if q["id"] not in used_ids]
    
    if len(available_qs) < 10:
        win_embed = discord.Embed(title="ğŸ† NATIONAL TOPPER", color=0xFFD700)
        win_embed.description = "You have successfully solved **EVERY** available Biology question in the database!\nWait for the syllabus update."
        return await i.followup.send(embed=win_embed)
    
    # ğŸ¯ Pick 10 random unique questions
    game_questions = random.sample(available_qs, 10)
    
    # ğŸ’ Premium Intro Embed
    embed = discord.Embed(title="ğŸ§¬ NATIONAL ELIGIBILITY TEST (NEET)", color=0x2ECC71)
    embed.description = (
        f"### âš ï¸ EXAM PROTOCOL INITIATED\n"
        f"**Candidate:** {i.user.mention}\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f" â”£ ğŸ“š **Subject:** `Biology (NCERT Based)`\n"
        f" â”£ ğŸ¯ **Target:** `10 Questions Non-Stop`\n"
        f" â”£ ğŸ’° **Scholarship:** `$500,000`\n"
        f" â”— ğŸ’€ **Penalty:** `Public Humiliation (Name Change)`\n\n"
        f"*Initializing question paper...*\n"
    )
    embed.set_thumbnail(url=i.user.display_avatar.url)
    
    msg = await i.followup.send(embed=embed)
    await asyncio.sleep(2) # Fake loading suspense
    
    view = NeetBioView(i.user, msg, game_questions)
    
    # Display Question 1
    q_text = view.questions[0]["q"]
    first_embed = discord.Embed(title="ğŸ§¬ NEET BIO: STAGE 1 / 10", color=0x3498db)
    first_embed.description = (
        f"ğŸ‘¤ **Student:** {i.user.mention}\n"
        f"ğŸ† **Goal:** `$500,000`\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"â“ **{q_text}**\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"> âš¡ **15 SECONDS LEFT! THINK FAST!**"
    )
    first_embed.set_footer(text="Galti ki toh naam 'Unpad' rakh diya jayega!", icon_url=i.user.display_avatar.url)
    
    await msg.edit(embed=first_embed, view=view)
               

import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# ğŸ§  THE TRIVIA GAUNTLET COMMAND (FIXED & ULTRA-PREMIUM)
# ==============================================================================

@bot.tree.command(name="quiz", description="ğŸ§  The Gauntlet: Answer 7 Hard Questions consecutively for a 10x Reward!")
@app_commands.describe(bet="How much are you willing to risk?")
@check_seized()
async def quiz(i: discord.Interaction, bet: int):
    # â³ 1. INSTANT DEFER (Crash Prevention)
    await i.response.defer(ephemeral=False)

    # ğŸ›¡ï¸ 2. VALIDATION CHECKS
    if bet < 5000:
        return await i.followup.send("âŒ **Error:** Minimum bet is `$5,000`. This is for true intellects only!", ephemeral=True)
    
    # Check if 'TRIVIA_QUESTIONS' exists in your global code
    if 'TRIVIA_QUESTIONS' not in globals() or len(TRIVIA_QUESTIONS) < 7:
        return await i.followup.send("âŒ **System Error:** Trivia Database is currently offline or insufficient.", ephemeral=True)

    # ğŸ’³ 3. SMART CHARGE (Checks Wallet + Bank combined)
    # Automatically handles checking balance and deducting funds
    paid = await smart_charge(i.user.id, bet)
    if not paid:
        # Fetch current total net worth for display
        try:
            res = await db_call(lambda: supabase.table("economy").select("balance, bank").eq("user_id", str(i.user.id)).execute())
            bal = int(res.data[0].get('balance', 0)) if res and res.data else 0
            bank = int(res.data[0].get('bank', 0)) if res and res.data else 0
            total = bal + bank
        except: total = 0
            
        return await i.followup.send(f"âŒ **Broke Alert!** You need `${bet:,}` in your Wallet + Bank. Current Net Worth: `${total:,}`", ephemeral=True)

    # ğŸ¯ 4. GAME INITIALIZATION
    # Pick 7 Random Unique Questions
    gauntlet_questions = random.sample(TRIVIA_QUESTIONS, 7)
    
    # ğŸ’ Premium Intro Embed
    embed = discord.Embed(title="ğŸ§  TRIVIA GAUNTLET: INITIATED", color=0x9B59B6) # Deep Purple
    embed.description = (
        f"### âš ï¸ INTELLIGENCE CALIBRATION\n"
        f"**Subject:** {i.user.mention}\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f" â”£ ğŸ¯ **Target:** `7 Questions (Stage 1-7)`\n"
        f" â”£ ğŸ’° **Original Bet:** `${bet:,}`\n"
        f" â”£ ğŸ¤‘ **Jackpot Prize:** `${(bet * 10):,}` *(10x)*\n"
        f" â”— ğŸ’€ **Penalty:** `1 Hour Mute (Hospital)`\n\n"
        f"*Initializing secure connection to the mainframe...*\n"
    )
    embed.set_thumbnail(url=i.user.display_avatar.url)
    embed.set_image(url="https://media.tenor.com/4J1d3uJtB3QAAAAC/matrix-code.gif")
    
    msg = await i.followup.send(embed=embed)
    await asyncio.sleep(2) # Suspense builder

    # ğŸš€ 5. START FIRST ROUND
    first_q = gauntlet_questions[0]
    
    # Update to Stage 1 Embed
    stage_embed = discord.Embed(title="ğŸ§  TRIVIA GAUNTLET: STAGE 1 / 7", color=0x3498db)
    stage_embed.description = (
        f"ğŸ‘¤ **Candidate:** {i.user.mention}\n"
        f"ğŸ’° **Current Pot:** `${bet:,}`\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"**Question:**\n> {first_q['q']}\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"âš¡ **Time Limit:** `10 Seconds!`"
    )
    stage_embed.set_footer(text="A single mistake results in immediate termination.", icon_url=i.user.display_avatar.url)
    
    # Initialize the Gauntlet View (Helper function only)
    view = TriviaGauntletView(i.user, bet, msg, gauntlet_questions)
    
    # Final Edit to start the game
    await msg.edit(embed=stage_embed, view=view)

import discord
from discord import app_commands
import asyncio

# ==============================================================================
# ğŸ† GLOBAL TITAN LEADERBOARD: THE TOP BILLIONAIRES
# ==============================================================================

class LeaderboardView(discord.ui.View):
    def __init__(self, interaction_user):
        super().__init__(timeout=120)
        self.interaction_user = interaction_user

    @discord.ui.button(label="REFRESH DATA", style=discord.ButtonStyle.success, emoji="ğŸ”„")
    async def refresh_callback(self, interaction: discord.Interaction, button: discord.ui.Button):
        # ğŸ› ï¸ Security: Only the command triggerer can refresh to save API calls
        if interaction.user.id != self.interaction_user.id:
            return await interaction.response.send_message("âŒ **Denied:** Create your own leaderboard to refresh!", ephemeral=True)
            
        await interaction.response.defer() # â³ Instant Defer
        await show_leaderboard(interaction, is_refresh=True)

# --- MAIN ENGINE ---
async def show_leaderboard(interaction: discord.Interaction, is_refresh=False):
    try:
        # ğŸ—„ï¸ SAFE DATA FETCH (Fetching net worth: balance + bank)
        res = await db_call(lambda: supabase.table("economy").select("user_id, balance, bank").execute())
        db_data = res.data if res else []
    except Exception as e:
        print(f"Leaderboard DB Error: {e}")
        error_msg = "âŒ **Mainframe Error:** Could not sync with the banking server."
        if is_refresh: await interaction.edit_original_response(content=error_msg, embed=None, view=None)
        else: await interaction.followup.send(error_msg, ephemeral=True)
        return

    if not db_data:
        msg = "ğŸ“­ **Database Empty:** No accounts detected in the Titan Ledger."
        if is_refresh: await interaction.edit_original_response(content=msg, embed=None, view=None)
        else: await interaction.followup.send(msg, ephemeral=True)
        return

    # ğŸ§® PROCESS & SORT DATA
    leaderboard_data = []
    total_economy = 0
    
    for row in db_data:
        uid = row.get('user_id')
        total_net_worth = int(row.get('balance', 0)) + int(row.get('bank', 0))
        total_economy += total_net_worth
        leaderboard_data.append((uid, total_net_worth))
    
    # Highest to Lowest
    sorted_users = sorted(leaderboard_data, key=lambda x: x[1], reverse=True)
    top_10 = sorted_users[:10]
    
    # ğŸ¨ BUILD THE LIST (PREMIUM TREE UI)
    desc = ""
    medals = ["ğŸ¥‡", "ğŸ¥ˆ", "ğŸ¥‰"]
    
    for rank, (user_id, amount) in enumerate(top_10):
        formatted_bal = f"${amount:,}"
        user_mention = f"<@{user_id}>"
        
        if rank < 3:
            rank_icon = medals[rank]
            desc += f"{rank_icon} **{user_mention}**\n â”— ğŸ’ **Net Worth:** `{formatted_bal}`\n\n"
        else:
            # Hacker Style Tree for Rank 4-10
            is_last = (rank == len(top_10) - 1)
            prefix = " â”—" if is_last else " â”£"
            desc += f"`#{rank+1:02d}` {user_mention}\n{prefix} ğŸ’¸ `{formatted_bal}`\n"

    # ğŸ‘¤ CALCULATE CALLER'S PERSONAL STATS
    user_rank = "N/A"
    user_net_worth = 0
    target_id = str(interaction.user.id)
    
    for rank, (uid, amount) in enumerate(sorted_users):
        if str(uid) == target_id:
            user_rank = f"#{rank+1}"
            user_net_worth = amount
            break

    # ğŸ’ CREATE ULTRA-PREMIUM EMBED
    embed = discord.Embed(title="ğŸ† GLOBAL TITAN LEADERBOARD", color=0xFFD700)
    embed.description = (
        f"### ğŸŒ Server GDP: `${total_economy:,}`\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"{desc}"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬"
    )
    
    # Image selection for premium feel
    embed.set_thumbnail(url=interaction.guild.icon.url if interaction.guild.icon else None)
    embed.set_image(url="https://media.tenor.com/EA84s3occX8AAAAC/burning-money-money.gif") # Burning Money GIF
    
    embed.set_footer(
        text=f"ğŸ«µ Your Standing: {user_rank} | Total Worth: ${user_net_worth:,}", 
        icon_url=interaction.user.display_avatar.url
    )
    embed.timestamp = discord.utils.utcnow()

    view = LeaderboardView(interaction.user)
    
    if is_refresh:
        await interaction.edit_original_response(embed=embed, view=view)
    else:
        await interaction.followup.send(embed=embed, view=view)

# ==============================================================================
# ğŸš€ MAIN SLASH COMMAND
# ==============================================================================
@bot.tree.command(name="leaderboard", description="ğŸ† View the Top 10 Richest Billionaires in the World")
@check_seized()
async def leaderboard(interaction: discord.Interaction):
    await interaction.response.defer() # â³ Prevent 'Interaction Failed' during heavy DB loads
    await show_leaderboard(interaction)


# --- RPS VIEW CLASS ---
import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# âš”ï¸ ROCK PAPER SCISSORS: ULTRA-PREMIUM DUEL ARENA (SMART BANKING + CAP)
# ==============================================================================

class RPSGameView(discord.ui.View):
    def __init__(self, p1: discord.Member, p2: discord.Member, bet: int):
        super().__init__(timeout=300) # â³ 5 Minute Duel Buffer
        self.p1 = p1
        self.p2 = p2
        self.bet = bet
        self.moves = {} # {user_id: "rock"}
        self.round_num = 1

    async def resolve_round(self, interaction: discord.Interaction):
        """ ğŸ§  CORE LOGIC: Determines the fate of the players """
        m1 = self.moves[self.p1.id]
        m2 = self.moves[self.p2.id]
        
        # Determine Winner
        winner = None
        if m1 == m2:
            winner = "draw"
        elif (m1 == "rock" and m2 == "scissors") or \
             (m1 == "paper" and m2 == "rock") or \
             (m1 == "scissors" and m2 == "paper"):
            winner = self.p1
        else:
            winner = self.p2

        emoji_map = {"rock": "ğŸª¨ ROCK", "paper": "ğŸ“„ PAPER", "scissors": "âœ‚ï¸ SCISSORS"}

        # ğŸ¤ SCENARIO A: THE STALEMATE (DRAW)
        if winner == "draw":
            self.moves = {} # Reset moves for next round
            self.round_num += 1
            
            embed = discord.Embed(title="ğŸ¤ STALEMATE! IT'S A DRAW", color=0xF1C40F) # Yellow
            embed.description = (
                f"### ğŸ”„ RE-ARMING FOR ROUND {self.round_num}\n"
                f"Both warriors chose the same weapon!\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ âš”ï¸ **{self.p1.display_name}:** `{emoji_map[m1]}`\n"
                f" â”£ âš”ï¸ **{self.p2.display_name}:** `{emoji_map[m2]}`\n"
                f" â”— ğŸ’° **Pot Status:** `${(self.bet * 2):,}` remains on the table!\n\n"
                f"ğŸ‘‡ **CHOOSE YOUR WEAPON AGAIN!**"
            )
            embed.set_image(url="https://media.tenor.com/Images/draw.gif")
            return await interaction.edit_original_response(embed=embed, view=self)

        # ğŸ† SCENARIO B: TOTAL DOMINATION (WINNER)
        self.stop()
        loser = self.p2 if winner == self.p1 else self.p1
        
        # ğŸ’³ EXECUTE SMART TRANSACTION
        total_pot = self.bet * 2
        await smart_reward(winner.id, total_pot)

        # Final Victory Embed
        embed = discord.Embed(title="ğŸ† DUEL CONCLUDED: FATAL BLOW", color=0x2ECC71) # Green
        embed.set_thumbnail(url=winner.display_avatar.url)
        embed.description = (
            f"### ğŸ‰ {winner.mention} HAS EMERGED VICTORIOUS!\n"
            f"The dust settles and only one stands.\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ‘‘ **Winner:** {winner.mention} (`{emoji_map[self.moves[winner.id]]}`)\n"
            f" â”£ ğŸ’€ **Loser:** {loser.mention} (`{emoji_map[self.moves[loser.id]]}`)\n"
            f" â”£ ğŸ’° **Bounty Collected:** `${total_pot:,}`\n"
            f" â”— ğŸ“ˆ **Net Profit:** `+${self.bet:,}`\n"
        )
        embed.set_footer(text=f"Match resolved in {self.round_num} round(s)", icon_url=winner.display_avatar.url)
        embed.set_image(url="https://media.tenor.com/p7a8o1r5c8cAAAAC/money-rain.gif")
        
        await interaction.edit_original_response(embed=embed, view=None)

    async def process_move(self, interaction: discord.Interaction, move: str):
        """ ğŸ›¡ï¸ SAFETY CHECK & MOVE HANDLER """
        if interaction.user.id not in [self.p1.id, self.p2.id]:
            return await interaction.response.send_message("âŒ **Guard:** Stay back! This is a private execution.", ephemeral=True)
        
        if interaction.user.id in self.moves:
            return await interaction.response.send_message("âœ… **Guard:** Weapon already selected. Wait for the opponent!", ephemeral=True)

        await interaction.response.defer() # ğŸ› ï¸ Interaction Failed Shield
        
        # Save Move
        self.moves[interaction.user.id] = move
        await interaction.followup.send(f"ğŸ¤« You chose **{move.upper()}**! Pray they chose weak.", ephemeral=True)

        # Check if both played
        if len(self.moves) == 2:
            await self.resolve_round(interaction)

    # --- BUTTONS (NEON STYLE) ---
    @discord.ui.button(emoji="ğŸª¨", label="ROCK", style=discord.ButtonStyle.secondary)
    async def rock(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.process_move(interaction, "rock")

    @discord.ui.button(emoji="ğŸ“„", label="PAPER", style=discord.ButtonStyle.secondary)
    async def paper(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.process_move(interaction, "paper")

    @discord.ui.button(emoji="âœ‚ï¸", label="SCISSORS", style=discord.ButtonStyle.secondary)
    async def scissors(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.process_move(interaction, "scissors")


# --- ğŸ›¡ï¸ CHALLENGE REQUEST HANDLER ---
class RPSRequestView(discord.ui.View):
    def __init__(self, challenger: discord.Member, opponent: discord.Member, bet: int):
        super().__init__(timeout=60)
        self.challenger = challenger
        self.opponent = opponent
        self.bet = bet
        self.message = None

    @discord.ui.button(label="ACCEPT CHALLENGE", style=discord.ButtonStyle.success, emoji="âš”ï¸")
    async def accept(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.opponent.id:
            return await interaction.response.send_message("âŒ **Guard:** Not your fight.", ephemeral=True)

        await interaction.response.defer()

        # ğŸ’³ SMART CHARGE (CHALLENGER & OPPONENT)
        c_paid = await smart_charge(self.challenger.id, self.bet)
        if not c_paid:
            return await interaction.followup.send(f"âŒ {self.challenger.mention} is now too broke to fund this duel!", ephemeral=True)

        o_paid = await smart_charge(self.opponent.id, self.bet)
        if not o_paid:
            await smart_reward(self.challenger.id, self.bet)
            return await interaction.followup.send(f"âŒ You need `${self.bet:,}` in your Wallet + Bank to accept!", ephemeral=True)

        self.stop()
        embed = discord.Embed(title="ğŸ”¥ NEON DUEL ARENA: OPEN", color=0xE67E22)
        embed.set_author(name=f"DUEL: {self.challenger.display_name} vs {self.opponent.display_name}", icon_url=self.challenger.display_avatar.url)
        embed.description = (
            f"ğŸ’° **Total Stakes:** `${(self.bet * 2):,}`\n"
            f"ğŸŸï¸ **Phase:** Weapons Selection\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ âš”ï¸ **Challenger:** {self.challenger.mention}\n"
            f" â”£ ğŸ›¡ï¸ **Defender:** {self.opponent.mention}\n"
            f" â”— âš–ï¸ **Rules:** Draw = Restart Round\n\n"
            f"ğŸ‘‡ **SELECT YOUR WEAPON BELOW!**"
        )
        embed.set_image(url="https://media.tenor.com/JUPQeN4jXzAAAAAC/rock-paper-scissors.gif")
        
        view = RPSGameView(self.challenger, self.opponent, self.bet)
        await interaction.edit_original_response(embed=embed, view=view)

    @discord.ui.button(label="RETREAT", style=discord.ButtonStyle.danger, emoji="ğŸƒâ€â™‚ï¸")
    async def decline(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.opponent.id:
            return await interaction.response.send_message("âŒ Just watch the cowards run.", ephemeral=True)
        
        self.stop()
        embed = discord.Embed(title="ğŸƒâ€â™‚ï¸ CHALLENGE REJECTED", description=f"**{self.opponent.mention}** has retreated from the duel. Cowardice noted.", color=0x95a5a6)
        await interaction.edit_original_response(embed=embed, view=None)

    async def on_timeout(self):
        if self.message:
            try: await self.message.edit(content="â³ *Duel request expired in the wind...*", embed=None, view=None)
            except: pass


# ==============================================================================
# ğŸš€ MAIN COMMAND
# ==============================================================================
@bot.tree.command(name="rps", description="ğŸ° Duel another player in Rock Paper Scissors for high stakes!")
@app_commands.describe(opponent="The warrior you wish to challenge", amount="Wager amount (Min: $100 | Max: $50,000)")
@check_seized()
async def rps(interaction: discord.Interaction, opponent: discord.Member, amount: int):
    
    # ğŸ›¡ï¸ 1. BASE SECURITY & BET LIMIT
    if opponent.id == interaction.user.id:
        return await interaction.response.send_message("âŒ **Guard:** You cannot duel your own shadow.", ephemeral=True)
    if opponent.bot:
        return await interaction.response.send_message("âŒ **Guard:** Machines have no honor. Challenge a human.", ephemeral=True)
    
    # ğŸ‘‡ THE NEW BET LIMIT LOGIC ($50,000 MAX)
    MAX_BET = 50000
    if amount > MAX_BET:
        return await interaction.response.send_message(f"âŒ **Arena Rules:** Maximum bet allowed is `${MAX_BET:,}`! Keep it under control.", ephemeral=True)
    
    if amount < 100:
        return await interaction.response.send_message("âŒ **Guard:** Minimum wager is **$100**.", ephemeral=True)

    # ğŸ—„ï¸ 2. PRE-CHECK LIQUIDITY
    try:
        c_res = await db_call(lambda: supabase.table("economy").select("balance, bank").eq("user_id", str(interaction.user.id)).execute())
        c_total = int(c_res.data[0].get('balance', 0)) + int(c_res.data[0].get('bank', 0)) if c_res and c_res.data else 0
        if c_total < amount:
            return await interaction.response.send_message(f"âŒ **Guard:** You are too broke! Current Net Worth: `${c_total:,}`", ephemeral=True)

        o_res = await db_call(lambda: supabase.table("economy").select("balance, bank").eq("user_id", str(opponent.id)).execute())
        o_total = int(o_res.data[0].get('balance', 0)) + int(o_res.data[0].get('bank', 0)) if o_res and o_res.data else 0
        if o_total < amount:
            return await interaction.response.send_message(f"âŒ **Guard:** **{opponent.display_name}** is a peasant. They can't afford this duel!", ephemeral=True)
            
    except Exception as e:
        print(f"RPS Check Error: {e}")
        return await interaction.response.send_message("âŒ **Mainframe Error:** Database unreachable.", ephemeral=True)

    # ğŸ“œ 3. SEND FORMAL CHALLENGE
    embed = discord.Embed(title="âš”ï¸ FORMAL DUEL CHALLENGE", color=0xFFA500)
    embed.set_author(name=f"{interaction.user.display_name} has thrown the gauntlet!", icon_url=interaction.user.display_avatar.url)
    embed.set_thumbnail(url="https://media.tenor.com/JUPQeN4jXzAAAAAC/rock-paper-scissors.gif")
    
    embed.description = (
        f"### ğŸ›¡ï¸ AWAITING RESPONSE\n"
        f"**{interaction.user.mention}** is challenging **{opponent.mention}** to a deathmatch!\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f" â”£ âš”ï¸ **Challenger:** {interaction.user.mention}\n"
        f" â”£ ğŸ›¡ï¸ **Defender:** {opponent.mention}\n"
        f" â”— ğŸ’° **Wager:** `${amount:,}`\n\n"
        f"ğŸ‘‡ **{opponent.mention}, will you defend your honor?**"
    )
    
    view = RPSRequestView(interaction.user, opponent, amount)
    msg = await interaction.response.send_message(content=f"ğŸ”” {opponent.mention}, you have been challenged!", embed=embed, view=view)
    view.message = msg


# --- TIC TAC TOE BUTTON ---
import discord
from discord import app_commands
import datetime as dt
import asyncio

# ==============================================================================
# âŒâ­• TIC-TAC-TOE: THE DEATHMATCH ARENA (ULTRA-PREMIUM + SMART BANKING)
# ==============================================================================

# --- 1. THE BUTTON CLASS (High-Tech Grid Cell) ---
class TTTButton(discord.ui.Button):
    def __init__(self, x, y):
        super().__init__(style=discord.ButtonStyle.secondary, label="\u200b", row=y)
        self.x = x
        self.y = y

    async def callback(self, interaction: discord.Interaction):
        view: TicTacToeGameView = self.view
        
        # ğŸ›¡ï¸ SECURITY CHECKS
        if view.winner is not None: return
        if interaction.user.id != view.current_turn.id:
            return await interaction.response.send_message("âŒ **Wait your turn!** Only the active player can move.", ephemeral=True)
        
        await interaction.response.defer() # ğŸ› ï¸ Instant Defer to prevent lag

        # âš”ï¸ UPDATE STATE
        view.board[self.y * 3 + self.x] = view.current_turn.id
        self.style = discord.ButtonStyle.danger if view.current_turn == view.p1 else discord.ButtonStyle.success
        self.label = "âŒ" if view.current_turn == view.p1 else "â­•"
        self.disabled = True
        
        # ğŸ“Š CHECK WINNER
        winner = view.check_winner()
        
        if winner:
            view.winner = winner
            await view.game_over(interaction, winner)
        elif 0 not in view.board: 
            await view.handle_draw(interaction)
        else:
            view.switch_turn()
            await view.update_message(interaction)


# --- 2. THE GAME VIEW (Logic Engine) ---
class TicTacToeGameView(discord.ui.View):
    def __init__(self, p1, p2, bet, message=None):
        super().__init__(timeout=300)
        self.p1 = p1
        self.p2 = p2
        self.bet = bet
        self.message = message
        self.current_turn = p1 
        self.board = [0] * 9
        self.winner = None
        self.draw_count = 0

        # Generate 3x3 Grid
        for y in range(3):
            for x in range(3):
                self.add_item(TTTButton(x, y))

    def check_winner(self):
        wins = [(0,1,2), (3,4,5), (6,7,8), (0,3,6), (1,4,7), (2,5,8), (0,4,8), (2,4,6)]
        for a, b, c in wins:
            if self.board[a] == self.board[b] == self.board[c] and self.board[a] != 0:
                return self.p1 if self.board[a] == self.p1.id else self.p2
        return None

    def switch_turn(self):
        self.current_turn = self.p2 if self.current_turn == self.p1 else self.p1

    async def update_message(self, interaction, custom_msg=None):
        embed = interaction.message.embeds[0]
        symbol = "âŒ" if self.current_turn == self.p1 else "â­•"
        status = custom_msg if custom_msg else f"ğŸ‘‰ **{self.current_turn.name}'s Turn** ({symbol})"
        
        embed.description = (
            f"ğŸ’° **Total Pot:** `${self.bet * 2:,}` | ğŸ”„ **Draws:** `{self.draw_count}`\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ âŒ **Challenger:** {self.p1.mention}\n"
            f" â”£ â­• **Defender:** {self.p2.mention}\n"
            f" â”— âš¡ **Status:** {status}"
        )
        embed.color = 0xe74c3c if self.current_turn == self.p1 else 0x2ecc71
        await interaction.edit_original_response(embed=embed, view=self)

    async def handle_draw(self, interaction):
        self.board = [0] * 9
        self.draw_count += 1
        for child in self.children:
            child.label = "\u200b"
            child.style = discord.ButtonStyle.secondary
            child.disabled = False
        await self.update_message(interaction, custom_msg="âš ï¸ **STALEMATE!** Resetting Board...")

    async def game_over(self, interaction, winner):
        for child in self.children: child.disabled = True 
        loser = self.p2 if winner == self.p1 else self.p1
        
        # ğŸ’¸ TRANSACTION (Winner takes the whole pot)
        await smart_reward(winner.id, self.bet * 2)

        # ğŸ’€ PUNISHMENT
        punish_msg = "`No Punishment (VIP/Life Safe)`"
        try:
            res = await db_call(lambda: supabase.table("economy").select("vip_expiry, inventory").eq("user_id", str(loser.id)).execute())
            data = res.data[0] if res and res.data else {}
            inv = data.get('inventory', {}) or {}
            is_vip = bool(data.get("vip_expiry"))

            if not is_vip and inv.get("life", 0) > 0:
                inv["life"] -= 1
                await db_call(lambda: supabase.table("economy").update({"inventory": inv}).eq("user_id", str(loser.id)).execute())
                punish_msg = "ğŸ’– **Extra Life Used!** (Honor Saved)"
            elif not is_vip:
                try:
                    await loser.timeout(dt.timedelta(seconds=20), reason="Lost Tic Tac Toe Duel")
                    punish_msg = f"ğŸ”‡ **MUTED:** {loser.mention} silenced for 20s!"
                except: punish_msg = "*(Admin Shield Active)*"
        except Exception as e: print(f"TTT Punish Error: {e}")

        # ğŸ† FINAL EMBED
        embed = discord.Embed(title="ğŸ‘‘ ARENA VICTORY", color=0xFFD700)
        embed.set_thumbnail(url=winner.display_avatar.url)
        embed.description = (
            f"### ğŸ‰ {winner.mention} HAS WON!\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ’° **Bounty Collected:** `${(self.bet * 2):,}`\n"
            f" â”£ ğŸ’€ **Loser:** {loser.mention}\n"
            f" â”— ğŸ¥ **Report:** {punish_msg}"
        )
        embed.set_image(url="https://media.tenor.com/p7a8o1r5c8cAAAAC/money-rain.gif")
        await interaction.edit_original_response(embed=embed, view=None)


# --- 3. REQUEST VIEW ---
class TTTRequestView(discord.ui.View):
    def __init__(self, challenger, opponent, bet):
        super().__init__(timeout=60)
        self.challenger = challenger
        self.opponent = opponent
        self.bet = bet

    @discord.ui.button(label="ACCEPT CHALLENGE", style=discord.ButtonStyle.success, emoji="âš”ï¸")
    async def accept(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.opponent.id:
            return await interaction.response.send_message("âŒ **Guard:** This fight is not for you!", ephemeral=True)

        await interaction.response.defer()

        # ğŸ’³ SMART CHARGE BOTH PLAYERS
        c_paid = await smart_charge(self.challenger.id, self.bet)
        if not c_paid:
            return await interaction.followup.send(f"âŒ {self.challenger.mention} can no longer afford this bet!", ephemeral=True)
            
        o_paid = await smart_charge(self.opponent.id, self.bet)
        if not o_paid:
            await smart_reward(self.challenger.id, self.bet) # Refund
            return await interaction.followup.send(f"âŒ You need `${self.bet:,}` in your Wallet + Bank to accept!", ephemeral=True)

        # START ARENA
        embed = discord.Embed(title="âš”ï¸ TIC-TAC-TOE DEATHMATCH", color=0x2ECC71)
        embed.description = (
            f"ğŸ’° **Total Pot:** `${self.bet * 2:,}`\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ âŒ **Challenger:** {self.challenger.mention}\n"
            f" â”£ â­• **Defender:** {self.opponent.mention}\n"
            f" â”— âš¡ **Status:** ğŸ‘‰ **{self.challenger.name}'s Turn** (âŒ)"
        )
        embed.set_thumbnail(url=self.challenger.display_avatar.url)
        
        game_view = TicTacToeGameView(self.challenger, self.opponent, self.bet)
        await interaction.edit_original_response(embed=embed, view=game_view)

    @discord.ui.button(label="DECLINE", style=discord.ButtonStyle.danger, emoji="ğŸƒâ€â™‚ï¸")
    async def decline(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.opponent.id:
            return await interaction.response.send_message("âŒ **Guard:** Back off!", ephemeral=True)
        
        self.stop()
        embed = discord.Embed(description=f"ğŸƒâ€â™‚ï¸ **{self.opponent.mention}** has retreated from the match. Cowardice noted.", color=0xe74c3c)
        await interaction.response.edit_message(embed=embed, view=None)


# --- 4. MAIN COMMAND ---
@bot.tree.command(name="tictactoe", description="âŒâ­• High Stakes: Winner takes the Pot, Loser gets Muted!")
@app_commands.describe(opponent="The user you wish to challenge", amount="Wager amount (Min: $100 | Max: $50,000)")
@check_seized()
async def tictactoe(interaction: discord.Interaction, opponent: discord.Member, amount: int):
    
    # ğŸ›‘ 1. BASE SECURITY & LIMITS
    MAX_BET = 50000
    if opponent.id == interaction.user.id:
        return await interaction.response.send_message("âŒ **Error:** You cannot duel yourself.", ephemeral=True)
    if opponent.bot:
        return await interaction.response.send_message("âŒ **Error:** Bots have no souls to mute.", ephemeral=True)
    if amount > MAX_BET:
        return await interaction.response.send_message(f"âŒ **Arena Rules:** Maximum bet allowed is `${MAX_BET:,}`!", ephemeral=True)
    if amount < 100:
        return await interaction.response.send_message("âŒ **Error:** Minimum bet is `$100`.", ephemeral=True)

    # ğŸ—„ï¸ 2. PRE-CHECK LIQUIDITY (Wallet + Bank)
    try:
        # Challenger Check
        c_res = await db_call(lambda: supabase.table("economy").select("balance, bank").eq("user_id", str(interaction.user.id)).execute())
        c_total = int(c_res.data[0].get('balance', 0)) + int(c_res.data[0].get('bank', 0)) if c_res and c_res.data else 0
        if c_total < amount:
            return await interaction.response.send_message(f"âŒ **Broke:** You need `${amount:,}` (Wallet + Bank).", ephemeral=True)
        
        # Opponent Check
        o_res = await db_call(lambda: supabase.table("economy").select("balance, bank").eq("user_id", str(opponent.id)).execute())
        o_total = int(o_res.data[0].get('balance', 0)) + int(o_res.data[0].get('bank', 0)) if o_res and o_res.data else 0
        if o_total < amount:
            return await interaction.response.send_message(f"âŒ **Error:** {opponent.display_name} doesn't have enough money!", ephemeral=True)
    except Exception as e:
        return await interaction.response.send_message("âŒ **Mainframe Error:** Database unreachable.", ephemeral=True)

    # ğŸŸï¸ 3. SEND FORMAL CHALLENGE
    embed = discord.Embed(title="ğŸ“œ TIC-TAC-TOE CHALLENGE Inbound", color=0xF1C40F)
    embed.set_thumbnail(url="https://media.tenor.com/84j7q3u2vSAAAAAi/tic-tac-toe.gif")
    embed.description = (
        f"âš”ï¸ **Challenger:** {interaction.user.mention}\n"
        f"ğŸ›¡ï¸ **Opponent:** {opponent.mention}\n"
        f"ğŸ’° **Stakes:** `${amount:,}`\n\n"
        f"**RULES:**\n"
        f"â”£ ğŸ† **Winner takes all** (`Pot: ${(amount*2):,}`)\n"
        f"â”£ ğŸ”‡ **Loser gets Muted** for 20s (Unless Life-Saver active)\n"
        f"â”— ğŸ”„ **Draw = Rematch** (Auto-Reset)\n\n"
        f"ğŸ‘‡ **{opponent.mention}, do you accept this duel?**"
    )
    
    view = TTTRequestView(interaction.user, opponent, amount)
    await interaction.response.send_message(f"ğŸ”” {opponent.mention}, you have been challenged to a Deathmatch!", embed=embed, view=view)
        

# ================== MINE FIELD ================
import discord
from discord import app_commands
import random
import asyncio
import datetime as dt

# ==============================================================================
# ğŸ’£ THE MINEFIELD: DIAMONDS & EXPLOSIONS (ULTRA-PREMIUM)
# ==============================================================================

# --- âš™ï¸ GLOBAL CONFIGURATION ---
ENTRY_FEE = 10000
MAX_BET = 50000 # ğŸ›¡ï¸ MAX BET LIMIT APPLIED

LEVEL_CONFIG = {
    1: {"grid": (2, 2), "diamonds": 1, "multiplier": 1.2, "name": "ğŸŸ¢ Baby Mode", "bombs": 3},  
    2: {"grid": (3, 3), "diamonds": 2, "multiplier": 1.8, "name": "ğŸŸ¡ Easy Mode", "bombs": 7},      
    3: {"grid": (4, 3), "diamonds": 3, "multiplier": 2.5, "name": "ğŸŸ  Medium Mode", "bombs": 9},    
    4: {"grid": (4, 4), "diamonds": 3, "multiplier": 5.0, "name": "ğŸ”´ Hard Mode", "bombs": 13},      
    5: {"grid": (5, 4), "diamonds": 3, "multiplier": 10.0, "name": "ğŸ’€ HELL MODE", "bombs": 17} 
}

# --- ğŸ’£ MINE BUTTON (The Grid Cell) ---
class MineButton(discord.ui.Button):
    def __init__(self, x, y, is_diamond):
        super().__init__(style=discord.ButtonStyle.secondary, label="\u200b", row=y)
        self.x = x
        self.y = y
        self.is_diamond = is_diamond

    async def callback(self, interaction: discord.Interaction):
        view: MinefieldGameView = self.view
        
        # ğŸ›¡ï¸ Security Check
        if interaction.user.id != view.player.id:
            return await interaction.response.send_message("âŒ **Guard:** Step back! This is an active minefield.", ephemeral=True)

        await interaction.response.defer() # ğŸ› ï¸ Instant Defer to prevent crash

        if self.is_diamond:
            # ==========================================
            # âœ… CORRECT (FOUND DIAMOND)
            # ==========================================
            self.style = discord.ButtonStyle.success
            self.emoji = "ğŸ’"
            self.disabled = True
            view.found_diamonds += 1
            
            # Enable Cashout Button (Always the last child)
            view.children[-1].disabled = False 
            
            # Check for Jackpot (Found all required diamonds)
            if view.found_diamonds == LEVEL_CONFIG[view.level]["diamonds"]:
                await view.end_game(interaction, "jackpot")
            else:
                await view.update_board(interaction)
        else:
            # ==========================================
            # âŒ BLAST (FOUND BOMB)
            # ==========================================
            self.style = discord.ButtonStyle.danger
            self.emoji = "ğŸ’¥"
            self.disabled = True
            await view.end_game(interaction, "blast")


# --- ğŸ’° CASHOUT BUTTON ---
class CashoutButton(discord.ui.Button):
    def __init__(self):
        super().__init__(style=discord.ButtonStyle.primary, label="CLAIM WINNINGS", emoji="ğŸ’°", row=4, disabled=True)

    async def callback(self, interaction: discord.Interaction):
        view: MinefieldGameView = self.view
        if interaction.user.id != view.player.id: 
            return await interaction.response.send_message("âŒ Cannot claim someone else's money!", ephemeral=True)
            
        await interaction.response.defer()
        await view.end_game(interaction, "cashout")


# --- ğŸ® THE MAIN GAME ENGINE ---
class MinefieldGameView(discord.ui.View):
    def __init__(self, player: discord.Member, bet: int, level: int):
        super().__init__(timeout=300) # â³ 5 Min Timeout
        self.player = player
        self.bet = bet
        self.level = level
        self.found_diamonds = 0
        self.config = LEVEL_CONFIG[level]
        self.game_over = False
        
        # Grid Generation Logic
        rows, cols = self.config["grid"]
        total_slots = rows * cols
        num_diamonds = self.config["diamonds"]
        
        layout = [0] * (total_slots - num_diamonds) + [1] * num_diamonds
        random.shuffle(layout)
        
        index = 0
        for r in range(rows):
            for c in range(cols):
                is_diamond = (layout[index] == 1)
                self.add_item(MineButton(c, r, is_diamond))
                index += 1
        
        # Add Cashout Button at the end
        self.add_item(CashoutButton())

    async def update_board(self, interaction: discord.Interaction):
        current_mult = 1.0 + (self.found_diamonds * (self.config["multiplier"] / 3)) 
        potential_win = int(self.bet * current_mult)
        
        embed = interaction.message.embeds[0]
        embed.color = 0x2ECC71 # Green
        embed.description = (
            f"### â›ï¸ EXCAVATION IN PROGRESS...\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ’ **Diamonds Found:** `{self.found_diamonds}/{self.config['diamonds']}`\n"
            f" â”£ ğŸ“ˆ **Current Multiplier:** `{current_mult:.2f}x`\n"
            f" â”— ğŸ’µ **Potential Value:** `${potential_win:,}`\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"> *Cash out now to secure your funds, or dig deeper for the Jackpot!*"
        )
        await interaction.edit_original_response(embed=embed, view=self)

    async def end_game(self, interaction: discord.Interaction, result: str):
        if self.game_over: return
        self.game_over = True

        # ğŸ‘ï¸ REVEAL THE ENTIRE BOARD
        for child in self.children:
            child.disabled = True
            if isinstance(child, MineButton):
                if child.is_diamond:
                    if child.style != discord.ButtonStyle.success: 
                        child.style = discord.ButtonStyle.secondary 
                        child.emoji = "ğŸ’"
                elif not child.is_diamond: 
                    if child.style == discord.ButtonStyle.danger: 
                        child.emoji = "ğŸ’¥" # Exploded mine
                    else:
                        child.emoji = "ğŸ’£" # Hidden mines revealed

        # ==========================================
        # ğŸ’¥ SCENARIO A: BOMB DETONATED
        # ==========================================
        if result == "blast":
            punish_text = ""
            try:
                # ğŸ—„ï¸ SAFE DB FETCH FOR INVENTORY
                res = await db_call(lambda: supabase.table("economy").select("vip_expiry, inventory").eq("user_id", str(self.player.id)).execute())
                if res and res.data:
                    data = res.data[0]
                    inv = data.get('inventory', {}) or {}
                    
                    if data.get("vip_expiry"):
                        punish_text = "ğŸ›¡ï¸ **VIP Protocol:** Saved from Hospital Timeout."
                    elif inv.get("life", 0) > 0:
                        inv["life"] -= 1
                        await db_call(lambda: supabase.table("economy").update({"inventory": inv}).eq("user_id", str(self.player.id)).execute())
                        punish_text = "ğŸ’– **Extra Life Used:** Saved from Hospital Timeout."
                    else:
                        # ğŸ› ï¸ FIXED INDENTATION CRASH
                        try:
                            await self.player.timeout(dt.timedelta(seconds=60), reason="Minefield Blast")
                            punish_text = "ğŸ”‡ **Penalty:** 60s Hospital Timeout!"
                        except:
                            punish_text = "*(Admin Shield: Immune to Timeout)*"
            except Exception as e:
                print(f"Mine Punish Error: {e}")

            embed = discord.Embed(title="ğŸ’¥ DETONATION TRIGGERED!", color=0xe74c3c)
            embed.set_thumbnail(url=self.player.display_avatar.url)
            embed.description = (
                f"### ğŸ’€ WASTED!\n"
                f"**You dug too deep and hit a landmine!**\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ’¸ **Total Loss:** `${(self.bet + ENTRY_FEE):,}`\n"
                f" â”— ğŸ¥ **Status:** {punish_text}\n"
            )
            embed.set_image(url="https://media.tenor.com/1-11Yd6_QpYAAAAC/explosion-blast.gif")

        # ==========================================
        # ğŸ’° SCENARIO B: TACTICAL CASHOUT
        # ==========================================
        elif result == "cashout":
            base_math = 1.0 + (self.found_diamonds * (self.config["multiplier"] / self.config["diamonds"]))
            winnings = int(self.bet * base_math)
            
            await smart_reward(self.player.id, winnings) # ğŸ’¸ SAFE PAYOUT

            embed = discord.Embed(title="ğŸ’° CASHOUT SUCCESSFUL", color=0xF1C40F)
            embed.set_thumbnail(url=self.player.display_avatar.url)
            embed.description = (
                f"### ğŸ‰ TACTICAL RETREAT!\n"
                f"**You secured your gems and escaped the minefield.**\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ’ **Diamonds Extracted:** `{self.found_diamonds}`\n"
                f" â”— ğŸ’¸ **Net Winnings:** `${winnings:,}`\n"
            )

        # ==========================================
        # ğŸ’ SCENARIO C: ULTIMATE JACKPOT
        # ==========================================
        elif result == "jackpot":
            winnings = int(self.bet * self.config["multiplier"])
            
            # ğŸ‘‘ AUTO ROLE LOGIC (Level 4 & 5)
            role_text = ""
            if self.level >= 4:
                try:
                    role = discord.utils.get(interaction.guild.roles, name="ğŸ’ ğŒğ¢ğ§ğ ğ†ğ¨ğ ğŸ‘‘")
                    if not role: 
                        role = await interaction.guild.create_role(name="ğŸ’ ğŒğ¢ğ§ğ ğ†ğ¨ğ ğŸ‘‘", color=discord.Color.gold(), hoist=True)
                    if role not in self.player.roles:
                        await self.player.add_roles(role)
                        role_text = f" â”— ğŸ‘‘ **Unlocked Title:** {role.mention}\n"
                except Exception as e:
                    print(f"Role Assignment Error: {e}")

            await smart_reward(self.player.id, winnings) # ğŸ’¸ SAFE PAYOUT

            embed = discord.Embed(title="ğŸ’ JACKPOT DISCOVERED!", color=0x9B59B6)
            embed.set_thumbnail(url=self.player.display_avatar.url)
            embed.description = (
                f"### ğŸ‘‘ GODLIKE EXCAVATION!\n"
                f"**You cleared the entire minefield without a scratch!**\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ“ˆ **Final Multiplier:** `{self.config['multiplier']}x`\n"
                f" â”£ ğŸ’¸ **MASSIVE PAYOUT:** `${winnings:,}`\n"
                f"{role_text}"
            )
            embed.set_image(url="https://media.tenor.com/p7a8o1r5c8cAAAAC/money-rain.gif")

        await interaction.edit_original_response(embed=embed, view=self)


# --- ğŸ“ PAYMENT GATEWAY VIEW ---
class MineConfirmationView(discord.ui.View):
    def __init__(self, player: discord.Member, bet: int, level: int):
        super().__init__(timeout=60)
        self.player = player
        self.bet = bet
        self.level = level
        self.config = LEVEL_CONFIG[level]

    @discord.ui.button(label="AUTHORIZE PAYMENT", style=discord.ButtonStyle.success, emoji="âœ…")
    async def confirm(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.player.id: return
        
        await interaction.response.defer() # ğŸŸ¢ PREVENT CRASH
        
        # Disable buttons immediately to prevent double-charging!
        self.stop()
        for child in self.children: child.disabled = True
        await interaction.edit_original_response(view=self)
        
        total_cost = self.bet + ENTRY_FEE

        # ğŸ’³ SMART CHARGE (Checks Wallet + Bank and deducts safely)
        paid = await smart_charge(self.player.id, total_cost)
        if not paid:
            return await interaction.followup.send(f"âŒ **Transaction Failed:** You need `${total_cost:,}` in your Wallet + Bank to authorize this excavation.", ephemeral=True)

        # ğŸš€ START GAME
        embed = discord.Embed(title=f"ğŸ’£ THE MINEFIELD: {self.config['name']}", color=0x3498DB)
        embed.set_thumbnail(url=self.player.display_avatar.url)
        embed.description = (
            f"### âš ï¸ AREA SECURED. READY TO DIG.\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ’µ **Pot Value:** `${self.bet:,}`\n"
            f" â”£ ğŸ’ **Target:** Find `{self.config['diamonds']}` Diamonds\n"
            f" â”— ğŸ’£ **Danger:** Avoid `{self.config['bombs']}` Mines\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"ğŸ‘‡ **CLICK A TILE TO BEGIN EXCAVATION!**"
        )
        await interaction.edit_original_response(embed=embed, view=MinefieldGameView(self.player, self.bet, self.level))

    @discord.ui.button(label="ABORT MISSION", style=discord.ButtonStyle.danger, emoji="âŒ")
    async def cancel(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.player.id: return
        self.stop()
        await interaction.message.delete()


# --- ğŸ¢ LEVEL SELECTOR LOBBY ---
class MineLevelSelect(discord.ui.View):
    def __init__(self, player: discord.Member, bet: int):
        super().__init__(timeout=60)
        self.player = player
        self.bet = bet

    async def show_confirm(self, interaction: discord.Interaction, level: int):
        if interaction.user.id != self.player.id: return
        
        await interaction.response.defer()
        
        cfg = LEVEL_CONFIG[level]
        total_risk = self.bet + ENTRY_FEE
        
        embed = discord.Embed(title="ğŸ“ CONTRACT CONFIRMATION", color=0x2B2D31)
        embed.set_author(name=self.player.display_name, icon_url=self.player.display_avatar.url)
        embed.set_thumbnail(url="https://cdn-icons-png.flaticon.com/512/10000/10000808.png")
        
        embed.description = (
            f"### Selected Zone: {cfg['name']}\n"
            f"Please review the contract details before descending.\n\n"
            f"ğŸ§¾ **BILLING STATEMENT:**\n"
            f" â”£ Entry Clearance: `$10,000`\n"
            f" â”£ Wager Amount: `${self.bet:,}`\n"
            f" â”— ğŸ’° **Total Deduction:** `${total_risk:,}`\n\n"
            f"ğŸ“Š **ZONE STATISTICS:**\n"
            f" â”£ **Grid Size:** `{cfg['grid'][0]}x{cfg['grid'][1]}`\n"
            f" â”£ **Active Mines:** `{cfg['bombs']}` ğŸ’£\n"
            f" â”— **Hidden Gems:** `{cfg['diamonds']}` ğŸ’\n\n"
            f"> âš ï¸ **WARNING:** Detonating a mine results in total loss of funds and immediate medical hospitalization (Timeout)."
        )
        
        await interaction.edit_original_response(embed=embed, view=MineConfirmationView(self.player, self.bet, level))

    @discord.ui.button(label="Lvl 1", style=discord.ButtonStyle.success, row=0)
    async def l1(self, i, b): await self.show_confirm(i, 1)

    @discord.ui.button(label="Lvl 2", style=discord.ButtonStyle.primary, row=0)
    async def l2(self, i, b): await self.show_confirm(i, 2)

    @discord.ui.button(label="Lvl 3", style=discord.ButtonStyle.secondary, row=1)
    async def l3(self, i, b): await self.show_confirm(i, 3)

    @discord.ui.button(label="Lvl 4", style=discord.ButtonStyle.danger, row=1)
    async def l4(self, i, b): await self.show_confirm(i, 4)

    @discord.ui.button(label="Lvl 5 (HELL)", style=discord.ButtonStyle.danger, row=2)
    async def l5(self, i, b): await self.show_confirm(i, 5)


# ==============================================================================
# ğŸ’» MAIN COMMAND
# ==============================================================================
@bot.tree.command(name="mines", description="ğŸ’£ Navigate the minefield to uncover diamonds. Huge multipliers!")
@app_commands.describe(bet_amount="Bet Amount (Min: $100 | Max: $50,000)")
@check_seized()
async def mines(interaction: discord.Interaction, bet_amount: int):
    
    # ğŸ›¡ï¸ VALIDATION & BET LIMITS
    if bet_amount > MAX_BET:
        return await interaction.response.send_message(f"âŒ **Safety Protocol:** Maximum allowed bet is `${MAX_BET:,}`!", ephemeral=True)
    if bet_amount < 100:
        return await interaction.response.send_message("âŒ **Error:** Minimum bet is `$100`.", ephemeral=True)
    
    embed = discord.Embed(title="ğŸ’£ TITAN MINING CORPORATION", color=0x2b2d31)
    embed.set_author(name=interaction.user.display_name, icon_url=interaction.user.display_avatar.url)
    embed.set_image(url="https://media.tenor.com/2s_0Hi-j1OAAAAAC/bomb-explode.gif")
    embed.description = (
        f"### âš ï¸ ENTER THE DANGER ZONE\n"
        f"**Objective:** Extract Diamonds ğŸ’, Avoid Explosives ğŸ’£\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f" â”£ ğŸŸï¸ **Clearance Fee:** `$10,000`\n"
        f" â”— ğŸ’° **Your Wager:** `${bet_amount:,}`\n\n"
        f"ğŸ‘‡ **SELECT DIFFICULTY LEVEL TO PROCEED:**"
    )
    
    await interaction.response.send_message(embed=embed, view=MineLevelSelect(interaction.user, bet_amount))

# --- HACKER RUN CONFIG (UPDATED: +2 Colors Added) ---
import discord
from discord import app_commands
import random
import asyncio
import datetime as dt

# ==============================================================================
# ğŸ’» CYBER HEIST: THE MEMORY HACKER (ULTRA-PREMIUM)
# ==============================================================================

# --- âš™ï¸ CONFIGURATION ---
HACKER_LEVELS = {
    1: {"len": 5, "mult": 1.5, "time": 5},  
    2: {"len": 6, "mult": 2.0, "time": 6},  
    3: {"len": 7, "mult": 2.5, "time": 7},  
    4: {"len": 8, "mult": 3.0, "time": 8},  
    5: {"len": 9, "mult": 3.5, "time": 9},  
    6: {"len": 10, "mult": 4.0, "time": 10} 
}

hacker_cooldowns = {}
EMOJI_MAP = {"red": "ğŸŸ¥", "blue": "ğŸŸ¦", "green": "ğŸŸ©", "yellow": "ğŸŸ¨"}

# --- âŒ¨ï¸ GAME BUTTONS ---
class HackerButton(discord.ui.Button):
    def __init__(self, color_name, emoji):
        super().__init__(style=discord.ButtonStyle.secondary, emoji=emoji, custom_id=color_name)
        self.color_name = color_name

    async def callback(self, interaction: discord.Interaction):
        view: HackerGameView = self.view
        
        # ğŸ›¡ï¸ Security
        if interaction.user.id != view.player.id:
            return await interaction.response.send_message("âŒ **Access Denied:** Unauthorized IP.", ephemeral=True)

        await interaction.response.defer() # ğŸ› ï¸ Instant Defer

        # Check Input
        expected_color = view.sequence[view.current_step]
        
        if self.color_name == expected_color:
            # ==========================================
            # âœ… CORRECT INPUT
            # ==========================================
            view.current_step += 1
            
            if view.current_step >= len(view.sequence):
                await view.win_game(interaction)
            else:
                # ğŸ”„ LIVE PROGRESS TRACKER
                progress_locks = ("ğŸ”“ " * view.current_step) + ("ğŸ”’ " * (len(view.sequence) - view.current_step))
                
                embed = interaction.message.embeds[0]
                embed.description = (
                    f"### ğŸ” DECRYPTING MAINFRAME...\n"
                    f"**Sequence Length:** `{len(view.sequence)} Nodes`\n"
                    f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                    f"**PROGRESS:**\n"
                    f"> {progress_locks}\n\n"
                    f"ğŸ‘‡ **Inject the next node!**"
                )
                await interaction.edit_original_response(embed=embed, view=view)
        else:
            # ==========================================
            # âŒ WRONG INPUT
            # ==========================================
            await view.lose_game(interaction)


# --- ğŸ® THE MAIN GAME ENGINE ---
class HackerGameView(discord.ui.View):
    def __init__(self, player: discord.Member, bet: int, level: int):
        super().__init__(timeout=60) 
        self.player = player
        self.bet = bet
        self.level_data = HACKER_LEVELS[level]
        self.current_step = 0
        
        # Generate Random Sequence
        colors = ["red", "blue", "green", "yellow"]
        self.sequence = [random.choice(colors) for _ in range(self.level_data["len"])]
        
        # Add Input Nodes
        self.add_item(HackerButton("red", "ğŸŸ¥"))
        self.add_item(HackerButton("blue", "ğŸŸ¦"))
        self.add_item(HackerButton("green", "ğŸŸ©"))
        self.add_item(HackerButton("yellow", "ğŸŸ¨"))

    async def win_game(self, interaction: discord.Interaction):
        for child in self.children: child.disabled = True
        
        winnings = int(self.bet * self.level_data["mult"])
        
        # ğŸ’¸ SAFE SMART REWARD
        await smart_reward(self.player.id, winnings)

        embed = discord.Embed(title="ğŸ”“ MAINFRAME BREACHED", color=0x2ecc71)
        embed.set_thumbnail(url=self.player.display_avatar.url)
        embed.description = (
            f"### ğŸ’» HACK COMPLETE!\n"
            f"**Sequence Matched:** `100%`\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ“ˆ **Multiplier:** `{self.level_data['mult']}x`\n"
            f" â”£ ğŸ’¸ **Funds Extracted:** `${winnings:,}`\n"
            f" â”— ğŸ•µï¸â€â™‚ï¸ **Status:** `Ghost Mode Active`\n"
        )
        embed.set_image(url="https://media.tenor.com/GfSX-u7_NSAAAAAC/coding-hacker.gif")
        await interaction.edit_original_response(embed=embed, view=None)

    async def lose_game(self, interaction: discord.Interaction):
        for child in self.children: child.disabled = True
        
        # âŒ FAILED SEQUENCE DISPLAY
        correct_emoji = EMOJI_MAP[self.sequence[self.current_step]]
        
        embed = discord.Embed(title="ğŸš¨ FIREWALL TRIGGERED!", color=0xe74c3c)
        embed.set_thumbnail(url=self.player.display_avatar.url)
        embed.description = (
            f"### ğŸš« ACCESS DENIED!\n"
            f"**Invalid Node Injected.**\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ âŒ **Failed At Node:** `{self.current_step + 1}`\n"
            f" â”£ âœ… **Expected Node:** {correct_emoji}\n"
            f" â”£ ğŸ’¸ **Funds Lost:** `${self.bet:,}`\n"
            f" â”— ğŸš“ **Trace Status:** `99% Complete (RUN!)`\n"
        )
        embed.set_image(url="https://media.tenor.com/2s_0Hi-j1OAAAAAC/bomb-explode.gif")
        await interaction.edit_original_response(embed=embed, view=None)


# --- ğŸ¢ LEVEL SELECTOR LOBBY ---
class HackerLevelSelect(discord.ui.View):
    def __init__(self, player: discord.Member, bet: int):
        super().__init__(timeout=60)
        self.player = player
        self.bet = bet

    async def start_hacker_run(self, interaction: discord.Interaction, level: int):
        if interaction.user.id != self.player.id: return
        
        await interaction.response.defer() # ğŸ› ï¸ CRITICAL DEFER
        self.stop() # Stop listening to level buttons
        
        config = HACKER_LEVELS[level]
        seq_len = config["len"]
        mem_time = config["time"]

        # 1. SHOW SEQUENCE (MEMORIZE PHASE)
        game_view = HackerGameView(self.player, self.bet, level)
        sequence_str = " ".join([EMOJI_MAP[c] for c in game_view.sequence])
        
        embed = discord.Embed(title=f"ğŸ’» SYSTEM OVERRIDE: LEVEL {level}", color=0x3498DB)
        embed.description = (
            f"### ğŸ” MEMORIZE THE DECRYPTION KEY\n"
            f"**Length:** `{seq_len} Nodes`\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"> {sequence_str}\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"â³ **Time Remaining:** `{mem_time} Seconds`..."
        )
        embed.set_footer(text="Focus! The code will self-destruct shortly.")
        
        await interaction.edit_original_response(embed=embed, view=None)
        
        # â³ WAIT FOR MEMORIZATION
        await asyncio.sleep(mem_time)
        
        # 2. HIDE SEQUENCE (INPUT PHASE)
        hidden_locks = "ğŸ”’ " * seq_len
        embed.color = 0xF1C40F # Yellow/Warning
        embed.description = (
            f"### ğŸ” MAINFRAME LOCKED\n"
            f"**Sequence Length:** `{seq_len} Nodes`\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"**ENTER THE CODE:**\n"
            f"> {hidden_locks}\n\n"
            f"ğŸ‘‡ **Tap the nodes in the exact order!**"
        )
        embed.set_footer(text="One wrong move triggers the firewall.")
        
        await interaction.edit_original_response(embed=embed, view=game_view)


    @discord.ui.button(label="Lvl 1 (1.5x)", style=discord.ButtonStyle.primary)
    async def l1(self, i, b): await self.start_hacker_run(i, 1)

    @discord.ui.button(label="Lvl 2 (2.0x)", style=discord.ButtonStyle.primary)
    async def l2(self, i, b): await self.start_hacker_run(i, 2)

    @discord.ui.button(label="Lvl 3 (2.5x)", style=discord.ButtonStyle.secondary)
    async def l3(self, i, b): await self.start_hacker_run(i, 3)

    @discord.ui.button(label="Lvl 4 (3.0x)", style=discord.ButtonStyle.secondary)
    async def l4(self, i, b): await self.start_hacker_run(i, 4)

    @discord.ui.button(label="Lvl 5 (3.5x)", style=discord.ButtonStyle.danger)
    async def l5(self, i, b): await self.start_hacker_run(i, 5)

    @discord.ui.button(label="Lvl 6 (GOD)", style=discord.ButtonStyle.danger)
    async def l6(self, i, b): await self.start_hacker_run(i, 6)


# ==============================================================================
# ğŸ’» MAIN COMMAND
# ==============================================================================
@bot.tree.command(name="hacker", description="ğŸ’» Cyber Heist: Memorize the color sequence & Win Big!")
@app_commands.describe(bet="Amount to bet (Max 50k / 70k VIP)")
@check_seized()
async def hacker(interaction: discord.Interaction, bet: int):
    await interaction.response.defer() # â³ Prevent Interaction Failed

    user = interaction.user
    
    # â±ï¸ 1. COOLDOWN CHECK (10 Mins)
    now = discord.utils.utcnow()
    if user.id in hacker_cooldowns:
        last_time = hacker_cooldowns[user.id]
        if now < last_time + dt.timedelta(minutes=10):
            remaining = (last_time + dt.timedelta(minutes=10)) - now
            mins, secs = divmod(int(remaining.total_seconds()), 60)
            return await interaction.followup.send(f"â³ **System Cooldown:** Your IP is being tracked. Lay low for `{mins}m {secs}s`.", ephemeral=True)

    # ğŸ‘‘ 2. BET & VIP CHECK (Safe DB Call)
    is_vip = False
    try:
        res = await db_call(lambda: supabase.table("economy").select("vip_expiry").eq("user_id", str(user.id)).execute())
        if res and res.data and res.data[0].get("vip_expiry"):
            is_vip = True
    except Exception as e:
        print(f"Hacker DB Error: {e}")

    max_bet = 70000 if is_vip else 50000
    
    if bet > max_bet:
        return await interaction.followup.send(f"âŒ **Risk Limit Exceeded:** Maximum payload is **${max_bet:,}**.", ephemeral=True)
    if bet < 500:
        return await interaction.followup.send("âŒ **Error:** Minimum funding required is **$500**.", ephemeral=True)

    # ğŸ’³ 3. DEDUCT MONEY (SMART CHARGE)
    paid = await smart_charge(user.id, bet)
    if not paid:
        return await interaction.followup.send(f"âŒ **Insufficient Funds:** You need `${bet:,}` in Wallet + Bank to execute this hack.", ephemeral=True)

    # ğŸš€ 4. START HEIST
    hacker_cooldowns[user.id] = now # Log IP

    embed = discord.Embed(title="ğŸ’» CYBER HEIST INITIATED", color=0x2B2D31)
    embed.set_thumbnail(url="https://media.tenor.com/On7kvXhzml4AAAAi/loading-gif.gif")
    embed.description = (
        f"### âš ï¸ ENTERING THE SHADOWS\n"
        f"**Agent:** {user.mention}\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f" â”£ ğŸ’° **Funds Locked:** `${bet:,}`\n"
        f" â”— ğŸ›¡ï¸ **VIP Clearance:** `{'Active' if is_vip else 'None'}`\n\n"
        f"**MISSION INSTRUCTIONS:**\n"
        f"`1.` Select Firewall Level (Higher = More Colors).\n"
        f"`2.` Memorize the **Random Color Sequence**.\n"
        f"`3.` Re-enter the exact sequence before the trace completes!\n\n"
        f"ğŸ‘‡ **SELECT YOUR TARGET NODE:**"
    )
    
    await interaction.followup.send(embed=embed, view=HackerLevelSelect(user, bet))
           
import discord
from discord import app_commands
import asyncio

# ==============================================================================
# ğŸ‘‘ TITAN GOD MODE: SEIZE CONTROL (ULTRA-PREMIUM OMNIPOTENCE)
# ==============================================================================

@bot.tree.command(name="admin_seize", description="ğŸ‘‘ GOD MODE: Freeze/Unfreeze Accounts (Owner Only)")
@app_commands.describe(action="Select Executive Operation", user="Target User (Leave empty for Blacklist)")
@app_commands.choices(action=[
    app_commands.Choice(name="ğŸ’€ SEIZE (Wipe Assets & Ban)", value="add"),
    app_commands.Choice(name="ğŸ•Šï¸ UNSEIZE (Issue Pardon)", value="remove"),
    app_commands.Choice(name="ğŸ“œ VIEW BLACKLIST", value="list")
])
async def admin_seize(interaction: discord.Interaction, action: str, user: discord.Member = None):
    
    # ğŸ›‘ 1. OMNIPOTENCE CHECK (Strict Owner Only)
    # Make sure OWNER_ID is defined in your code (e.g., OWNER_ID = 123456789012345678)
    if interaction.user.id != OWNER_ID:
        embed = discord.Embed(title="ğŸš« ACCESS DENIED", color=0x8B0000)
        embed.description = "âš ï¸ **Security Alert:** You lack the Supreme Clearance to execute this command."
        return await interaction.response.send_message(embed=embed, ephemeral=True)

    # ==========================================
    # ğŸ“œ ACTION: VIEW BLACKLIST
    # ==========================================
    if action == "list":
        await interaction.response.defer(ephemeral=False)
        try:
            # Safe DB Fetch
            res = await db_call(lambda: supabase.table("economy").select("user_id").eq("is_seized", True).execute())
            
            if not res or not res.data:
                embed = discord.Embed(title="ğŸ•Šï¸ PRISON EMPTY", color=0x2ECC71)
                embed.description = "The blacklist is currently clean. No active prisoners."
                return await interaction.followup.send(embed=embed)

            # Premium List Build
            desc_lines = []
            for i, row in enumerate(res.data, 1):
                desc_lines.append(f"`{i:02d}.` <@{row['user_id']}> *(ID: {row['user_id']})*")
            
            embed = discord.Embed(title="ğŸš« TITAN BLACKLIST: SEIZED ACCOUNTS", color=0x2B2D31)
            embed.description = "### ğŸ”’ Inmates Currently Serving Sentences\n" + "\n".join(desc_lines)
            embed.set_footer(text=f"Total Prisoners: {len(res.data)}", icon_url=interaction.client.user.display_avatar.url)
            embed.set_thumbnail(url="https://cdn-icons-png.flaticon.com/512/9203/9203747.png") 
            
            await interaction.followup.send(embed=embed)
            
        except Exception as e:
            await interaction.followup.send(f"âŒ **Mainframe Error:** `{e}`")
        return

    # ğŸ¯ TARGET VALIDATION
    if not user:
        return await interaction.response.send_message("âŒ **Error:** Target user required for Seize/Unseize operations.", ephemeral=True)

    # ==========================================
    # ğŸ’€ ACTION: SEIZE (TOTAL ANNIHILATION)
    # ==========================================
    if action == "add":
        await interaction.response.defer(ephemeral=False)
        try:
            # 1. Fetch Current Total Assets (Wallet + Bank) for the dramatic receipt
            old_res = await db_call(lambda: supabase.table("economy").select("balance, bank").eq("user_id", str(user.id)).execute())
            if old_res and old_res.data:
                lost_money = int(old_res.data[0].get('balance', 0)) + int(old_res.data[0].get('bank', 0))
            else:
                lost_money = 0

            # 2. DESTROY DATA (Absolute Zero Payload)
            data_update = {
                "balance": 0,    # Wipe Wallet
                "bank": 0,       # Wipe Bank
                "inventory": {}, # Burn Inventory
                "is_seized": True # Lock Account
            }
            
            # Safe DB Execution
            res = await db_call(lambda: supabase.table("economy").update(data_update).eq("user_id", str(user.id)).execute())
            
            # If user doesn't exist, create an empty seized profile
            if not res or not res.data:
                 data_update["user_id"] = str(user.id)
                 await db_call(lambda: supabase.table("economy").insert(data_update).execute())

            # 3. ULTRA-PREMIUM EMBED
            embed = discord.Embed(title="ğŸ”’ TITAN JUDGEMENT: ACCOUNT SEIZED", color=0x8B0000) # Blood Red
            embed.set_thumbnail(url=user.display_avatar.url)
            embed.description = (
                f"### âš ï¸ ABSOLUTE WIPEOUT AUTHORIZED\n"
                f"The Supreme Authority has seized **{user.mention}**'s assets.\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ‘® **Executed By:** {interaction.user.mention}\n"
                f" â”£ ğŸ’¸ **Total Assets Burned:** `-${lost_money:,}`\n"
                f" â”— âš–ï¸ **Status:** `Indefinitely Locked`\n\n"
                f"**ğŸš« RESTRICTIONS APPLIED:**\n"
                f"> â€¢ Zero Balance (Wallet & Bank)\n"
                f"> â€¢ Complete Inventory Confiscation\n"
                f"> â€¢ Permanent Ban from Casino & Economy"
            )
            embed.set_image(url="https://media.tenor.com/J3i0g4ySj44AAAAC/busted-police.gif")
            
            # Send DM Alert
            try: 
                dm_embed = discord.Embed(title="ğŸš« ACCOUNT SEIZED", description="Aapka account Owner dwara **SEIZED** kar diya gaya hai. Saare paise aur items zero ho gaye hain.", color=0xFF0000)
                await user.send(embed=dm_embed)
            except: pass

            await interaction.followup.send(embed=embed)

        except Exception as e:
            await interaction.followup.send(f"âŒ **System Error:** `{e}`")

    # ==========================================
    # ğŸ•Šï¸ ACTION: UNSEIZE (PARDON)
    # ==========================================
    elif action == "remove":
        await interaction.response.defer(ephemeral=False)
        try:
            # Release User
            await db_call(lambda: supabase.table("economy").update({"is_seized": False}).eq("user_id", str(user.id)).execute())

            # PREMIUM EMBED
            embed = discord.Embed(title="ğŸ”“ TITAN PARDON ISSUED", color=0xF1C40F) # Gold
            embed.set_thumbnail(url=user.display_avatar.url)
            embed.description = (
                f"### âœ… ACCOUNT UNLOCKED\n"
                f"**{user.mention}** has been granted a supreme pardon.\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ âš–ï¸ **New Status:** `Active / Unrestricted`\n"
                f" â”— ğŸ‘® **Authorized By:** {interaction.user.mention}\n\n"
                f"> *The user is now permitted to participate in the economy.*"
            )
            
            # Send DM Alert
            try: 
                dm_embed = discord.Embed(title="âœ… ACCOUNT RELEASED", description="Aapka account **Unseized** kar diya gaya hai! Ab aap dobara commands use kar à¤¸à¤•à¤¤à¥‡ hain. Welcome back!", color=0x2ECC71)
                await user.send(embed=dm_embed)
            except: pass

            await interaction.followup.send(embed=embed)

        except Exception as e:
            await interaction.followup.send(f"âŒ **System Error:** `{e}`")


import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# ğŸŒ‘ THE BLACK MARKET: 0.01% JACKPOT ROULETTE (ULTRA-PREMIUM SPAM SAFE)
# ==============================================================================

class BlackMarketView(discord.ui.View):
    def __init__(self, user: discord.Member, initial_balance: int):
        super().__init__(timeout=None) # â™¾ï¸ No Timeout - Spin until you bleed
        self.user = user
        self.spin_count = 0
        self.total_spent = 0
        self.current_balance = initial_balance # Visual tracking for speed

    @discord.ui.button(label="ROLL THE DICE ($1)", style=discord.ButtonStyle.secondary, emoji="ğŸ©¸")
    async def spin_btn(self, interaction: discord.Interaction, button: discord.ui.Button):
        # ğŸ›¡ï¸ 1. Security Check
        if interaction.user.id != self.user.id:
            return await interaction.response.send_message("âŒ **Guard:** This terminal is locked to someone else. Step back!", ephemeral=True)

        # â³ 2. INSTANT DEFER (CRITICAL FOR SPAM CLICKING)
        await interaction.response.defer()

        # ğŸ’³ 3. SMART CHARGE (Checks Wallet + Bank securely)
        paid = await smart_charge(self.user.id, 1)
        if not paid:
            embed = interaction.message.embeds[0]
            embed.color = 0xFF0000 # Red
            embed.description = (
                f"### ğŸ’€ FUNDS EXHAUSTED\n"
                f"**You have completely bled out.**\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ’¸ **Total Spends:** `${self.total_spent:,}`\n"
                f" â”— ğŸ”„ **Total Spins:** `{self.spin_count}`\n\n"
                f"> *Get more money if you want to test your luck again.*"
            )
            for child in self.children: child.disabled = True
            return await interaction.edit_original_response(embed=embed, view=self)

        # ğŸ”„ 4. UPDATE SESSION STATS
        self.spin_count += 1
        self.total_spent += 1
        self.current_balance -= 1 # Local update for fast UI rendering

        # ğŸ² 5. THE 0.01% LUCK LOGIC (1 in 10,000)
        lucky_number = random.randint(1, 10000) 
        is_jackpot = (lucky_number == 1)

        embed = discord.Embed()
        
        # ==========================================
        # ğŸ‰ SCENARIO A: THE IMPOSSIBLE JACKPOT
        # ==========================================
        if is_jackpot:
            prize = random.randint(100000, 500000)
            
            # Safe DB Reward
            await smart_reward(self.user.id, prize)

            embed.title = "ğŸ’ THE SYSTEM HAS BEEN BROKEN!"
            embed.color = 0xFFD700 # Gold
            embed.description = (
                f"### ğŸ¤¯ IMPOSSIBLE HIT! (0.01% ODDS)\n"
                f"**{self.user.mention} just hacked the Black Market!**\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ¯ **Lucky Roll:** `{lucky_number}` (Needed: 1)\n"
                f" â”£ ğŸ’° **JACKPOT WON:** `${prize:,}`\n"
                f" â”— ğŸ”„ **Spins Taken:** `{self.spin_count}`\n\n"
                f"**System Override Successful.** ğŸ’€"
            )
            embed.set_image(url="https://media.tenor.com/p7a8o1r5c8cAAAAC/money-rain.gif")
            embed.set_thumbnail(url=self.user.display_avatar.url)
            
            for child in self.children: child.disabled = True # Stop spinning after jackpot

        # ==========================================
        # ğŸŒ‘ SCENARIO B: NORMAL LOSS (99.99%)
        # ==========================================
        else:
            embed.title = "ğŸŒ‘ DEEP WEB ROULETTE"
            embed.color = 0x111111 # Pitch Black / Dark Gray
            embed.description = (
                f"### ğŸ° SPINNING THE VOID...\n"
                f"**Agent:** {self.user.mention}\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ² **Roll Result:** `{lucky_number:04d}` *(Needed: 0001)*\n"
                f" â”£ ğŸ“‰ **Outcome:** `Nothing.`\n"
                f" â”— ğŸ’¸ **Cost:** `-$1`\n\n"
                f"**SESSION TRACKER:**\n"
                f"> ğŸ”„ **Total Spins:** `{self.spin_count}`\n"
                f"> ğŸ©¸ **Total Bled:** `${self.total_spent:,}`\n"
                f"> ğŸ’³ **Est. Wealth:** `${max(0, self.current_balance):,}`\n\n"
                f"*The darkness consumes your dollar. Spin again...*"
            )
            embed.set_thumbnail(url=self.user.display_avatar.url)

        # ğŸ–¥ï¸ 6. UPDATE TERMINAL
        # Safe edit using edit_original_response to handle spam seamlessly
        try: await interaction.edit_original_response(embed=embed, view=self)
        except Exception as e: print(f"Black Market UI Sync Error: {e}")


# ==============================================================================
# ğŸ’» MAIN COMMAND
# ==============================================================================
@bot.tree.command(name="black_market", description="ğŸ©¸ $1 Spin. 0.01% Chance for $500k. Unlimited Greed.")
@check_seized()
async def black_market(i: discord.Interaction):
    await i.response.defer() # â³ Prevent Interaction Failed on boot
    
    # ğŸ—„ï¸ Initial DB Check
    try:
        res = await db_call(lambda: supabase.table("economy").select("balance, bank").eq("user_id", str(i.user.id)).execute())
        data = res.data[0] if res and res.data else None
        
        if not data:
            return await i.followup.send("âŒ **Error:** You do not have an active Titan Account.", ephemeral=True)
            
        total_bal = int(data.get('balance', 0)) + int(data.get('bank', 0))
        
        if total_bal < 1:
            return await i.followup.send("âŒ **Broke:** You don't even have `$1` to enter the shadows.", ephemeral=True)
            
    except Exception as e:
        return await i.followup.send(f"âŒ **System Error:** `{e}`", ephemeral=True)

    # ğŸ’ Premium Intro Embed
    embed = discord.Embed(title="ğŸŒ‘ WELCOME TO THE UNDERGROUND", color=0x000000)
    embed.description = (
        f"**User Identified:** {i.user.mention}\n"
        f"**Detected Wealth:** `${total_bal:,}`\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"ğŸ° **THE DEVIL'S DEAL:**\n"
        f" â”£ **Cost:** `$1` per Spin\n"
        f" â”£ **Prize Pool:** `$100,000 - $500,000`\n"
        f" â”— **Odds:** `0.01%` *(1 in 10,000)*\n\n"
        f"âš ï¸ **WARNING: No Refunds. No Limits. No Mercy.**\n"
        f"> *Keep hitting the button until you bleed dry, or become a king.*"
    )
    embed.set_thumbnail(url=i.user.display_avatar.url)
    
    # Launch Terminal
    view = BlackMarketView(i.user, total_bal)
    await i.followup.send(embed=embed, view=view)


#============== Global Cooldown Dictionary===================
import discord
from discord import app_commands
import random
import asyncio
import datetime as dt

# ==============================================================================
# â˜ ï¸ WIPEOUT PROTOCOL: THE ULTIMATE HEIST (PUBLIC & BRUTAL)
# ==============================================================================

wipeout_cooldowns = {}

# --- ğŸ§  5-STAGE HACKING GAUNTLET VIEW ---
class WipeoutGauntletView(discord.ui.View):
    def __init__(self, robber: discord.Member, victim: discord.Member, message: discord.Message, rob_data, vic_data):
        super().__init__(timeout=8.0) # âš¡ ONLY 8 SECONDS PER STAGE!
        self.robber = robber
        self.victim = victim
        self.message = message
        self.rob_data = rob_data
        self.vic_data = vic_data
        
        self.current_stage = 1
        self.max_stages = 5
        self.game_ended = False
        
        self.generate_task()

    def generate_task(self):
        """ Generates a brutal rapid-fire logic/math task """
        self.clear_items()
        
        # Difficulty scales with stage
        if self.current_stage == 1:   a, b, op = random.randint(10, 50), random.randint(10, 50), '+'
        elif self.current_stage == 2: a, b, op = random.randint(50, 150), random.randint(20, 80), '-'
        elif self.current_stage == 3: a, b, op = random.randint(12, 25), random.randint(3, 9), '*'
        elif self.current_stage == 4: a, b, op = random.randint(200, 500), random.randint(100, 300), '-'
        else:                         a, b, op = random.randint(15, 35), random.randint(11, 19), '*'

        if op == '+': self.answer = a + b
        elif op == '-': self.answer = a - b
        else: self.answer = a * b

        self.question = f"DECRYPT NODE {self.current_stage}: {a} {op} {b} = ?"
        
        # Generate options
        options = [self.answer, self.answer + random.randint(1, 15), self.answer - random.randint(1, 15), self.answer + random.randint(16, 30)]
        random.shuffle(options)

        for opt in options:
            btn = discord.ui.Button(label=str(opt), style=discord.ButtonStyle.secondary, custom_id=str(opt))
            btn.callback = self.task_callback
            self.add_item(btn)

    async def on_timeout(self):
        if self.game_ended: return
        self.game_ended = True
        for item in self.children: item.disabled = True
        await self.fail_heist("â³ TIME EXPIRED! The firewall detected you.")

    async def task_callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.robber.id:
            return await interaction.response.send_message("âŒ **Guard:** Stay back! This is a live hack.", ephemeral=True)
            
        if self.game_ended: return
        await interaction.response.defer()

        selected = int(interaction.data["custom_id"])

        if selected == self.answer:
            # âœ… STAGE PASSED
            if self.current_stage == self.max_stages:
                # ğŸ‰ ALL 5 STAGES CLEARED -> TOTAL WIPEOUT!
                self.game_ended = True
                await self.success_heist(interaction)
            else:
                # â¡ï¸ NEXT STAGE
                self.current_stage += 1
                self.generate_task()
                
                embed = discord.Embed(title="â˜ ï¸ WIPEOUT: HACKING IN PROGRESS", color=0xF1C40F)
                embed.description = (
                    f"### âš ï¸ SECURITY LAYER {self.current_stage}/5\n"
                    f"**Target:** {self.victim.mention}\n"
                    f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                    f"ğŸ’» **{self.question}**\n"
                    f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                    f"> âš¡ **8 SECONDS REMAINING! THINK FAST!**"
                )
                await interaction.edit_original_response(embed=embed, view=self)
        else:
            # âŒ WRONG ANSWER
            self.game_ended = True
            await self.fail_heist("âŒ INVALID DECRYPTION! Alarm triggered.")

    async def fail_heist(self, reason):
        """ ğŸ’¥ THE 500 MILLION PENALTY """
        penalty = 500000000 # 500M
        
        rob_inv = self.rob_data.get('inventory', {}) or {}
        rob_inv['master_key'] = max(0, rob_inv.get('master_key', 1) - 1) # Break Key
        
        # Deduct 500M (Can go negative)
        new_bal = self.rob_data['balance'] - penalty

        try:
            await db_call(lambda: supabase.table("economy").update({
                "balance": new_bal,
                "inventory": rob_inv
            }).eq("user_id", str(self.robber.id)).execute())
        except Exception as e: print(f"Fail DB Error: {e}")

        embed = discord.Embed(title="ğŸš“ BUSTED! RAID FAILED", color=0x8B0000)
        embed.description = (
            f"### ğŸš¨ {reason}\n"
            f"The FBI has surrounded **{self.robber.mention}**!\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ’¸ **Penalty Applied:** `-$500,000,000`\n"
            f" â”£ ğŸ’³ **New Balance:** `${new_bal:,}`\n"
            f" â”£ ğŸ—ï¸ **Master Key:** `Broken`\n"
            f" â”— ğŸ“‰ **Failed At:** `Layer {self.current_stage}/5`\n"
        )
        embed.set_image(url="https://media.tenor.com/J3i0g4ySj44AAAAC/busted-police.gif")
        
        try: await self.message.edit(embed=embed, view=None)
        except: pass

    async def success_heist(self, interaction):
        """ ğŸ† THE ULTIMATE LOOT (VICTIM = 0, ROBBER = EVERYTHING) """
        vic_bal = self.vic_data.get('balance', 0)
        vic_bank = self.vic_data.get('bank', 0)
        total_cash_stolen = vic_bal + vic_bank
        
        vic_inv = self.vic_data.get('inventory', {}) or {}
        rob_inv = self.rob_data.get('inventory', {}) or {}
        
        items_stolen = 0
        for item, qty in vic_inv.items():
            if qty > 0:
                rob_inv[item] = rob_inv.get(item, 0) + qty
                items_stolen += qty

        try:
            # 1. Zero out Victim
            await db_call(lambda: supabase.table("economy").update({
                "balance": 0,
                "bank": 0,
                "inventory": {}
            }).eq("user_id", str(self.victim.id)).execute())

            # 2. Make Robber Filthy Rich
            await db_call(lambda: supabase.table("economy").update({
                "balance": self.rob_data['balance'] + total_cash_stolen,
                "inventory": rob_inv
            }).eq("user_id", str(self.robber.id)).execute())
        except Exception as e: print(f"Success DB Error: {e}")

        embed = discord.Embed(title="ğŸ´â€â˜ ï¸ WIPEOUT SUCCESSFUL!", color=0xFFD700) # Gold
        embed.description = (
            f"### ğŸ˜ˆ TOTAL ANNIHILATION!\n"
            f"**{self.robber.mention}** just bypassed all security and wiped out **{self.victim.mention}**!\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ’° **Cash Looted:** `${total_cash_stolen:,}` *(Wallet + Bank)*\n"
            f" â”£ ğŸ“¦ **Items Looted:** `{items_stolen}` Items Stolen\n"
            f" â”— ğŸª¦ **Victim's New Net Worth:** `$0` (Completely Bankrupt)\n"
        )
        embed.set_thumbnail(url=self.robber.display_avatar.url)
        embed.set_image(url="https://media.tenor.com/p7a8o1r5c8cAAAAC/money-rain.gif")
        
        await interaction.edit_original_response(embed=embed, view=None)


# --- ğŸ“ CONFIRMATION VIEW (PUBLIC) ---
class WipeoutConfirmView(discord.ui.View):
    def __init__(self, robber: discord.Member, victim: discord.Member):
        super().__init__(timeout=60)
        self.robber = robber
        self.victim = victim

    @discord.ui.button(label="ğŸ’€ EXECUTE RAID (RISK: -500M)", style=discord.ButtonStyle.danger)
    async def confirm_raid(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.robber.id: return await interaction.response.send_message("âŒ This is not your heist.", ephemeral=True)

        await interaction.response.defer()
        for child in self.children: child.disabled = True
        
        key = f"{self.robber.id}-{self.victim.id}"
        wipeout_cooldowns[key] = discord.utils.utcnow() # Lock Cooldown

        try:
            # Fetch fresh data
            vic_res = await db_call(lambda: supabase.table("economy").select("*").eq("user_id", str(self.victim.id)).execute())
            rob_res = await db_call(lambda: supabase.table("economy").select("*").eq("user_id", str(self.robber.id)).execute())
            
            vic_data = vic_res.data[0]
            rob_data = rob_res.data[0]
            vic_inv = vic_data.get('inventory', {}) or {}
            
            penalty = 500000000 # 500M Penalty

            # ==========================================
            # â˜¢ï¸ TRAP 1: NUCLEAR BOMB
            # ==========================================
            if vic_inv.get('nuclear_bomb', 0) > 0:
                vic_inv['nuclear_bomb'] -= 1
                new_bal = rob_data['balance'] - penalty
                
                await db_call(lambda: supabase.table("economy").update({"inventory": vic_inv}).eq("user_id", str(self.victim.id)).execute())
                await db_call(lambda: supabase.table("economy").update({"balance": new_bal}).eq("user_id", str(self.robber.id)).execute())

                embed = discord.Embed(title="â˜¢ï¸ NUCLEAR TRAP TRIGGERED!", color=0x000000)
                embed.description = (
                    f"### ğŸ’€ RAID FAILED INSTANTLY!\n"
                    f"**{self.victim.display_name}** had a Nuclear Bomb in their vault!\n"
                    f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                    f" â”£ ğŸ“‰ **Penalty Applied:** `-$500,000,000`\n"
                    f" â”£ ğŸ’³ **Your New Balance:** `${new_bal:,}`\n"
                    f" â”— ğŸ›¡ï¸ **Victim Status:** `Safe`\n"
                )
                embed.set_image(url="https://media.tenor.com/1-11Yd6_QpYAAAAC/explosion-blast.gif")
                return await interaction.edit_original_response(embed=embed, view=None)

            # ==========================================
            # ğŸ• TRAP 2: GUARD DOG (90% Catch Rate)
            # ==========================================
            if vic_inv.get('guard_dog', 0) > 0 and random.randint(1, 100) <= 90:
                new_bal = rob_data['balance'] - penalty
                await db_call(lambda: supabase.table("economy").update({"balance": new_bal}).eq("user_id", str(self.robber.id)).execute())

                embed = discord.Embed(title="ğŸ• GUARD DOG ATTACK!", color=0xFF0000)
                embed.description = (
                    f"### ğŸ©¸ MAULED!\n"
                    f"**{self.victim.display_name}**'s Guard Dog tore you to pieces!\n"
                    f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                    f" â”£ ğŸ¥ **Hospital & Fines:** `-$500,000,000`\n"
                    f" â”£ ğŸ’³ **Your New Balance:** `${new_bal:,}`\n"
                    f" â”— ğŸƒ **Status:** `Raid Failed`\n"
                )
                return await interaction.edit_original_response(embed=embed, view=None)

            # ==========================================
            # ğŸ’» NO TRAPS: ENTER GAUNTLET (5 STAGES)
            # ==========================================
            gauntlet_view = WipeoutGauntletView(self.robber, self.victim, interaction.message, rob_data, vic_data)
            
            embed = discord.Embed(title="â˜ ï¸ WIPEOUT: HACKING IN PROGRESS", color=0x3498db)
            embed.description = (
                f"### âš ï¸ SECURITY LAYER 1/5\n"
                f"**Target:** {self.victim.mention}\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f"ğŸ’» **{gauntlet_view.question}**\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f"> âš¡ **8 SECONDS REMAINING! THINK FAST!**"
            )
            await interaction.edit_original_response(embed=embed, view=gauntlet_view)

        except Exception as e:
            await interaction.followup.send(f"âŒ **System Error:** `{e}`")

    @discord.ui.button(label="ğŸƒ ABORT MISSION", style=discord.ButtonStyle.secondary)
    async def cancel_raid(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.robber.id: return
        self.stop()
        embed = discord.Embed(title="ğŸƒ MISSION ABORTED", description=f"**{self.robber.mention}** chickened out. The 500M risk was too high.", color=0x95a5a6)
        await interaction.response.edit_message(embed=embed, view=None)


# ==============================================================================
# ğŸš€ MAIN COMMAND (/wipeout)
# ==============================================================================
@bot.tree.command(name="wipeout", description="â˜ ï¸ High Risk (500M): Hack 5 layers to wipe out target's Wallet, Bank & Inv!")
@app_commands.describe(victim="The Billionaire you want to bankrupt")
@check_seized()
async def wipeout(interaction: discord.Interaction, victim: discord.Member):
    await interaction.response.defer(ephemeral=False) # ğŸŒ PUBLIC VISIBILITY
    
    user = interaction.user

    # ğŸ›‘ 1. BASIC CHECKS
    if user.id == victim.id: return await interaction.followup.send("âŒ **Error:** You cannot wipeout yourself.")
    if victim.bot: return await interaction.followup.send("âŒ **Error:** Bots do not have bank accounts.")

    # â±ï¸ 2. COOLDOWN CHECK (3 Hours)
    key = f"{user.id}-{victim.id}"
    now = discord.utils.utcnow()
    if key in wipeout_cooldowns:
        last_time = wipeout_cooldowns[key]
        if now < last_time + dt.timedelta(hours=3):
            rem = (last_time + dt.timedelta(hours=3)) - now
            h, m = divmod(rem.seconds // 60, 60)
            return await interaction.followup.send(f"â³ **Lay Low:** You must wait `{h}h {m}m` before targeting {victim.display_name} again.")

    # ğŸ—„ï¸ 3. DATABASE CHECKS
    try:
        vic_res = await db_call(lambda: supabase.table("economy").select("*").eq("user_id", str(victim.id)).execute())
        rob_res = await db_call(lambda: supabase.table("economy").select("*").eq("user_id", str(user.id)).execute())

        if not vic_res or not vic_res.data:
            return await interaction.followup.send(f"âŒ **Error:** **{victim.display_name}** does not exist in the database.")
        if not rob_res or not rob_res.data:
            return await interaction.followup.send("âŒ **Error:** You need a Titan Account first.")

        vic = vic_res.data[0]
        rob = rob_res.data[0]
        rob_inv = rob.get('inventory', {}) or {}

        # ğŸ’° 100M STARTING REQUIREMENT (Bank + Wallet)
        total_rob_wealth = int(rob.get('balance', 0)) + int(rob.get('bank', 0))
        if total_rob_wealth < 100000000:
            return await interaction.followup.send(f"ğŸš« **Too Poor:** You need a Net Worth of at least `$100,000,000` to initiate a Wipeout protocol.", ephemeral=True)

        # ğŸ—ï¸ MASTER KEY REQUIREMENT
        if rob_inv.get('master_key', 0) < 1:
            return await interaction.followup.send("ğŸš« **Access Denied:** You need a **Master Key** in your inventory to bypass external security.", ephemeral=True)

        # âš ï¸ TARGET EMPTY CHECK
        total_vic_wealth = int(vic.get('balance', 0)) + int(vic.get('bank', 0))
        vic_inv = vic.get('inventory', {}) or {}
        if total_vic_wealth < 1000 and not vic_inv:
            return await interaction.followup.send("âš ï¸ **Target Empty:** This user is practically homeless. Not worth the 500M risk.")

    except Exception as e:
        return await interaction.followup.send(f"âŒ **Database Error:** `{e}`")

    # ğŸ“œ 4. PUBLIC CONFIRMATION
    embed = discord.Embed(title="â˜ ï¸ INITIALIZING WIPEOUT PROTOCOL", color=0xFF0000)
    embed.set_thumbnail(url=victim.display_avatar.url)
    embed.description = (
        f"### âš ï¸ EXTREME DANGER WARNING\n"
        f"**{user.mention}** is preparing to completely eradicate **{victim.mention}**'s existence!\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f" â”£ ğŸ¯ **Target Wealth:** `${total_vic_wealth:,}` + `Items`\n"
        f" â”£ ğŸ› ï¸ **Task:** `Solve 5 Security Nodes in 8 seconds each`\n"
        f" â”— ğŸ’€ **Failure Penalty:** `-$500,000,000` (Direct Deduction)\n\n"
        f"> *If you fail, you will owe the bank 500 Million. Do you accept the risk?*"
    )

    view = WipeoutConfirmView(user, victim)
    await interaction.followup.send(embed=embed, view=view)

# --- ğŸ› ï¸ FIX NAME COMMAND (ONLY FOR TOP 3 STAFF) ---
import discord
from discord import app_commands
import asyncio

# ==============================================================================
# ğŸ›¡ï¸ TITAN EXECUTIVE PANEL: STAFF NAME SYNCHRONIZATION
# ==============================================================================

# --- ğŸ›ï¸ DYNAMIC DROPDOWN MENU ---
class FixNameSelect(discord.ui.Select):
    def __init__(self, options):
        super().__init__(
            placeholder="Select Staff Member to synchronize...", 
            min_values=1, 
            max_values=1, 
            options=options,
            custom_id="staff_name_selector"
        )

    async def callback(self, interaction: discord.Interaction):
        await interaction.response.defer(ephemeral=True) # â³ Instant Defer
        
        target_id = int(self.values[0])
        target_member = interaction.guild.get_member(target_id)

        if not target_member:
            return await interaction.followup.send("âŒ **System Error:** The target executive is no longer in the server.", ephemeral=True)

        try:
            # ğŸ¯ CORE LOGIC: Fetch Global Name
            real_name = target_member.global_name if target_member.global_name else target_member.name
            
            # ğŸ“› Nickname Formatting (Max 32 chars strict)
            new_nick = f"[BOT STAFF] {real_name[:18]}"
            
            # Execute Name Change
            await target_member.edit(nick=new_nick)
            
            # ğŸ’ Premium Success Embed
            embed = discord.Embed(title="âœ… CREDENTIALS SYNCHRONIZED", color=0x2ECC71) # Green
            embed.description = (
                f"### ğŸ›¡ï¸ STAFF ID CARD ISSUED\n"
                f"**Executive:** {target_member.mention}\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ“ **Global Identity:** `{real_name}`\n"
                f" â”— ğŸ“› **New Designation:** `{new_nick}`\n\n"
                f"> *Official Titan Casino Staff credentials have been updated.*"
            )
            embed.set_thumbnail(url=target_member.display_avatar.url)
            
            await interaction.followup.send(embed=embed, ephemeral=True)
            
        except discord.Forbidden:
            await interaction.followup.send("âŒ **Access Denied:** I lack `Manage Nicknames` permission, or the user's role is higher than mine!", ephemeral=True)
        except Exception as e:
            await interaction.followup.send(f"âŒ **Fatal Error:** `{e}`", ephemeral=True)


# --- ğŸ–¥ï¸ VIEW CONTAINER ---
class FixNameView(discord.ui.View):
    def __init__(self, options):
        super().__init__(timeout=60)
        self.add_item(FixNameSelect(options))


# ==============================================================================
# ğŸš€ MAIN COMMAND
# ==============================================================================
@bot.tree.command(name="fix_name", description="ğŸ›¡ï¸ Staff Only: Synchronize official global display name")
async def fix_name_global(interaction: discord.Interaction):
    await interaction.response.defer(ephemeral=True)
    
    # ğŸ—„ï¸ 1. FETCH TOP 3 ACTIVE STAFF (SAFE DB CALL)
    try:
        # Assuming OWNER_ID is defined globally in your code
        res = await db_call(lambda: supabase.table("economy").select("user_id, command_count").neq("user_id", str(OWNER_ID)).order("command_count", desc=True).limit(3).execute())
        data = res.data if res and res.data else []
    except Exception as e:
        return await interaction.followup.send("âŒ **Mainframe Error:** Database unreachable.", ephemeral=True)
    
    if not data:
        return await interaction.followup.send("âŒ **Database Empty:** No active staff records found.", ephemeral=True)

    top_3_ids = [int(u['user_id']) for u in data]
    
    # ğŸ” 2. CLEARANCE CHECK
    is_owner = (interaction.user.id == OWNER_ID)
    is_staff = (interaction.user.id in top_3_ids)

    if not is_owner and not is_staff:
        embed = discord.Embed(title="ğŸš« CLEARANCE REJECTED", color=0x8B0000)
        embed.description = "âš ï¸ **Security Alert:** You lack the Executive Clearance to access this terminal."
        return await interaction.followup.send(embed=embed, ephemeral=True)

    # ğŸ“‹ 3. DYNAMIC OPTIONS BUILDER
    options = []
    for uid in top_3_ids:
        member = interaction.guild.get_member(uid)
        if member:
            # ğŸ›¡ï¸ Security: Staff can only see/fix themselves. Owner sees everyone.
            if not is_owner and uid != interaction.user.id:
                continue
                
            label_name = member.global_name if member.global_name else member.name
            options.append(discord.SelectOption(
                label=f"Staff: {label_name[:20]}", 
                value=str(uid), 
                description=f"Clearance ID: {uid}", 
                emoji="ğŸ›¡ï¸"
            ))

    if not options:
        return await interaction.followup.send("âŒ **Error:** Eligible staff members are not currently in the server.", ephemeral=True)

    # ğŸ’ 4. PREMIUM PANEL RENDER
    embed = discord.Embed(title="ğŸ›¡ï¸ TITAN EXECUTIVE PANEL", color=0x3498DB)
    embed.description = (
        f"**Welcome to the Staff Synchronization Terminal.**\n"
        f"Select a staff member below to sync their official Titan identity with their global Discord profile.\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬"
    )
    embed.set_thumbnail(url=interaction.client.user.display_avatar.url)
    
    view = FixNameView(options)
    await interaction.followup.send(embed=embed, view=view, ephemeral=True)

# --- ğŸ“Š COMMAND: STAFF LEADERBOARD (Premium & Fix) ---
import discord
from discord import app_commands
import asyncio

# ==============================================================================
# ğŸ‘‘ TITAN ELITE RECRUITMENT: ACTIVE STAFF LEADERBOARD
# ==============================================================================

@bot.tree.command(name="staff_stats", description="ğŸ‘‘ View the Elite Staff Leaderboard (Anti-Spam Evaluated)")
@check_seized()
async def staff_stats(interaction: discord.Interaction):
    # â³ 1. INSTANT DEFER (Crucial for Heavy DB & Role Syncs)
    await interaction.response.defer(ephemeral=False)
    
    try:
        # ğŸ”„ 2. LIVE ROLE SYNCHRONIZATION (SAFE EXECUTION)
        # Wrapping this in a try-except so if Discord API rate-limits us, the command still works!
        try:
            # Assuming update_staff_roles is defined globally
            await update_staff_roles(interaction.guild)
        except Exception as role_err:
            print(f"âš ï¸ [WARNING] Role Sync Delayed: {role_err}")
        
        # ğŸ“¥ 3. SECURE DATABASE FETCH (Top 10 Agents)
        # Using db_call to prevent "Errno 11" and blocking
        res = await db_call(lambda: supabase.table("economy").select("user_id, command_count").neq("user_id", str(OWNER_ID)).order("command_count", desc=True).limit(10).execute())
        data = res.data if res and res.data else []
        
        if not data:
            embed = discord.Embed(title="ğŸ“­ MAINFRAME EMPTY", description="No agent activity recorded yet. The field is wide open!", color=0x2b2d31)
            return await interaction.followup.send(embed=embed)

        # ğŸ¨ 4. BUILD PREMIUM DASHBOARD
        embed = discord.Embed(title="ğŸ‘‘ TITAN ELITE RECRUITMENT", color=0x2b2d31) # Stealth Dark Gray
        
        embed.description = (
            f"### âš¡ SYSTEM STATUS: ACTIVE MONITORING\n"
            f"Only the most dedicated agents secure the Staff Protocol.\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ›¡ï¸ **Anti-Spam Filter:** `Active (1 XP / 30s)`\n"
            f" â”£ ğŸ’° **Daily Salary:** `$50,000,000` *(Top 3 Agents)*\n"
            f" â”— ğŸ‘® **Perks:** `Auto-Staff Role + Executive Immunity`\n"
        )
        
        # ğŸ† 5. RANK LIST GENERATION
        rank_text = ""
        user_rank_info = "Status: Unranked (Not in Top 10)" 
        
        for idx, user in enumerate(data):
            uid = user.get('user_id')
            score = user.get('command_count', 0)
            
            # Tier & Icon Setup
            if idx == 0:   
                icon = "ğŸ¥‡ **TITAN**"
                status = "âœ… `[ACTIVE STAFF]`"
            elif idx == 1: 
                icon = "ğŸ¥ˆ **BOSS**"
                status = "âœ… `[ACTIVE STAFF]`"
            elif idx == 2: 
                icon = "ğŸ¥‰ **PRO**"
                status = "âœ… `[ACTIVE STAFF]`"
            else:          
                icon = f"`#{idx+1:02d}`"
                status = "â³ `[IN QUEUE]`"
            
            # Tree Formatting for Clean Look
            is_last = (idx == len(data) - 1)
            tree_char = " â”—" if is_last else " â”£"
            
            # Append to list
            rank_text += f"{icon} <@{uid}>\n{tree_char} ğŸ“Š **{score} XP** â€¢ {status}\n\n"
            
            # Find Caller's Position
            if str(uid) == str(interaction.user.id):
                user_rank_info = f"Your Rank: #{idx+1} | Total Score: {score} XP"

        # ğŸ§© 6. ASSEMBLE EMBED
        embed.add_field(name="ğŸ§¬ TOP AGENTS (Real-Time Activity)", value=rank_text, inline=False)
        
        # Footer & Graphics
        embed.set_footer(text=f"{user_rank_info} â€¢ Keep Grinding!", icon_url=interaction.user.display_avatar.url)
        if interaction.guild and interaction.guild.icon:
            embed.set_thumbnail(url=interaction.guild.icon.url)
        
        # ğŸš€ 7. EXECUTE
        await interaction.followup.send(embed=embed)
        
    except Exception as e:
        print(f"Staff Stats Critical Error: {e}")
        await interaction.followup.send(f"âŒ **Mainframe Error:** Database failed to sync. `{e}`")
    
 # ====================== DALGONA DUEL =======================
import discord
from discord import app_commands
import asyncio
import random

# ==============================================================================
# ğŸª SQUID GAME: DALGONA TRACING DUEL (ULTRA-PREMIUM)
# ==============================================================================

# --- ğŸ¨ CONFIG: SHAPES & IMAGES ---
DUEL_SHAPES = {
    "triangle": {
        "name": "Triangle (ğŸ”º)", 
        "icon": "ğŸ”º",
        "img": "https://media.tenor.com/Psh5n4-XlYQAAAAC/squid-game-dalgona.gif", 
        "steps": 4
    },
    "circle": {
        "name": "Circle (ğŸŸ )", 
        "icon": "ğŸŸ ",
        "img": "https://media.tenor.com/Psh5n4-XlYQAAAAC/squid-game-dalgona.gif", 
        "steps": 6
    },
    "star": {
        "name": "Star (â­)", 
        "icon": "â­",
        "img": "https://media.tenor.com/Psh5n4-XlYQAAAAC/squid-game-dalgona.gif", 
        "steps": 8
    },
    "umbrella": {
        "name": "Umbrella (â˜‚ï¸)", 
        "icon": "â˜‚ï¸",
        "img": "https://media.tenor.com/Psh5n4-XlYQAAAAC/squid-game-dalgona.gif", 
        "steps": 10
    }
}

MOVES = ["â¬†ï¸", "â¬‡ï¸", "â¬…ï¸", "â¡ï¸"]

# --- 1. THE GAME BUTTONS (Tracing Input) ---
class DuelTraceBtn(discord.ui.Button):
    def __init__(self, emoji, row):
        super().__init__(style=discord.ButtonStyle.secondary, emoji=emoji, row=row)

    async def callback(self, interaction: discord.Interaction):
        view: SquidDuelLiveView = self.view
        
        # ğŸ›¡ï¸ 1. Identify Player
        if interaction.user.id == view.p1.id: player_idx = 1
        elif interaction.user.id == view.p2.id: player_idx = 2
        else:
            return await interaction.response.send_message("âŒ **Guard:** Spectators, step back!", ephemeral=True)

        await interaction.response.defer() # ğŸ› ï¸ INSTANT DEFER FOR SPAM SAFETY

        # 2. Get Current Pattern Step
        current_step = view.p1_step if player_idx == 1 else view.p2_step
        pattern = view.pattern
        
        if current_step >= len(pattern) or view.game_over: 
            return

        # ğŸ¯ 3. CHECK INPUT LOGIC
        expected_move = pattern[current_step]
        
        if str(self.emoji) == expected_move:
            # ==========================================
            # âœ… CORRECT MOVE (TRACE SUCCESS)
            # ==========================================
            if player_idx == 1:
                view.p1_step += 1
                if view.p1_step == len(pattern):
                    return await view.declare_winner(interaction, view.p1)
            else:
                view.p2_step += 1
                if view.p2_step == len(pattern):
                    return await view.declare_winner(interaction, view.p2)
            
            # UI Update (Silent, fast update)
            await view.update_duel_board(interaction)
            
        else:
            # ==========================================
            # âŒ WRONG MOVE -> CRACK! (INSTANT LOSS)
            # ==========================================
            loser = view.p1 if player_idx == 1 else view.p2
            winner = view.p2 if player_idx == 1 else view.p1
            await view.trigger_crack(interaction, loser, winner)


# --- 2. THE GAME VIEW (Logic Engine) ---
class SquidDuelLiveView(discord.ui.View):
    def __init__(self, p1: discord.Member, p2: discord.Member, bet: int, shape_key: str):
        super().__init__(timeout=120) # â³ 2 Min to finish
        self.p1 = p1
        self.p2 = p2
        self.bet = bet
        self.shape_data = DUEL_SHAPES[shape_key]
        
        # Generate Random Pattern
        self.pattern = [random.choice(MOVES) for _ in range(self.shape_data['steps'])]
        self.p1_step = 0
        self.p2_step = 0
        self.game_over = False

        # Add D-Pad Controls
        self.add_item(DuelTraceBtn("â¬†ï¸", 0))
        self.add_item(DuelTraceBtn("â¬‡ï¸", 0))
        self.add_item(DuelTraceBtn("â¬…ï¸", 1))
        self.add_item(DuelTraceBtn("â¡ï¸", 1))

    async def update_duel_board(self, interaction: discord.Interaction):
        if self.game_over: return

        total = len(self.pattern)
        
        # Dynamic Progress Bars
        p1_fill = "ğŸŸ©" * self.p1_step + "â¬›" * (total - self.p1_step)
        p1_next = self.pattern[self.p1_step] if self.p1_step < total else "ğŸ†"
        
        p2_fill = "ğŸŸ©" * self.p2_step + "â¬›" * (total - self.p2_step)
        p2_next = self.pattern[self.p2_step] if self.p2_step < total else "ğŸ†"

        embed = interaction.message.embeds[0]
        embed.description = (
            f"### ğŸ“ TRACE THE PATTERN FAST!\n"
            f"Match the **Next Move** arrows without making a single mistake.\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"ğŸ‘¤ **{self.p1.display_name}**\n"
            f"> Target: **{p1_next}**\n"
            f"> `{p1_fill}`\n\n"
            f"ğŸ‘¤ **{self.p2.display_name}**\n"
            f"> Target: **{p2_next}**\n"
            f"> `{p2_fill}`\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"âš ï¸ **WARNING:** One wrong click = The Cookie Cracks! (Instant Loss)"
        )
        try: await interaction.edit_original_response(embed=embed, view=self)
        except: pass

    async def declare_winner(self, interaction: discord.Interaction, winner: discord.Member):
        if self.game_over: return
        self.game_over = True
        self.stop()
        
        loser = self.p2 if winner == self.p1 else self.p1
        total_pot = self.bet * 2
        
        # ğŸ’¸ REWARD THE WINNER (Safe)
        await smart_reward(winner.id, total_pot)

        for child in self.children: child.disabled = True
        
        embed = discord.Embed(title="ğŸª DALGONA SURVIVOR!", color=0x2ECC71) # Green
        embed.set_thumbnail(url=winner.display_avatar.url)
        embed.description = (
            f"### ğŸ‰ FLAWLESS EXTRACTION!\n"
            f"**{winner.mention}** perfectly carved the **{self.shape_data['name']}**!\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ’° **Bounty Collected:** `${total_pot:,}`\n"
            f" â”£ ğŸ’€ **Eliminated:** {loser.mention}\n"
            f" â”— ğŸª **Cookie Status:** `Perfect Shape`\n"
        )
        embed.set_image(url="https://media.tenor.com/bXjOidvDvoQAAAAC/confetti-celebrate.gif")
        
        try: await interaction.edit_original_response(embed=embed, view=None)
        except: pass

    async def trigger_crack(self, interaction: discord.Interaction, loser: discord.Member, winner: discord.Member):
        if self.game_over: return
        self.game_over = True
        self.stop()
        
        total_pot = self.bet * 2
        
        # ğŸ’¸ REWARD THE WINNER (Safe)
        await smart_reward(winner.id, total_pot)

        for child in self.children: child.disabled = True
        
        embed = discord.Embed(title="ğŸ’” CRACK! FATAL MISTAKE!", color=0xe74c3c) # Blood Red
        embed.set_thumbnail(url=loser.display_avatar.url)
        embed.description = (
            f"### ğŸ’€ {loser.mention} HAS BEEN ELIMINATED!\n"
            f"A wrong move caused the Dalgona to crack into pieces!\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ† **Survivor (Winner):** {winner.mention}\n"
            f" â”£ ğŸ’° **Bounty Collected:** `${total_pot:,}`\n"
            f" â”— ğŸª **Cookie Status:** `Destroyed`\n"
        )
        embed.set_image(url="https://media.tenor.com/2147kZ75wW8AAAAC/squid-game-card.gif")
        
        try: await interaction.edit_original_response(embed=embed, view=None)
        except: pass


# --- 3. SHAPE SELECTION VIEW ---
class DuelShapeSelectView(discord.ui.View):
    def __init__(self, p1: discord.Member, p2: discord.Member, bet: int):
        super().__init__(timeout=60)
        self.p1 = p1
        self.p2 = p2
        self.bet = bet

    async def start_duel(self, interaction: discord.Interaction, shape_key: str):
        if interaction.user.id != self.p1.id:
            return await interaction.response.send_message("âŒ **Guard:** Only the Challenger selects the shape!", ephemeral=True)
        
        await interaction.response.defer() # ğŸ› ï¸ CRITICAL DEFER
        self.stop()
        
        shape_data = DUEL_SHAPES[shape_key]
        game_view = SquidDuelLiveView(self.p1, self.p2, self.bet, shape_key)
        
        embed = discord.Embed(title=f"ğŸª ARENA: {shape_data['name']}", color=0xE91E63) # Squid Pink
        embed.set_author(name=f"{self.p1.display_name} VS {self.p2.display_name}", icon_url="https://cdn-icons-png.flaticon.com/512/5705/5705917.png")
        embed.set_thumbnail(url=shape_data['img'])
        
        p1_next = game_view.pattern[0]
        p2_next = game_view.pattern[0]
        empty_bar = "â¬›" * shape_data['steps']
        
        embed.description = (
            f"### ğŸ“ TRACE THE PATTERN FAST!\n"
            f"Match the **Next Move** arrows without making a single mistake.\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"ğŸ‘¤ **{self.p1.display_name}**\n"
            f"> Target: **{p1_next}**\n"
            f"> `{empty_bar}`\n\n"
            f"ğŸ‘¤ **{self.p2.display_name}**\n"
            f"> Target: **{p2_next}**\n"
            f"> `{empty_bar}`\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"âš ï¸ **WARNING:** One wrong click = The Cookie Cracks! (Instant Loss)"
        )
        embed.set_footer(text=f"Total Prize Pool: ${self.bet*2:,}", icon_url=self.p1.display_avatar.url)
        
        await interaction.edit_original_response(embed=embed, view=game_view)

    @discord.ui.button(label="Triangle", emoji="ğŸ”º", style=discord.ButtonStyle.success)
    async def tri(self, i, b): await self.start_duel(i, "triangle")

    @discord.ui.button(label="Circle", emoji="ğŸŸ ", style=discord.ButtonStyle.primary)
    async def cir(self, i, b): await self.start_duel(i, "circle")

    @discord.ui.button(label="Star", emoji="â­", style=discord.ButtonStyle.secondary)
    async def star(self, i, b): await self.start_duel(i, "star")

    @discord.ui.button(label="Umbrella", emoji="â˜‚ï¸", style=discord.ButtonStyle.danger)
    async def umb(self, i, b): await self.start_duel(i, "umbrella")


# --- 4. INVITE VIEW ---
class DuelInviteView(discord.ui.View):
    def __init__(self, p1: discord.Member, p2: discord.Member, bet: int):
        super().__init__(timeout=60)
        self.p1 = p1
        self.p2 = p2
        self.bet = bet

    @discord.ui.button(label="ENTER ARENA", style=discord.ButtonStyle.success, emoji="âš”ï¸")
    async def accept(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.p2.id:
            return await interaction.response.send_message("âŒ **Guard:** This invitation is not for you.", ephemeral=True)

        await interaction.response.defer()
        self.stop()

        # ğŸ’³ DOUBLE SMART CHARGE (Secures the Pot Upfront)
        p1_paid = await smart_charge(self.p1.id, self.bet)
        if not p1_paid:
            return await interaction.followup.send(f"âŒ **Error:** {self.p1.mention} no longer has the funds to start the duel.", ephemeral=True)
            
        p2_paid = await smart_charge(self.p2.id, self.bet)
        if not p2_paid:
            await smart_reward(self.p1.id, self.bet) # Refund P1
            return await interaction.followup.send(f"âŒ **Error:** You need `${self.bet:,}` in your Wallet + Bank to accept.", ephemeral=True)

        embed = discord.Embed(title="ğŸª SELECT YOUR FATE", color=0x95a5a6)
        embed.description = (
            f"**{self.p1.mention}**, choose the shape for this duel!\n"
            f"*(Higher difficulty shapes have more tracing steps)*"
        )
        embed.set_thumbnail(url="https://media.tenor.com/Psh5n4-XlYQAAAAC/squid-game-dalgona.gif")
        
        view = DuelShapeSelectView(self.p1, self.p2, self.bet)
        await interaction.edit_original_response(embed=embed, view=view)

    @discord.ui.button(label="DECLINE", style=discord.ButtonStyle.danger, emoji="ğŸƒâ€â™‚ï¸")
    async def decline(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.p2.id: return
        self.stop()
        await interaction.message.delete()
        

# ==============================================================================
# ğŸ’» MAIN COMMAND
# ==============================================================================
@bot.tree.command(name="dalgona_duel", description="ğŸª Squid Game: 1v1 Dalgona Tracing Battle (Max 50k)")
@app_commands.describe(opponent="The player you wish to challenge", amount="Bet Amount (Min: $100 | Max: $50,000)")
@check_seized()
async def dalgona_duel(interaction: discord.Interaction, opponent: discord.Member, amount: int):
    
    # ğŸ›‘ 1. SECURITY & LIMITS
    MAX_BET = 50000
    if opponent.bot or opponent.id == interaction.user.id:
        return await interaction.response.send_message("âŒ **Guard:** Invalid Opponent.", ephemeral=True)
    if amount > MAX_BET:
        return await interaction.response.send_message(f"âŒ **Arena Rules:** Maximum allowed bet is `${MAX_BET:,}`!", ephemeral=True)
    if amount < 100:
        return await interaction.response.send_message("âŒ **Error:** Minimum bet is `$100`.", ephemeral=True)

    # ğŸ—„ï¸ 2. PRE-CHECK LIQUIDITY (Safe DB Check)
    try:
        r1 = await db_call(lambda: supabase.table("economy").select("balance, bank").eq("user_id", str(interaction.user.id)).execute())
        c_total = int(r1.data[0].get('balance', 0)) + int(r1.data[0].get('bank', 0)) if r1 and r1.data else 0
        if c_total < amount:
            return await interaction.response.send_message(f"âŒ **Broke:** You need `${amount:,}` in your Wallet + Bank.", ephemeral=True)
            
        r2 = await db_call(lambda: supabase.table("economy").select("balance, bank").eq("user_id", str(opponent.id)).execute())
        o_total = int(r2.data[0].get('balance', 0)) + int(r2.data[0].get('bank', 0)) if r2 and r2.data else 0
        if o_total < amount:
            return await interaction.response.send_message(f"âŒ **Error:** {opponent.display_name} cannot afford this duel.", ephemeral=True)
    except Exception as e:
        return await interaction.response.send_message("âŒ **Mainframe Error:** Database unreachable.", ephemeral=True)

    # ğŸ“œ 3. SEND FORMAL CHALLENGE
    embed = discord.Embed(title="ğŸ¦‘ SQUID GAME: DALGONA DUEL", color=0xE91E63) # Squid Pink
    embed.set_thumbnail(url="https://media.tenor.com/Psh5n4-XlYQAAAAC/squid-game-dalgona.gif")
    embed.description = (
        f"### âš ï¸ ENTER THE ARENA\n"
        f"**{interaction.user.mention}** has challenged **{opponent.mention}**!\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f" â”£ ğŸ’° **Stakes:** `${amount:,}`\n"
        f" â”£ ğŸ¯ **Objective:** `Trace the pattern faster than your opponent!`\n"
        f" â”— ğŸ’€ **Rule:** `One wrong click = The Cookie Cracks (Instant Loss)`\n\n"
        f"ğŸ‘‡ **{opponent.mention}, do you accept this deathmatch?**"
    )
    
    view = DuelInviteView(interaction.user, opponent, amount)
    await interaction.response.send_message(content=f"ğŸ”” {opponent.mention}, you have been challenged!", embed=embed, view=view)
                  
# =========================== ğŸ›’ ADVANCED SELL CART SYSTEM ===========================
import discord
from discord import app_commands
import asyncio

# ==============================================================================
# ğŸ›’ TITAN BLACK MARKET: SELL TERMINAL (CART SYSTEM)
# ==============================================================================

# --- 1. QUANTITY MODAL (Add to Cart) ---
class AddToCartModal(discord.ui.Modal, title="ğŸ›’ ADD TO CART"):
    def __init__(self, item_id: str, item_name: str, max_qty: int, parent_view):
        super().__init__()
        self.item_id = item_id
        self.item_name = item_name
        self.max_qty = max_qty
        self.parent_view = parent_view 
        
        self.qty_input = discord.ui.TextInput(
            label=f"Quantity to sell ({item_name})",
            placeholder=f"Max available: {max_qty}",
            min_length=1, 
            max_length=6, 
            required=True,
            style=discord.TextStyle.short
        )
        self.add_item(self.qty_input)

    async def on_submit(self, interaction: discord.Interaction):
        # 1. Validate Input
        try:
            qty = int(self.qty_input.value)
        except ValueError:
            return await interaction.response.send_message("âŒ **Error:** Please enter a valid number.", ephemeral=True)

        if qty <= 0 or qty > self.max_qty:
            return await interaction.response.send_message(f"âŒ **Invalid Quantity!** You only have `{self.max_qty}`.", ephemeral=True)

        # 2. Update Cart & Refresh UI
        self.parent_view.cart[self.item_id] = qty
        await self.parent_view.update_message(interaction)


# --- 2. DYNAMIC SELECT MENU ---
class CartSelect(discord.ui.Select):
    def __init__(self, inventory: dict, view_instance):
        options = []
        # Filter only sellable items from global SHOP_ITEMS
        for item_id, qty in list(inventory.items())[:25]: # Discord max 25 options
            if item_id in SHOP_ITEMS:
                item = SHOP_ITEMS[item_id]
                sell_price = int(item['price'] * 0.70) # 70% Refund Value
                options.append(discord.SelectOption(
                    label=f"{item['name']} (Owns: {qty})", 
                    value=item_id,
                    description=f"Sell Value: ${sell_price:,} each",
                    emoji="ğŸ“¦"
                ))
        
        if not options:
            options.append(discord.SelectOption(label="No sellable items", value="none", description="Empty"))

        self.view_instance = view_instance
        super().__init__(
            placeholder="Select an item to add to your Cart...", 
            options=options, 
            disabled=(len(options)==0 or options[0].value == "none")
        )

    async def callback(self, interaction: discord.Interaction):
        if self.values[0] == "none":
            return await interaction.response.send_message("âŒ You don't have anything valuable to sell.", ephemeral=True)

        item_id = self.values[0]
        max_qty = self.view_instance.inventory.get(item_id, 0)
        item_name = SHOP_ITEMS[item_id]['name']
        
        # Open Modal
        modal = AddToCartModal(item_id, item_name, max_qty, self.view_instance)
        await interaction.response.send_modal(modal)


# --- 3. THE CART MANAGER VIEW ---
class SellCartView(discord.ui.View):
    def __init__(self, inventory: dict, user_id: int):
        super().__init__(timeout=120)
        self.inventory = inventory
        self.user_id = user_id 
        self.cart = {} # {item_id: qty}
        
        self.add_item(CartSelect(inventory, self))

    # ğŸ›¡ï¸ PROTECTION LAYER
    async def interaction_check(self, interaction: discord.Interaction) -> bool:
        if interaction.user.id != self.user_id:
            await interaction.response.send_message("âŒ **Guard:** This is someone else's cart. Use `/sell` yourself.", ephemeral=True)
            return False
        return True

    # ğŸ¨ PREMIUM UI UPDATER
    async def update_message(self, interaction: discord.Interaction):
        total_payout = 0
        desc_lines = []
        
        if not self.cart:
            desc_lines.append("> ğŸ“­ *Your cart is currently empty.*")
        else:
            desc_lines.append("**ğŸ§¾ OFFICIAL BILLING STATEMENT:**\n")
            for i_id, q in self.cart.items():
                name = SHOP_ITEMS[i_id]['name']
                price = SHOP_ITEMS[i_id]['price']
                refund = int(price * 0.70) * q # 70% payout
                total_payout += refund
                desc_lines.append(f" â”£ ğŸ“¦ **{name}** `x{q}` â” `${refund:,}`")
            
            desc_lines.append(f" â”— ğŸ’° **TOTAL ESTIMATED VALUE:** `${total_payout:,}`")

        embed = discord.Embed(title="ğŸ›’ TITAN SELL TERMINAL", color=0xF1C40F) # Gold
        embed.description = "\n".join(desc_lines)
        embed.set_footer(text="Select items from the dropdown to build your cart.")
        
        if not interaction.response.is_done():
            await interaction.response.edit_message(embed=embed, view=self)
        else:
            await interaction.edit_original_response(embed=embed, view=self)

    # --- BUTTONS ---
    @discord.ui.button(label="AUTHORIZE SALE", style=discord.ButtonStyle.success, emoji="âœ…", row=2)
    async def confirm(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not self.cart:
            return await interaction.response.send_message("âŒ **Error:** Cannot authorize an empty cart!", ephemeral=True)
        
        await interaction.response.defer() # â³ DB Shield
        
        # ğŸ›¡ï¸ LOCK BUTTONS INSTANTLY (Prevents Item Duplication Hack)
        self.stop()
        for child in self.children: child.disabled = True
        await interaction.edit_original_response(view=self)
            
        try:
            # ğŸ—„ï¸ SAFE DB FETCH
            res = await db_call(lambda: supabase.table("economy").select("balance, inventory").eq("user_id", str(self.user_id)).execute())
            if not res or not res.data:
                return await interaction.followup.send("âŒ **Database Error:** Account not found.", ephemeral=True)

            curr_inv = res.data[0].get('inventory', {}) or {}
            curr_bal = res.data[0].get('balance', 0)
            
            total_profit = 0
            sold_log = []
            
            # ğŸ§® PROCESS TRANSACTIONS
            for i_id, qty_to_sell in self.cart.items():
                if i_id in curr_inv and curr_inv[i_id] >= qty_to_sell:
                    price = SHOP_ITEMS[i_id]['price']
                    profit = int(price * 0.70) * qty_to_sell
                    total_profit += profit
                    
                    # Deduct from inventory
                    curr_inv[i_id] -= qty_to_sell
                    if curr_inv[i_id] <= 0:
                        del curr_inv[i_id]
                        
                    sold_log.append(f"`{SHOP_ITEMS[i_id]['name']} x{qty_to_sell}`")
            
            if total_profit == 0:
                return await interaction.followup.send("âŒ **Error:** Transaction failed. Inventory mismatch.", ephemeral=True)

            # ğŸ’¾ SINGLE ATOMIC DB UPDATE (Safest method)
            await db_call(lambda: supabase.table("economy").update({
                "balance": curr_bal + total_profit,
                "inventory": curr_inv
            }).eq("user_id", str(self.user_id)).execute())
            
            # ğŸ’ PREMIUM RECEIPT
            embed = discord.Embed(title="ğŸ¤ TRANSACTION APPROVED", color=0x2ECC71)
            embed.set_thumbnail(url=interaction.user.display_avatar.url)
            embed.description = (
                f"### ğŸ‰ ITEMS SOLD SUCCESSFULLY!\n"
                f"Your items have been liquidated into pure cash.\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f"**ğŸ“¦ Items Liquidated:**\n" + ", ".join(sold_log) + "\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ’¸ **Cash Earned:** `+${total_profit:,}`\n"
                f" â”— ğŸ’³ **New Wallet Balance:** `${(curr_bal + total_profit):,}`\n"
            )

            await interaction.edit_original_response(embed=embed, view=None)

        except Exception as e:
            print(f"Sell Cart Error: {e}")
            await interaction.followup.send(f"âŒ **System Error:** Transaction failed. `{e}`", ephemeral=True)

    @discord.ui.button(label="CLEAR CART", style=discord.ButtonStyle.danger, emoji="ğŸ—‘ï¸", row=2)
    async def clear(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.cart = {} 
        await self.update_message(interaction)


# ==============================================================================
# ğŸš€ MAIN COMMAND
# ==============================================================================
@bot.tree.command(name="sell", description="ğŸ›’ Sell multiple inventory items at once for quick cash!")
@check_seized()
async def sell_items(interaction: discord.Interaction):
    await interaction.response.defer(ephemeral=False) # â³ Defer safely
    
    try:
        # ğŸ—„ï¸ SAFE DB FETCH
        res = await db_call(lambda: supabase.table("economy").select("inventory").eq("user_id", str(interaction.user.id)).execute())
        data = res.data[0] if res and res.data else None
        
        # Empty Inventory Check
        if not data or not data.get('inventory') or len(data['inventory']) == 0:
            return await interaction.followup.send("âŒ **Error:** Your inventory is completely empty. Buy something first!", ephemeral=True)
            
        user_inv = data['inventory']
        
        # Validation: Do they have anything from the SHOP_ITEMS?
        sellable_found = any(item_id in SHOP_ITEMS for item_id in user_inv)
                
        if not sellable_found:
            return await interaction.followup.send("âŒ **Error:** You don't have any items that the market wants to buy.", ephemeral=True)

        view = SellCartView(user_inv, interaction.user.id)
        
        embed = discord.Embed(title="ğŸ›’ TITAN SELL TERMINAL", color=0x2b2d31)
        embed.set_thumbnail(url="https://cdn-icons-png.flaticon.com/512/833/833314.png")
        embed.description = (
            f"**Welcome to the Market Checkout, {interaction.user.mention}.**\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"> ğŸ“­ *Your cart is currently empty.*\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"ğŸ‘‡ **Select items from the dropdown to build your cart.**"
        )
        
        await interaction.followup.send(embed=embed, view=view)

    except Exception as e:
        print(f"Sell command error: {e}")
        await interaction.followup.send(f"âŒ **System Error:** `{e}`", ephemeral=True)
                


import discord
from discord import app_commands
import asyncio

# --- âš™ï¸ CONFIGURATION (Ensure these are defined at the top) ---
OWNER_ID = 804687084249284618   
STAFF_ROLE_ID = 1459074209191039049  
GUILD_ID = 1257403231127076915       
SALARY_LOG_CHANNEL_ID = 1457066104819028089 
STAFF_SALARY = 5000000 # Adjusted to 50M to match your previous design, change as needed!

# ==============================================================================
# ğŸ”´ EXECUTIVE OVERRIDE: MANUAL SALARY PAYROLL
# ==============================================================================

@bot.tree.command(name="force_pay_salary", description="ğŸ‘‘ Executive Only: Force authorize and disburse staff payroll")
async def force_pay_salary(interaction: discord.Interaction):
    
    # ğŸ›¡ï¸ 1. SUPREME CLEARANCE CHECK
    if int(interaction.user.id) != int(OWNER_ID):
        embed = discord.Embed(title="ğŸš« CLEARANCE REJECTED", color=0x8B0000)
        embed.description = "âš ï¸ **Security Alert:** Only the Supreme Commander can authorize manual payroll operations."
        return await interaction.response.send_message(embed=embed, ephemeral=True)

    await interaction.response.defer(ephemeral=True) # â³ Safe Defer

    try:
        # ğŸ¢ 2. HQ VERIFICATION (Smart Guild Fetch)
        guild = interaction.guild
        if not guild:
            return await interaction.followup.send("âŒ **System Error:** This terminal must be operated within the Main Server.", ephemeral=True)

        # ğŸ“¡ 3. ESTABLISH SECURE COMMS (Channel Fallback)
        channel = guild.get_channel(int(SALARY_LOG_CHANNEL_ID))
        warning_msg = ""
        
        if not channel:
            channel = interaction.channel
            warning_msg = f"\n> âš ï¸ *Warning: Official Log Channel (`{SALARY_LOG_CHANNEL_ID}`) offline. Rerouting receipt to current terminal.*"

        # ğŸ—„ï¸ 4. FETCH ELITE STAFF (Safe DB Call)
        res = await db_call(lambda: supabase.table("economy").select("user_id, balance, command_count").neq("user_id", str(OWNER_ID)).order("command_count", desc=True).limit(3).execute())
        data = res.data if res and res.data else []
        
        if not data:
            return await interaction.followup.send("ğŸ“­ **Payroll Empty:** No active agents found in the database to receive funds.", ephemeral=True)

        # ğŸ¨ 5. BUILD PREMIUM PAYROLL RECEIPT
        embed = discord.Embed(
            title="ğŸ’¸ TITAN PAYROLL: MANUAL OVERRIDE",
            color=0x2ECC71, # Success Green
            timestamp=discord.utils.utcnow()
        )
        embed.description = (
            f"### âš ï¸ EXECUTIVE AUTHORIZATION\n"
            f"**{interaction.user.mention}** has manually triggered the staff payroll distribution.{warning_msg}\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬"
        )
        embed.set_thumbnail(url="https://media.tenor.com/p7a8o1r5c8cAAAAC/money-rain.gif")
        
        # ğŸ’³ 6. DISBURSE FUNDS (Atomic Loop)
        count = 0
        trophies = ["ğŸ¥‡", "ğŸ¥ˆ", "ğŸ¥‰"]
        
        for idx, user in enumerate(data):
            uid = int(user['user_id'])
            current_bal = int(user.get('balance', 0))
            
            # Dynamic Balance Calculation
            new_bal = current_bal + STAFF_SALARY
            
            # ğŸ’¾ Safe DB Update per user
            await db_call(lambda: supabase.table("economy").update({"balance": new_bal}).eq("user_id", str(uid)).execute())
            
            member = guild.get_member(uid)
            user_mention = member.mention if member else f"`Unknown Agent ({uid})`"
            icon = trophies[idx] if idx < 3 else "ğŸ…"
            
            # Append to Receipt
            embed.add_field(
                name=f"{icon} Rank #{idx+1} | {member.display_name if member else uid}",
                value=(
                    f" â”£ ğŸ‘¤ **Agent:** {user_mention}\n"
                    f" â”£ ğŸ’° **Salary Paid:** `${STAFF_SALARY:,}`\n"
                    f" â”— ğŸ’³ **New Wallet:** `${new_bal:,}`\n"
                ),
                inline=False
            )
            count += 1

        # ğŸ“¤ 7. TRANSMIT LOGS
        try:
            await channel.send(embed=embed)
        except Exception as e:
            print(f"Log Transmit Error: {e}")
            return await interaction.followup.send("âŒ **Transmission Failed:** The bot lacks permission to send messages in the log channel.", ephemeral=True)

        # ğŸ”„ 8. SYNCHRONIZE ROLES
        try:
            await update_staff_roles(guild)
        except Exception as e:
            print(f"Role Sync Warning: {e}") # Non-fatal error
        
        # âœ… Final Confirmation to Owner
        await interaction.followup.send(f"âœ… **Payroll Executed!** Successfully disbursed `${STAFF_SALARY:,}` to `{count}` agents.\nğŸ§¾ **View Receipt:** {channel.mention}", ephemeral=True)

    except Exception as e:
        print(f"Force Salary Critical Error: {e}")
        await interaction.followup.send(f"âŒ **Mainframe Error:** `{e}`", ephemeral=True)

# ==========================================
# ğŸ¢ ULTRA PREMIUM BUSINESS SELLING SYSTEM
# =========================================
import discord
from discord import app_commands
import asyncio

# --- âš™ï¸ CONFIGURATION ---
APPROVAL_CHANNEL_ID = 1440733604702584976 
# Note: Ensure OWNER_ID, BUSINESSES, bot, and db_call are defined in your main code.

# ==============================================================================
# ğŸ¢ CORPORATE ACQUISITION: BUSINESS SELL & TAKEOVER PROTOCOL
# ==============================================================================

# --- ğŸ” HELPER: AUTOCOMPLETE FOR SELLING ---
async def sell_biz_autocomplete(interaction: discord.Interaction, current: str):
    user_id = str(interaction.user.id)
    try:
        # Safe DB Call
        res = await asyncio.to_thread(lambda: supabase.table("economy").select("businesses").eq("user_id", user_id).execute())
        data = res.data if res else []
        if not data or not data[0].get('businesses'): return []
        
        owned = data[0]['businesses']
        choices = []
        for biz_id in owned:
            if biz_id in BUSINESSES and current.lower() in BUSINESSES[biz_id]['name'].lower():
                choices.append(discord.app_commands.Choice(name=BUSINESSES[biz_id]['name'], value=biz_id))
        return choices[:25]
    except:
        return []


# --- ğŸ”„ USER'S SECOND CHANCE VIEW (DM TERMINAL) ---
class RejectOfferOptions(discord.ui.View):
    def __init__(self, user_id: str, user_name: str, biz_id: str, biz_name: str, actual_price: int, biz_data: dict):
        super().__init__(timeout=300) # â³ 5 Min Timeout for the offer
        self.user_id = str(user_id)
        self.user_name = user_name
        self.biz_id = biz_id
        self.biz_name = biz_name
        self.biz_data = biz_data
        self.actual_price = actual_price
        self.offer_price = int(actual_price * 0.40) # 40% Hostile Takeover Offer

        # ğŸ› ï¸ DYNAMIC BUTTON LABEL FIX
        self.sell_to_owner.label = f"ACCEPT OFFER (${self.offer_price:,})"

    # âœ‹ OPTION 1: KEEP BUSINESS
    @discord.ui.button(label="DECLINE & KEEP BUSINESS", style=discord.ButtonStyle.secondary, emoji="âœ‹")
    async def keep(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id: return
        
        embed = discord.Embed(title="ğŸ›¡ï¸ ASSET RETAINED", color=0x95a5a6)
        embed.description = f"**Deal Canceled.**\nYou have chosen to retain ownership of **{self.biz_name}**."
        await interaction.response.edit_message(embed=embed, view=None)

    # ğŸ‘‘ OPTION 2: SELL TO OWNER (40% System Pay -> Transfer to Owner)
    @discord.ui.button(custom_id="sell_to_owner_btn", style=discord.ButtonStyle.success, emoji="ğŸ¤")
    async def sell_to_owner(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != self.user_id: return

        await interaction.response.defer() # â³ Prevent Interaction Failed

        try:
            # 1. ğŸ—„ï¸ FETCH SELLER DATA (Safe)
            seller_res = await db_call(lambda: supabase.table("economy").select("*").eq("user_id", self.user_id).execute())
            if not seller_res or not seller_res.data: return
            
            seller_data = seller_res.data[0]
            seller_biz = seller_data.get('businesses', {}) or {}
            
            if self.biz_id not in seller_biz:
                return await interaction.followup.send("âŒ **Error:** You no longer possess this business.", ephemeral=True)

            # 2. ğŸ—„ï¸ FETCH OWNER DATA (Safe)
            owner_res = await db_call(lambda: supabase.table("economy").select("businesses").eq("user_id", str(OWNER_ID)).execute())
            owner_biz = owner_res.data[0].get('businesses', {}) if owner_res and owner_res.data else {}

            # 3. âš™ï¸ PROCESS HOSTILE TAKEOVER
            # A. Remove from Seller & Add 40% Funds
            del seller_biz[self.biz_id]
            new_seller_bal = seller_data.get('balance', 0) + self.offer_price

            # B. Transfer Asset to Owner
            owner_biz[self.biz_id] = self.biz_data 
            
            # 4. ğŸ’¾ SAVE TRANSACTIONS (Atomic-like execution)
            await db_call(lambda: supabase.table("economy").update({"businesses": seller_biz, "balance": new_seller_bal}).eq("user_id", self.user_id).execute())
            
            # If owner didn't exist in DB, insert them. Otherwise, update.
            if not owner_res or not owner_res.data:
                await db_call(lambda: supabase.table("economy").insert({"user_id": str(OWNER_ID), "balance": 0, "inventory": {}, "businesses": owner_biz}).execute())
            else:
                await db_call(lambda: supabase.table("economy").update({"businesses": owner_biz}).eq("user_id", str(OWNER_ID)).execute())

            # 5. ğŸ‰ SUCCESS MESSAGE TO SELLER
            embed = discord.Embed(title="ğŸ¤ CORPORATE ACQUISITION COMPLETE", color=0x2ECC71) # Green
            embed.description = (
                f"### ğŸ¢ ASSET TRANSFERRED\n"
                f"**{self.biz_name}** has been legally transferred to the **Supreme Executive (Owner)**.\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ’° **Payment Received:** `${self.offer_price:,}` *(40% Valuation)*\n"
                f" â”— ğŸ¦ **Funded By:** `System Treasury`\n"
            )
            embed.set_thumbnail(url="https://media.tenor.com/p7a8o1r5c8cAAAAC/money-rain.gif")
            await interaction.edit_original_response(embed=embed, view=None)

            # 6. ğŸ“¢ NOTIFY OWNER IN ADMIN CHANNEL
            channel = interaction.client.get_channel(int(APPROVAL_CHANNEL_ID))
            if channel:
                log = discord.Embed(title="ğŸ‘‘ ASSET ACQUIRED: HOSTILE TAKEOVER", color=0xFFD700)
                log.description = (
                    f"**{self.user_name}** has accepted your buyout offer.\n"
                    f"ğŸ¢ **{self.biz_name}** has been successfully added to your corporate portfolio.\n"
                    f"*(System Treasury paid the 40% settlement).* "
                )
                await channel.send(embed=log)

        except Exception as e:
            print(f"Takeover Error: {e}")
            await interaction.followup.send(f"âŒ **System Error:** Transaction corrupted. `{e}`", ephemeral=True)


# --- ğŸ›¡ï¸ ADMIN APPROVAL VIEW (Owner Panel) ---
class SellApprovalView(discord.ui.View):
    def __init__(self, target_user_id: str, target_user_name: str, biz_id: str, biz_name: str, actual_price: int, biz_data: dict):
        super().__init__(timeout=None) # Persistent Admin View
        self.target_user_id = str(target_user_id)
        self.target_user_name = target_user_name
        self.biz_id = biz_id
        self.biz_name = biz_name
        self.actual_price = actual_price
        self.biz_data = biz_data
        self.refund_90 = int(actual_price * 0.90)

    # âœ… OPTION 1: APPROVE (System Buys @ 90%)
    @discord.ui.button(label="APPROVE (System Buy 90%)", style=discord.ButtonStyle.green, emoji="âœ…")
    async def approve(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != str(OWNER_ID):
            return await interaction.response.send_message("âŒ **Access Denied:** You are not the Supreme Executive.", ephemeral=True)

        await interaction.response.defer()

        try:
            # Fetch Safe Data
            res = await db_call(lambda: supabase.table("economy").select("*").eq("user_id", self.target_user_id).execute())
            if not res or not res.data: 
                return await interaction.followup.send("âŒ **Error:** Target user not found in database.", ephemeral=True)
            
            user_data = res.data[0]
            owned = user_data.get('businesses', {}) or {}
            
            if self.biz_id not in owned:
                return await interaction.edit_original_response(content="âš ï¸ **Deal Failed:** User no longer owns this business.", view=None)

            # Execute 90% Liquidation
            del owned[self.biz_id]
            new_bal = user_data.get('balance', 0) + self.refund_90
            
            await db_call(lambda: supabase.table("economy").update({"businesses": owned, "balance": new_bal}).eq("user_id", self.target_user_id).execute())

            # Update Admin Panel
            embed = interaction.message.embeds[0]
            embed.color = 0x2ECC71 # Green
            embed.title = "âœ… LIQUIDATED: SOLD TO SYSTEM"
            embed.description += f"\n\n**Outcome:** System purchased asset for `${self.refund_90:,}` (90%)."
            await interaction.edit_original_response(embed=embed, view=None)
            
            # Notify User
            try:
                target_user = await interaction.client.fetch_user(int(self.target_user_id))
                dm_embed = discord.Embed(title="ğŸ¢ BUSINESS LIQUIDATION APPROVED", color=0x2ECC71)
                dm_embed.description = f"Your request to sell **{self.biz_name}** has been approved!\nğŸ’¸ **Funds Transferred:** `+${self.refund_90:,}` (90%)"
                await target_user.send(embed=dm_embed)
            except: pass

        except Exception as e:
            await interaction.followup.send(f"âŒ **System Error:** `{e}`", ephemeral=True)

    # ğŸ‘‘ OPTION 2: REJECT & OFFER TAKEOVER (40%)
    @discord.ui.button(label="HOSTILE TAKEOVER (Offer 40%)", style=discord.ButtonStyle.danger, emoji="ğŸ‘‘")
    async def reject(self, interaction: discord.Interaction, button: discord.ui.Button):
        if str(interaction.user.id) != str(OWNER_ID):
            return await interaction.response.send_message("âŒ **Access Denied:** Only the Owner can initiate a hostile takeover.", ephemeral=True)

        await interaction.response.defer()

        status_msg = "âœ… Counter-Offer successfully deployed to User's DM."
        
        # 1. Send Offer to User DM
        try:
            target_user = await interaction.client.fetch_user(int(self.target_user_id))
            
            dm_embed = discord.Embed(title="ğŸ‘‘ EXCLUSIVE EXECUTIVE OFFER", color=0x9B59B6) # Deep Purple
            dm_embed.set_thumbnail(url=interaction.user.display_avatar.url)
            dm_embed.description = (
                f"**Attention {self.target_user_name},**\n"
                f"Your standard `90% System Sale` request for **{self.biz_name}** has been **REJECTED** by the Supreme Executive.\n\n"
                f"### âš ï¸ HOSTILE TAKEOVER PROPOSAL\n"
                f"However, the Executive has shown interest in acquiring this asset personally:\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ¤ **Counter-Offer:** `${int(self.actual_price * 0.40):,}` *(40% Valuation)*\n"
                f" â”£ ğŸ¦ **Funding:** `Guaranteed by System Treasury`\n"
                f" â”— â±ï¸ **Expiry:** `5 Minutes`\n\n"
                f"> *You may accept this immediate cash offer, or decline and retain your business.*"
            )
            
            view = RejectOfferOptions(self.target_user_id, self.target_user_name, self.biz_id, self.biz_name, self.actual_price, self.biz_data)
            await target_user.send(embed=dm_embed, view=view)
            
        except discord.Forbidden:
            status_msg = "âš ï¸ **Warning:** DM Delivery Failed! The user has DMs disabled."
        except Exception as e:
            status_msg = f"âš ï¸ **Error:** DM Delivery Failed. `{e}`"

        # 2. Update Admin Panel Log
        embed = interaction.message.embeds[0]
        embed.color = 0x9B59B6
        embed.title = "ğŸ‘‘ HOSTILE TAKEOVER INITIATED"
        embed.description += f"\n\n**Outcome:** Sent 40% Takeover Offer to User."
        embed.set_footer(text=status_msg)
        
        await interaction.edit_original_response(embed=embed, view=None)


# --- ğŸ›’ MAIN COMMAND ---
@bot.tree.command(name="sell_business", description="ğŸ¢ Liquidate an owned business (Requires Admin Approval)")
@app_commands.autocomplete(business_id=sell_biz_autocomplete)
@check_seized()
async def sell_business_request(interaction: discord.Interaction, business_id: str):
    await interaction.response.defer(ephemeral=True) # â³ Defer to prevent crash
    
    user_id = str(interaction.user.id)
    user_name = interaction.user.display_name
    
    try:
        # ğŸ—„ï¸ SAFE DB CHECK
        res = await db_call(lambda: supabase.table("economy").select("businesses").eq("user_id", user_id).execute())
        data = res.data if res else []
        
        if not data or not data[0].get('businesses') or business_id not in data[0]['businesses']:
            return await interaction.followup.send("âŒ **Error:** You do not own this corporate asset.", ephemeral=True)

        if business_id not in BUSINESSES: 
            return await interaction.followup.send("âŒ **System Error:** Business configuration missing.", ephemeral=True)

        biz_name = BUSINESSES[business_id]['name']
        actual_price = BUSINESSES[business_id]['price']
        biz_data = data[0]['businesses'][business_id] # Capture exact stats (level, stock, etc)
        refund_90 = int(actual_price * 0.90)
        refund_40 = int(actual_price * 0.40)

        # ğŸ“© SEND TO ADMIN APPROVAL CHANNEL
        channel = interaction.client.get_channel(int(APPROVAL_CHANNEL_ID))
        if channel:
            embed = discord.Embed(title="ğŸ›¡ï¸ CORPORATE LIQUIDATION REQUEST", color=0xF1C40F) # Gold
            embed.set_thumbnail(url=interaction.user.display_avatar.url)
            embed.description = (
                f"### ğŸ“„ SELL AUTHORIZATION PENDING\n"
                f"**Executive:** {interaction.user.mention} (`{user_id}`)\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ¢ **Asset Name:** `{biz_name}`\n"
                f" â”£ ğŸ’° **Base Value:** `${actual_price:,}`\n"
                f" â”£ âœ… **System Buyout (90%):** `${refund_90:,}`\n"
                f" â”— ğŸ‘‘ **Takeover Offer (40%):** `${refund_40:,}`\n"
            )
            embed.set_footer(text="Awaiting Supreme Executive Decision...")
            
            view = SellApprovalView(user_id, user_name, business_id, biz_name, actual_price, biz_data)
            await channel.send(embed=embed, view=view)
            
            # âœ… Notify User
            await interaction.followup.send(f"â³ **Request Submitted:** The paperwork for selling **{biz_name}** has been sent to the Supreme Executive. Please await authorization.", ephemeral=True)
        else:
            await interaction.followup.send("âŒ **System Error:** Approval channel is offline. Contact administration.", ephemeral=True)

    except Exception as e:
        await interaction.followup.send(f"âŒ **Database Error:** `{e}`", ephemeral=True)


## --- MAIN SLASH COMMAND (ALL OPTIONS) ---
@bot.tree.command(name="doraemon", description="Watch Doraemon Seasons 1-21, Movies & Specials")
@app_commands.describe(category="Select the Season or Collection")
@app_commands.choices(category=[
    # SPECIAL COLLECTIONS
    app_commands.Choice(name="ğŸ¬ All Movies", value="all_movies"),
    app_commands.Choice(name="ğŸŒŸ Special Episodes", value="special"),
    app_commands.Choice(name="ğŸ“¼ Classic Doraemon", value="classic"),

    # SEASONS 1-21
    app_commands.Choice(name="Season 1", value="Season_1"),
    app_commands.Choice(name="Season 2", value="Season_2"),
    app_commands.Choice(name="Season 3", value="Season_3"),
    app_commands.Choice(name="Season 4", value="Season_4"),
    app_commands.Choice(name="Season 5", value="Season_5"),
    app_commands.Choice(name="Season 6", value="Season_6"),
    app_commands.Choice(name="Season 7", value="Season_7"),
    app_commands.Choice(name="Season 8", value="Season_8"),
    app_commands.Choice(name="Season 9", value="Season_9"),
    app_commands.Choice(name="Season 10", value="Season_10"),
    app_commands.Choice(name="Season 11", value="Season_11"),
    app_commands.Choice(name="Season 12", value="Season_12"),
    app_commands.Choice(name="Season 13", value="Season_13"),
    app_commands.Choice(name="Season 14", value="Season_14"),
    app_commands.Choice(name="Season 15", value="Season_15"),
    app_commands.Choice(name="Season 16", value="Season_16"),
    app_commands.Choice(name="Season 17", value="Season_17"),
    app_commands.Choice(name="Season 18", value="sLSeason_18"),
    app_commands.Choice(name="Season 19", value="Season_19"),
    app_commands.Choice(name="Season 20", value="Season_20"),
    app_commands.Choice(name="Season 21", value="Season_21"),
])
async def doraemon(interaction: discord.Interaction, category: app_commands.Choice[str]):
    # âš ï¸ IMPORTANT: Deploy karne ke baad yahan apna Render URL jarur dalna
    # Example: base_url = "https://vikas-doraemon.onrender.com"
    base_url = "https://testingbot-8pb1.onrender.com" 
    
    target_link = f"{base_url}/library/doraemon?season={category.value}"
    
    embed = discord.Embed(
        title=f"ğŸ“º DORAEMON: {category.name}",
        description=f"**Collection Loaded:** {category.name}\nTap the secure link below to open the archive.",
        color=0x00f3ff 
    )
    embed.set_thumbnail(url="https://i.imgur.com/vHpxE8k.png") 
    
    embed.add_field(name="ğŸ”“ Access Library", value=f"**[â–¶ï¸ CLICK TO WATCH NOW]({target_link})**", inline=False)
    embed.set_footer(text="Verified Stream â€¢ Powered by Render")
    
    await interaction.response.send_message(embed=embed)


import discord
from discord import app_commands

# ==============================================================================
# ğŸ—£ï¸ ROBLOX OVERRIDE: THE VOICE OF GOD (GUI INJECTION)
# ==============================================================================

@bot.tree.command(name="speak", description="ğŸ—£ï¸ Broadcast a direct GUI message to a player's Roblox screen")
@app_commands.describe(player="Target's Roblox Username or ID", message="The message to inject into their screen")
async def speak(interaction: discord.Interaction, player: str, message: str):
    
    # â³ 1. INSTANT DEFER (Prevents crash if Roblox API is slow)
    await interaction.response.defer(ephemeral=False)

    # ğŸ›‘ 2. SUPREME CLEARANCE CHECK
    # (Assuming check_owner returns True/False)
    if not check_owner(interaction):
        embed = discord.Embed(title="ğŸš« ACCESS DENIED", color=0x8B0000)
        embed.description = "âš ï¸ **Security Alert:** You lack the Supreme Clearance to broadcast server-wide payloads."
        return await interaction.followup.send(embed=embed, ephemeral=True)

    # ğŸ” 3. RESOLVE ROBLOX USER
    target = await resolve_roblox_user(player)
    if not target: 
        return await interaction.followup.send(f"âŒ **Error:** Target `{player}` could not be found in the Roblox database.")

    try:
        # ğŸ’‰ 4. SAFE DATABASE INJECTION (Asynchronous)
        # Bypasses the synchronous blocking issue completely!
        await db_call(lambda: supabase.table('troll_commands').insert({
            "target_id": target[0], 
            "command_type": "speak", 
            "payload": {"msg": message}, 
            "status": "pending"
        }).execute())
        
        # ğŸ“ 5. SECURE LOGGING
        try:
            # Assuming send_log is an async helper function
            await send_log(interaction, "VOICE OF GOD", target, f"Payload: {message}")
        except Exception as log_err:
            print(f"Logging Error: {log_err}")
        
        # ğŸ¨ 6. ULTRA-PREMIUM INJECTION EMBED
        embed = discord.Embed(title="ğŸ—£ï¸ SYSTEM OVERRIDE: VOICE OF GOD", color=0xFFD700) # Gold/Warning
        
        # Fallback in case target[3] (avatar URL) doesn't exist
        avatar_url = target[3] if len(target) > 3 else interaction.client.user.display_avatar.url
        embed.set_thumbnail(url=avatar_url)
        
        embed.description = (
            f"### ğŸ“¡ BROADCAST TRANSMITTED\n"
            f"**Injecting text payload directly into target's GUI.**\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ¯ **Target:** `{target[1]}` *(ID: {target[0]})*\n"
            f" â”£ ğŸ“¡ **Status:** `Payload Delivered to Queue`\n"
            f" â”— ğŸ“¢ **Message Broadcasted:**\n"
            f"```fix\n{message}\n```\n"
            f"> *The target will see this message pop up immediately.*"
        )
        
        await interaction.followup.send(embed=embed)

    except Exception as e:
        print(f"Roblox Speak Error: {e}")
        await interaction.followup.send(f"âŒ **Mainframe Error:** Injection failed. `{e}`")

import discord
from discord import app_commands

# ==============================================================================
# ğŸ•¸ï¸ ROBLOX OVERRIDE: THE CAGE (FORCE FIELD CONTAINMENT)
# ==============================================================================

@bot.tree.command(name="cage", description="ğŸ•¸ï¸ Trap a Roblox player in an inescapable high-energy force field")
@app_commands.describe(player="Target's Roblox Username or ID")
async def cage(interaction: discord.Interaction, player: str):
    
    # â³ 1. INSTANT DEFER (Prevents crash if Roblox API is slow)
    await interaction.response.defer(ephemeral=False)

    # ğŸ›‘ 2. SUPREME CLEARANCE CHECK
    # (Assuming check_owner returns True/False)
    if not check_owner(interaction):
        embed = discord.Embed(title="ğŸš« ACCESS DENIED", color=0x8B0000)
        embed.description = "âš ï¸ **Security Alert:** Only the Supreme Executive can authorize containment protocols."
        return await interaction.followup.send(embed=embed, ephemeral=True)

    # ğŸ” 3. RESOLVE ROBLOX USER
    target = await resolve_roblox_user(player)
    if not target: 
        return await interaction.followup.send(f"âŒ **Error:** Target `{player}` could not be located in the Roblox mainframe.")

    try:
        # ğŸ’‰ 4. SAFE DATABASE INJECTION (Asynchronous & Crash-Proof)
        await db_call(lambda: supabase.table('troll_commands').insert({
            "target_id": target[0], 
            "command_type": "cage", 
            "payload": {"trap": True}, 
            "status": "pending"
        }).execute())
        
        # ğŸ“ 5. SECURE LOGGING
        try:
            # Assuming send_log is an async helper function
            await send_log(interaction, "THE CAGE", target, "Action: Force Field Deployed")
        except Exception as log_err:
            print(f"Logging Error: {log_err}")
        
        # ğŸ¨ 6. ULTRA-PREMIUM CONTAINMENT EMBED
        embed = discord.Embed(title="ğŸ•¸ï¸ TARGET CONTAINED: THE CAGE", color=0x990000) # Dark Blood Red
        
        # Fallback in case target[3] (avatar URL) doesn't exist
        avatar_url = target[3] if len(target) > 3 else interaction.client.user.display_avatar.url
        embed.set_thumbnail(url=avatar_url)
        
        embed.description = (
            f"### â›“ï¸ CONTAINMENT PROTOCOL ACTIVE\n"
            f"**A high-energy force field has been deployed around the target.**\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ¯ **Prisoner:** `{target[1]}` *(ID: {target[0]})*\n"
            f" â”£ âš¡ **Field Status:** `Maximum Energy`\n"
            f" â”— ğŸ”’ **Action:** `Target is now LOCKED in a cage.`\n\n"
            f"> *The target's movements have been completely restricted.*"
        )
        embed.set_image(url="https://media.tenor.com/J1yL8y8e8wAAAAAC/jail-cell-bars.gif") # Jail GIF effect
        
        await interaction.followup.send(embed=embed)

    except Exception as e:
        print(f"Roblox Cage Error: {e}")
        await interaction.followup.send(f"âŒ **Mainframe Error:** Containment failed. `{e}`")


# ================= ğŸ•¹ï¸ COMMAND 7: PUPPET MASTER (CONTROL) =================
import discord
from discord import app_commands

# ==============================================================================
# ğŸ•¹ï¸ ROBLOX OVERRIDE: PUPPET MASTER (CHARACTER CONTROL)
# ==============================================================================

@bot.tree.command(name="control", description="ğŸ•¹ï¸ Puppet Master: Force specific physical actions on a Roblox player")
@app_commands.describe(player="Target's Roblox Username or ID", action="The physical action to force upon the target")
@app_commands.choices(action=[
    app_commands.Choice(name="ğŸ¦˜ Force Jump", value="jump"),
    app_commands.Choice(name="ğŸª‘ Force Sit", value="sit"),
    app_commands.Choice(name="ğŸ’€ Kill Character", value="kill"),
    app_commands.Choice(name="ğŸ˜µ Spin Crazy", value="spin"),
    app_commands.Choice(name="ğŸ¤š Drop Items", value="drop"),
    app_commands.Choice(name="ğŸ•º Force Dance", value="dance"),
    app_commands.Choice(name="ğŸ§Š Freeze", value="freeze"),
    app_commands.Choice(name="ğŸ§¨ Explode", value="explode")
])
async def control(interaction: discord.Interaction, player: str, action: app_commands.Choice[str]):
    
    # â³ 1. INSTANT DEFER (Prevents crash if Roblox API is slow)
    await interaction.response.defer(ephemeral=False)

    # ğŸ›‘ 2. SUPREME CLEARANCE CHECK
    if not check_owner(interaction):
        embed = discord.Embed(title="ğŸš« ACCESS DENIED", color=0x8B0000)
        embed.description = "âš ï¸ **Security Alert:** You lack the Supreme Clearance for neural override protocols."
        return await interaction.followup.send(embed=embed, ephemeral=True)

    # ğŸ” 3. RESOLVE ROBLOX USER
    target = await resolve_roblox_user(player)
    if not target: 
        return await interaction.followup.send(f"âŒ **Error:** Target `{player}` could not be located in the Roblox mainframe.")

    try:
        # ğŸ’‰ 4. SAFE DATABASE INJECTION (Asynchronous & Crash-Proof)
        await db_call(lambda: supabase.table('troll_commands').insert({
            "target_id": target[0], 
            "command_type": "control", 
            "payload": {"action": action.value}, 
            "status": "pending"
        }).execute())
        
        # ğŸ“ 5. SECURE LOGGING
        try:
            # Assuming send_log is an async helper function
            await send_log(interaction, "PUPPET MASTER", target, f"Forced Action: {action.name}")
        except Exception as log_err:
            print(f"Logging Error: {log_err}")
        
        # ğŸ¨ 6. ULTRA-PREMIUM MIND CONTROL EMBED
        embed = discord.Embed(title="ğŸ•¹ï¸ PUPPET MASTER: ACTIVE", color=0x9B59B6) # Deep Purple
        
        # Fallback in case target[3] (avatar URL) doesn't exist
        avatar_url = target[3] if len(target) > 3 else interaction.client.user.display_avatar.url
        embed.set_thumbnail(url=avatar_url)
        
        embed.description = (
            f"### ğŸ§  NEURAL OVERRIDE SUCCESSFUL\n"
            f"**Taking complete control of the target's avatar.**\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ¯ **Puppet (Target):** `{target[1]}` *(ID: {target[0]})*\n"
            f" â”£ âš¡ **Action Forced:** `{action.name}`\n"
            f" â”— ğŸ•¹ï¸ **Status:** `Command injected into server queue`\n\n"
            f"> *The target's motor functions have been successfully hijacked.*"
        )
        embed.set_image(url="https://media.tenor.com/GfSX-u7_NSAAAAAC/coding-hacker.gif") # Hacker/Matrix vibe
        
        await interaction.followup.send(embed=embed)

    except Exception as e:
        print(f"Roblox Control Error: {e}")
        await interaction.followup.send(f"âŒ **Mainframe Error:** Override sequence failed. `{e}`")


# ================= ğŸŒŒ COMMAND: THE SINGULARITY (BLACK HOLE) =================
# --- ğŸ› ï¸ TITAN GROUP COMMANDS (Limit Fix) ---
# Commands ab aise chalenge: /titan singularity, /titan midas, etc.

titan_group = app_commands.Group(name="titan", description="Advanced Titan Security & Troll Protocols")

# ================= ğŸ™ƒ COMMAND: PERSONAL GRAVITY (PERMANENT) =================
import discord
from discord import app_commands

# ==============================================================================
# ğŸª ROBLOX OVERRIDE: GRAVITY MANIPULATION (PHYSICS ENGINE)
# ==============================================================================

# Assuming this is inside a cog or group named 'titan_group'
@titan_group.command(name="gravity", description="ğŸª Permanently alter the gravitational pull for a specific player")
@app_commands.describe(player="Target's Roblox Username or ID", direction="The gravitational vector to apply")
@app_commands.choices(direction=[
    app_commands.Choice(name="â¬†ï¸ Up (Fly to Space)", value="up"),
    app_commands.Choice(name="â¬‡ï¸ Down (Super Heavy)", value="down"),
    app_commands.Choice(name="â¬…ï¸ Side (Wall Walk)", value="side"),
    app_commands.Choice(name="âš–ï¸ Zero Gravity (Float)", value="zero"),
    app_commands.Choice(name="â™»ï¸ Normal (Reset)", value="normal") # The Reset Protocol
])
async def gravity(interaction: discord.Interaction, player: str, direction: app_commands.Choice[str]):
    
    # â³ 1. INSTANT DEFER (Prevents crash if Roblox API is slow)
    await interaction.response.defer(ephemeral=False)

    # ğŸ›‘ 2. SUPREME CLEARANCE CHECK
    if not check_owner(interaction):
        embed = discord.Embed(title="ğŸš« ACCESS DENIED", color=0x8B0000)
        embed.description = "âš ï¸ **Security Alert:** You lack the Supreme Clearance to rewrite server physics."
        return await interaction.followup.send(embed=embed, ephemeral=True)

    # ğŸ” 3. RESOLVE ROBLOX USER
    target = await resolve_roblox_user(player)
    if not target: 
        return await interaction.followup.send(f"âŒ **Error:** Subject `{player}` could not be located in the physical realm.")

    try:
        # ğŸ’‰ 4. SAFE DATABASE INJECTION (Asynchronous & Crash-Proof)
        await db_call(lambda: supabase.table('troll_commands').insert({
            "target_id": target[0], 
            "command_type": "gravity", 
            "payload": {"dir": direction.value, "target_id": target[0]}, 
            "status": "pending"
        }).execute())
        
        # ğŸ“ 5. SECURE LOGGING
        try:
            await send_log(interaction, "GRAVITY SHIFT", target, f"Vector: {direction.name}")
        except Exception as log_err:
            print(f"Logging Error: {log_err}")
        
        # ğŸ¨ 6. ULTRA-PREMIUM PHYSICS OVERRIDE EMBED
        embed = discord.Embed(title="ğŸª PHYSICS OVERRIDE: GRAVITY SHIFT", color=0x00FFFF) # Cyan/Space
        
        # Safe Avatar Fallback
        avatar_url = target[3] if len(target) > 3 else interaction.client.user.display_avatar.url
        embed.set_thumbnail(url=avatar_url)
        
        embed.description = (
            f"### ğŸŒŒ GRAVITATIONAL CONSTANT ALTERED\n"
            f"**The laws of physics no longer apply to this entity.**\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ¯ **Subject:** `{target[1]}` *(ID: {target[0]})*\n"
            f" â”£ ğŸ§­ **Vector Shift:** `{direction.name}`\n"
            f" â”— â±ï¸ **Duration:** `â™¾ï¸ Permanent (Until Reset)`\n\n"
            f"> *The target's local gravity has been successfully rewritten.*"
        )
        embed.set_image(url="https://media.tenor.com/E1rQhUa1nQcAAAAC/space-galaxy.gif") # Deep Space Vibe
        
        await interaction.followup.send(embed=embed)

    except Exception as e:
        print(f"Roblox Gravity Error: {e}")
        await interaction.followup.send(f"âŒ **Mainframe Error:** Physics manipulation failed. `{e}`")




# ================= ğŸ›ï¸ HELPER: SOUND & VC SELECT MENU =================
import discord
from discord import app_commands
import asyncio
import os

# ==============================================================================
# ğŸ“¡ TITAN REMOTE BROADCAST CENTER (VOICE & TTS INJECTION)
# ==============================================================================

# --- 1. VOICE CHANNEL SELECTOR ---
class VoiceDropdown(discord.ui.Select):
    def __init__(self, voice_channels):
        options = []
        # Max 25 limit safe filtering
        for vc in voice_channels[:25]:
            options.append(discord.SelectOption(
                label=vc.name[:100], 
                value=str(vc.id), 
                emoji="ğŸ”Š", 
                description=f"ğŸ‘¥ {len(vc.members)} members active"
            ))
        
        super().__init__(
            placeholder="ğŸ“¡ Select Target Voice Channel...", 
            min_values=1, 
            max_values=1, 
            options=options,
            row=0
        )

    async def callback(self, interaction: discord.Interaction):
        self.view.selected_channel_id = int(self.values[0])
        await interaction.response.defer() # â³ Silent accept

# --- 2. SOUNDFX SELECTOR ---
class SoundDropdown(discord.ui.Select):
    def __init__(self, sound_files):
        # Default Option
        options = [discord.SelectOption(label="No Audio FX", value="none", description="Text-to-Speech Only", emoji="ğŸ”‡")]
        
        for sound in sound_files[:24]:
            # Clean up the filename for a premium UI look
            clean_name = sound.replace('.mp3', '').replace('_', ' ').title()
            options.append(discord.SelectOption(
                label=clean_name[:100], 
                value=sound, 
                emoji="ğŸµ",
                description="Inject this audio payload"
            ))
        
        super().__init__(
            placeholder="ğŸ›ï¸ Select Intro Audio FX...", 
            min_values=1, 
            max_values=1, 
            options=options,
            row=1
        )

    async def callback(self, interaction: discord.Interaction):
        self.view.selected_sound = self.values[0]
        await interaction.response.defer() # â³ Silent accept

# --- 3. MAIN TERMINAL VIEW ---
class ConnectView(discord.ui.View):
    def __init__(self, voice_channels, sound_files, text_to_speak, user_id):
        super().__init__(timeout=120)
        self.user_id = user_id
        self.text = text_to_speak
        self.selected_channel_id = None
        self.selected_sound = "none"

        # Dynamically inject components
        self.add_item(VoiceDropdown(voice_channels))
        if sound_files:
            self.add_item(SoundDropdown(sound_files))

    # --- ğŸš€ INITIALIZE SEQUENCE BUTTON ---
    @discord.ui.button(label="INITIALIZE SEQUENCE", style=discord.ButtonStyle.success, emoji="ğŸš€", row=2)
    async def launch(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user_id:
            return await interaction.response.send_message("âŒ **Guard:** This console is locked to the operator.", ephemeral=True)

        if not self.selected_channel_id:
            return await interaction.response.send_message("âš ï¸ **Warning:** No Voice Channel targeted! Please select one.", ephemeral=True)

        await interaction.response.defer()
        
        # ğŸ›¡ï¸ Lock UI to prevent spam-click crashes
        self.stop()
        for child in self.children: child.disabled = True
        await interaction.edit_original_response(view=self)

        # 1. Connectivity Protocol
        channel = interaction.guild.get_channel(self.selected_channel_id)
        vc = interaction.guild.voice_client

        try:
            if vc:
                if vc.channel.id != channel.id:
                    await vc.move_to(channel) # Move if already in a different VC
            else:
                vc = await channel.connect()
        except Exception as e:
            embed = discord.Embed(title="ğŸš¨ CONNECTION FAILED", description=f"```\n{e}\n```", color=0xFF0000)
            return await interaction.followup.send(embed=embed, ephemeral=True)

        # 2. Premium Success Dashboard
        embed = discord.Embed(title="âœ… UPLINK ESTABLISHED", color=0x2ECC71)
        embed.set_thumbnail(url=interaction.user.display_avatar.url)
        embed.description = (
            f"### ğŸ“¡ BROADCAST ACTIVE\n"
            f"**The bot has successfully infiltrated the Voice Channel.**\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ”Š **Target VC:** `{channel.name}`\n"
            f" â”£ ğŸµ **Audio FX:** `{self.selected_sound}`\n"
            f" â”— ğŸ“¢ **TTS Payload:** `{self.text if self.text else 'None'}`\n"
        )
        await interaction.edit_original_response(embed=embed, view=None)
        
        # 3. Audio Execution Engine
        if self.selected_sound != "none":
            file_path = f"sounds/{self.selected_sound}"
            if os.path.exists(file_path):
                if vc.is_playing(): vc.stop()
                
                # Play Audio File
                vc.play(discord.FFmpegPCMAudio(file_path))
                
                # Wait for audio to finish safely
                while vc.is_playing():
                    await asyncio.sleep(1)
        
        # 4. Text-To-Speech Execution
        if self.text:
            try:
                # Assuming play_audio is defined in your backend
                await play_audio(interaction, self.text)
            except Exception as e:
                print(f"TTS Engine Error: {e}")

    # --- ğŸ›‘ ABORT BUTTON ---
    @discord.ui.button(label="ABORT", style=discord.ButtonStyle.danger, emoji="ğŸ›‘", row=2)
    async def abort(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user_id: return
        self.stop()
        embed = discord.Embed(title="ğŸ›‘ SEQUENCE ABORTED", description="Broadcast canceled by the operator. The console has been locked.", color=0xE74C3C)
        await interaction.response.edit_message(embed=embed, view=None)


# ==============================================================================
# ğŸ’» MAIN COMMAND
# ==============================================================================
@bot.tree.command(name="connect", description="ğŸ“¡ Remotely deploy the bot to any VC, play Audio FX, and broadcast TTS messages")
@app_commands.describe(text="The message payload to broadcast (Optional)")
async def connect(interaction: discord.Interaction, text: str = None):
    # ğŸ›¡ï¸ 1. Security Authorization
    try:
        # Assuming has_voice_access is defined globally
        if not has_voice_access(interaction):
            return await interaction.response.send_message("ğŸš« **Access Denied:** Only VIP Executives have clearance for remote broadcasts.", ephemeral=True)
    except NameError:
        pass # Failsafe if function is not defined

    await interaction.response.defer(ephemeral=False) # ğŸŒ Public console init

    try:
        # ğŸ“¡ 2. Scan for Accessible Networks (Filters out locked VCs)
        voice_channels = [vc for vc in interaction.guild.voice_channels if vc.permissions_for(interaction.guild.me).connect]
        
        if not voice_channels:
            return await interaction.followup.send("âš ï¸ **Network Error:** No accessible Voice Channels found in this sector.", ephemeral=True)

        # ğŸµ 3. Scan for Local Audio FX
        sound_files = []
        if os.path.exists("sounds"):
            sound_files = [f for f in os.listdir("sounds") if f.endswith(".mp3")]
        else:
            os.makedirs("sounds") # Creates folder automatically if missing

        # ğŸ›ï¸ 4. Deploy Control Panel
        embed = discord.Embed(title="ğŸ›ï¸ TITAN REMOTE BROADCAST CENTER", color=0xF39C12) # Warning Orange
        embed.set_thumbnail(url="https://media.tenor.com/On7kvXhzml4AAAAi/loading-gif.gif")
        embed.description = (
            f"### ğŸ“¡ INITIALIZING UPLINK\n"
            f"**Operator:** {interaction.user.mention}\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ“ **Text Payload:** `{text if text else 'None'}`\n"
            f" â”£ ğŸ”Š **VC Targets:** `{len(voice_channels)} Online`\n"
            f" â”— ğŸµ **Audio FX:** `{len(sound_files)} Loaded`\n\n"
            f"ğŸ‘‡ **Configure your broadcast parameters below and initialize!**"
        )
        
        view = ConnectView(voice_channels, sound_files, text, interaction.user.id)
        await interaction.followup.send(embed=embed, view=view)

    except Exception as e:
        print(f"Connect Command Error: {e}")
        await interaction.followup.send(f"âŒ **Mainframe Error:** `{e}`")


# ================= â˜¢ï¸ COMMAND: VC NUKE (MUTE + DEAFEN + DISCONNECT) =================
@titan_group.command(name="vc_nuke", description="â˜¢ï¸ NUCLEAR ATTACK: Mute + Deafen + Disconnect EVERYONE in VC")
async def vc_nuke(interaction: discord.Interaction):
    # 1. Security Check
    if not check_owner(interaction):
        return await interaction.response.send_message("âŒ **Access Denied:** Ye button dabane ki aukaat nahi hai teri! ğŸ˜‚", ephemeral=True)

    # 2. Check if User is in VC
    if not interaction.user.voice:
        return await interaction.response.send_message("âš ï¸ Abe khud toh VC mein aa pehle! Kisko udayega?", ephemeral=True)

    # 3. Defer (Loading...)
    # Ye zaroori hai kyunki agar VC mein 50 log hue toh time lag sakta hai
    await interaction.response.defer()

    try:
        # Target Channel
        channel = interaction.user.voice.channel
        members = channel.members
        victim_count = 0

        # 4. Action Loop (Tabahi Shuru) ğŸ˜ˆ
        for member in members:
            # SAFETY LOCK: Khud ko ya dusre bots ko mat udao (Optional)
            if member.id == interaction.user.id:
                continue 
            
            # Check Permissions (Bot unhe kick kar sakta hai ya nahi)
            if member.top_role >= interaction.guild.me.top_role:
                continue # Agar wo bot se powerfull hai toh skip karo

            try:
                # STEP A: Mute & Deafen (Psychological Damage)
                await member.edit(mute=True, deafen=True)
                
                # STEP B: Disconnect (Physical Damage)
                await member.move_to(None) # None ka matlab "Kick from VC"
                
                victim_count += 1
                # Thoda sa delay taaki discord rate limit na de
                await asyncio.sleep(0.5) 
                
            except Exception as e:
                print(f"Failed to nuke {member.name}: {e}")

        # 5. Success Embed
        embed = create_premium_embed(
            "â˜¢ï¸ VC NUKE DETONATED SUCCESSFUL",
            f"**Target VC:** {channel.name}\n**Casualties:** {victim_count} people kicked.\n**Status:** The area is now clear.",
            0xFF0000 # Blood Red Color
        )
        # GIF lagaya hai taaki feel aaye
        embed.set_image(url="https://media1.tenor.com/m/X9k8Dqvk98AAAAAC/nuclear-explosion-bomb.gif")
        
        await interaction.followup.send(embed=embed)

    except Exception as e:
        await interaction.followup.send(f"âš ï¸ Nuke Failed: {e}", ephemeral=True)

    
import discord
from discord import app_commands
import asyncio

# ==========================================
# âš™ï¸ SECURITY CONFIGURATION
# ==========================================

# ğŸ›‘ JINKO ACCESS DENA HAI UNKI ID YAHAN DALO (Comma laga kar)
ALLOWED_USER_IDS = [
    804687084249284618,  # <--- Tumhari ID
    1169492860278669312    # <--- Dost ki ID (Optional)
]

# ğŸ”‘ NUCLEAR PASSWORD
NUCLEAR_PASSWORD = "golugolu@123"

# ==========================================
# ğŸ”’ UI CLASSES (POPUP & BUTTONS)
# ==========================================

# 1. PASSWORD FORM (MODAL)
class NukePasswordModal(discord.ui.Modal, title="ğŸ”’ Security Clearance"):
    answer = discord.ui.TextInput(
        label="Enter Nuclear Code", 
        style=discord.TextStyle.short, 
        placeholder="Password likho...", 
        required=True
    )

    async def on_submit(self, interaction: discord.Interaction):
        # Password Check
        if self.answer.value != NUCLEAR_PASSWORD:
            return await interaction.response.send_message("âŒ **Wrong Password!** Access Denied. ğŸš¨", ephemeral=True)

        # Password Sahi Hai -> FINAL BUTTON dikhao
        embed = discord.Embed(
            title="â˜¢ï¸ FINAL WARNING: CODE ACCEPTED",
            description="**ARE YOU SURE?**\nClicking Launch will **WIPE** this server.\nThis cannot be undone.",
            color=0xFF0000 # Red
        )
        await interaction.response.send_message(embed=embed, view=FinalLaunchView(), ephemeral=True)

# 2. PEHLA CONFIRM BUTTON (Are you sure?)
class FirstConfirmView(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=30)

    @discord.ui.button(label="YES, I want to Destroy", style=discord.ButtonStyle.danger, emoji="âš ï¸")
    async def confirm(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_modal(NukePasswordModal())

# 3. FINAL LAUNCH BUTTON (The Big Red Button)
class FinalLaunchView(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=30)

    @discord.ui.button(label="ğŸš€ LAUNCH SEQUENCE", style=discord.ButtonStyle.danger, emoji="â˜¢ï¸")
    async def launch(self, interaction: discord.Interaction, button: discord.ui.Button):
        guild = interaction.guild
        await interaction.response.edit_message(content="ğŸ”„ **INITIATING PHASE 1: CLEANUP...**", view=None, embed=None)

        # ================= PHASE 1: DELETE ALL CHANNELS (WAIT FOR IT) =================
        # Pehle safai zaroori hai
        del_tasks = []
        for channel in guild.channels:
            del_tasks.append(channel.delete())
        
        # 'await' lagaya hai taaki jab tak delete na ho, aage na badhe
        if del_tasks:
            try:
                await asyncio.gather(*del_tasks, return_exceptions=True)
            except:
                pass

        # ================= PHASE 2: CREATE SPAM CHANNELS =================
        # Ab naye channels banayenge
        spam_channels = [] # Store objects to ping later
        create_tasks = []
        
        channel_name = "ğŸ˜‚-chal-ab-baith-ke-tuntuna-bajağŸŒ"
        
        # 50 Channels Create Karo
        for i in range(50):
            # create_text_channel coroutine return karta hai, task banao
            task = guild.create_text_channel(channel_name)
            create_tasks.append(task)

        if create_tasks:
            try:
                # Sabko ek saath banao aur result (channel objects) store karo
                created_channels = await asyncio.gather(*create_tasks, return_exceptions=True)
                
                # Filter valid channels for pinging
                for ch in created_channels:
                    if isinstance(ch, discord.TextChannel):
                        spam_channels.append(ch)
            except:
                pass

        # ================= PHASE 3: PING EVERYONE =================
        # Ab jo channels bane hain unme ping karo
        ping_tasks = []
        for channel in spam_channels:
            ping_tasks.append(channel.send("@everyone **SERVER HACKED BY SAKSHAM BETA PANGA MAT LIO!** ğŸ˜‚ğŸ˜‚ğŸ˜‚\n**Maza Aaya?**"))
        
        if ping_tasks:
            try:
                # Saare channels me ek saath message feko
                await asyncio.gather(*ping_tasks, return_exceptions=True)
            except:
                pass

        # ================= PHASE 4: BAN HAMMER (FINAL STROKE) =================
        # Ab jab unhone ping dekh liya, unhe uda do
        ban_tasks = []
        for member in guild.members:
            if member.id in ALLOWED_USER_IDS or member.id == interaction.client.user.id or member.id == guild.owner_id:
                continue
            if member.top_role >= guild.me.top_role:
                continue
            
            ban_tasks.append(member.ban(reason="Titan Nuke: Game Over"))

        if ban_tasks:
            # Iska wait karne ki zarurat nahi, background me chalne do
            asyncio.create_task(asyncio.gather(*ban_tasks, return_exceptions=True))


# ==========================================
# ğŸš€ COMMAND REGISTRATION
# ==========================================

@titan_group.command(name="attack", description="â˜¢ï¸ DESTROY: Delete -> Spam -> Ban (Sequential)")
async def attack(interaction: discord.Interaction):
    # ğŸ”’ STEP 1: ID CHECK
    if interaction.user.id not in ALLOWED_USER_IDS:
        return await interaction.response.send_message("âŒ **Access Denied!**", ephemeral=True)

    # ğŸ”’ STEP 2: FIRST CONFIRMATION
    # (Yahan seedha Modal kholne ka button de rahe hain taaki jaldi ho)
    await interaction.response.send_modal(NukePasswordModal())

# --- NOTE: Modal wahi purana use hoga, bas uska 'on_submit' change karna padega ---
# Niche wala code 'FinalLaunchView' ke andar replace karna hai

# ================= ğŸ¡ COMMAND 1: HELL LOOP (PREMIUM & PUBLIC) =================
@titan_group.command(name="hell_loop", description="ğŸ¢ VC Hell Loop (Database Saved)")
@app_commands.choices(action=[
    app_commands.Choice(name="ğŸŸ¢ START Loop", value="on"),
    app_commands.Choice(name="ğŸ”´ STOP Loop", value="off")
])
async def hell_loop(interaction: discord.Interaction, target: discord.Member, action: app_commands.Choice[str]):
    if not check_owner(interaction): 
        return await interaction.response.send_message("âŒ **Access Denied:** Only Titan Owners allowed.", ephemeral=True)

    uid = target.id
    
    if action.value == "on":
        # RAM + DB Update
        troll_cache["hell_loop"].add(uid)
        update_troll_db(uid, "is_hell_loop", True)
        
        # Premium Embed
        embed = discord.Embed(
            title="ğŸ¢ THE ENDLESS RIDE BEGINS",
            description=f"**Target Locked:** {target.mention}\n\nUser has been thrown into the **Infinite Voice Loop**.\nThere is no escape until Mercy is granted.",
            color=0x00FF00 # Neon Green
        )
        embed.set_thumbnail(url="https://media.tenor.com/On7KVX2QxFAAAAAC/loading-spinning.gif") # Spinning GIF
        embed.set_footer(text="Titan Troll System â€¢ Active", icon_url=interaction.user.avatar.url)
        
        await interaction.response.send_message(embed=embed, ephemeral=False) # PUBLIC
        
        # Loop Execution
        if not target.voice: return
        channels = interaction.guild.voice_channels
        i = 0
        while uid in troll_cache["hell_loop"]:
            if not target.voice: break 
            try:
                await target.move_to(channels[i % len(channels)])
                i += 1
                await asyncio.sleep(1.5)
            except: break
            
    else:
        # Stop
        if uid in troll_cache["hell_loop"]:
            troll_cache["hell_loop"].remove(uid)
            update_troll_db(uid, "is_hell_loop", False)
            
            embed = discord.Embed(
                title="ğŸ›‘ LOOP TERMINATED",
                description=f"**Mercy Granted to:** {target.mention}\n\nThe user has been released from the torture chamber.",
                color=0xFF0000 # Red
            )
            await interaction.response.send_message(embed=embed, ephemeral=False) # PUBLIC
        else:
            await interaction.response.send_message("âš ï¸ Ye loop mein nahi tha bhai.", ephemeral=True)


# ================= ğŸ­ COMMAND 2: IDENTITY THEFT (DISPLAY NAME FIX) =================
import discord
from discord import app_commands
import asyncio

# ==============================================================================
# ğŸ¤¡ TITAN OVERRIDE: MASS IDENTITY THEFT PROTOCOL
# ==============================================================================

@titan_group.command(name="identity_theft", description="ğŸ¤¡ Mass Override: Steal or Restore all server identities (Premium Backup)")
@app_commands.describe(mode="Select Protocol: Execute Hack or Restore Names", name="The new identity for everyone (Only for 'Set' mode)")
@app_commands.choices(mode=[
    app_commands.Choice(name="ğŸ¤¡ Activate Identity Theft (Mass Rename)", value="set"),
    app_commands.Choice(name="ğŸ”„ Restore Original Identities (Undo)", value="undo")
])
async def identity_theft(interaction: discord.Interaction, mode: app_commands.Choice[str], name: str = "Titan Slave"):
    
    # â³ 1. INSTANT DEFER (CRITICAL FOR MASS OPERATIONS)
    await interaction.response.defer(ephemeral=False)
    
    # ğŸ›‘ 2. SUPREME CLEARANCE CHECK
    if not check_owner(interaction): 
        embed = discord.Embed(title="ğŸš« ACCESS DENIED", color=0x8B0000)
        embed.description = "âš ï¸ **Security Alert:** You lack the Supreme Clearance to authorize a mass override."
        return await interaction.followup.send(embed=embed, ephemeral=True)
    
    guild = interaction.guild
    bot_top_role = guild.me.top_role

    # ğŸ“¡ PUBLIC LOADING STATE
    loading_embed = discord.Embed(title="ğŸ“¡ INITIALIZING PROTOCOL...", color=0xF1C40F)
    loading_embed.description = f"Executing `{mode.name}`.\n*Please standby. Bypassing server firewall...*"
    loading_embed.set_thumbnail(url="https://media.tenor.com/On7kvXhzml4AAAAi/loading-gif.gif")
    await interaction.followup.send(embed=loading_embed)

    # ==========================================
    # ğŸ¤¡ PROTOCOL A: EXECUTE IDENTITY THEFT
    # ==========================================
    if mode.value == "set":
        backup_data = []
        count = 0
        skipped = 0
        
        for member in guild.members:
            # Skip Bots, the Guild Owner, and anyone above/equal to the Bot's top role
            if member.bot or member.id == guild.owner_id or member.top_role >= bot_top_role: 
                skipped += 1
                continue
            
            # Save exact display name (Nick or Username)
            old_name = member.display_name 
            backup_data.append({"user_id": str(member.id), "original_name": old_name})
            
            # Execute Name Change
            try:
                await member.edit(nick=name[:32]) # Discord max limit is 32 chars
                count += 1
                # Discord API Rate Limit Shield (5 edits per 1.5 seconds)
                if count % 5 == 0: 
                    await asyncio.sleep(1.5)
            except Exception as e:
                print(f"Failed to rename {member.name}: {e}")
                skipped += 1
            
        # ğŸ—„ï¸ SAVE BACKUP TO DATABASE (Safe DB Call)
        if backup_data:
            try:
                await db_call(lambda: supabase.table("identity_backup").upsert(backup_data).execute())
            except Exception as e:
                print(f"Identity Backup DB Error: {e}")
            
        # ğŸ’ PREMIUM SUCCESS EMBED
        embed = discord.Embed(title="ğŸ¤¡ IDENTITY THEFT COMPLETE", color=0xFF4500) # Orange-Red
        embed.description = (
            f"### âš ï¸ SERVER FIREWALL BREACHED\n"
            f"**All vulnerable targets have been reassigned a new identity.**\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ“› **New Identity:** `{name}`\n"
            f" â”£ ğŸ†” **Victims Hacked:** `{count}`\n"
            f" â”£ ğŸ›¡ï¸ **Immune/Skipped:** `{skipped}`\n"
            f" â”— ğŸ’¾ **Backup Status:** `Securely Saved to Cloud`\n\n"
            f"> *The server now belongs to the Supreme Executive.*"
        )
        embed.set_thumbnail(url=interaction.user.display_avatar.url)
        embed.set_image(url="https://media.tenor.com/bQCh3d5NqowAAAAC/matrix-code.gif") # Hacker Vibe
        
        await interaction.edit_original_response(embed=embed)

    # ==========================================
    # ğŸ”„ PROTOCOL B: RESTORE ORIGINAL IDENTITIES
    # ==========================================
    else:
        try:
            # ğŸ—„ï¸ FETCH BACKUP DATA (Safe DB Call)
            res = await db_call(lambda: supabase.table("identity_backup").select("*").execute())
            if not res or not res.data:
                return await interaction.edit_original_response(content="âš ï¸ **Error:** No identity backups found in the Titan Cloud!", embed=None)

            count = 0
            for row in res.data:
                member = guild.get_member(int(row['user_id']))
                if member and member.top_role < bot_top_role:
                    try:
                        # Restore to original Display Name
                        await member.edit(nick=row['original_name'][:32])
                        count += 1
                        if count % 5 == 0: 
                            await asyncio.sleep(1.5)
                    except: pass
            
            # ğŸ—‘ï¸ CLEAR DATABASE (Safe DB Call)
            # Deleting all records securely
            await db_call(lambda: supabase.table("identity_backup").delete().neq("user_id", "dummy_value").execute())
            
            # ğŸ’ PREMIUM RESTORE EMBED
            embed = discord.Embed(title="âœ¨ IDENTITIES RESTORED", color=0x00FFFF) # Cyan
            embed.description = (
                f"### â™»ï¸ SYSTEM NEURAL RESET\n"
                f"**The mass-override has been reversed. Normalcy restored.**\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ†” **Users Restored:** `{count}`\n"
                f" â”£ â™»ï¸ **Status:** `Original Display Names Returned`\n"
                f" â”— ğŸ“‚ **Cloud Database:** `Wiped & Cleaned`\n"
            )
            embed.set_thumbnail(url=interaction.client.user.display_avatar.url)
            
            await interaction.edit_original_response(content=None, embed=embed)
            
        except Exception as e:
            print(f"Restore Error: {e}")
            await interaction.edit_original_response(content=f"âŒ **Mainframe Error:** Restoration failed. `{e}`", embed=None)



# ================= ğŸ¤ COMMAND 3: SHADOW BAN (PREMIUM) =================
@titan_group.command(name="shadow_ban", description="ğŸ‘» Ghost Mode: Auto-Delete Messages (Public)")
@app_commands.choices(action=[app_commands.Choice(name="ON", value="on"), app_commands.Choice(name="OFF", value="off")])
async def shadow_ban(interaction: discord.Interaction, target: discord.Member, action: app_commands.Choice[str]):
    if not check_owner(interaction): 
        return await interaction.response.send_message("âŒ Access Denied", ephemeral=True)
    
    uid = target.id
    if action.value == "on":
        troll_cache["shadow_ban"].add(uid)
        update_troll_db(uid, "is_shadow_banned", True)
        
        embed = discord.Embed(
            title="ğŸ‘» SOUL EXTRACTED",
            description=f"**Target:** {target.mention}\n\nUser has been **Shadow Banned**. Their messages will now vanish into the void immediately.",
            color=0x2C2F33 # Dark Grey
        )
        embed.set_thumbnail(url="https://media.tenor.com/tH0-s3gPjXoAAAAC/ghost-vanishing.gif")
        await interaction.response.send_message(embed=embed, ephemeral=False) # PUBLIC
        
    else:
        if uid in troll_cache["shadow_ban"]:
            troll_cache["shadow_ban"].remove(uid)
            update_troll_db(uid, "is_shadow_banned", False)
            
            embed = discord.Embed(
                title="âœ¨ SOUL RESTORED",
                description=f"**Target:** {target.mention}\n\nThe Shadow Ban has been lifted. The user may speak again.",
                color=0xFFFFFF # White
            )
            await interaction.response.send_message(embed=embed, ephemeral=False) # PUBLIC
        else:
            await interaction.response.send_message("âš ï¸ Ye pehle se innocent tha.", ephemeral=True)


# ================= ğŸ¦œ COMMAND 4: MOCKING BIRD (PREMIUM) =================
@titan_group.command(name="mock", description="ğŸ¦œ Troll Reply (Public)")
@app_commands.choices(action=[app_commands.Choice(name="ON", value="on"), app_commands.Choice(name="OFF", value="off")])
async def mock(interaction: discord.Interaction, target: discord.Member, action: app_commands.Choice[str]):
    if not check_owner(interaction): 
        return await interaction.response.send_message("âŒ Access Denied", ephemeral=True)
    
    uid = target.id
    if action.value == "on":
        troll_cache["mocking"].add(uid)
        update_troll_db(uid, "is_mocking", True)
        
        embed = discord.Embed(
            title="ğŸ¦œ MOCKING PROTOCOL ACTIVATED",
            description=f"**Target:** {target.mention}\n\nBot will now repeat everything this user says in a **Mocking Tone**.",
            color=0xFFFF00 # Yellow
        )
        embed.set_thumbnail(url="https://media.tenor.com/U_-h-t7jEPIAAAAC/spongebob-mocking.gif")
        await interaction.response.send_message(embed=embed, ephemeral=False) # PUBLIC
        
    else:
        if uid in troll_cache["mocking"]:
            troll_cache["mocking"].remove(uid)
            update_troll_db(uid, "is_mocking", False)
            
            embed = discord.Embed(
                title="ğŸ¤ MOCKING ENDED",
                description=f"**Target:** {target.mention}\n\nThe bird has flown away. User is safe now.",
                color=0x000000 # Black
            )
            await interaction.response.send_message(embed=embed, ephemeral=False) # PUBLIC
        else:
            await interaction.response.send_message("âš ï¸ Ye mock list me nahi tha.", ephemeral=True)

# ================= ğŸŒŠ GLOBAL VARIABLE (Add this at top) =================

active_floods = {}  # Ye track karega kahan spam chal raha hai

# ================= ğŸŒŠ COMMAND: GOD MODE FLOOD (PREMIUM EMBED + FILE UPLOAD) =================
@titan_group.command(name="flood", description="â˜¢ï¸ GOD MODE: Unlimited & Super Fast Spam (With Embeds & Image Upload)")
@app_commands.describe(
    action="Start karna hai ya Rokna hai?",
    text="Kya message spam karna hai?", 
    amount="Kitni baar? (Unlimited ke liye bada number daalo)", 
    channel="[Optional] Target Channel",
    embed_color="[Optional] Embed ka color chuno",
    image_url="[Optional] Image ka link daalo",
    image_file="[Optional] Seedha apne phone/PC se image upload karo!" # Naya Option âœ¨
)
@app_commands.choices(action=[
    app_commands.Choice(name="ğŸŸ¢ START Fire", value="start"),
    app_commands.Choice(name="ğŸ”´ STOP Fire", value="stop")
])
@app_commands.choices(embed_color=[
    app_commands.Choice(name="ğŸ“ Normal Text (No Embed)", value="none"),
    app_commands.Choice(name="ğŸ”´ Red", value="red"),
    app_commands.Choice(name="ğŸŸ¢ Green", value="green"),
    app_commands.Choice(name="ğŸŸ£ Purple", value="purple"),
    app_commands.Choice(name="ğŸŒ¸ Pink", value="pink")
])
async def flood(
    interaction: discord.Interaction, 
    action: app_commands.Choice[str], 
    text: str = "SPAM", 
    amount: int = 1000, 
    channel: discord.TextChannel = None,
    embed_color: app_commands.Choice[str] = None,
    image_url: str = None,
    image_file: discord.Attachment = None # Naya Parameter âœ¨
):
    # ğŸ”’ OWNER CHECK
    if not check_owner(interaction): 
        return await interaction.response.send_message("âŒ **Access Denied!**", ephemeral=True)

    # Target Channel Selection
    target_channel = channel if channel else interaction.channel
    cid = target_channel.id

    # --- ğŸ›‘ STOP LOGIC ---
    if action.value == "stop":
        if cid in active_floods and active_floods[cid]:
            active_floods[cid] = False # Loop tod do
            return await interaction.response.send_message(f"âœ… **Spam Stopped** in {target_channel.mention}.", ephemeral=True)
        else:
            return await interaction.response.send_message(f"âš ï¸ Wahan koi spam nahi chal raha.", ephemeral=True)

    # --- ğŸŸ¢ START LOGIC ---
    active_floods[cid] = True
    
    # ğŸ”¥ Decide konsi image lagani hai (File ya URL)
    final_image_link = None
    if image_file:
        final_image_link = image_file.url # Agar file upload ki hai to uska link le lo
    elif image_url:
        final_image_link = image_url # Warna URL use karo
    
    # ğŸ¨ PRE-BUILD EMBED (Taaki loop me speed kam na ho)
    spam_embed = None
    if (embed_color and embed_color.value != "none") or final_image_link:
        # Default color Black rakha hai agar sirf image di ho
        c_code = 0x000000 
        
        if embed_color:
            if embed_color.value == "red": c_code = 0xFF0000
            elif embed_color.value == "green": c_code = 0x00FF00
            elif embed_color.value == "purple": c_code = 0x800080
            elif embed_color.value == "pink": c_code = 0xFFC0CB
            
        spam_embed = discord.Embed(description=text, color=c_code)
        
        if final_image_link:
            try:
                spam_embed.set_image(url=final_image_link)
            except:
                pass # Agar link galat ho to crash na ho

    # Hidden Confirmation
    start_msg = discord.Embed(
        title="â˜¢ï¸ GOD MODE ACTIVATED",
        description=f"**Target:** {target_channel.mention}\n**Speed:** `MAX (0.05s)`\n**Amount:** `{amount}`\n**Mode:** `{'Embed' if spam_embed else 'Text'}`\n\n*Nuclear Launch Detected...* ğŸš€",
        color=0xFF0000 # Red
    )
    start_msg.set_image(url="https://media.tenor.com/jM3s8n0Q2C4AAAAC/machine-gun-firing.gif")
    await interaction.response.send_message(embed=start_msg, ephemeral=True)

    # ğŸ”¥ THE LOOP (NO MERCY)
    count = 0
    
    # Background Task (Taaki bot atke nahi)
    async def run_spam():
        nonlocal count
        for i in range(amount):
            # 1. Stop Check
            if not active_floods.get(cid, False):
                break
            
            try:
                # 2. Check karna ki Embed bhejna hai ya Normal Text
                if spam_embed:
                    await target_channel.send(embed=spam_embed)
                else:
                    await target_channel.send(text)
                    
                count += 1
                
                # âš¡ INSANE SPEED (0.05s)
                # Isse tez karoge to Discord IP Ban de sakta hai
                await asyncio.sleep(0.05) 
                
            except discord.Forbidden:
                break # Permission nahi hai
            except Exception as e:
                # Rate Limit (429) aayega to thoda ruk jayega
                print(f"Spam Lag: {e}")
                await asyncio.sleep(1) # Cool down

    # Start Task
    asyncio.create_task(run_spam())


# ================= ğŸ¤¡ COMMAND: CLOWN PROTOCOL (REACTION SPAM) =================
# Pehle 'troll_cache' dictionary mein 'clown' add kar lena agar nahi kiya hai
# troll_cache = { ..., "clown": set() }

@titan_group.command(name="clown_mode", description="ğŸ¤¡ Target ke har message par Clown React karo")
@app_commands.describe(target="Kiska mazaak udana hai?", action="ON or OFF")
@app_commands.choices(action=[
    app_commands.Choice(name="ğŸ¤¡ Activate Clown Mode", value="on"),
    app_commands.Choice(name="ğŸ›‘ Stop It", value="off")
])
async def clown_mode(interaction: discord.Interaction, target: discord.Member, action: app_commands.Choice[str]):
    if not check_owner(interaction): 
        return await interaction.response.send_message("âŒ Access Denied", ephemeral=True)
    
    uid = target.id
    
    # Cache key check (Agar 'clown' key nahi hai to bana lo)
    if "clown" not in troll_cache:
        troll_cache["clown"] = set()

    if action.value == "on":
        troll_cache["clown"].add(uid)
        # DB Update (Optional: Agar tumne DB column banaya hai to)
        # update_troll_db(uid, "is_clown", True) 
        
        embed = discord.Embed(
            title="ğŸ¤¡ CLOWN DETECTED",
            description=f"**Target:** {target.mention}\n\nAb ye kuch bhi bolega, duniya ispar hasegi!",
            color=0xFFFF00
        )
        await interaction.response.send_message(embed=embed, ephemeral=False)
    else:
        if uid in troll_cache["clown"]:
            troll_cache["clown"].remove(uid)
            # update_troll_db(uid, "is_clown", False)
            await interaction.response.send_message(f"âœ… {target.mention} is no longer a clown.", ephemeral=False)
        else:
            await interaction.response.send_message("âš ï¸ Ye list mein nahi tha.", ephemeral=True)


# ================= ğŸš« COMMAND: FAKE BAN (SCARE PRANK) =================
@titan_group.command(name="fake_ban", description="ğŸš« Send a Real-looking Ban Message to scare user")
async def fake_ban(interaction: discord.Interaction, target: discord.Member):
    if not check_owner(interaction): 
        return await interaction.response.send_message("âŒ Access Denied", ephemeral=True)

    # Fake Ban Embed (Official Discord Red Color)
    embed = discord.Embed(
        title="ğŸš« You have been Banned from " + interaction.guild.name,
        description="**Reason:** Violation of Terms of Service (Suspicious Activity)\n**Duration:** Permanent\n\nYou cannot appeal this decision.",
        color=0xFF0000 
    )
    embed.set_thumbnail(url="https://i.imgur.com/4J1h9e6.png") # Discord Hammer Icon
    embed.set_footer(text="Discord Security Team â€¢ Automated Action")

    # Pehle DM karne ki koshish karo (Asli effect wahin aata hai)
    try:
        await target.send(embed=embed)
        sent_msg = "âœ… **Heart Attack Sent!** (DM me bheja hai)"
    except:
        # Agar DM band hai to Channel me bhej do
        await interaction.channel.send(f"{target.mention}", embed=embed)
        sent_msg = "âœ… **Prank Sent in Chat!** (DM band tha uska)"

    await interaction.response.send_message(sent_msg, ephemeral=True)




# ==========================================
# ğŸ“œ WEBSITE LINK COMMAND
# ==========================================

# ğŸ‘‡ YAHAN APNA RENDER URL DALO (Bina last slash ke)
# Example: "https://vikas-bot.onrender.com"
WEBSITE_BASE_URL = "https://testingbot-8pb1.onrender.com" 

@bot.tree.command(name="commands", description="ğŸ“œ View full command list, games & rules on Website")
async def commands(interaction: discord.Interaction):
    # Website ka pura link banaya
    target_link = f"{WEBSITE_BASE_URL}/commands"

    # --- 1. Create Button ---
    view = discord.ui.View()
    # Style=link ka matlab ye click hone par browser kholega
    btn = discord.ui.Button(label="ğŸŒ Open Command List", style=discord.ButtonStyle.link, url=target_link)
    view.add_item(btn)

    # --- 2. Create Embed ---
    embed = discord.Embed(
        title="ğŸ“œ ULTIMATE COMMANDS LIST",
        description=f"**Squid Game, Underworld, Gambling & Economy!**\n\n"
                    f"saare games, rules aur prices dekhne ke liye niche button par click karein.\n"
                    f"ğŸ‘‰ **[Click Here to Open Website]({target_link})**",
        color=0x00ffcc # Cyan Color (Website se match karega)
    )
    
    # Optional: Cool GIF image lagana hai to
    embed.set_image(url="https://media.tenor.com/2147kZ75wW8AAAAC/squid-game-card.gif")
    embed.set_thumbnail(url=interaction.client.user.avatar.url if interaction.client.user.avatar else None)
    embed.set_footer(text="Mobile Optimized â€¢ Premium UI")

    await interaction.response.send_message(embed=embed, view=view)


# ==========================================
# ğŸ›¡ï¸ SERVER GATEKEEPER SYSTEM (OWNER ONLY)
# ==========================================

# 1. Group Definition (Ye match hona chahiye niche wale add_command se)
server_group = app_commands.Group(name="servers", description="ğŸ”’ Manage Bot Servers (Owner Only)")

import discord
from discord import app_commands
import os
import asyncio

# ==============================================================================
# ğŸŒ TITAN NETWORK: GLOBAL SERVER CONTROL & GATEKEEPER
# ==============================================================================

# --- ğŸ” HELPER: SUPREME CLEARANCE CHECK ---
async def verify_supreme_commander(interaction: discord.Interaction):
    """Returns True if user is the Owner, else sends an Access Denied embed."""
    owner_id = os.getenv("OWNER_ID")
    if str(interaction.user.id) != str(owner_id):
        embed = discord.Embed(title="ğŸš« CLEARANCE REJECTED", color=0x8B0000) # Blood Red
        embed.description = "âš ï¸ **Security Alert:** You lack the Supreme Clearance to access the Global Network Terminal."
        await interaction.response.send_message(embed=embed, ephemeral=True)
        return False
    return True

# ==========================================
# ğŸ“Š COMMAND A: GLOBAL NETWORK MAP (LIST)
# ==========================================
@server_group.command(name="list", description="ğŸ“œ Network Map: View all connected servers & populations")
async def list_servers(interaction: discord.Interaction):
    if not await verify_supreme_commander(interaction): return
    
    await interaction.response.defer(ephemeral=True) # â³ Secure Defer
    
    guilds = interaction.client.guilds
    total_servers = len(guilds)
    total_members = sum(g.member_count for g in guilds)

    # Sort guilds by member count (Highest to Lowest)
    sorted_guilds = sorted(guilds, key=lambda g: g.member_count, reverse=True)

    embed = discord.Embed(title="ğŸŒ TITAN GLOBAL NETWORK MAP", color=0x3498DB) # Hacker Blue
    embed.description = (
        f"### ğŸ“¡ SYSTEM UPLINK ESTABLISHED\n"
        f"**Global Population:** `{total_members:,}` Entities\n"
        f"**Active Nodes (Servers):** `{total_servers}`\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬"
    )
    embed.set_thumbnail(url=interaction.client.user.display_avatar.url)
    
    # ğŸ“‹ Dynamic Top 20 Listing
    for i, guild in enumerate(sorted_guilds):
        if i >= 20: 
            embed.add_field(name="...And Beyond", value=f"```\n+ {total_servers - 20} additional nodes hidden\n```", inline=False)
            break
            
        owner_name = guild.owner.name if guild.owner else "Unknown Entity"
        embed.add_field(
            name=f"[{i+1}] {guild.name[:20]}", 
            value=f"ğŸ†” `{guild.id}`\nğŸ‘¥ `{guild.member_count:,}` | ğŸ‘‘ {owner_name}",
            inline=True
        )

    embed.set_footer(text="ğŸ”’ Secure Executive Terminal", icon_url=interaction.user.display_avatar.url)
    await interaction.followup.send(embed=embed)

# ==========================================
# ğŸš« COMMAND B: BLACKLIST / BAN SERVER
# ==========================================
@server_group.command(name="block", description="ğŸš« Blacklist a server and trigger auto-leave protocol")
@app_commands.describe(server_id="The exact ID of the server to ban", reason="Reason for the ban")
async def block_server(interaction: discord.Interaction, server_id: str, reason: str = "Treason / Violation of Titan Protocol"):
    if not await verify_supreme_commander(interaction): return
    
    await interaction.response.defer(ephemeral=True)

    try:
        # ğŸ—„ï¸ SAFE DB UPSERT
        await db_call(lambda: supabase.table("server_whitelist").upsert({
            "server_id": str(server_id),
            "status": "banned",
            "reason": reason
        }).execute())
        
        # ğŸƒ AUTO-LEAVE IF CURRENTLY IN SERVER
        guild = interaction.client.get_guild(int(server_id))
        status_msg = "`Target is offline / Not connected.`"
        
        if guild:
            await guild.leave()
            status_msg = f"**Connection severed.** Left `{guild.name}` successfully."
        
        # ğŸ’ PREMIUM EMBED
        embed = discord.Embed(title="ğŸš« NODE BLACKLISTED", color=0x8B0000)
        embed.description = (
            f"### âš ï¸ SERVER EXCOMMUNICATED\n"
            f"**The target sector has been permanently banned from the Titan Network.**\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ¯ **Server ID:** `{server_id}`\n"
            f" â”£ ğŸ“ **Reason:** `{reason}`\n"
            f" â”— ğŸ“¡ **Status:** {status_msg}\n"
        )
        await interaction.followup.send(embed=embed)
        
    except Exception as e:
        await interaction.followup.send(f"âŒ **Mainframe Error:** `{e}`")

# ==========================================
# âœ… COMMAND C: UNBLOCK SERVER
# ==========================================
@server_group.command(name="unblock", description="âœ… Pardon a server and remove it from the Blacklist")
@app_commands.describe(server_id="The exact ID of the server to pardon")
async def unblock_server(interaction: discord.Interaction, server_id: str):
    if not await verify_supreme_commander(interaction): return
    
    await interaction.response.defer(ephemeral=True)

    try:
        # ğŸ—„ï¸ SAFE DB DELETE
        await db_call(lambda: supabase.table("server_whitelist").delete().eq("server_id", str(server_id)).execute())
        
        embed = discord.Embed(title="âœ… NODE PARDONED", color=0xF1C40F) # Gold
        embed.description = (
            f"### ğŸ•Šï¸ RESTRICTIONS LIFTED\n"
            f"**Server ID `{server_id}` has been cleared from the Blacklist.**\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"> *The Titan Bot is now authorized to rejoin this sector.*"
        )
        await interaction.followup.send(embed=embed)
    except Exception as e:
        await interaction.followup.send(f"âŒ **Mainframe Error:** `{e}`")

# ==========================================
# ğŸ‘‹ COMMAND D: FORCE LEAVE (MANUAL)
# ==========================================
@server_group.command(name="leave", description="ğŸ‘‹ Manually sever connection from a specific server")
@app_commands.describe(server_id="The exact ID of the server to leave")
async def leave_guild(interaction: discord.Interaction, server_id: str):
    if not await verify_supreme_commander(interaction): return
    
    await interaction.response.defer(ephemeral=True)

    guild = interaction.client.get_guild(int(server_id))
    if guild:
        name = guild.name
        await guild.leave()
        
        embed = discord.Embed(title="ğŸ‘‹ CONNECTION SEVERED", color=0xE67E22) # Orange
        embed.description = f"Successfully extracted from **{name}** (`{server_id}`)."
        await interaction.followup.send(embed=embed)
    else:
        await interaction.followup.send(f"âŒ **Error:** The bot is not currently connected to Server ID `{server_id}`.")


# ==============================================================================
# ğŸ›‘ SECURITY EVENT: THE GATEKEEPER (ON_GUILD_JOIN)
# ==============================================================================
@bot.event
async def on_guild_join(guild):
    """Automatically scans new servers and leaves if they are blacklisted."""
    try:
        # ğŸ—„ï¸ SAFE DB CHECK (Prevents Bot from freezing on join)
        res = await db_call(lambda: supabase.table("server_whitelist").select("status, reason").eq("server_id", str(guild.id)).execute())
        
        if res and res.data and res.data[0]['status'] == 'banned':
            reason = res.data[0].get('reason', 'Violation of Titan Protocol')
            print(f"ğŸš« [GATEKEEPER] Intrusion Attempt by Banned Server: {guild.name} ({guild.id}) - Initiating Leave Protocol...")
            
            # ğŸ“© SEND FINAL WARNING TO OWNER
            try:
                if guild.owner:
                    embed = discord.Embed(title="ğŸš« TITAN NETWORK: ACCESS DENIED", color=0x8B0000)
                    embed.description = (
                        f"Your server **{guild.name}** is officially blacklisted from the Titan Network.\n\n"
                        f"**Reason:** `{reason}`\n\n"
                        f"> *The bot has automatically severed the connection.*"
                    )
                    await guild.owner.send(embed=embed)
            except Exception as dm_err:
                print(f"[GATEKEEPER] Could not DM Owner of {guild.name}: {dm_err}")
            
            # ğŸƒ TURANT LEAVE
            await guild.leave()
            print(f"âœ… [GATEKEEPER] Successfully extracted from {guild.name}.")
            
    except Exception as e:
        print(f"Gatekeeper Critical Error: {e}")

import random
import datetime
import asyncio # Animation ke liye zaruri hai
from discord import app_commands, ButtonStyle

# ==========================================
# ğŸ® TITAN ELITE GAMES & ECONOMY
# ==========================================

import asyncio

# ==============================================================================
# ğŸ¦ TITAN ECONOMY: ATOMIC BANKING ENGINE
# ==============================================================================

async def smart_charge(user_id, amount):
    """
    ğŸ›¡ï¸ ANTI-CHEAT TRANSACTION:
    Deducts money from Wallet first, then Bank if needed.
    Returns True if successful, False if broke.
    """
    uid = str(user_id)
    try:
        # 1. Fetch current totals
        res = await db_call(lambda: supabase.table("economy").select("balance, bank").eq("user_id", uid).execute())
        
        if not res or not res.data:
            # Create account if missing
            await db_call(lambda: supabase.table("economy").insert({"user_id": uid, "balance": 0, "bank": 0}).execute())
            return False

        wallet = int(res.data[0].get('balance', 0))
        bank = int(res.data[0].get('bank', 0))

        if (wallet + bank) < amount:
            return False # Kangaal check

        # 2. Logic: Wallet se kato, bacha hua Bank se
        if wallet >= amount:
            new_wallet = wallet - amount
            new_bank = bank
        else:
            remaining = amount - wallet
            new_wallet = 0
            new_bank = bank - remaining

        # 3. ATOMIC UPDATE
        await db_call(lambda: supabase.table("economy").update({
            "balance": new_wallet,
            "bank": new_bank
        }).eq("user_id", uid).execute())
        
        return True
    except Exception as e:
        print(f"Transaction Error: {e}")
        return False

async def smart_reward(user_id, amount):
    """
    ğŸ’° SECURE PAYOUT:
    Adds money directly to the balance using RPC or Atomic increment.
    """
    uid = str(user_id)
    try:
        # Step 1: Get current balance (Safe)
        res = await db_call(lambda: supabase.table("economy").select("balance").eq("user_id", uid).execute())
        
        if not res or not res.data:
            # Create account and add reward
            await db_call(lambda: supabase.table("economy").insert({"user_id": uid, "balance": amount, "bank": 0}).execute())
            return amount

        current_bal = int(res.data[0].get('balance', 0))
        new_bal = current_bal + amount

        # Step 2: Push to DB
        await db_call(lambda: supabase.table("economy").update({"balance": new_bal}).eq("user_id", uid).execute())
        return new_bal
    except Exception as e:
        print(f"Reward Error: {e}")
        return 0

async def get_balance(user_id):
    """ğŸš€ High-Speed Balance Fetch"""
    uid = str(user_id)
    try:
        res = await db_call(lambda: supabase.table("economy").select("balance, bank").eq("user_id", uid).execute())
        if res and res.data:
            return int(res.data[0]['balance']), int(res.data[0]['bank'])
        else:
            # Auto-Register
            await db_call(lambda: supabase.table("economy").insert({"user_id": uid, "balance": 0, "bank": 0}).execute())
            return 0, 0
    except:
        return 0, 0

# ==========================================
# ğŸ° SYSTEM: ADVANCED SLOTS (WITH SPIN BUTTON)
# ==========================================
import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# ğŸ° TITAN CASINO: ADVANCED SLOT MACHINE (VIP EDITION)
# ==============================================================================

class SlotsView(discord.ui.View):
    def __init__(self, user: discord.Member, bet: int):
        super().__init__(timeout=60) # â³ 1 Minute to spin
        self.user = user
        self.bet = bet

    @discord.ui.button(label="PULL THE LEVER", style=discord.ButtonStyle.success, emoji="ğŸ°")
    async def spin_callback(self, interaction: discord.Interaction, button: discord.ui.Button):
        # ğŸ›¡ï¸ 1. Security Check
        if interaction.user.id != self.user.id:
            return await interaction.response.send_message("âŒ **Guard:** This machine is reserved for someone else!", ephemeral=True)
        
        # â³ 2. Instant Defer & Lock (Anti-Spam)
        await interaction.response.defer()
        self.stop() # Stops listening to further clicks
        for child in self.children: child.disabled = True
        
        # ğŸ’³ 3. Smart Charge (Checks Wallet + Bank securely)
        paid = await smart_charge(self.user.id, self.bet)
        if not paid:
            embed = discord.Embed(title="ğŸš¨ TRANSACTION FAILED", color=0xFF0000)
            embed.description = f"âŒ **Insufficient Funds:** You need `${self.bet:,}` to spin this VIP machine."
            return await interaction.edit_original_response(embed=embed, view=None)
        
        # ğŸŒ€ 4. The Spin Animation (Suspense Building)
        anim_embed = discord.Embed(title="ğŸ° TITAN CASINO: VIP SLOTS", color=0xF1C40F) # Gold/Yellow
        anim_embed.set_thumbnail(url=self.user.display_avatar.url)
        anim_embed.description = (
            f"### âš™ï¸ ROLLING THE CYLINDERS...\n"
            f"**Wager:** `${self.bet:,}`\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"> ğŸ° `[ ğŸŒ€ | ğŸŒ€ | ğŸŒ€ ]`\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"*The machine is calculating your fate...*"
        )
        await interaction.edit_original_response(embed=anim_embed, view=self)
        
        # Suspsense Delay (Real Casino feel)
        await asyncio.sleep(2.5) 
        
        # ğŸ² 5. The RNG Engine (Math Logic)
        emojis = ["ğŸ", "ğŸŠ", "ğŸ‡", "ğŸ’", "ğŸ’", "ğŸ””", "7ï¸âƒ£"]
        a, b, c = random.choice(emojis), random.choice(emojis), random.choice(emojis)
        
        win_amount = 0
        status_title = ""
        color = 0xFF0000 # Default Red
        
        # Payout Multipliers
        if a == b == c: 
            if a == "7ï¸âƒ£": # ğŸ‘‘ THE MEGA JACKPOT
                win_amount = self.bet * 50
                status_title = "ğŸ‘‘ MEGA JACKPOT HIT! (50x)"
                color = 0x9B59B6 # Purple
            else: # ğŸ‰ STANDARD JACKPOT
                win_amount = self.bet * 10
                status_title = "ğŸ’ JACKPOT HIT! (10x)"
                color = 0xFFD700 # Gold
        elif a == b or b == c or a == c: # âœ… PARTIAL MATCH
            win_amount = self.bet * 2
            status_title = "âœ… NICE MATCH! (2x)"
            color = 0x2ECC71 # Green
        else: # âŒ TOTAL LOSS
            status_title = "ğŸ’€ TOTAL LOSS (0x)"
            color = 0xE74C3C # Blood Red
            
        # ğŸ’¸ 6. Reward Processing (Safe DB Call)
        if win_amount > 0:
            await smart_reward(self.user.id, win_amount)
            
        # ğŸ¨ 7. Final Results Display
        final_embed = discord.Embed(title=f"ğŸ° SLOTS: {status_title}", color=color)
        final_embed.set_thumbnail(url=self.user.display_avatar.url)
        
        desc = (
            f"### ğŸ¯ THE REELS HAVE STOPPED\n"
            f"**Player:** {self.user.mention}\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"> ğŸ° `[ {a} | {b} | {c} ]`\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        )
        
        if win_amount > 0:
            desc += f" â”£ ğŸ“ˆ **Original Bet:** `${self.bet:,}`\n"
            desc += f" â”— ğŸ’° **Total Payout:** `+${win_amount:,}`\n"
            final_embed.set_image(url="https://media.tenor.com/J_wWwD9sD0gAAAAC/winner-money.gif")
        else:
            desc += f" â”£ ğŸ“‰ **Original Bet:** `${self.bet:,}`\n"
            desc += f" â”— ğŸ’¸ **Net Loss:** `-${self.bet:,}`\n"
            
        final_embed.description = desc
        final_embed.set_footer(text="Play responsibly. The house always has the edge.", icon_url=interaction.client.user.display_avatar.url)
        
        await interaction.edit_original_response(embed=final_embed, view=None)

    async def on_timeout(self):
        """If they don't spin within 1 minute, expire the machine."""
        for child in self.children: child.disabled = True
        try: await self.message.edit(content="â³ *Slot machine session expired. Start a new game.*", view=self)
        except: pass


# ==============================================================================
# ğŸ’» MAIN COMMAND
# ==============================================================================
@bot.tree.command(name="slots", description="ğŸ° Test your luck on the VIP Slot Machine (Max 50k)")
@app_commands.describe(amount="The amount of cash to wager")
@check_seized()
async def slots(interaction: discord.Interaction, amount: int):
    
    # ğŸ›‘ 1. SECURITY & BET LIMITS
    MAX_BET = 50000
    if amount > MAX_BET:
        return await interaction.response.send_message(f"âŒ **Casino Rules:** Maximum bet allowed is `${MAX_BET:,}`!", ephemeral=True)
    if amount < 100:
        return await interaction.response.send_message("âŒ **Casino Rules:** Minimum bet is `$100`.", ephemeral=True)

    # ğŸ—„ï¸ 2. PRE-CHECK LIQUIDITY (Safe DB Call)
    await interaction.response.defer(ephemeral=False)
    try:
        res = await db_call(lambda: supabase.table("economy").select("balance, bank").eq("user_id", str(interaction.user.id)).execute())
        total_wealth = int(res.data[0].get('balance', 0)) + int(res.data[0].get('bank', 0)) if res and res.data else 0
        
        if total_wealth < amount:
            return await interaction.followup.send(f"âŒ **Broke:** You need `${amount:,}` in your Wallet + Bank to play.", ephemeral=True)
    except Exception as e:
        return await interaction.followup.send(f"âŒ **System Error:** Cannot access bank records. `{e}`", ephemeral=True)

    # ğŸŸï¸ 3. SPAWN THE MACHINE
    embed = discord.Embed(title="ğŸ° TITAN CASINO: SLOT MACHINE", color=0x2b2d31)
    embed.set_thumbnail(url="https://media.tenor.com/On7kvXhzml4AAAAi/loading-gif.gif")
    embed.description = (
        f"**Welcome to the high-rollers table, {interaction.user.mention}.**\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f" â”£ ğŸ’µ **Your Wager:** `${amount:,}`\n"
        f" â”£ ğŸ’ **Standard Jackpot (10x):** `${(amount * 10):,}`\n"
        f" â”— ğŸ‘‘ **Mega Jackpot (50x):** `${(amount * 50):,}`\n\n"
        f"ğŸ‘‡ **Pull the lever to authorize payment and spin the reels!**"
    )
    
    view = SlotsView(interaction.user, amount)
    msg = await interaction.followup.send(embed=embed, view=view)
    view.message = msg # Save message for timeout logic



# ==========================================
# ğŸ’¼ SYSTEM: HACKING WORK (TERMINAL STYLE)
# ==========================================
import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# ğŸ’» TITAN TERMINAL: CYBER HACKING TASK (/WORK)
# ==============================================================================

def generate_hex_code():
    """Generates a random 4-character hex code like 'A4-X9'"""
    letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    return f"{random.choice(letters)}{random.randint(0,9)}-{random.choice(letters)}{random.randint(0,9)}"

# --- 1. DYNAMIC HACK NODE (BUTTON) ---
class HackNodeButton(discord.ui.Button):
    def __init__(self, code: str, is_correct: bool):
        super().__init__(style=discord.ButtonStyle.secondary, label=code, custom_id=code)
        self.code = code
        self.is_correct = is_correct

    async def callback(self, interaction: discord.Interaction):
        view: HackWorkView = self.view
        
        # ğŸ›¡ï¸ Security Guard
        if interaction.user.id != view.user_id:
            return await interaction.response.send_message("âŒ **Guard:** Unauthorized terminal access.", ephemeral=True)

        await interaction.response.defer() # â³ Prevent Interaction Failed
        
        # ğŸ”’ Lock Terminal
        view.game_over = True
        view.stop()
        for child in view.children: child.disabled = True
        
        # ==========================================
        # âœ… SUCCESS: FIREWALL BYPASSED
        # ==========================================
        if self.is_correct:
            earnings = random.randint(1500, 3500) # Premium Payout
            
            self.style = discord.ButtonStyle.success # Turn correct button green
            
            # ğŸ’¸ Safe DB Reward
            try:
                # Assuming smart_reward is your async global DB function
                await smart_reward(view.user_id, earnings)
            except Exception as e:
                print(f"Work Reward Error: {e}")

            embed = discord.Embed(title="âœ… SYSTEM BYPASSED", color=0x2ECC71) # Matrix Green
            embed.set_thumbnail(url=interaction.user.display_avatar.url)
            embed.description = (
                f"```diff\n"
                f"+ ACCESS GRANTED\n"
                f"+ NODE DECRYPTED\n"
                f"+ DOWNLOAD COMPLETE\n"
                f"```\n"
                f"### ğŸ’¼ DATA SOLD TO THE BLACK MARKET\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ¯ **Agent:** {interaction.user.mention}\n"
                f" â”— ğŸ’° **Payment Received:** `+${earnings:,}`\n"
            )
            await interaction.edit_original_response(embed=embed, view=view)
            
        # ==========================================
        # âŒ FAILURE: WRONG CODE
        # ==========================================
        else:
            self.style = discord.ButtonStyle.danger # Turn wrong button red
            
            # Highlight the correct one
            for child in view.children:
                if getattr(child, 'is_correct', False):
                    child.style = discord.ButtonStyle.success 
            
            embed = discord.Embed(title="ğŸš¨ FIREWALL TRIGGERED!", color=0xE74C3C) # Blood Red
            embed.set_thumbnail(url=interaction.user.display_avatar.url)
            embed.description = (
                f"```diff\n"
                f"- INCORRECT DECRYPTION KEY\n"
                f"- CONNECTION TERMINATED\n"
                f"- IP TRACE INITIATED\n"
                f"```\n"
                f"### ğŸ’€ HACK FAILED\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ¯ **Target Node:** `{view.correct_code}`\n"
                f" â”£ âŒ **Your Input:** `{self.code}`\n"
                f" â”— ğŸ’¸ **Payment:** `$0` (Fled the scene)\n\n"
                f"> *You narrowly escaped the cyber police. Try again later.*"
            )
            await interaction.edit_original_response(embed=embed, view=view)


# --- 2. THE TERMINAL VIEW ---
class HackWorkView(discord.ui.View):
    def __init__(self, user_id: int, message: discord.Message = None):
        super().__init__(timeout=8.0) # âš¡ ONLY 8 SECONDS FOR MAXIMUM PRESSURE
        self.user_id = user_id
        self.message = message
        self.game_over = False
        
        # ğŸ² Generate 1 Correct Code and 3 Fake Codes Dynamically
        self.correct_code = generate_hex_code()
        options = [self.correct_code]
        
        while len(options) < 4:
            fake_code = generate_hex_code()
            if fake_code not in options:
                options.append(fake_code)
                
        random.shuffle(options) # Mix them up!
        
        # Render Buttons
        for opt in options:
            self.add_item(HackNodeButton(opt, is_correct=(opt == self.correct_code)))

    async def on_timeout(self):
        """If the user takes longer than 8 seconds, the firewall catches them."""
        if self.game_over: return
        self.game_over = True
        
        for child in self.children: child.disabled = True
        
        embed = discord.Embed(title="ğŸš“ TRACE COMPLETED", color=0x8B0000)
        embed.description = (
            f"```diff\n"
            f"- TIME EXPIRED\n"
            f"- IP ADDRESS LOGGED\n"
            f"- FBI DISPATCHED\n"
            f"```\n"
            f"**You took too long to decrypt the node. Run!**\n"
            f"ğŸ’¸ **Payment:** `$0`"
        )
        try: await self.message.edit(embed=embed, view=self)
        except: pass


# ==============================================================================
# ğŸ’» MAIN COMMAND
# ==============================================================================
@bot.tree.command(name="work", description="ğŸ’» Cyber Hacking: Decrypt the Central Bank's firewall for quick cash")
@app_commands.checks.cooldown(1, 300, key=lambda i: (i.guild_id, i.user.id)) # 5 Mins Cooldown
@check_seized() # Optional: if you want to block seized users from working
async def work(interaction: discord.Interaction):
    
    # ğŸ—„ï¸ Initial DB Check (Ensure they have an account)
    try:
        res = await db_call(lambda: supabase.table("economy").select("balance").eq("user_id", str(interaction.user.id)).execute())
        if not res or not res.data:
            return await interaction.response.send_message("âŒ **Error:** You need a Titan Account to accept contracts. Type `/balance` to register.", ephemeral=True)
    except: pass # Proceed anyway if DB lags

    # ğŸš€ Deploy Terminal View
    view = HackWorkView(interaction.user.id)
    
    embed = discord.Embed(title="ğŸ•µï¸ TITAN SECURITY BREACH", color=0x2b2d31)
    embed.description = (
        f"### ğŸŒ SYSTEM INFILTRATION\n"
        f"**Target:** `Central Bank Sub-Routine`\n"
        f"**Encryption:** `Active`\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"â¬‡ï¸ **AUTHORIZATION REQUIRED:**\n"
        f"> # `{view.correct_code}`\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"â³ *You have **8 seconds** to click the matching decryption key below!*"
    )
    embed.set_image(url="https://media.tenor.com/GfSX-u7_RR4AAAAC/coding-hacking.gif") # Cyberpunk Hacker GIF
    
    await interaction.response.send_message(embed=embed, view=view)
    
    # Capture message for timeout edits
    view.message = await interaction.original_response()

# --- â³ COOLDOWN ERROR HANDLER ---
@work.error
async def work_error(interaction: discord.Interaction, error: app_commands.AppCommandError):
    if isinstance(error, app_commands.CommandOnCooldown):
        rem = int(error.retry_after)
        m, s = divmod(rem, 60)
        embed = discord.Embed(title="â³ SYSTEM COOLING DOWN", color=0xF39C12)
        embed.description = f"The cyber-police are still scanning the area.\nStay low for `{m}m {s}s` before taking another job."
        await interaction.response.send_message(embed=embed, ephemeral=True)
    else:
        # Pass other errors up the chain or print them
        print(f"Work Command Error: {error}")

games_group = app_commands.Group(name="games", description="ğŸ° All Casino and Arcade Games")


# ==========================================
# ğŸª™ SYSTEM: COIN FLIP (ANIMATED)
# ==========================================
import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# ğŸª™ TITAN CASINO: HIGH-STAKES COIN FLIP
# ==============================================================================

@games_group.command(name="coin_flip", description="ğŸª™ Double or Nothing! Flip a coin for a 50/50 chance to double your money.")
@app_commands.describe(choice="Call it in the air!", amount="The amount of cash to wager (Max: 50k)")
@app_commands.choices(choice=[
    app_commands.Choice(name="ğŸ¦… Heads", value="Heads"), 
    app_commands.Choice(name="ğŸª™ Tails", value="Tails")
])
@app_commands.checks.cooldown(1, 10, key=lambda i: (i.guild_id, i.user.id)) # 10s Cooldown
@check_seized()
async def coin_flip(interaction: discord.Interaction, choice: app_commands.Choice[str], amount: int):
    
    # ğŸ›‘ 1. SECURITY & LIMITS
    MAX_BET = 50000
    if amount > MAX_BET:
        return await interaction.response.send_message(f"âŒ **Casino Rules:** Maximum bet allowed is `${MAX_BET:,}`!", ephemeral=True)
    if amount < 100:
        return await interaction.response.send_message("âŒ **Casino Rules:** Minimum bet is `$100`.", ephemeral=True)

    # â³ 2. INSTANT DEFER
    await interaction.response.defer(ephemeral=False)

    # ğŸ’³ 3. THE ANTI-CHEAT CHARGE (Deduct BEFORE flipping)
    paid = await smart_charge(interaction.user.id, amount)
    if not paid:
        embed = discord.Embed(title="ğŸš¨ TRANSACTION FAILED", color=0xFF0000)
        embed.description = f"âŒ **Insufficient Funds:** You need `${amount:,}` in your Wallet + Bank to place this bet."
        return await interaction.followup.send(embed=embed)

    # ğŸŒ€ 4. THE SUSPENSE ANIMATION
    anim_embed = discord.Embed(title="ğŸª™ TITAN CASINO: COIN FLIP", color=0xF1C40F) # Gold
    anim_embed.set_thumbnail(url=interaction.user.display_avatar.url)
    anim_embed.description = (
        f"### ğŸ†™ THE COIN IS IN THE AIR...\n"
        f"**Player:** {interaction.user.mention}\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f" â”£ ğŸ’µ **Wager:** `${amount:,}`\n"
        f" â”£ ğŸ—£ï¸ **Your Call:** `{choice.value}`\n"
        f" â”— ğŸ¯ **Potential Payout:** `${(amount * 2):,}`\n\n"
        f"> *Flipping...*"
    )
    # Optional: You can put a coin flipping GIF url here
    anim_embed.set_image(url="https://media.tenor.com/1_8Abo99yN8AAAAC/coin-flip-flip-coin.gif") 
    
    await interaction.followup.send(embed=anim_embed)
    
    # Let the coin spin...
    await asyncio.sleep(2.5)

    # ğŸ² 5. THE RNG OUTCOME
    outcome = random.choice(["Heads", "Tails"])
    is_win = (choice.value == outcome)
    
    # ğŸ“Š 6. PROCESS RESULTS
    final_embed = discord.Embed(title="ğŸª™ COIN FLIP: RESULT")
    final_embed.set_thumbnail(url=interaction.user.display_avatar.url)

    desc = (
        f"### ğŸ›‘ THE COIN HAS LANDED\n"
        f"**The result is {outcome.upper()}!**\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f" â”£ ğŸ—£ï¸ **Your Call:** `{choice.value}`\n"
        f" â”£ ğŸ² **Actual Result:** `{outcome}`\n"
    )

    if is_win:
        # ğŸ‰ WINNER (Reward 2x the bet amount because we deducted it earlier)
        winnings = amount * 2
        await smart_reward(interaction.user.id, winnings)
        
        final_embed.color = 0x2ECC71 # Green
        desc += f" â”— ğŸ’° **Outcome:** `YOU WON!`\n\n"
        desc += f"ğŸ’¸ **Total Payout:** `+${winnings:,}` (Profit: `${amount:,}`)"
        final_embed.set_image(url="https://media.tenor.com/bXjOidvDvoQAAAAC/confetti-celebrate.gif")
    else:
        # ğŸ’€ LOSER (Do nothing, money was already deducted)
        final_embed.color = 0xE74C3C # Blood Red
        desc += f" â”— ğŸ’€ **Outcome:** `YOU LOST!`\n\n"
        desc += f"ğŸ“‰ **Net Loss:** `-${amount:,}`"
        # Optional: final_embed.set_image(url="loser_gif_url")

    final_embed.description = desc
    final_embed.set_footer(text="Play responsibly. The house always has the edge.")

    # Edit the animation message with the final result
    await interaction.edit_original_response(embed=final_embed)


# --- â³ COOLDOWN ERROR HANDLER ---
@coin_flip.error
async def coin_flip_error(interaction: discord.Interaction, error: app_commands.AppCommandError):
    if isinstance(error, app_commands.CommandOnCooldown):
        rem = int(error.retry_after)
        embed = discord.Embed(title="â³ TOO FAST!", color=0xF39C12)
        embed.description = f"The coin is still rolling on the floor!\nWait `{rem}s` before flipping again."
        
        # Checking if interaction has been responded to already (just in case)
        if interaction.response.is_done():
            await interaction.followup.send(embed=embed, ephemeral=True)
        else:
            await interaction.response.send_message(embed=embed, ephemeral=True)
    else:
        print(f"Coin Flip Error: {error}")



# ==========================================
# ğŸ“… SYSTEM: DAILY (BANK RECEIPT STYLE) - 100% FIXED
# ==========================================
import discord
from discord import app_commands
import datetime as dt
import random

# ==============================================================================
# ğŸ¦ TITAN BANK: DAILY STIPEND PROTOCOL (00:00 IST RESET)
# ==============================================================================

@games_group.command(name="daily", description="ğŸ’° Claim your daily stipend from the Titan Treasury (Resets at 00:00 IST)")
@check_seized() # Optional: Block seized users
async def daily(interaction: discord.Interaction):
    await interaction.response.defer(ephemeral=False)
    
    try:
        # ğŸ•’ 1. ESTABLISH TIMEZONE (IST)
        IST = dt.timezone(dt.timedelta(hours=5, minutes=30))
        now = dt.datetime.now(IST)
        user_id = str(interaction.user.id)

        # ğŸ—„ï¸ 2. FETCH LAST CLAIM STATUS (Safe DB Call)
        res = await db_call(lambda: supabase.table("economy").select("last_daily, inventory").eq("user_id", user_id).execute())
        
        can_claim = True
        inventory = {}
        
        if res and res.data:
            inventory = res.data[0].get('inventory', {}) or {}
            last_daily_str = res.data[0].get('last_daily')
            
            if last_daily_str:
                try:
                    # Parse and convert to IST
                    last_dt = dt.datetime.fromisoformat(last_daily_str.replace('Z', '+00:00')).astimezone(IST)
                    if last_dt.date() >= now.date():
                        can_claim = False
                except:
                    can_claim = True # Failsafe: Let them claim if data is corrupt

        # ==========================================
        # âœ… SUCCESS: PROCESSING DISBURSEMENT
        # ==========================================
        if can_claim:
            # Base Reward Logic
            base_reward = random.randint(2500, 7500)
            
            # ğŸ‘‘ VIP Bonus (1.5x Multiplier)
            is_vip = "vip" in inventory
            final_reward = int(base_reward * 1.5) if is_vip else base_reward
            
            # ğŸ’³ ATOMIC REWARD (No Race Conditions)
            # smart_reward directly updates and returns new balance
            new_bal = await smart_reward(user_id, final_reward)
            
            # Update Last Claim Timestamp
            await db_call(lambda: supabase.table("economy").update({
                "last_daily": now.isoformat()
            }).eq("user_id", user_id).execute())
            
            # ğŸ’ PREMIUM RECEIPT EMBED
            embed = discord.Embed(title="ğŸ¦ TITAN BANK: DAILY DISBURSEMENT", color=0x2ECC71) # Emerald Green
            embed.set_thumbnail(url=interaction.user.display_avatar.url)
            
            vip_tag = "ğŸ‘‘ **VIP 1.5x Applied**" if is_vip else "âš¡ *Standard Rate*"
            
            embed.description = (
                f"### ğŸ’¸ FUNDS CREDITED SUCCESSFULLY\n"
                f"Your daily stipend has been processed by the Treasury.\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ‘¤ **Beneficiary:** {interaction.user.mention}\n"
                f" â”£ ğŸ’° **Amount:** `${final_reward:,}`\n"
                f" â”£ ğŸ’³ **Total Balance:** `${new_bal:,}`\n"
                f" â”— ğŸ·ï¸ **Status:** {vip_tag}\n\n"
                f"> *The next stipend will be available after midnight (00:00 IST).* "
            )
            embed.set_footer(text=f"Transaction ID: {random.randint(100000, 999999)} â€¢ {now.strftime('%d %b, %Y')}")
            
            await interaction.followup.send(embed=embed)

        # ==========================================
        # â³ FAILURE: DAILY LIMIT REACHED
        # ==========================================
        else:
            # Calculate Time until Midnight IST
            tomorrow = now.date() + dt.timedelta(days=1)
            midnight = dt.datetime(tomorrow.year, tomorrow.month, tomorrow.day, 0, 0, 0, tzinfo=IST)
            diff = midnight - now
            
            hours, remainder = divmod(int(diff.total_seconds()), 3600)
            minutes, _ = divmod(remainder, 60)
            
            embed = discord.Embed(title="â³ TRANSACTION PENDING", color=0xE74C3C) # Alizarin Red
            embed.set_thumbnail(url=interaction.user.display_avatar.url)
            
            embed.description = (
                f"### ğŸš« DAILY LIMIT REACHED\n"
                f"Your account is not yet eligible for another claim.\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f"â³ **Next Payout In:** `{hours}h {minutes}m`\n"
                f"ğŸ“… **Scheduled Reset:** `00:00 IST`\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f"> *Please return after midnight to refresh your balance.*"
            )
            
            await interaction.followup.send(embed=embed)

    except Exception as e:
        print(f"Daily Command Critical Error: {e}")
        await interaction.followup.send(f"âŒ **Mainframe Error:** Transaction declined. `{e}`")


import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# ğŸ® MASSIVE GAME DATA DICTIONARIES (LEVELS & DIFFICULTIES)
# ==============================================================================

SCRAMBLE_WORDS = {
    1: [ # ğŸŸ¢ EASY (4-5 Letters)
        "APPLE", "WATER", "GHOST", "HOUSE", "TRAIN", "MOUSE", "CLOCK", "CHAIR", "TABLE", 
        "SWORD", "MAGIC", "BRAIN", "HEART", "LIGHT", "MUSIC", "NIGHT", "RIVER", "SMILE", 
        "TIGER", "WATCH", "BEACH", "BREAD", "BRUSH", "CANDY", "CLOUD", "DANCE", "DREAM", 
        "EARTH", "FLAME", "GLASS", "HONEY", "JUICE", "KNIFE", "LEMON", "MONEY", "NURSE", 
        "OCEAN", "PAPER", "PIZZA", "QUEEN", "ROBOT", "SHEEP", "SNAKE", "SPOON", "SUGAR",
        "BLANK", "BRAVE", "CHESS", "CHILL", "CRASH", "DAISY", "EAGLE", "FLOCK", "FUNNY", "GIANT", 
        "HAPPY", "HOTEL", "IGLOO", "MANGO", "NOBLE", "ONION", "PUPPY", "QUIET", "SHARK", "TOAST", 
        "ULTRA", "VENOM", "VOICE", "YOUTH", "ZEBRA", "BLIND", "FAITH", "GLORY", "HABIT", "JELLY", 
        "KNOCK", "LOGIC", "NERVE", "OASIS", "PEARL", "RUMOR", "SALAD", "THEME", "UNCLE", "VALUE",
        "WHEEL", "YACHT", "BACON", "CABIN", "DELTA", "EIGHT", "FROST", "GHOST", "HEAVY", "IMAGE"
        
    ],
    2: [ # ğŸŸ¡ MEDIUM (6-7 Letters)
        "PIRATE", "PLANET", "DRAGON", "GUITAR", "ROCKET", "CASTLE", "JUNGLE", "ANIMAL", 
        "BOTTLE", "CAMERA", "CANYON", "DESERT", "DOCTOR", "ENGINE", "FOREST", "FRIEND", 
        "GARDEN", "ISLAND", "LIZARD", "MARKET", "MIRROR", "MONKEY", "NUMBER", "ORANGE", 
        "PALACE", "PENCIL", "POCKET", "POLICE", "PRISON", "PUZZLE", "RABBIT", "RECORD", 
        "SCHOOL", "SCREEN", "SECRET", "SILVER", "SISTER", "SPIDER", "SPIRIT", "SPRING", 
        "SQUARE", "STREET", "SUMMER", "SUNSET", "TARGET", "TEMPLE", "TICKET", "WINDOW",
        "AIRPORT", "BALLOON", "BALANCE", "CABINET", "CAPTAIN", "DYNAMIC", "ECLIPSE", "FABRIC", 
        "GARAGE", "HABITAT", "ICEBERG", "JOURNAL", "KETCHUP", "LAGOON", "MACHINE", "MAGNET", 
        "NARROW", "OCTOPUS", "PACIFIC", "PANCAKE", "RADICAL", "REACTOR", "SALMON", "SAUSAGE", 
        "TACTICS", "THUNDER", "VAMPIRE", "VETERAN", "VOLTAGE", "WARRIOR", "WEALTHY", "YOGHURT", 
        "ZEALOUS", "ZOMBIE", "WEAPON", "VILLAGE", "TUNNEL", "SHADOW", "PUMPKIN", "OXYGEN"
    ],
    3: [ # ğŸ”´ HARD (8+ Letters)
        "ASTRONAUT", "TELESCOPE", "ADVENTURE", "MYSTERY", "PYRAMID", "UNIVERSE", "ABSOLUTE", 
        "BEAUTIFUL", "BRILLIANT", "CAMPAIGN", "CHAMPION", "CHOCOLATE", "COMPUTER", "DAUGHTER", 
        "DINOSAUR", "DIRECTOR", "DISCOVER", "ELEPHANT", "ENGINEER", "ENVELOPE", "EVIDENCE", 
        "FESTIVAL", "GENERATE", "GORGEOUS", "HOSPITAL", "IDENTITY", "INDUSTRY", "LANGUAGE", 
        "MACARONI", "MOUNTAIN", "MUSHROOM", "NECKLACE", "OPPOSITE", "PARADISE", "PHARMACY", 
        "PINEAPPLE", "PORTRAIT", "QUESTION", "REMEMBER", "SANDWICH", "SCISSORS", "SKELETON", 
        "SOFTWARE", "SYMPHONY", "SYNDROME", "TREASURE", "UMBRELLA", "VACATION", "WARDROBE",
        "AMBULANCE", "ARCHITECT", "BILLIONAIRE", "BREAKFAST", "CALCULATOR", "CELEBRATION", 
        "DETECTIVE", "DIMENSION", "EARTHQUAKE", "EMERGENCY", "FIREPLACE", "GENERATOR", 
        "HELICOPTER", "INVISIBLE", "JOURNALIST", "KNOWLEDGE", "LANDSCAPE", "METABOLISM", 
        "NAVIGATOR", "OBSERVATORY", "PASSENGER", "QUARANTINE", "RADIATION", "SUPERNOVA", 
        "TELEPHONE", "UNIVERSITY", "VEGETARIAN", "WRESTLING", "XYLOPHONE", "YOUTUBER", 
        "ZOOLOGIST", "AQUARIUM", "BOULEVARD", "CHAMELEON", "DIAGNOSIS", "EVOLUTION"
    ]
}

EMOJI_PUZZLES = {
    1: [ # ğŸŸ¢ EASY (Famous Movies / Characters)
        ("ğŸ‘¦ğŸ‘“âš¡", "HARRY POTTER"), 
        ("ğŸ¦‡ğŸ‘¨", "BATMAN"), 
        ("ğŸš¢ğŸ¥¶ğŸ’”", "TITANIC"), 
        ("ğŸ•·ï¸ğŸ‘¨", "SPIDER-MAN"), 
        ("ğŸ¦ğŸ‘‘", "THE LION KING"), 
        ("ğŸ¼ğŸ‘ŠğŸœ", "KUNG FU PANDA"), 
        ("ğŸŸğŸ”ğŸ ", "FINDING NEMO"), 
        ("ğŸ«ğŸ­", "CHARLIE AND THE CHOCOLATE FACTORY"), 
        ("ğŸ¦–ğŸƒâ€â™‚ï¸ğŸš™", "JURASSIC PARK"), 
        ("ğŸš—âš¡ğŸ†", "CARS"), 
        ("ğŸˆğŸ ğŸ‘´", "UP"), 
        ("ğŸ€ğŸ‘¨â€ğŸ³ğŸ²", "RATATOUILLE"), 
        ("â„ï¸ğŸ‘¸â›„", "FROZEN"), 
        ("ğŸ§¸ğŸ¤ ğŸš€", "TOY STORY"), 
        ("ğŸ¦ğŸ¢âœˆï¸", "KING KONG"),
        ("ğŸ±ğŸ­ğŸ”¨", "TOM AND JERRY"),
        ("ğŸ§½ğŸ‘–ğŸ", "SPONGEBOB SQUAREPANTS"),
        ("ğŸ¦¸â€â™‚ï¸â˜„ï¸ğŸ‘“", "SUPERMAN"),
        ("ğŸ‘¦ğŸ»ğŸ’ğŸ»", "THE JUNGLE BOOK"),
        ("ğŸ—¡ï¸ğŸ›¡ï¸ğŸ‘‘", "GLADIATOR"),
        ("ğŸ§šâ€â™€ï¸âœ¨ğŸ´â€â˜ ï¸", "PETER PAN"),
        ("ğŸ¦ŠğŸ°ğŸ‘®â€â™‚ï¸", "ZOOTOPIA"),
        ("ğŸ‘¿ğŸ‘—ğŸ‘ ", "THE DEVIL WEARS PRADA"),
        ("ğŸ‘¸ğŸ’‡â€â™€ï¸ğŸ—¼", "TANGLED"),
        ("ğŸ¶ğŸ¾ğŸ•µï¸â€â™‚ï¸", "SCOOBY DOO"),
        ("ğŸ¢ğŸ¥·ğŸ•", "TEENAGE MUTANT NINJA TURTLES"),
        ("ğŸ¥‹ğŸ‘¦ğŸš—", "THE KARATE KID"),
        ("ğŸ¦ğŸ¢ğŸ‘©", "KING KONG"),
        ("ğŸ¼ğŸ¥‹ğŸ‰", "KUNG FU PANDA 2"),
        ("ğŸ¦„ğŸŒˆğŸ’–", "MY LITTLE PONY")
    ],
    2: [ # ğŸŸ¡ MEDIUM (Pop Culture / Needs thinking)
        ("ğŸŒğŸ’ğŸ—½", "PLANET OF THE APES"), 
        ("ğŸ‘¨ğŸ»ğŸ”¨âš¡", "THOR"), 
        ("ğŸ”´ğŸ’ŠğŸ”µğŸ’ŠğŸ•¶ï¸", "THE MATRIX"), 
        ("ğŸ’ğŸŒ‹ğŸ‘ï¸", "THE LORD OF THE RINGS"), 
        ("ğŸ•µï¸â€â™‚ï¸ğŸ”ğŸ‡¬ğŸ‡§", "SHERLOCK HOLMES"), 
        ("ğŸ‘¸ğŸ‘ ğŸƒ", "CINDERELLA"), 
        ("ğŸ§œâ€â™€ï¸ğŸ¦€ğŸ¶", "THE LITTLE MERMAID"), 
        ("ğŸ§â€â™‚ï¸ğŸ…ğŸ•Œ", "ALADDIN"), 
        ("ğŸ‘§ğŸ°ğŸ•³ï¸â±ï¸", "ALICE IN WONDERLAND"), 
        ("ğŸ‘¨â€ğŸš€ğŸŒŒâ³", "INTERSTELLAR"), 
        ("ğŸ”ªğŸš¿ğŸ˜±", "PSYCHO"), 
        ("ğŸ¥ŠğŸƒâ€â™‚ï¸ğŸ¥©", "ROCKY"), 
        ("ğŸš˜ğŸ”™â±ï¸ğŸ‘¨â€ğŸ”¬", "BACK TO THE FUTURE"), 
        ("ğŸ‘»ğŸš«ğŸ”«", "GHOSTBUSTERS"), 
        ("ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ğŸ¦¸â€â™‚ï¸ğŸ¦¸â€â™€ï¸ğŸ‘¶", "THE INCREDIBLES"), 
        ("ğŸ—‘ï¸ğŸ¤–ğŸŒ±", "WALL-E"), 
        ("ğŸ§›â€â™‚ï¸ğŸ¦‡ğŸ©¸", "DRACULA"), 
        ("ğŸï¸ğŸğŸ§”", "CAST AWAY"), 
        ("ğŸ«ğŸƒâ€â™‚ï¸ğŸ¤", "FORREST GUMP"), 
        ("ğŸ±ğŸ‘¢ğŸ—¡ï¸", "PUSS IN BOOTS"),
        ("ğŸ‘®â€â™‚ï¸ğŸ’ªğŸ¦", "SINGHAM"),
        ("ğŸ‘¨â€ğŸ«ğŸ‘½ğŸ›¸", "KOI MIL GAYA"),
        ("ğŸ”«ğŸ‘¨â€ğŸ¦²ğŸ•¶ï¸", "TERMINATOR"),
        ("ğŸï¸ğŸ•¶ï¸ğŸ’£", "DHOOM"),
        ("ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦âœˆï¸ğŸ‡«ğŸ‡·", "HOME ALONE"),
        ("ğŸ§”ğŸ»â›ï¸ğŸª™", "KGF"),
        ("ğŸ«ğŸ‘»ğŸ‘§", "STREE"),
        ("ğŸ‘±â€â™€ï¸ğŸ’–ğŸ‘±â€â™‚ï¸ğŸš‚", "JAB WE MET"),
        ("ğŸ§›â€â™‚ï¸ğŸºğŸŒ™", "TWILIGHT"),
        ("ğŸ¥·ğŸ¦ŠğŸœ", "NARUTO"),
        ("â˜ ï¸ğŸ““ğŸ–Šï¸", "DEATH NOTE"),
        ("ğŸ´â€â˜ ï¸ğŸ‘’ğŸ–", "ONE PIECE"),
        ("ğŸ‘ŠğŸ¥šğŸ‘¨â€ğŸ¦²", "ONE PUNCH MAN"),
        ("ğŸ€â›¹ï¸â€â™‚ï¸", "SLAM DUNK"),
        ("ğŸ¦¸â€â™‚ï¸ğŸ«ğŸ’¥", "MY HERO ACADEMIA"),
        ("ğŸ‘¦ğŸ»ğŸğŸ‘‘", "HAIKYUU"),
        ("ğŸ‘¨â€ğŸ“ğŸ“šğŸ†", "12TH FAIL"),
        ("ğŸ‘¨â€ğŸš€ğŸŒ•ğŸ‡ºğŸ‡¸", "APOLLO 13")
    ],
    3: [ # ğŸ”´ HARD (Tricky / Long Names)
        ("ğŸ‘¨â€ğŸ«ğŸ§ªğŸ’", "BREAKING BAD"), 
        ("ğŸ¤¡ğŸˆâ›µ", "IT"), 
        ("ğŸ¦¹â€â™‚ï¸ğŸ¦‡ğŸƒ", "THE DARK KNIGHT"), 
        ("ğŸ‰ğŸ”¥ğŸ‘¸âš”ï¸", "GAME OF THRONES"), 
        ("ğŸ‘§ğŸ¹ğŸ”¥ğŸ¦", "THE HUNGER GAMES"), 
        ("ğŸ°ğŸ§Ÿâ€â™‚ï¸ğŸŒ¿", "THE LAST OF US"), 
        ("ğŸ‘¨â€ğŸ’¼ğŸ‘”ğŸ”ªğŸ©¸", "AMERICAN PSYCHO"), 
        ("ğŸ¤«ğŸ‘ğŸ‘©â€ğŸ’¼", "THE SILENCE OF THE LAMBS"), 
        ("ğŸ‘¦ğŸ»ğŸ¯ğŸ›¶ğŸŒŠ", "LIFE OF PI"), 
        ("ğŸŒŒâš”ï¸ğŸ¤–â­", "STAR WARS"), 
        ("ğŸ‘¨ğŸ»âœ‚ï¸ğŸ‘", "EDWARD SCISSORHANDS"), 
        ("ğŸ˜´ğŸ’­ğŸ¢ğŸ”„", "INCEPTION"), 
        ("ğŸ»ğŸ¯ğŸˆ", "WINNIE THE POOH"), 
        ("ğŸ‘¨â€ğŸš€ğŸ¥”ğŸš€", "THE MARTIAN"), 
        ("ğŸ’ƒğŸ•ºğŸŒ§ï¸ğŸŒ‚", "SINGIN IN THE RAIN"), 
        ("ğŸ‘¨â€ğŸ¦¯ğŸ¹ğŸ•¶ï¸", "RAY"), 
        ("ğŸ©ğŸ°ğŸ¤¹â€â™‚ï¸", "THE PRESTIGE"), 
        ("ğŸ¦ğŸ¥ŠğŸ¦", "GODZILLA VS KONG"),
        ("ğŸ´â€â˜ ï¸ğŸš¢âš”ï¸ğŸ™", "PIRATES OF THE CARIBBEAN"),
        ("ğŸ‘¨â€ğŸ‘¦ğŸ’¼ğŸƒâ€â™‚ï¸ğŸš‡", "THE PURSUIT OF HAPPYNESS"),
        ("ğŸ¤«ğŸ“ğŸŒ", "A QUIET PLACE"),
        ("ğŸ‘¨â€ğŸ”¬âš›ï¸ğŸ’£", "OPPENHEIMER"),
        ("ğŸ€ğŸ‘ ğŸ’–", "BARBIE"),
        ("ğŸ¦¹â€â™‚ï¸ğŸ§¤ğŸ’", "AVENGERS INFINITY WAR"),
        ("ğŸ•·ï¸ğŸŒ€ğŸŒ", "SPIDER-MAN INTO THE SPIDER-VERSE"),
        ("ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ğŸ”ªğŸšï¸", "PARASITE"),
        ("ğŸ‘¨â€ğŸŒ¾ğŸŒ½ğŸ›¸", "SIGNS"),
        ("ğŸ”ªğŸ§…ğŸ§…", "KNIVES OUT"),
        ("ğŸ¤¡ğŸ”ªğŸƒ", "JOKER"),
        ("ğŸ§ŠğŸª“ğŸ”ª", "THE SHINING"),
        ("ğŸ°ğŸ‰ğŸ”¥", "HOUSE OF THE DRAGON"),
        ("ğŸ§”ğŸ»ğŸ”«ğŸ¶", "JOHN WICK"),
        ("ğŸ’ƒğŸ•ºâ­ğŸŒ†", "LA LA LAND"),
        ("ğŸ§Ÿâ€â™‚ï¸ğŸƒâ€â™‚ï¸ğŸš†", "TRAIN TO BUSAN"),
        ("ğŸª“ğŸŒ²ğŸ©¸", "EVIL DEAD"),
        ("ğŸ§”ğŸ»ğŸª“ğŸ©¸", "ANIMAL"),
        ("ğŸ™ğŸ¦‘ğŸ®ğŸ’°", "SQUID GAME"),
        ("ğŸ‘¨â€ğŸ‘§â³ğŸ“š", "INTERSTELLAR"),
        ("ğŸ¦‡ğŸƒğŸŒ†ğŸ”¥", "THE DARK KNIGHT"),
        ("ğŸ”ªğŸ“ğŸ˜±", "SCREAM")
    ]
}

# ======================================================

REWARD_AMOUNT = 10000

# ==============================================================================
# 1ï¸âƒ£ GUESS THE NUMBER (Premium Edition)
# ==============================================================================
import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# ğŸ”¢ GUESS THE NUMBER: THE DECRYPTION CHALLENGE (ULTRA-PREMIUM)
# ==============================================================================

REWARD_AMOUNT = 10000

# --- 1. THE INPUT MODAL (Pop-up for Guessing) ---
class GuessInputModal(discord.ui.Modal, title="ğŸ”¢ ENTER YOUR GUESS"):
    guess_input = discord.ui.TextInput(
        label="What is the secret number?",
        placeholder="Enter a number between 1 and 100...",
        min_length=1,
        max_length=3,
        required=True
    )

    def __init__(self, parent_view):
        super().__init__()
        self.parent_view = parent_view

    async def on_submit(self, interaction: discord.Interaction):
        if not self.guess_input.value.isdigit():
            return await interaction.response.send_message("âŒ **Invalid Input:** Please enter a number only!", ephemeral=True)
        
        guess = int(self.guess_input.value)
        await self.parent_view.process_guess(interaction, guess)


# --- 2. THE GAME VIEW ---
class GuessNumberView(discord.ui.View):
    def __init__(self, user: discord.Member, secret_number: int, attempts: int):
        super().__init__(timeout=60.0)
        self.user = user
        self.secret_number = secret_number
        self.attempts_left = attempts
        self.game_over = False
        self.last_hint = "No guesses yet."

    @discord.ui.button(label="SUBMIT GUESS", style=discord.ButtonStyle.primary, emoji="ğŸ”“")
    async def guess_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user.id:
            return await interaction.response.send_message("âŒ **Guard:** This terminal is locked to the operator.", ephemeral=True)
        
        await interaction.response.send_modal(GuessInputModal(self))

    async def process_guess(self, interaction: discord.Interaction, guess: int):
        if self.game_over: return
        
        self.attempts_left -= 1
        
        if guess == self.secret_number:
            # ğŸ‰ WINNER
            self.game_over = True
            self.stop()
            
            # ğŸ’¸ Safe Reward
            await smart_reward(self.user.id, REWARD_AMOUNT)
            
            embed = discord.Embed(title="ğŸ‰ JACKPOT! SYSTEM DECRYPTED", color=0x2ECC71)
            embed.set_thumbnail(url=self.user.display_avatar.url)
            embed.description = (
                f"### ğŸ”“ SUCCESSFUL ACCESS\n"
                f"The secret number was indeed **{self.secret_number}**!\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ’° **Reward:** `${REWARD_AMOUNT:,}`\n"
                f" â”— ğŸ† **Status:** `Winner`"
            )
            embed.set_image(url="https://media.tenor.com/p7a8o1r5c8cAAAAC/money-rain.gif")
            await interaction.response.edit_message(embed=embed, view=None)

        elif self.attempts_left <= 0:
            # ğŸ’€ OUT OF ATTEMPTS
            self.game_over = True
            self.stop()
            
            embed = discord.Embed(title="ğŸ’€ CONNECTION TERMINATED", color=0xE74C3C)
            embed.description = (
                f"### âŒ GAME OVER\n"
                f"You failed to crack the code.\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ”¢ **The Number was:** `{self.secret_number}`\n"
                f" â”— ğŸ’¸ **Lost:** `$0` (Better luck next time)"
            )
            await interaction.response.edit_message(embed=embed, view=None)
            
        else:
            # â¬†ï¸â¬‡ï¸ HINT LOGIC
            self.last_hint = "â¬†ï¸ **HIGHER!**" if guess < self.secret_number else "â¬‡ï¸ **LOWER!**"
            
            embed = interaction.message.embeds[0]
            embed.description = (
                f"### ğŸ§ª DECRYPTION IN PROGRESS...\n"
                f"Find the secret number between **1 and 100**.\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ“‰ **Last Guess:** `{guess}`\n"
                f" â”£ ğŸ’¡ **Hint:** {self.last_hint}\n"
                f" â”— â³ **Attempts Left:** `{self.attempts_left}`\n"
            )
            embed.color = 0xF1C40F # Warning Yellow
            await interaction.response.edit_message(embed=embed, view=self)

    async def on_timeout(self):
        if self.game_over: return
        self.game_over = True
        for child in self.children: child.disabled = True
        # Note: In on_timeout we can't edit interaction easily without saving original msg


# --- 3. MAIN COMMAND ---
@bot.tree.command(name="guess_number", description="ğŸ”¢ Crack the secret code to win $10,000!")
@check_seized()
async def guess_number(interaction: discord.Interaction):
    # â³ 1. DEFER
    await interaction.response.defer(ephemeral=False)
    
    secret_number = random.randint(1, 100)
    attempts = 5
    
    # ğŸ§ª 2. INITIAL EMBED
    embed = discord.Embed(title="ğŸ”¢ NUMERICAL DECRYPTION", color=0x3498DB)
    embed.set_thumbnail(url=interaction.user.display_avatar.url)
    embed.description = (
        f"### ğŸŒ SYSTEM CHALLENGE\n"
        f"I have encrypted a number between **1 and 100**.\n"
        f"You have **{attempts} attempts** to bypass the security.\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f" â”£ ğŸ’° **Reward:** `${REWARD_AMOUNT:,}`\n"
        f" â”£ â³ **Timeout:** `60 Seconds`\n"
        f" â”— ğŸ”“ **Action:** Click the button to guess!"
    )
    embed.set_footer(text=f"Agent: {interaction.user.name}")
    
    view = GuessNumberView(interaction.user, secret_number, attempts)
    await interaction.followup.send(embed=embed, view=view)


# ==============================================================================
# 2ï¸âƒ£ WORD SCRAMBLE (Level Based)
# ==============================================================================
import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# ğŸ”  TITAN GAMES: WORD SCRAMBLE (ULTRA-PREMIUM)
# ==============================================================================

# --- 1. THE INPUT MODAL (Pop-up for Answer) ---
class ScrambleModal(discord.ui.Modal, title="ğŸ”  SOLVE THE PUZZLE"):
    answer_input = discord.ui.TextInput(
        label="What is the unscrambled word?",
        placeholder="Enter your answer here...",
        min_length=3,
        max_length=15,
        required=True
    )

    def __init__(self, parent_view):
        super().__init__()
        self.parent_view = parent_view

    async def on_submit(self, interaction: discord.Interaction):
        # Answer check
        user_answer = self.answer_input.value.strip().upper()
        await self.parent_view.process_answer(interaction, user_answer)


# --- 2. THE GAME VIEW ---
class ScrambleView(discord.ui.View):
    def __init__(self, user: discord.Member, original_word: str, scrambled_word: str, level_name: str):
        super().__init__(timeout=45.0) # â³ 45 Seconds total session
        self.user = user
        self.original_word = original_word.upper()
        self.scrambled_word = scrambled_word
        self.level_name = level_name
        self.game_over = False

    @discord.ui.button(label="SUBMIT ANSWER", style=discord.ButtonStyle.primary, emoji="âœï¸")
    async def answer_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user.id:
            return await interaction.response.send_message("âŒ **Guard:** This puzzle is assigned to someone else.", ephemeral=True)
        
        await interaction.response.send_modal(ScrambleModal(self))

    async def process_answer(self, interaction: discord.Interaction, user_answer: str):
        if self.game_over: return
        self.game_over = True
        self.stop()
        
        # Disable buttons
        for child in self.children: child.disabled = True

        if user_answer == self.original_word:
            # âœ… CORRECT: VICTORY
            await smart_reward(self.user.id, REWARD_AMOUNT) # ğŸ’¸ Safe Reward

            embed = discord.Embed(title="âœ… PUZZLE SOLVED!", color=0x2ECC71)
            embed.set_thumbnail(url=self.user.display_avatar.url)
            embed.description = (
                f"### ğŸ† BRILLIANT WORK!\n"
                f"You decoded the word perfectly.\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ§© **The Word:** `{self.original_word}`\n"
                f" â”£ ğŸ’° **Reward:** `${REWARD_AMOUNT:,}`\n"
                f" â”— ğŸ† **Status:** `Winner`"
            )
            embed.set_image(url="https://media.tenor.com/p7a8o1r5c8cAAAAC/money-rain.gif")
            await interaction.response.edit_message(embed=embed, view=None)
        else:
            # âŒ WRONG: DEFEAT
            embed = discord.Embed(title="âŒ DECODER FAILED", color=0xE74C3C)
            embed.description = (
                f"### ğŸ’€ MISSION FAILED\n"
                f"That was not the correct sequence.\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ§© **Correct Word:** `{self.original_word}`\n"
                f" â”£ âœï¸ **Your Guess:** `{user_answer}`\n"
                f" â”— ğŸ’¸ **Lost:** `$0`"
            )
            await interaction.response.edit_message(embed=embed, view=None)

    async def on_timeout(self):
        if self.game_over: return
        self.game_over = True
        for child in self.children: child.disabled = True
        # Note: Message edit in on_timeout requires saving the message object


# --- 3. MAIN COMMAND ---
@bot.tree.command(name="scramble", description="ğŸ”  Word Scramble: Unscramble the word to win cash!")
@app_commands.describe(level="Select Difficulty Level")
@app_commands.choices(level=[
    app_commands.Choice(name="ğŸŸ¢ Easy (4-5 Letters)", value=1),
    app_commands.Choice(name="ğŸŸ¡ Medium (6-7 Letters)", value=2),
    app_commands.Choice(name="ğŸ”´ Hard (8+ Letters)", value=3)
])
@check_seized()
async def scramble(i: discord.Interaction, level: app_commands.Choice[int]):
    await i.response.defer(ephemeral=False) 
    
    # ğŸ—„ï¸ Fetch words from your config (Example words below)
    # SCRAMBLE_WORDS = {1: ["APPLE", "GOLD"], 2: ["TITANIC", "CRYPTO"], 3: ["BLOCKCHAIN", "ALGORITHM"]}
    try:
        word_list = SCRAMBLE_WORDS.get(level.value, ["TITAN"])
        word = random.choice(word_list).upper()
    except:
        word = "TITAN"

    # Scramble Logic
    scrambled = list(word)
    random.shuffle(scrambled)
    scrambled_word = "".join(scrambled)
    
    while scrambled_word == word:
        random.shuffle(scrambled)
        scrambled_word = "".join(scrambled)

    # Initial Embed
    embed = discord.Embed(title="ğŸ”  TITAN WORD SCRAMBLE", color=0x9B59B6)
    embed.set_thumbnail(url=i.user.display_avatar.url)
    embed.description = (
        f"### ğŸ§© UNSCRAMBLE THE PAYLOAD\n"
        f"Decode the jumbled letters to claim the reward.\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f" â”£ ğŸ”´ **Scrambled:** `{scrambled_word}`\n"
        f" â”£ ğŸ“Š **Difficulty:** `{level.name}`\n"
        f" â”£ ğŸ’° **Reward:** `${REWARD_AMOUNT:,}`\n"
        f" â”— â³ **Time Limit:** `30 Seconds`\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"ğŸ‘‰ **Click the button below to submit your answer!**"
    )
    
    view = ScrambleView(i.user, word, scrambled_word, level.name)
    await i.followup.send(embed=embed, view=view)


# ==============================================================================
# 3ï¸âƒ£ EMOJI PUZZLE (Level Based)
# ==============================================================================
import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# ğŸ­ TITAN GAMES: EMOJI PUZZLE CHALLENGE (ULTRA-PREMIUM)
# ==============================================================================

# --- 1. THE INPUT MODAL (Answer Pop-up) ---
class EmojiAnswerModal(discord.ui.Modal, title="ğŸ­ GUESS THE MOVIE/WORD"):
    answer_input = discord.ui.TextInput(
        label="What is your answer?",
        placeholder="Enter the full name here...",
        min_length=1,
        max_length=50,
        required=True
    )

    def __init__(self, parent_view):
        super().__init__()
        self.parent_view = parent_view

    async def on_submit(self, interaction: discord.Interaction):
        # Normalize the answer
        cleaned_answer = self.answer_input.value.strip().upper()
        await self.parent_view.process_answer(interaction, cleaned_answer)


# --- 2. THE GAME VIEW ---
class EmojiPuzzleView(discord.ui.View):
    def __init__(self, user: discord.Member, correct_answer: str, puzzle: str, level_name: str):
        super().__init__(timeout=45.0) # â³ 45 second session
        self.user = user
        self.correct_answer = correct_answer.upper()
        self.puzzle = puzzle
        self.level_name = level_name
        self.game_over = False

    @discord.ui.button(label="ENTER ANSWER", style=discord.ButtonStyle.primary, emoji="ğŸ­")
    async def answer_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user.id:
            return await interaction.response.send_message("âŒ **Guard:** This puzzle is locked to another player.", ephemeral=True)
        
        await interaction.response.send_modal(EmojiAnswerModal(self))

    async def process_answer(self, interaction: discord.Interaction, user_answer: str):
        if self.game_over: return
        self.game_over = True
        self.stop()
        
        # Disable terminal buttons
        for child in self.children: child.disabled = True

        if user_answer == self.correct_answer:
            # âœ… CORRECT: VICTORY
            await smart_reward(self.user.id, REWARD_AMOUNT) # ğŸ’¸ Safe DB Reward

            embed = discord.Embed(title="âœ… YOU NAILED IT!", color=0x2ECC71)
            embed.set_thumbnail(url=self.user.display_avatar.url)
            embed.description = (
                f"### ğŸ† ELITE PERCEPTION!\n"
                f"Your deduction was 100% accurate.\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ§© **Emojis:** {self.puzzle}\n"
                f" â”£ ğŸ­ **Answer:** `{self.correct_answer}`\n"
                f" â”£ ğŸ’° **Reward:** `${REWARD_AMOUNT:,}`\n"
                f" â”— ğŸ† **Status:** `Winner`"
            )
            embed.set_image(url="https://media.tenor.com/bXjOidvDvoQAAAAC/confetti-celebrate.gif")
            await interaction.response.edit_message(embed=embed, view=None)
        else:
            # âŒ WRONG: DEFEAT
            embed = discord.Embed(title="âŒ ACCESS DENIED", color=0xE74C3C)
            embed.description = (
                f"### ğŸ’€ INCORRECT DEDUCTION\n"
                f"The code remains uncracked.\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ§© **Emojis:** {self.puzzle}\n"
                f" â”£ ğŸ­ **Correct Answer:** `{self.correct_answer}`\n"
                f" â”£ âœï¸ **Your Guess:** `{user_answer}`\n"
                f" â”— ğŸ’¸ **Lost:** `$0`"
            )
            await interaction.response.edit_message(embed=embed, view=None)

    async def on_timeout(self):
        if self.game_over: return
        self.game_over = True
        for child in self.children: child.disabled = True


# --- 3. MAIN COMMAND ---
@bot.tree.command(name="emojipuzzle", description="ğŸ­ Guess the movie/word from emojis to win $10,000!")
@app_commands.describe(level="Select Difficulty Level")
@app_commands.choices(level=[
    app_commands.Choice(name="ğŸŸ¢ Easy", value=1),
    app_commands.Choice(name="ğŸŸ¡ Medium", value=2),
    app_commands.Choice(name="ğŸ”´ Hard", value=3)
])
@check_seized()
async def emojipuzzle(i: discord.Interaction, level: app_commands.Choice[int]):
    await i.response.defer(ephemeral=False)
    
    # ğŸ—„ï¸ Fetch from your EMOJI_PUZZLES config
    try:
        puzzle, answer = random.choice(EMOJI_PUZZLES.get(level.value))
    except:
        return await i.followup.send("âŒ **Config Error:** Emoji puzzles not loaded.", ephemeral=True)

    # Initial Game Embed
    embed = discord.Embed(title="ğŸ­ TITAN EMOJI PUZZLE", color=0xF1C40F) # Yellow
    embed.set_thumbnail(url=i.user.display_avatar.url)
    embed.description = (
        f"### ğŸ§© ANALYZE THE ICONS\n"
        f"Can you identify the hidden movie or word?\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f" â”£ ğŸ“Š **Difficulty:** `{level.name}`\n"
        f" â”£ ğŸ’° **Reward:** `${REWARD_AMOUNT:,}`\n"
        f" â”£ â³ **Time Limit:** `30 Seconds`\n"
        f" â”— âš¡ **Emojis:** {puzzle}\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"ğŸ‘‰ **Click the button below to submit your guess!**"
    )
    
    view = EmojiPuzzleView(i.user, answer, puzzle, level.name)
    await i.followup.send(embed=embed, view=view)


# ==============================================================================
# 4ï¸âƒ£ SUPREME LOOTBOX (High Risk, RNG Based)
# ==============================================================================
import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# ğŸ“¦ TITAN ECONOMY: MYSTERY LOOTBOX SYSTEM (ULTRA-PREMIUM)
# ==============================================================================

LOOTBOX_PRICE = 5000 # Configurable

@games_group.command(name="lootbox", description=f"ğŸ“¦ Purchase a Mysterious Lootbox for ${LOOTBOX_PRICE:,}")
@check_seized()
async def lootbox(i: discord.Interaction):
    # â³ 1. SECURE INITIALIZATION
    await i.response.defer(ephemeral=False)
    
    # ğŸ’³ 2. SMART CHARGE (Checks Wallet + Bank)
    paid = await smart_charge(i.user.id, LOOTBOX_PRICE)
    if not paid:
        embed = discord.Embed(title="ğŸš¨ INSUFFICIENT FUNDS", color=0xE74C3C)
        embed.description = f"âŒ You need at least **${LOOTBOX_PRICE:,}** (Wallet + Bank) to purchase this crate."
        return await i.followup.send(embed=embed)

    # ğŸŒ€ 3. SUSPENSE ANIMATION
    anim_embed = discord.Embed(title="ğŸ“¦ UNBOXING IN PROGRESS...", color=0x2b2d31)
    anim_embed.description = (
        f"### âš™ï¸ ANALYZING CRATE CONTENTS...\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"**Buyer:** {i.user.mention}\n"
        f"**Cost:** `${LOOTBOX_PRICE:,}`\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"*Decoding the mysterious security locks...*"
    )
    anim_embed.set_image(url="https://media.tenor.com/E0lQ-J9YpKwAAAAC/chest-open.gif")
    await i.followup.send(embed=anim_embed)
    
    await asyncio.sleep(3.5) # The Wait of Destiny...

    # ğŸ² 4. THE RNG ENGINE
    # Items: Poop, Wood, Gold, Platinum, Diamond, Cash
    outcomes = ["poop", "wood", "gold", "platinum", "diamond", "cash"]
    weights = [80.0, 12.0, 5.0, 2.0, 0.5, 0.5] # Slightly adjusted for better balance
    
    result = random.choices(outcomes, weights=weights, k=1)[0]
    
    # ğŸ“Š 5. FETCH INVENTORY FOR UPDATE
    try:
        res = await db_call(lambda: supabase.table("economy").select("inventory").eq("user_id", str(i.user.id)).execute())
        curr_inv = res.data[0].get('inventory', {}) or {} if res and res.data else {}
    except:
        curr_inv = {}

    # ğŸ 6. PROCESS RESULT
    final_embed = discord.Embed(title="ğŸ“¦ CRATE UNLOCKED")
    final_embed.set_thumbnail(url=i.user.display_avatar.url)
    status_msg = ""

    if result == "poop":
        final_embed.title = "ğŸ’© YOU GOT TRASH!"
        final_embed.color = 0x8b4513 # Brown
        final_embed.description = "## POOP!\nBetter luck next time. You found a steaming pile of nothing."
        final_embed.set_image(url="https://media.tenor.com/P1f8q1dd2fAAAAAC/glitch-static.gif")
        
    elif result == "cash":
        cash_won = random.randint(5000, 150000) # Big potential
        await smart_reward(i.user.id, cash_won)
        final_embed.title = "ğŸ’µ CASH JACKPOT!"
        final_embed.color = 0x2ecc71
        final_embed.description = f"## PURE CASH!\nYou found a hidden pouch of money inside!\n\n**Payout:** `+${cash_won:,}`"
        final_embed.set_image(url="https://media.tenor.com/p7a8o1r5c8cAAAAC/money-rain.gif")

    else:
        # IT'S AN ITEM (Wood, Gold, Platinum, Diamond)
        item_names = {
            "wood": ("ğŸªµ WOOD LOG", 0xa0522d, "https://cdn-icons-png.flaticon.com/512/3522/3522604.png"),
            "gold": ("ğŸª™ GOLD CHUNK", 0xFFD700, "https://cdn-icons-png.flaticon.com/512/2613/2613123.png"),
            "platinum": ("ğŸ’¿ RARE PLATINUM", 0xe5e4e2, "https://cdn-icons-png.flaticon.com/512/10427/10427244.png"),
            "diamond": ("ğŸ’ LEGENDARY DIAMOND", 0x00ffff, "https://cdn-icons-png.flaticon.com/512/2874/2874136.png")
        }
        name, color, icon = item_names[result]
        
        # UPDATE INVENTORY
        curr_inv[result] = curr_inv.get(result, 0) + 1
        await db_call(lambda: supabase.table("economy").update({"inventory": curr_inv}).eq("user_id", str(i.user.id)).execute())
        
        final_embed.title = name
        final_embed.color = color
        final_embed.description = f"## {name}!\nA rare find! This item has been added to your **inventory**."
        final_embed.set_thumbnail(url=icon)

    # Final Polish
    final_embed.description += (
        f"\n\nâ–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f" â”£ ğŸ‘¤ **Operator:** {i.user.mention}\n"
        f" â”— ğŸ“¦ **Crate Status:** `Depleted`"
    )
    
    await i.edit_original_response(embed=final_embed)


import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# ğŸƒ TITAN ARCADE: DODGE SURVIVAL (ULTRA-PREMIUM REFLEX GAME)
# ==============================================================================

REWARD_AMOUNT = 10000
ENTRY_FEE = 500

class DodgeSurvivalGame(discord.ui.View):
    def __init__(self, player: discord.Member, level_name: str, max_rounds: int, reaction_time: float, message: discord.Message):
        super().__init__(timeout=180) # â³ 3 Min Max Session
        self.player = player
        self.level_name = level_name
        self.max_rounds = max_rounds
        self.reaction_time = reaction_time
        self.message = message
        
        self.current_round = 1
        self.danger_lane = None
        self.game_over = False
        self.won = False
        self.clicked_this_round = False
        self.timer_task = None # To cancel the timeout if they click fast enough

        self.lanes = ["LEFT", "CENTER", "RIGHT"]

    async def start_round(self):
        if self.game_over or self.won: return

        self.clicked_this_round = False
        self.danger_lane = random.choice(self.lanes)

        # ğŸ¨ Premium Visual Track
        track_lines = []
        for lane in self.lanes:
            if lane == self.danger_lane:
                track_lines.append(f"ğŸŸ¥ **[ DANGER ]** ` {lane} `")
            else:
                track_lines.append(f"ğŸŸ© **[  SAFE  ]** ` {lane} `")
                
        embed = discord.Embed(title="ğŸƒ DODGE SURVIVAL: ACTIVE RUN", color=0xE74C3C) # Action Red
        embed.description = (
            f"### ğŸ›‘ OBSTACLE IN THE **{self.danger_lane}** LANE!\n"
            f"**Click a GREEN lane before time runs out!**\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"**ğŸ›£ï¸ THE TRACK:**\n" + "\n".join(track_lines) + "\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ”„ **Round:** `{self.current_round}/{self.max_rounds}`\n"
            f" â”£ ğŸ“Š **Difficulty:** `{self.level_name}`\n"
            f" â”— â³ **Time to React:** `{self.reaction_time}s`\n"
        )
        embed.set_thumbnail(url=self.player.display_avatar.url)
        embed.set_image(url="https://media.tenor.com/mO2Xp_Aet1sAAAAC/running-run.gif") 

        try:
            await self.message.edit(embed=embed, view=self)
        except Exception as e:
            print(f"Dodge Edit Error: {e}")
            return

        # â±ï¸ LAUNCH SMART TIMER
        self.timer_task = asyncio.create_task(self.round_timer(self.current_round))

    async def round_timer(self, round_snapshot: int):
        """Wait for reaction time. If round hasn't changed, kill the player."""
        try:
            await asyncio.sleep(self.reaction_time)
            
            # If the round is still the same and they haven't clicked, they are too slow!
            if not self.game_over and not self.won and self.current_round == round_snapshot and not self.clicked_this_round:
                self.game_over = True
                await self.end_game(reason=f"â³ **TOO SLOW!**\nYou failed to react within `{self.reaction_time}s` and got crushed!", success=False)
        except asyncio.CancelledError:
            # Timer was cancelled because they clicked fast enough. All good!
            pass

    @discord.ui.button(label="DODGE LEFT", emoji="â¬…ï¸", style=discord.ButtonStyle.primary, custom_id="LEFT")
    async def btn_left(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.handle_dodge(interaction, "LEFT")

    @discord.ui.button(label="DODGE CENTER", emoji="â¬†ï¸", style=discord.ButtonStyle.primary, custom_id="CENTER")
    async def btn_center(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.handle_dodge(interaction, "CENTER")

    @discord.ui.button(label="DODGE RIGHT", emoji="â¡ï¸", style=discord.ButtonStyle.primary, custom_id="RIGHT")
    async def btn_right(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.handle_dodge(interaction, "RIGHT")

    async def handle_dodge(self, interaction: discord.Interaction, chosen_lane: str):
        # 1. Security & State Checks
        if interaction.user.id != self.player.id:
            return await interaction.response.send_message("âŒ **Guard:** This is not your run!", ephemeral=True)

        if self.game_over or self.won or self.clicked_this_round:
            return await interaction.response.defer() # Ignore spam clicks

        self.clicked_this_round = True # Lock further clicks for this round
        await interaction.response.defer() # â³ Instant Defer
        
        # Kill the timer since they reacted
        if self.timer_task and not self.timer_task.done():
            self.timer_task.cancel()

        # 2. Check Collision
        if chosen_lane == self.danger_lane:
            self.game_over = True
            await self.end_game(reason=f"ğŸ’¥ **FATAL CRASH!**\nYou dodged directly into the **{chosen_lane}** obstacle!", success=False)
        else:
            # 3. Successful Dodge
            self.current_round += 1
            
            if self.current_round > self.max_rounds:
                # ğŸ‰ VICTORY
                self.won = True
                await self.end_game(reason="### ğŸ† SURVIVAL COMPLETE!\nYou flawlessly dodged every obstacle like a true Titan Ninja!", success=True)
            else:
                # â¡ï¸ NEXT ROUND PREP
                success_embed = discord.Embed(title="âœ… PERFECT DODGE!", color=0x2ECC71)
                success_embed.description = f"*Speeding up for Round {self.current_round}... Brace yourself!*"
                
                # Briefly disable buttons to show transition
                for child in self.children: child.disabled = True
                await self.message.edit(embed=success_embed, view=self)
                
                # Re-enable buttons and start next round
                await asyncio.sleep(0.8) # Short breather
                for child in self.children: child.disabled = False
                await self.start_round()

    async def end_game(self, reason: str, success: bool):
        for child in self.children: child.disabled = True # Lock UI
        self.stop()

        embed = discord.Embed()
        
        if success:
            embed.title = "ğŸ‰ MISSION ACCOMPLISHED"
            embed.color = 0x2ECC71 # Green
            embed.set_thumbnail(url=self.player.display_avatar.url)
            embed.description = (
                f"{reason}\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ… **Difficulty:** `{self.level_name}`\n"
                f" â”£ ğŸ’° **Reward:** `+${REWARD_AMOUNT:,}`\n"
                f" â”— ğŸ† **Status:** `Winner`"
            )
            embed.set_image(url="https://media.tenor.com/bXjOidvDvoQAAAAC/confetti-celebrate.gif")
            
            # ğŸ’¸ Safe DB Reward
            await smart_reward(self.player.id, REWARD_AMOUNT)
            
        else:
            embed.title = "ğŸ’€ WASTED"
            embed.color = 0x8B0000 # Dark Red
            embed.set_thumbnail(url=self.player.display_avatar.url)
            embed.description = (
                f"{reason}\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ… **Difficulty:** `{self.level_name}`\n"
                f" â”£ ğŸ“‰ **Survived Until:** `Round {self.current_round}`\n"
                f" â”— ğŸ’¸ **Lost:** `Entry Fee (${ENTRY_FEE})`"
            )
            embed.set_image(url="https://media.tenor.com/d6-SreC3_p8AAAAC/wasted-gta5.gif")

        try: await self.message.edit(embed=embed, view=self)
        except: pass


# ==============================================================================
# ğŸ’» MAIN COMMAND
# ==============================================================================
@games_group.command(name="dodge", description=f"ğŸƒ Dodge obstacles in this fast-paced reaction game! (Fee: ${ENTRY_FEE})")
@app_commands.describe(level="Select Difficulty Level")
@app_commands.choices(level=[
    app_commands.Choice(name="ğŸŸ¢ Easy (5 Rounds | 3.0s Reaction)", value="easy"),
    app_commands.Choice(name="ğŸŸ¡ Medium (8 Rounds | 2.0s Reaction)", value="medium"),
    app_commands.Choice(name="ğŸ”´ Hard (12 Rounds | 1.2s Reaction)", value="hard"),
    app_commands.Choice(name="ğŸ’€ EXTREME (15 Rounds | 0.8s Reaction)", value="extreme")
])
@check_seized()
async def dodge_game(interaction: discord.Interaction, level: app_commands.Choice[str]):
    
    # â³ 1. SECURE INITIALIZATION
    await interaction.response.defer(ephemeral=False)

    # ğŸ’³ 2. SMART CHARGE ENTRY FEE
    paid = await smart_charge(interaction.user.id, ENTRY_FEE)
    if not paid:
        embed = discord.Embed(title="ğŸš¨ INSUFFICIENT FUNDS", color=0xE74C3C)
        embed.description = f"âŒ You need at least **${ENTRY_FEE:,}** (Wallet + Bank) to enter the Dodge Arena."
        return await interaction.followup.send(embed=embed)

    # âš™ï¸ 3. CONFIGURE DIFFICULTY
    settings = {
        "easy": {"rounds": 5, "time": 3.0},
        "medium": {"rounds": 8, "time": 2.0},
        "hard": {"rounds": 12, "time": 1.2},
        "extreme": {"rounds": 15, "time": 0.8} # True Ninja Level
    }
    cfg = settings[level.value]
    clean_level_name = level.name.split(" ")[1] # Extracts "Easy", "Medium", etc.
    
    # ğŸ“¢ 4. INTRO SEQUENCE
    intro_embed = discord.Embed(title="ğŸƒ TITAN ARENA: DODGE SURVIVAL", color=0x3498DB)
    intro_embed.set_thumbnail(url=interaction.user.display_avatar.url)
    intro_embed.description = (
        f"### âš ï¸ PREPARE YOUR REFLEXES\n"
        f"**Agent:** {interaction.user.mention}\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f" â”£ ğŸ“Š **Difficulty:** `{clean_level_name}`\n"
        f" â”£ ğŸ¯ **Target:** `Survive {cfg['rounds']} Rounds`\n"
        f" â”— â±ï¸ **Reaction Time:** `{cfg['time']} Seconds`\n\n"
        f"**RULES:**\n"
        f"An obstacle ğŸŸ¥ will appear in one of 3 lanes.\n"
        f"You must click a **SAFE LANE** (ğŸŸ©) before the timer runs out!\n\n"
        f"> *The run begins in 3 seconds... Brace yourself!*"
    )
    
    msg = await interaction.followup.send(embed=intro_embed, wait=True)
    await asyncio.sleep(3) # Countdown Suspense
    
    # ğŸš€ 5. LAUNCH GAME
    game_view = DodgeSurvivalGame(
        player=interaction.user, 
        level_name=clean_level_name, 
        max_rounds=cfg["rounds"], 
        reaction_time=cfg["time"],
        message=msg
    )
    
    await game_view.start_round()


import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# ğŸ¡ TITAN CASINO: WHEEL OF FORTUNE (HIGH RISK, HIGH REWARD)
# ==============================================================================

SPIN_COST = 5000

@games_group.command(name="spin", description=f"ğŸ¡ Spin the Wheel of Fortune! Win up to $1M or lose it all. (Cost: ${SPIN_COST:,})")
@check_seized()
async def spin_wheel(interaction: discord.Interaction):
    # â³ 1. SECURE INITIALIZATION
    await interaction.response.defer(ephemeral=False)
    
    # ğŸ’³ 2. SMART CHARGE (Anti-Cheat: Deduct before spinning)
    paid = await smart_charge(interaction.user.id, SPIN_COST)
    if not paid:
        embed = discord.Embed(title="ğŸš¨ TRANSACTION DECLINED", color=0xE74C3C)
        embed.description = f"âŒ **Broke:** You need at least **${SPIN_COST:,}** (Wallet + Bank) to buy a spin ticket."
        return await interaction.followup.send(embed=embed)

    # ğŸŒ€ 3. SUSPENSE ANIMATION
    anim_embed = discord.Embed(title="ğŸ¡ TITAN CASINO: WHEEL OF FORTUNE", color=0xF1C40F) # Gold
    anim_embed.description = (
        f"### âš™ï¸ THE WHEEL IS TURNING...\n"
        f"**Player:** {interaction.user.mention}\n"
        f"**Ticket Cost:** `${SPIN_COST:,}`\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"> *Calculating momentum and friction...*\n"
        f"> *Will you become a millionaire or go bankrupt?*"
    )
    anim_embed.set_image(url="https://media.tenor.com/7b58Hk1E5i0AAAAC/spin-the-wheel-wheel-of-fortune.gif")
    
    await interaction.followup.send(embed=anim_embed)
    
    # Let the wheel spin for 4 seconds
    await asyncio.sleep(4.0) 

    # ğŸ² 4. RNG ENGINE (True Probability)
    outcomes = ["SMALL", "NOTHING", "MEDIUM", "BANKRUPT", "JACKPOT"]
    weights = [40.0, 30.0, 15.0, 10.0, 5.0]
    result = random.choices(outcomes, weights=weights, k=1)[0]
    
    # ğŸ“Š 5. PROCESS RESULT
    final_embed = discord.Embed(title="ğŸ¡ WHEEL OF FORTUNE: RESULT")
    final_embed.set_thumbnail(url=interaction.user.display_avatar.url)
    
    desc = f"### ğŸ›‘ THE WHEEL HAS STOPPED\n**Player:** {interaction.user.mention}\nâ–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
    
    try:
        if result == "SMALL":
            win_amount = random.randint(6000, 15000)
            await smart_reward(interaction.user.id, win_amount)
            
            final_embed.color = 0x2ECC71 # Green
            desc += f" â”£ ğŸ¯ **Outcome:** `GREEN SLOT (Small Win)`\n"
            desc += f" â”£ ğŸ“ˆ **Investment:** `${SPIN_COST:,}`\n"
            desc += f" â”— ğŸ’° **Payout:** `+${win_amount:,}`\n"
            
        elif result == "MEDIUM":
            win_amount = random.randint(25000, 75000)
            await smart_reward(interaction.user.id, win_amount)
            
            final_embed.color = 0x3498DB # Blue
            desc += f" â”£ ğŸ¯ **Outcome:** `BLUE SLOT (Medium Win)`\n"
            desc += f" â”£ ğŸ“ˆ **Investment:** `${SPIN_COST:,}`\n"
            desc += f" â”— ğŸ’° **Payout:** `+${win_amount:,}`\n"
            
        elif result == "JACKPOT":
            win_amount = random.randint(500000, 1000000) # $500k to $1M
            await smart_reward(interaction.user.id, win_amount)
            
            final_embed.color = 0x9B59B6 # Purple/Gold
            desc += f" â”£ ğŸ¯ **Outcome:** `GOLDEN SLOT (MEGA JACKPOT!)`\n"
            desc += f" â”£ ğŸ“ˆ **Investment:** `${SPIN_COST:,}`\n"
            desc += f" â”— ğŸ‘‘ **MASSIVE PAYOUT:** `+${win_amount:,}`\n\n"
            desc += f"> *THE ENTIRE CASINO IS CHEERING FOR YOU!*"
            final_embed.set_image(url="https://media.tenor.com/bXjOidvDvoQAAAAC/confetti-celebrate.gif")
            
        elif result == "NOTHING":
            final_embed.color = 0x95A5A6 # Grey
            desc += f" â”£ ğŸ¯ **Outcome:** `BLANK SLOT (Nothing)`\n"
            desc += f" â”£ ğŸ“‰ **Investment:** `${SPIN_COST:,}`\n"
            desc += f" â”— ğŸ’¸ **Net Loss:** `-$5,000`\n\n"
            desc += f"> *Tough luck. The house takes your money.*"
            
        elif result == "BANKRUPT":
            penalty = 25000
            # Charge an extra penalty if they have it
            await smart_charge(interaction.user.id, penalty)
            
            final_embed.color = 0xE74C3C # Red
            desc += f" â”£ ğŸ¯ **Outcome:** `RED SKULL (BANKRUPT!)`\n"
            desc += f" â”£ ğŸ“‰ **Investment:** `${SPIN_COST:,}`\n"
            desc += f" â”— ğŸ’€ **Penalty Applied:** `-$25,000`\n\n"
            desc += f"> *You hit the trap! The casino guards have emptied your pockets.*"
            final_embed.set_image(url="https://media.tenor.com/d6-SreC3_p8AAAAC/wasted-gta5.gif")
            
    except Exception as e:
        print(f"Spin Wheel Error: {e}")
        desc += f"\nâŒ **System Error:** Failed to process payout."

    final_embed.description = desc
    final_embed.set_footer(text="Titan Casino â€¢ Play Responsibly", icon_url=interaction.client.user.display_avatar.url)
    
    await interaction.edit_original_response(embed=final_embed)


# ==============================================================================
# âš”ï¸ 2. RPG SOLO ADVENTURE (Interactive Text-Based RPG)
# ==============================================================================
import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# ğŸŒ² TITAN RPG: THE WILDERNESS ADVENTURE
# ==============================================================================

class RPGAdventureView(discord.ui.View):
    def __init__(self, player: discord.Member, encounter_type: str, enemy_name: str, enemy_power: int, message: discord.Message = None):
        super().__init__(timeout=45.0) # â³ 45 Seconds to decide
        self.player = player
        self.encounter_type = encounter_type
        self.enemy_name = enemy_name
        self.enemy_power = enemy_power 
        self.message = message
        self.game_over = False

    async def lock_view(self):
        """Disables all buttons safely"""
        self.game_over = True
        self.stop()
        for child in self.children:
            child.disabled = True

    @discord.ui.button(label="FIGHT OR DIE", emoji="âš”ï¸", style=discord.ButtonStyle.danger)
    async def btn_fight(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.player.id:
            return await interaction.response.send_message("âŒ **Guard:** This monster is hunting someone else!", ephemeral=True)
        
        await interaction.response.defer()
        await self.lock_view()
        
        # ğŸ² THE COMBAT ENGINE (RNG)
        player_roll = random.randint(1, 100)
        enemy_roll = random.randint(1, self.enemy_power)
        
        result_embed = discord.Embed(title="âš”ï¸ COMBAT LOG")
        result_embed.set_thumbnail(url=self.player.display_avatar.url)
        
        if player_roll >= enemy_roll:
            # ğŸ‰ VICTORY
            reward = random.randint(self.enemy_power * 100, self.enemy_power * 500)
            await smart_reward(self.player.id, reward) # ğŸ’¸ Safe Payout
            
            result_embed.color = 0x2ECC71 # Green
            result_embed.description = (
                f"### ğŸ‰ ENEMY SLAIN!\n"
                f"You bravely defeated the **{self.enemy_name}**!\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ—¡ï¸ **Your Strike (Roll):** `{player_roll}`\n"
                f" â”£ ğŸ›¡ï¸ **Enemy Defense (Roll):** `{enemy_roll}`\n"
                f" â”— ğŸ’° **Loot Collected:** `+${reward:,}`\n\n"
                f"> *You return to the Titan Casino as a hero.*"
            )
            result_embed.set_image(url="https://media.tenor.com/bXjOidvDvoQAAAAC/confetti-celebrate.gif")
            
        else:
            # ğŸ’€ DEFEAT
            penalty = random.randint(1000, 5000)
            paid = await smart_charge(self.player.id, penalty) # ğŸ’¸ Safe Penalty
            
            loss_text = f"`-${penalty:,}` (Medical Bills)" if paid else "`BANKRUPT` (Could not afford hospital)"
            
            result_embed.color = 0xE74C3C # Red
            result_embed.description = (
                f"### ğŸ’€ BRUTAL DEFEAT!\n"
                f"The **{self.enemy_name}** was too strong for you...\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ—¡ï¸ **Your Strike (Roll):** `{player_roll}`\n"
                f" â”£ ğŸ›¡ï¸ **Enemy Defense (Roll):** `{enemy_roll}`\n"
                f" â”— ğŸ©¸ **Lost/Penalty:** {loss_text}\n\n"
                f"> *The rescue team found you unconscious in the dirt.*"
            )
            result_embed.set_image(url="https://media.tenor.com/d6-SreC3_p8AAAAC/wasted-gta5.gif")

        await interaction.edit_original_response(embed=result_embed, view=self)

    @discord.ui.button(label="RUN AWAY", emoji="ğŸƒ", style=discord.ButtonStyle.secondary)
    async def btn_run(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.player.id:
            return await interaction.response.send_message("âŒ **Guard:** You cannot run from another person's fight!", ephemeral=True)
        
        await interaction.response.defer()
        await self.lock_view()
        
        run_chance = random.randint(1, 100)
        embed = discord.Embed(title="ğŸƒ ESCAPE ATTEMPT", color=0x3498DB)
        embed.set_thumbnail(url=self.player.display_avatar.url)
        
        if run_chance > 30: # 70% chance to escape safely
            embed.color = 0x3498DB # Blue
            embed.description = (
                f"### ğŸ’¨ ESCAPE SUCCESSFUL\n"
                f"You quickly threw a smoke bomb and vanished.\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ¯ **Action:** `Fled from {self.enemy_name}`\n"
                f" â”— ğŸ’° **Status:** `Safe, but empty-handed.`\n\n"
                f"> *Cowardly? Maybe. Alive? Yes.*"
            )
        else:
            # 30% chance to fail running
            penalty = random.randint(500, 2000)
            paid = await smart_charge(self.player.id, penalty)
            loss_text = f"`-${penalty:,}`" if paid else "`BANKRUPT`"
            
            embed.color = 0x8B0000 # Dark Red
            embed.description = (
                f"### ğŸ©¸ ESCAPE FAILED!\n"
                f"You tripped over a branch! The **{self.enemy_name}** attacked you from behind.\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ¯ **Action:** `Ambushed while fleeing`\n"
                f" â”— ğŸ’¸ **Robbed/Lost:** {loss_text}\n"
            )
            
        await interaction.edit_original_response(embed=embed, view=self)

    async def on_timeout(self):
        """If the player takes too long to decide, the monster attacks!"""
        if self.game_over: return
        await self.lock_view()
        
        penalty = random.randint(1500, 4000)
        await smart_charge(self.player.id, penalty) # Force charge them for sleeping on the job
        
        embed = discord.Embed(title="ğŸ’€ AMBUSHED!", color=0x8B0000)
        embed.description = (
            f"### â³ TIME EXPIRED\n"
            f"You hesitated for too long! The **{self.enemy_name}** struck while you were frozen in fear.\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”— ğŸ©¸ **Hospital Bill:** `-${penalty:,}`"
        )
        try:
            if self.message: await self.message.edit(embed=embed, view=self)
        except: pass


# ==============================================================================
# ğŸ’» MAIN COMMAND
# ==============================================================================
@games_group.command(name="adventure", description="ğŸŒ² Go on a dangerous RPG adventure to fight monsters and find epic loot!")
@app_commands.checks.cooldown(1, 60, key=lambda i: (i.guild_id, i.user.id)) # 1 min cooldown
@check_seized()
async def adventure(interaction: discord.Interaction):
    # â³ SECURE INITIALIZATION
    await interaction.response.defer(ephemeral=False)
    
    # ğŸ² 1. GENERATE ENCOUNTER
    encounters = [
        {"type": "MONSTER", "name": "Goblin Thief", "power": 40, "img": "https://media.tenor.com/v8tTq9z8p60AAAAC/goblin-slayer.gif", "color": 0x2ECC71},
        {"type": "MONSTER", "name": "Cave Troll", "power": 70, "img": "https://media.tenor.com/E8R9bUcw8L0AAAAC/lotr-troll.gif", "color": 0x8B4513},
        {"type": "MONSTER", "name": "Fierce Dragon", "power": 95, "img": "https://media.tenor.com/2s4-L7kE8LMAAAAC/dragon-fire.gif", "color": 0xE74C3C},
        {"type": "TREASURE", "name": "Abandoned Gold Chest", "power": 0, "img": "https://media.tenor.com/E0lQ-J9YpKwAAAAC/chest-open.gif", "color": 0xF1C40F}
    ]
    
    # Weights: 30% Goblin, 30% Troll, 20% Dragon, 20% Treasure
    weights = [30, 30, 20, 20] 
    encounter = random.choices(encounters, weights=weights, k=1)[0]
    
    embed = discord.Embed(title="ğŸŒ² INTO THE WILDERNESS...", color=encounter["color"])
    embed.set_image(url=encounter["img"])
    
    # âš”ï¸ 2. MONSTER ENCOUNTER
    if encounter["type"] == "MONSTER":
        embed.description = (
            f"### âš ï¸ ENEMY SPOTTED!\n"
            f"A wild **{encounter['name']}** has blocked your path!\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ âš”ï¸ **Enemy Power Level:** `{encounter['power']}/100`\n"
            f" â”— â³ **Decision Time:** `45 Seconds`\n\n"
            f"ğŸ‘‰ *Will you fight for glory, or run for your life?*"
        )
        
        view = RPGAdventureView(interaction.user, encounter["type"], encounter["name"], encounter["power"])
        
        # Save message object for timeout edits
        msg = await interaction.followup.send(embed=embed, view=view, wait=True)
        view.message = msg
        
    # ğŸ’ 3. TREASURE ENCOUNTER (Instant Win)
    elif encounter["type"] == "TREASURE":
        reward = random.randint(10000, 50000)
        await smart_reward(interaction.user.id, reward) # ğŸ’¸ Safe Reward
        
        embed.description = (
            f"### ğŸ’ HIDDEN TREASURE FOUND!\n"
            f"You stumbled upon an **{encounter['name']}** deep in the dark forest.\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ’° **Loot Collected:** `+${reward:,}`\n"
            f" â”— ğŸ† **Status:** `Lucky Survivor`\n\n"
            f"> *You carefully pack the gold and head back to safety.*"
        )
        await interaction.followup.send(embed=embed)

# --- â³ COOLDOWN ERROR HANDLER ---
@adventure.error
async def adventure_error(interaction: discord.Interaction, error: app_commands.AppCommandError):
    if isinstance(error, app_commands.CommandOnCooldown):
        rem = int(error.retry_after)
        embed = discord.Embed(title="â›º RESTING AT CAMP", color=0x3498DB)
        embed.description = f"You are too exhausted from your last adventure.\nRest for `{rem}s` before heading back into the woods."
        await interaction.response.send_message(embed=embed, ephemeral=True)



import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# ğŸ° TITAN CASINO: ROYAL VIP BINGO (SMART DEALER SYSTEM)
# ==============================================================================

class BingoBoardView(discord.ui.View):
    def __init__(self, player: discord.Member, entry_fee: int):
        super().__init__(timeout=300) # â³ 5 Mins Max Session
        self.player = player
        self.entry_fee = entry_fee
        
        # ğŸ² Game State
        self.grid = [] # 5x5 Matrix
        self.called_numbers = set()
        self.marked_numbers = set([0]) # 0 is the FREE space
        self.current_call = None
        self.calls_left = 45 # â³ INCREASED TO 45 CALLS
        
        self.lines_completed = 0
        self.payout_won = 0
        self.game_over = False
        self.message = None 
        self.lock = asyncio.Lock() # ğŸ›¡ï¸ Protection against API collisions
        
        self.generate_board()
        self.build_ui_buttons()

    # --- 1. SMART BOARD GENERATION (100% ORIGINAL LOGIC) ---
    def generate_board(self):
        # Bingo Columns: B(1-15), I(16-30), N(31-45), G(46-60), O(61-75)
        b = random.sample(range(1, 16), 5)
        i = random.sample(range(16, 31), 5)
        n = random.sample(range(31, 46), 5)
        g = random.sample(range(46, 61), 5)
        o = random.sample(range(61, 76), 5)
        
        n[2] = 0 # Center is FREE
        
        for row in range(5):
            self.grid.append([b[row], i[row], n[row], g[row], o[row]])
            
        # ğŸ§  SMART DEALER LOGIC (GUARANTEES HITS)
        flat_grid = [val for row in self.grid for val in row if val != 0] # Player's 24 numbers
        
        # Determine how lucky this game will be
        # 16 hits (1-2 lines), 18 hits (2-3 lines), 21 hits (3-4 lines), 24 hits (JACKPOT)
        hit_options = [16, 18, 20, 22, 24]
        weights = [25.0, 40.0, 20.0, 12.0, 3.0] # 3% chance for a guaranteed Full House!
        guaranteed_hit_count = random.choices(hit_options, weights=weights, k=1)[0]
        
        # Select guaranteed hits from player's board
        hits_to_call = random.sample(flat_grid, guaranteed_hit_count)
        
        # Fill the rest of the calls with misses
        all_misses = list(set(range(1, 76)) - set(flat_grid))
        filler_misses = random.sample(all_misses, self.calls_left - len(hits_to_call))
        
        # Combine and shuffle so the player doesn't know when the hits are coming
        self.call_pool = hits_to_call + filler_misses
        random.shuffle(self.call_pool)

    # --- 2. DYNAMIC BUTTONS ---
    def build_ui_buttons(self):
        self.clear_items()
        for r in range(5):
            for c in range(5):
                val = self.grid[r][c]
                
                if val == 0:
                    btn = discord.ui.Button(label="FREE", style=discord.ButtonStyle.success, disabled=True, row=r)
                else:
                    is_marked = val in self.marked_numbers
                    style = discord.ButtonStyle.success if is_marked else discord.ButtonStyle.secondary
                    btn = discord.ui.Button(label=str(val), style=style, row=r, custom_id=f"bingo_{r}_{c}_{val}")
                    btn.callback = self.make_callback(val)
                self.add_item(btn)

    def make_callback(self, val):
        async def button_callback(interaction: discord.Interaction):
            if interaction.user.id != self.player.id:
                return await interaction.response.send_message("âŒ **Bouncer:** Get your own VIP Bingo card!", ephemeral=True)
            
            # ğŸš¨ Anti-Cheat Penalty
            if val not in self.called_numbers:
                penalty = 1000 
                await smart_charge(self.player.id, penalty) # ğŸ’³ Safe DB Charge
                return await interaction.response.send_message(f"ğŸš¨ **FOUL!** The dealer hasn't called **{val}** yet!\nğŸ’¸ **Penalty Deducted:** `-${penalty:,}`", ephemeral=True)

            # âœ… Mark Number (Protected by Lock)
            if val not in self.marked_numbers:
                async with self.lock:
                    self.marked_numbers.add(val)
                    self.calculate_lines()
                    self.build_ui_buttons() 
                    
                    try:
                        await interaction.response.edit_message(embed=self.get_embed(), view=self)
                    except discord.HTTPException:
                        pass # Ignore rare API stutters
            else:
                await interaction.response.defer()

        return button_callback

    # --- 3. LINE CALCULATION LOGIC ---
    def calculate_lines(self):
        lines = 0
        for i in range(5):
            if all(self.grid[i][j] in self.marked_numbers for j in range(5)): lines += 1 # Row
            if all(self.grid[j][i] in self.marked_numbers for j in range(5)): lines += 1 # Col
            
        if all(self.grid[i][i] in self.marked_numbers for i in range(5)): lines += 1
        if all(self.grid[i][4-i] in self.marked_numbers for i in range(5)): lines += 1
        
        self.lines_completed = lines

        # ğŸ’° Payout Multipliers
        if lines == 1: self.payout_won = self.entry_fee # Break Even
        elif lines == 2: self.payout_won = 25000
        elif lines == 3: self.payout_won = 50000
        elif lines == 4: self.payout_won = 100000
        elif lines >= 5: self.payout_won = 1000000 # ğŸ‘‘ MEGA JACKPOT
        
        if lines >= 5: self.game_over = True

    # --- 4. LUXURY PREMIUM UI EMBED ---
    def get_embed(self):
        if self.game_over:
            title = "ğŸ° BINGO: GAME FINISHED!"
            color = 0xFFD700 if self.lines_completed > 0 else 0xE74C3C # Gold or Red
            desc = (
                f"### ğŸ FINAL RESULT\n"
                f"ğŸ‘¤ **VIP Player:** {self.player.mention}\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ¯ **Total Lines:** `{self.lines_completed}`\n"
                f" â”— ğŸ’° **Total Winnings:** `${self.payout_won:,}`\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            )
            if self.lines_completed >= 5:
                desc += "### ğŸ‘‘ MEGA JACKPOT HIT! UNBELIEVABLE!"
                img = "https://media.tenor.com/bXjOidvDvoQAAAAC/confetti-celebrate.gif"
            elif self.lines_completed > 0:
                desc += "### ğŸ‰ YOU BEAT THE HOUSE!"
                img = "https://media.tenor.com/p7a8o1r5c8cAAAAC/money-rain.gif"
            else:
                desc += "### ğŸ’€ BUSTED!\nThe house wins this round. Better luck next time."
                img = "https://media.tenor.com/d6-SreC3_p8AAAAC/wasted-gta5.gif"
        else:
            title = "ğŸ° ROYAL CASINO: VIP BINGO"
            color = 0x2b2d31 # Dark Luxury Theme
            
            call_text = f"### ğŸ“¢ DEALER CALLED: [ **{self.current_call}** ]" if self.current_call else "### ğŸ“¢ DEALER IS SHUFFLING THE DECK..."
            
            # Line Status Visuals
            line_visual = "ğŸŸ© " * self.lines_completed + "â¬œ " * (5 - self.lines_completed)
            
            desc = (
                f"**VIP:** {self.player.mention}  |  ğŸ’µ **Bet:** `${self.entry_fee:,}`\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f"{call_text}\n"
                f"â³ **Calls Remaining:** `{self.calls_left} / 45`\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ¯ **Lines Made:** {line_visual}\n"
                f" â”— ğŸ“ˆ **Current Payout:** `${self.payout_won:,}`\n\n"
                f"> âš ï¸ *Quick! Click the button if you have the called number!*"
            )
            img = "https://media.tenor.com/images/8051a8f9f603c4cbf03758b975e50529/tenor.gif" # Casino background

        embed = discord.Embed(title=title, description=desc, color=color)
        embed.set_thumbnail(url=self.player.display_avatar.url)
        embed.set_image(url=img)
        embed.set_footer(text="Titan Casino â€¢ VIP Lounge", icon_url="https://cdn-icons-png.flaticon.com/512/805/805273.png")
        return embed

    # --- 5. THE DEALER ENGINE (Background Task) ---
    async def start_dealer(self):
        await asyncio.sleep(3) 
        
        while self.calls_left > 0 and not self.game_over:
            new_num = self.call_pool.pop()
            self.called_numbers.add(new_num)
            self.current_call = new_num
            self.calls_left -= 1
            
            # ğŸ›¡ï¸ Lock prevents crashing if user clicks at the exact same millisecond
            async with self.lock:
                if self.message and not self.game_over:
                    try: 
                        await self.message.edit(embed=self.get_embed(), view=self)
                    except discord.HTTPException: 
                        pass 
            
            await asyncio.sleep(5.0) # 5 Sec interval gives player enough time to react
            
        # --- GAME END SEQUENCE ---
        self.game_over = True
        
        async with self.lock:
            for child in self.children: child.disabled = True
            
            # ğŸ’¸ Safe Atomic Payout
            if self.payout_won > 0:
                await smart_reward(self.player.id, self.payout_won)

            if self.message:
                try: await self.message.edit(embed=self.get_embed(), view=self)
                except Exception as e: print(f"Bingo Final Edit Error: {e}")


# ==============================================================================
# ğŸ’» MAIN COMMAND
# ==============================================================================
@games_group.command(name="bingo", description="ğŸ° Play VIP Casino Bingo! Interactive board with up to $1,000,000 Jackpot!")
@check_seized()
async def play_bingo(interaction: discord.Interaction):
    # â³ SECURE INITIALIZATION
    await interaction.response.defer(ephemeral=False) 
    
    entry_fee = 10000
    
    # ğŸ’³ SMART CHARGE ENTRY FEE
    paid = await smart_charge(interaction.user.id, entry_fee)
    if not paid:
        embed = discord.Embed(title="ğŸš¨ ACCESS DENIED", color=0xE74C3C)
        embed.description = f"âŒ **Bouncer:** You need at least **${entry_fee:,}** (Wallet + Bank) to enter the VIP Bingo Lounge."
        return await interaction.followup.send(embed=embed)

    # ğŸ² SPAWN THE BOARD
    view = BingoBoardView(interaction.user, entry_fee)
    
    # Send the board and capture the message object
    msg = await interaction.followup.send(embed=view.get_embed(), view=view, wait=True)
    view.message = msg
    
    # ğŸ¤– WAKE UP THE DEALER IN THE BACKGROUND
    asyncio.create_task(view.start_dealer())

import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# ğŸ TITAN ULTIMATE DAILY BONUS: 15-IN-1 VIP SYSTEM
# ==============================================================================

# --- 1. MYSTERY DOORS (Interactive) ---
class MysteryDoorsView(discord.ui.View):
    def __init__(self, user):
        super().__init__(timeout=60)
        self.user = user
        self.rewards = [0, 25000, 75000]
        random.shuffle(self.rewards)

    async def handle_door(self, interaction, index):
        if interaction.user.id != self.user.id: 
            return await interaction.response.send_message("âŒ **Guard:** Apni baari ka wait karo!", ephemeral=True)
        
        await interaction.response.defer()
        for child in self.children: child.disabled = True
        
        prize = self.rewards[index]
        embed = discord.Embed(title="ğŸšª MYSTERY DOOR OPENED!", color=0x2ECC71 if prize > 0 else 0xE74C3C)
        embed.set_thumbnail(url=interaction.user.display_avatar.url)
        
        if prize > 0:
            embed.description = f"### ğŸ‰ JACKPOT FOUND!\nAndar se **${prize:,}** nikle!\nğŸ’° **Status:** `Claimed`"
            embed.set_image(url="https://media.tenor.com/E0lQ-J9YpKwAAAAC/chest-open.gif")
            await smart_reward(self.user.id, prize)
        else:
            embed.description = f"### ğŸ¦ CHOR NIKLA!\nBox khali tha! Ek Raccoon tera bonus le bhaga!\nğŸ’¸ **Lost:** `$0`"
            embed.set_image(url="https://media.tenor.com/d6-SreC3_p8AAAAC/wasted-gta5.gif")
        
        await interaction.edit_original_response(embed=embed, view=self)

    @discord.ui.button(emoji="ğŸšª", style=discord.ButtonStyle.secondary)
    async def d1(self, i, b): await self.handle_door(i, 0)
    @discord.ui.button(emoji="ğŸšª", style=discord.ButtonStyle.secondary)
    async def d2(self, i, b): await self.handle_door(i, 1)
    @discord.ui.button(emoji="ğŸšª", style=discord.ButtonStyle.secondary)
    async def d3(self, i, b): await self.handle_door(i, 2)

# --- 2. DOUBLE OR NOTHING (Interactive) ---
class GambleBonusView(discord.ui.View):
    def __init__(self, user):
        super().__init__(timeout=60)
        self.user = user
        self.base_amount = 20000

    @discord.ui.button(label="TAKE $20,000 (SAFE)", emoji="ğŸ’°", style=discord.ButtonStyle.success)
    async def safe_btn(self, interaction, button):
        if interaction.user.id != self.user.id: return
        await interaction.response.defer()
        for child in self.children: child.disabled = True
        
        await smart_reward(self.user.id, self.base_amount)
        embed = discord.Embed(title="âœ… SAFE PLAY", description=f"### ğŸ’¼ SECURED!\nTune chup chap **${self.base_amount:,}** le liye.", color=0x2ECC71)
        await interaction.edit_original_response(embed=embed, view=self)

    @discord.ui.button(label="GAMBLE FOR $50,000", emoji="ğŸ²", style=discord.ButtonStyle.danger)
    async def gamble_btn(self, interaction, button):
        if interaction.user.id != self.user.id: return
        await interaction.response.defer()
        for child in self.children: child.disabled = True
        
        if random.choice([True, False]):
            await smart_reward(self.user.id, 50000)
            embed = discord.Embed(title="ğŸ° GAMBLE WON!", description="### ğŸ‰ LUCK IS WITH YOU!\nTune risk liya aur **$50,000** jeet gaya!", color=0xFFD700)
            embed.set_image(url="https://media.tenor.com/p7a8o1r5c8cAAAAC/money-rain.gif")
        else:
            embed = discord.Embed(title="ğŸ’€ GAMBLE LOST!", description="### ğŸ“‰ BUSTED!\nLalach buri bala hai! Tera bonus ZERO ho gaya.", color=0xFF0000)
            
        await interaction.edit_original_response(embed=embed, view=self)

# --- 3. FAST FINGER (Interactive) ---
class FastFingerView(discord.ui.View):
    def __init__(self, user, message=None):
        super().__init__(timeout=3.0) # âš¡ ONLY 3 SECONDS!
        self.user = user
        self.success = False
        self.message = message
        
        styles = [discord.ButtonStyle.success] + [discord.ButtonStyle.danger]*4
        random.shuffle(styles)
        
        for i, style in enumerate(styles):
            btn = discord.ui.Button(label="CLICK ME", style=style, custom_id=str(i))
            btn.callback = self.make_callback(style == discord.ButtonStyle.success)
            self.add_item(btn)

    async def on_timeout(self):
        if not self.success and self.message:
            for child in self.children: child.disabled = True
            embed = discord.Embed(title="ğŸŒ TOO SLOW!", description="Tu 3 second mein button nahi daba paya! Bonus missed. $0", color=0xFF0000)
            try: await self.message.edit(embed=embed, view=self)
            except: pass

    def make_callback(self, is_correct):
        async def callback(interaction: discord.Interaction):
            if interaction.user.id != self.user.id: return
            self.success = True
            await interaction.response.defer()
            for child in self.children: child.disabled = True
            
            if is_correct:
                reward = random.randint(30000, 60000)
                await smart_reward(self.user.id, reward)
                embed = discord.Embed(title="âš¡ LIGHTNING FAST!", description=f"Sahi button dabaya! Tune **${reward:,}** claim kar liye!", color=0x2ECC71)
            else:
                embed = discord.Embed(title="ğŸ’¥ FATAL ERROR!", description="Jaldbaazi mein galat (Red) button daba diya! $0 Bonus.", color=0xE74C3C)
            
            await interaction.edit_original_response(embed=embed, view=self)
        return callback

# --- 4. BOMB DEFUSAL (Interactive) ---
class BombDefusalView(discord.ui.View):
    def __init__(self, user):
        super().__init__(timeout=30)
        self.user = user
        self.wires = ["RED", "BLUE", "GREEN"]
        self.bomb_wire = random.choice(self.wires)

    async def cut_wire(self, interaction, color):
        if interaction.user.id != self.user.id: return
        await interaction.response.defer()
        for child in self.children: child.disabled = True
        
        if color == self.bomb_wire:
            embed = discord.Embed(title="ğŸ’¥ BOOM!", description="Tune galat taar kaat di! Bomb phat gaya. $0 Bonus!", color=0xFF0000)
            embed.set_image(url="https://media.tenor.com/1-11Yd6_QpYAAAAC/explosion-blast.gif")
        else:
            reward = random.randint(40000, 80000)
            await smart_reward(self.user.id, reward)
            embed = discord.Embed(title="âœ‚ï¸ BOMB DEFUSED!", description=f"### ğŸ›¡ï¸ SAVED THE CITY!\nSahi taar kaati! Jaan bhi bachi aur **${reward:,}** bhi mile!", color=0x2ECC71)
        
        await interaction.edit_original_response(embed=embed, view=self)

    @discord.ui.button(label="CUT RED", style=discord.ButtonStyle.danger)
    async def btn_r(self, i, b): await self.cut_wire(i, "RED")
    @discord.ui.button(label="CUT BLUE", style=discord.ButtonStyle.primary)
    async def btn_b(self, i, b): await self.cut_wire(i, "BLUE")
    @discord.ui.button(label="CUT GREEN", style=discord.ButtonStyle.success)
    async def btn_g(self, i, b): await self.cut_wire(i, "GREEN")

# --- MASTER DROPDOWN SELECT ---
class BonusSelect(discord.ui.Select):
    def __init__(self):
        options = [
            discord.SelectOption(label="1. Mystery Doors", description="3 Darwaze, ek mein Jackpot!", emoji="ğŸšª"),
            discord.SelectOption(label="2. Double Or Nothing", description="20k le lo, ya 50k ke liye risk lo.", emoji="ğŸ²"),
            discord.SelectOption(label="3. Fast Finger", description="3 sec mein Green button dabao.", emoji="âš¡"),
            discord.SelectOption(label="4. Bomb Defusal", description="Sahi taar kaato warna BOOM!", emoji="ğŸ’£"),
            discord.SelectOption(label="5. Daily Streak Box", description="Loyalty Box smash karo.", emoji="ğŸ“¦"),
            discord.SelectOption(label="6. Quick Slot Spin", description="Slot machine ghumao kismat aazmao.", emoji="ğŸ°"),
            discord.SelectOption(label="7. Rock Paper Scissor", description="Bot ko harao aur 50k le jao.", emoji="âœŒï¸"),
            discord.SelectOption(label="8. Coin Toss", description="Heads ya Tails? Win upto 40k.", emoji="ğŸª™"),
            discord.SelectOption(label="9. Vault Hack", description="Sahi PIN code guess karo.", emoji="ğŸ”"),
            discord.SelectOption(label="10. Scratch Card", description="Scratch karo aur instant paisa lo.", emoji="ğŸŸï¸"),
            # ğŸ”¥ NEW GAMES ADDED BELOW
            discord.SelectOption(label="11. Russian Roulette", description="5/6 Chance to win $80k. High Risk!", emoji="ğŸ”«"),
            discord.SelectOption(label="12. Crypto Pump", description="Hold karo aur Moon tak jao!", emoji="ğŸ“ˆ"),
            discord.SelectOption(label="13. Sniper Shot", description="Headshot laga to $75k pakka.", emoji="ğŸ¯"),
            discord.SelectOption(label="14. Lucky Card Draw", description="Ek patta khincho aur kismat dekho.", emoji="ğŸƒ"),
            discord.SelectOption(label="15. Titan's Blessing", description="100% Luck. Up to $100,000!", emoji="ğŸŒŒ")
        ]
        super().__init__(placeholder="ğŸ Select Your Daily Bonus Game...", min_values=1, max_values=1, options=options)

    async def callback(self, interaction: discord.Interaction):
        # Prevent others from using
        if interaction.user.id != self.view.user.id:
            return await interaction.response.send_message("âŒ **Guard:** Ye tera bonus menu nahi hai!", ephemeral=True)
            
        choice = self.values[0]
        await interaction.response.defer()
        
        # Lock Dropdown
        self.disabled = True
        await interaction.edit_original_response(view=self.view)

        # ==========================================
        # ğŸ® GAME ROUTING LOGIC
        # ==========================================
        if "1. Mystery Doors" in choice:
            view = MysteryDoorsView(interaction.user)
            embed = discord.Embed(title="ğŸšª MYSTERY DOORS", description="Kise ek darwaze ko kholo. Ek mein $75,000 hain!", color=0x9B59B6)
            await interaction.followup.send(embed=embed, view=view)

        elif "2. Double Or Nothing" in choice:
            view = GambleBonusView(interaction.user)
            embed = discord.Embed(title="ğŸ² DOUBLE OR NOTHING", description="Kya tu $20,000 se khush hai ya $50k ka risk lega?", color=0xF1C40F)
            await interaction.followup.send(embed=embed, view=view)

        elif "3. Fast Finger" in choice:
            embed = discord.Embed(title="âš¡ FAST FINGER", description="**GREEN BUTTON** ko 3 second ke andar dabao! JALDI!", color=0xE74C3C)
            view = FastFingerView(interaction.user)
            msg = await interaction.followup.send(embed=embed, view=view, wait=True)
            view.message = msg # Set message for timeout edit

        elif "4. Bomb Defusal" in choice:
            view = BombDefusalView(interaction.user)
            embed = discord.Embed(title="ğŸ’£ BOMB DEFUSAL", description="Bomb phatne wala hai! Koi ek taar kaat do jaldi!", color=0x34495E)
            await interaction.followup.send(embed=embed, view=view)

        elif "5. Daily Streak Box" in choice:
            reward = random.randint(15000, 60000)
            await smart_reward(interaction.user.id, reward)
            embed = discord.Embed(title="ğŸ“¦ STREAK BOX SMASHED!", description=f"Tune apna daily dabba toda aur **${reward:,}** nikle!", color=0x2ECC71)
            embed.set_thumbnail(url="https://media.tenor.com/E0lQ-J9YpKwAAAAC/chest-open.gif")
            await interaction.followup.send(embed=embed)

        elif "6. Quick Slot Spin" in choice:
            embed = discord.Embed(title="ğŸ° SLOT MACHINE", description="*Spinning the reels...*", color=0xE67E22)
            msg = await interaction.followup.send(embed=embed, wait=True)
            await asyncio.sleep(2)
            fruits = ["ğŸ’", "ğŸ‹", "ğŸ””", "ğŸ’"]
            res = [random.choice(fruits) for _ in range(3)]
            
            if res[0] == res[1] == res[2]:
                reward = 100000
                desc = f"### ğŸ‰ MEGA JACKPOT!\n`[ {' | '.join(res)} ]`\nTune **${reward:,}** jeet liye!"
            elif res[0] == res[1] or res[1] == res[2] or res[0] == res[2]:
                reward = 25000
                desc = f"### ğŸ’µ SMALL WIN!\n`[ {' | '.join(res)} ]`\nDo match huye! Tune **${reward:,}** jeete."
            else:
                reward = 0
                desc = f"### âŒ NO LUCK!\n`[ {' | '.join(res)} ]`\nKuch match nahi hua. $0"
                
            if reward > 0: await smart_reward(interaction.user.id, reward)
            embed.description = desc
            embed.color = 0xFFD700 if reward > 0 else 0xFF0000
            await msg.edit(embed=embed)

        elif "7. Rock Paper Scissor" in choice:
            bot_choice = random.choice(["ROCK ğŸª¨", "PAPER ğŸ“„", "SCISSOR âœ‚ï¸"])
            reward = random.randint(30000, 50000)
            await smart_reward(interaction.user.id, reward)
            embed = discord.Embed(title="âœŒï¸ EPIC RPS BATTLE", description=f"Bot chose **{bot_choice}**.\nTeri kismat achi thi, tune game jeet liya aur **${reward:,}** claim kar liye!", color=0x3498DB)
            await interaction.followup.send(embed=embed)

        elif "8. Coin Toss" in choice:
            flip = random.choice(["HEADS ğŸ¦…", "TAILS ğŸª™"])
            reward = random.randint(20000, 45000)
            await smart_reward(interaction.user.id, reward)
            embed = discord.Embed(title="ğŸª™ COIN FLIPPED!", description=f"Sikka uchhla aur aaya **{flip}**!\nTune **${reward:,}** jeet liye!", color=0xF1C40F)
            await interaction.followup.send(embed=embed)

        elif "9. Vault Hack" in choice:
            reward = random.randint(50000, 95000)
            await smart_reward(interaction.user.id, reward)
            embed = discord.Embed(title="ğŸ” VAULT HACKED", description=f"### ğŸ’» ACCESS GRANTED\nTune bina PIN ke bypass script chala di!\nVault se **${reward:,}** chura liye!", color=0x2b2d31)
            embed.set_image(url="https://media.tenor.com/GfSX-u7_NSAAAAAC/coding-hacker.gif")
            await interaction.followup.send(embed=embed)

        elif "10. Scratch Card" in choice:
            reward = random.randint(5000, 100000)
            await smart_reward(interaction.user.id, reward)
            embed = discord.Embed(title="ğŸŸï¸ SCRATCH CARD REVEALED", description=f"Tune card scratch kiya aur chhupe huye **${reward:,}** nikle!", color=0xE91E63)
            await interaction.followup.send(embed=embed)

        # ğŸ”¥ NEW PREMIUM GAMES START HERE
        elif "11. Russian Roulette" in choice:
            embed = discord.Embed(title="ğŸ”« RUSSIAN ROULETTE", description="*Spinning the cylinder and pulling the trigger...*", color=0x2b2d31)
            msg = await interaction.followup.send(embed=embed, wait=True)
            await asyncio.sleep(2.5)
            
            if random.randint(1, 6) == 1: # 1/6 chance to die
                embed.color = 0xFF0000
                embed.description = "### ğŸ’¥ BANG!\nGoli chal gayi! Tu mar gaya aur tera bonus $0 ho gaya."
            else:
                reward = 80000
                await smart_reward(interaction.user.id, reward)
                embed.color = 0x2ECC71
                embed.description = f"### ğŸ’¨ CLICK!\nChamber khali tha! Jaan bachi aur tune **${reward:,}** jeete!"
            await msg.edit(embed=embed)

        elif "12. Crypto Pump" in choice:
            embed = discord.Embed(title="ğŸ“ˆ CRYPTO MARKET", description="*Investing in ShitCoin... Waiting for the pump...*", color=0x3498DB)
            msg = await interaction.followup.send(embed=embed, wait=True)
            await asyncio.sleep(3)
            
            if random.choice([True, False]):
                reward = random.randint(40000, 90000)
                await smart_reward(interaction.user.id, reward)
                embed.color = 0x00FF00
                embed.description = f"### ğŸš€ TO THE MOON!\nCoin pump ho gaya! Tune **${reward:,}** ka profit banaya!"
            else:
                embed.color = 0xFF0000
                embed.description = f"### ğŸ“‰ RUG PULL!\nMarket crash ho gaya! Devs paisa leke bhaag gaye. $0 Bonus."
            await msg.edit(embed=embed)

        elif "13. Sniper Shot" in choice:
            embed = discord.Embed(title="ğŸ¯ SNIPER SHOT", description="*Calculating wind speed... Taking the shot...*", color=0x95A5A6)
            msg = await interaction.followup.send(embed=embed, wait=True)
            await asyncio.sleep(2)
            
            if random.randint(1, 10) > 4: # 60% chance to hit
                reward = 75000
                await smart_reward(interaction.user.id, reward)
                embed.color = 0x2ECC71
                embed.description = f"### ğŸ’¥ HEADSHOT!\nPerfect aim! Target down. Bountry: **${reward:,}**"
            else:
                reward = 10000
                await smart_reward(interaction.user.id, reward)
                embed.color = 0xE67E22
                embed.description = f"### ğŸ’¨ MISSED!\nGoli miss ho gayi. Par boss ne consolation prize diya: **${reward:,}**"
            await msg.edit(embed=embed)

        elif "14. Lucky Card Draw" in choice:
            cards = [("ğŸƒ JOKER", 100000), ("ğŸ‘‘ KING", 50000), ("â™ ï¸ ACE", 25000), ("ğŸ’© TRASH CARD", 0)]
            card_name, reward = random.choice(cards)
            
            if reward > 0: await smart_reward(interaction.user.id, reward)
            
            embed = discord.Embed(title="ğŸƒ LUCKY CARD DRAW", color=0x9B59B6 if reward > 0 else 0x8B0000)
            embed.description = f"Tune deck se patta khincha aur nikla:\n\n## {card_name}\n**Reward:** `${reward:,}`"
            await interaction.followup.send(embed=embed)

        elif "15. Titan's Blessing" in choice:
            reward = random.randint(1000, 100000)
            await smart_reward(interaction.user.id, reward)
            embed = discord.Embed(title="ğŸŒŒ TITAN'S BLESSING", color=0x00FFFF)
            embed.description = f"Aasman se ek roshni giri aur kismat ne tujhe chuna!\n\nâœ¨ **Godly Reward:** `+${reward:,}`"
            await interaction.followup.send(embed=embed)


class BonusMenuView(discord.ui.View):
    def __init__(self, user):
        super().__init__(timeout=120)
        self.user = user
        self.add_item(BonusSelect())

# ==========================================
# ğŸ THE MAIN COMMAND (WITH 24H COOLDOWN)
# ==========================================
@games_group.command(name="bonus", description="ğŸ Claim your Ultimate Daily Bonus via 15 Premium Mini-Games!")
@app_commands.checks.cooldown(1, 86400, key=lambda i: (i.guild_id, i.user.id)) # ğŸ•’ 24 HOURS COOLDOWN
@check_seized()
async def daily_bonus(interaction: discord.Interaction):
    
    embed = discord.Embed(title="ğŸ TITAN ULTIMATE BONUS MENU", color=0x2b2d31)
    embed.set_thumbnail(url=interaction.user.display_avatar.url)
    embed.description = (
        f"### ğŸ° CHOOSE YOUR DESTINY\n"
        f"Welcome {interaction.user.mention}! Apne daily bonus ko claim karne ka tareeqa select karo.\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"**RULES OF THE HOUSE:**\n"
        f"ğŸ”¹ Har game ka Risk aur Reward alag hai.\n"
        f"ğŸ”¹ Kuch mein dimag chahiye, kuch mein speed, aur kuch mein sirf Kismat!\n"
        f"ğŸ”¹ **Max Reward Limit:** `$100,000` ğŸ’¸\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"ğŸ‘‡ *Neeche dropdown se apna game select karo:* "
    )
    
    view = BonusMenuView(interaction.user)
    await interaction.response.send_message(embed=embed, view=view)

# --- â³ COOLDOWN ERROR HANDLER ---
@daily_bonus.error
async def bonus_error(interaction: discord.Interaction, error: app_commands.AppCommandError):
    if isinstance(error, app_commands.CommandOnCooldown):
        rem = int(error.retry_after)
        hours, remainder = divmod(rem, 3600)
        minutes, _ = divmod(remainder, 60)
        
        embed = discord.Embed(title="â³ BONUS ON COOLDOWN", color=0xF39C12)
        embed.description = f"Lalach buri bala hai! Tu apna aaj ka bonus le chuka hai.\n\nğŸ”„ **Come back in:** `{hours}h {minutes}m`"
        await interaction.response.send_message(embed=embed, ephemeral=True)

import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# ğŸ« TITAN LOTTERY: PREMIUM SCRATCH CARDS (SAFE & BOMB MODES)
# ==============================================================================

# --- 1. INTERACTIVE BUTTON BOARD ---
class InteractiveScratchView(discord.ui.View):
    def __init__(self, user: discord.Member, mode_type: str, entry_fee: int):
        super().__init__(timeout=120) # â³ 2 Mins to Scratch
        self.user = user
        self.mode_type = mode_type # "SAFE" or "BOMB"
        self.entry_fee = entry_fee
        
        self.board = []
        self.revealed_counts = {}
        self.game_over = False
        
        self.setup_board()
        self.build_buttons()

    def setup_board(self):
        symbols = ["ğŸ’", "ğŸ‹", "ğŸ””", "ğŸ’", "ğŸ’°"]
        
        # ğŸ² 40% Win Probability
        is_winner = random.randint(1, 100) <= 40 
        
        if is_winner:
            win_symbol = random.choice(symbols)
            self.board = [win_symbol] * 3
            filler = random.choices([s for s in symbols if s != win_symbol], k=6) # Don't accidentally make 4 or 5
            self.board.extend(filler)
        else:
            self.board = random.choices(symbols, k=9)
            
        if self.mode_type == "BOMB":
            # ğŸ’£ Safe Bomb Placement (Don't overwrite the winning 3 if applicable)
            bomb_placed = False
            while not bomb_placed:
                idx = random.randint(0, 8)
                # If it's a winner, don't overwrite the winning symbol. Otherwise, place anywhere.
                if not is_winner or (is_winner and self.board[idx] != win_symbol):
                    self.board[idx] = "ğŸ’£"
                    bomb_placed = True

        random.shuffle(self.board)

    def build_buttons(self):
        self.clear_items()
        for i, symbol in enumerate(self.board):
            row = i // 3
            btn = discord.ui.Button(label="SCRATCH", emoji="â¬œ", style=discord.ButtonStyle.secondary, row=row, custom_id=str(i))
            btn.callback = self.make_callback(i, symbol)
            self.add_item(btn)
            
        # âš¡ Auto-Scratch Button
        scratch_all_btn = discord.ui.Button(label="âš¡ SCRATCH ALL", style=discord.ButtonStyle.primary, row=3)
        scratch_all_btn.callback = self.scratch_all
        self.add_item(scratch_all_btn)

    def make_callback(self, index, symbol):
        async def callback(interaction: discord.Interaction):
            if interaction.user.id != self.user.id: 
                return await interaction.response.send_message("âŒ **Guard:** This is not your lottery ticket!", ephemeral=True)
            if self.game_over: 
                return await interaction.response.defer()
            
            await interaction.response.defer()
            
            # ğŸ” Reveal the symbol
            clicked_btn = [x for x in self.children if getattr(x, 'custom_id', None) == str(index)][0]
            clicked_btn.label = ""
            clicked_btn.emoji = symbol
            clicked_btn.style = discord.ButtonStyle.danger if symbol == "ğŸ’£" else discord.ButtonStyle.success
            clicked_btn.disabled = True
            
            # Track counts
            if symbol != "ğŸ’£":
                self.revealed_counts[symbol] = self.revealed_counts.get(symbol, 0) + 1
            
            # ğŸ’¥ Bomb Logic
            if symbol == "ğŸ’£":
                self.game_over = True
                await self.end_game(interaction, status="BOMBED")
                return
                
            # ğŸ‰ Win Logic
            if self.revealed_counts.get(symbol, 0) >= 3:
                self.game_over = True
                await self.end_game(interaction, status="WON", winning_symbol=symbol)
                return
                
            # ğŸ—‘ï¸ Draw Logic (All grid buttons disabled, no win)
            grid_buttons = [btn for btn in self.children if btn.custom_id and btn.custom_id.isdigit()]
            if all(btn.disabled for btn in grid_buttons):
                self.game_over = True
                await self.end_game(interaction, status="LOST")
                return

            # Keep playing
            await interaction.edit_original_response(view=self)
            
        return callback

    async def scratch_all(self, interaction: discord.Interaction):
        if interaction.user.id != self.user.id: 
            return await interaction.response.send_message("âŒ **Guard:** This is not your lottery ticket!", ephemeral=True)
        if self.game_over: 
            return await interaction.response.defer()
            
        await interaction.response.defer()
        
        # âš¡ Reveal Everything Instantly
        for child in self.children:
            if getattr(child, 'custom_id', None) and child.custom_id.isdigit(): 
                idx = int(child.custom_id)
                sym = self.board[idx]
                child.label = ""
                child.emoji = sym
                child.style = discord.ButtonStyle.danger if sym == "ğŸ’£" else discord.ButtonStyle.success
            child.disabled = True
            
        self.game_over = True
        
        # Determine Outcome
        if "ğŸ’£" in self.board and self.mode_type == "BOMB":
            await self.end_game(interaction, status="BOMBED")
        else:
            win_sym = None
            for sym in set(self.board):
                if self.board.count(sym) >= 3 and sym != "ğŸ’£":
                    win_sym = sym
                    break
            
            if win_sym: 
                await self.end_game(interaction, status="WON", winning_symbol=win_sym)
            else: 
                await self.end_game(interaction, status="LOST")

    async def end_game(self, interaction: discord.Interaction, status: str, winning_symbol: str = None):
        embed = discord.Embed()
        embed.set_thumbnail(url=self.user.display_avatar.url)
        
        if status == "WON":
            payout = random.randint(15000, 25000) if self.mode_type == "SAFE" else random.randint(50000, 100000)
            await smart_reward(self.user.id, payout) # ğŸ’¸ Safe DB Payout
            
            embed.title = f"ğŸ‰ {winning_symbol} JACKPOT HIT!"
            embed.color = 0x2ECC71 # Green
            embed.description = (
                f"### ğŸ° WINNER WINNER!\n"
                f"You matched three **{winning_symbol}** symbols!\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸŸï¸ **Ticket Cost:** `${self.entry_fee:,}`\n"
                f" â”— ğŸ’° **Total Winnings:** `+${payout:,}`\n"
            )
            embed.set_image(url="https://media.tenor.com/E0lQ-J9YpKwAAAAC/chest-open.gif")
            
        elif status == "BOMBED":
            embed.title = "ğŸ’¥ TICKET DESTROYED!"
            embed.color = 0xE74C3C # Red
            embed.description = (
                f"### ğŸ’€ DISASTER STRUCK\n"
                f"You scratched the hidden BOMB! The ticket burned to ashes.\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸŸï¸ **Ticket Cost:** `${self.entry_fee:,}`\n"
                f" â”— ğŸ’¸ **Lost:** `$0` (Total Loss)\n"
            )
            embed.set_image(url="https://media.tenor.com/1-11Yd6_QpYAAAAC/explosion-blast.gif")
            
        else:
            embed.title = "ğŸ—‘ï¸ BETTER LUCK NEXT TIME"
            embed.color = 0x95A5A6 # Grey
            embed.description = (
                f"### ğŸ“‰ NO MATCHES\n"
                f"You couldn't find 3 matching symbols. The ticket is worthless.\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸŸï¸ **Ticket Cost:** `${self.entry_fee:,}`\n"
                f" â”— ğŸ’¸ **Lost:** `$0` (Total Loss)\n"
            )
            
        # Lock UI
        for child in self.children: child.disabled = True
        try: await interaction.edit_original_response(embed=embed, view=self)
        except: pass


# --- 2. CLASSIC SPOILER TAG ENGINE (Text Based) ---
async def generate_spoiler_scratch(interaction: discord.Interaction, user: discord.Member, mode_type: str, fee: int):
    symbols = ["ğŸ’", "ğŸ‹", "ğŸ””", "ğŸ’", "ğŸ’°"]
    is_winner = random.randint(1, 100) <= 40
    
    board = []
    win_sym = random.choice(symbols) if is_winner else None
    
    if is_winner:
        board = [win_sym] * 3
        filler = random.choices([s for s in symbols if s != win_sym], k=6)
        board.extend(filler)
    else:
        board = random.choices(symbols, k=9)
        
    if mode_type == "BOMB":
        bomb_placed = False
        while not bomb_placed:
            idx = random.randint(0, 8)
            if not is_winner or (is_winner and board[idx] != win_sym):
                board[idx] = "ğŸ’£"
                bomb_placed = True
        
    random.shuffle(board)
    
    # ğŸ”² Format grid with Discord Spoiler Tags
    grid_str = (
        f"> || {board[0]} ||  || {board[1]} ||  || {board[2]} ||\n"
        f"> || {board[3]} ||  || {board[4]} ||  || {board[5]} ||\n"
        f"> || {board[6]} ||  || {board[7]} ||  || {board[8]} ||"
    )

    embed = discord.Embed(title="ğŸ« CLASSIC SCRATCH CARD", color=0x3498DB)
    embed.set_thumbnail(url=user.display_avatar.url)
    
    # ğŸ“Š Calculate and award instant result (Since it's text-based, result is pre-determined)
    if mode_type == "BOMB" and "ğŸ’£" in board:
        embed.color = 0xE74C3C
        embed.description = (
            f"### ğŸ’¥ WARNING: BOMB DETECTED!\n"
            f"*Tap the black boxes to reveal the tragedy.*\n\n"
            f"{grid_str}\n\n"
            f"**Result:** Ticket Burned. (Loss of `${fee:,}`)"
        )
    elif is_winner:
        payout = random.randint(15000, 25000) if mode_type == "SAFE" else random.randint(50000, 100000)
        await smart_reward(user.id, payout) # ğŸ’¸ Safe DB Payout
        
        embed.color = 0x2ECC71
        embed.description = (
            f"### ğŸ‰ WINNING TICKET!\n"
            f"*Tap the black boxes to reveal your `{win_sym}` prize!*\n\n"
            f"{grid_str}\n\n"
            f"**Result:** `+${payout:,}` Added to Bank!"
        )
    else:
        embed.color = 0x95A5A6
        embed.description = (
            f"### ğŸ—‘ï¸ LOSING TICKET\n"
            f"*Tap the black boxes if you want.*\n\n"
            f"{grid_str}\n\n"
            f"**Result:** No Matches. Try Again."
        )
        
    await interaction.edit_original_response(embed=embed, view=None)


# --- 3. THE MASTER DROPDOWN LOBBY ---
class ScratchSelect(discord.ui.Select):
    def __init__(self):
        options = [
            discord.SelectOption(label="Interactive (Safe Mode)", description="Cost: $5k | Win upto $25k | Buttons", emoji="âœ…", value="BTN_SAFE"),
            discord.SelectOption(label="Interactive (BOMB Mode)", description="Cost: $20k | Win upto $100k | High Risk", emoji="ğŸ’£", value="BTN_BOMB"),
            discord.SelectOption(label="Classic Text (Safe Mode)", description="Cost: $5k | Tap the black boxes", emoji="ğŸ“", value="TXT_SAFE"),
            discord.SelectOption(label="Classic Text (BOMB Mode)", description="Cost: $20k | Tap with extreme risk", emoji="ğŸ”¥", value="TXT_BOMB")
        ]
        super().__init__(placeholder="ğŸ« Select Your Scratch Card Tier...", min_values=1, max_values=1, options=options)

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.view.user.id:
            return await interaction.response.send_message("âŒ **Guard:** This menu is not for you!", ephemeral=True)
            
        choice = self.values[0]
        await interaction.response.defer()
        
        # ğŸ’³ SAFE PAYMENT LOGIC
        fee = 20000 if "BOMB" in choice else 5000
        paid = await smart_charge(interaction.user.id, fee)
        
        if not paid:
            embed = discord.Embed(title="ğŸš¨ TRANSACTION DECLINED", color=0xE74C3C)
            embed.description = f"âŒ **Broke:** You need at least **${fee:,}** (Wallet + Bank) to buy this tier."
            return await interaction.edit_original_response(embed=embed, view=None)

        # ğŸ® ROUTE TO CORRECT GAME
        if choice == "BTN_SAFE":
            view = InteractiveScratchView(interaction.user, "SAFE", fee)
            embed = discord.Embed(title="ğŸ« VIP SCRATCH (SAFE TIER)", color=0x2ECC71)
            embed.description = "### ğŸ€ GOOD LUCK!\nClick the `â¬œ` buttons to reveal symbols. **Match 3 to win!**"
            await interaction.edit_original_response(embed=embed, view=view)
            
        elif choice == "BTN_BOMB":
            view = InteractiveScratchView(interaction.user, "BOMB", fee)
            embed = discord.Embed(title="ğŸ’£ DEATH SCRATCH (BOMB TIER)", color=0xE74C3C)
            embed.description = "### âš ï¸ EXTREME DANGER\n**1 Bomb is hidden!** Match 3 symbols before hitting it to win massive payouts!"
            await interaction.edit_original_response(embed=embed, view=view)
            
        elif choice == "TXT_SAFE":
            await generate_spoiler_scratch(interaction, interaction.user, "SAFE", fee)
            
        elif choice == "TXT_BOMB":
            await generate_spoiler_scratch(interaction, interaction.user, "BOMB", fee)


class ScratchMenuView(discord.ui.View):
    def __init__(self, user: discord.Member):
        super().__init__(timeout=60)
        self.user = user
        self.add_item(ScratchSelect())

# --- 4. THE COMMAND ---
@games_group.command(name="scratch", description="ğŸ« Buy a Premium Scratch Card! Play safe or risk it all with BOMB mode.")
@check_seized()
async def scratch_game(interaction: discord.Interaction):
    await interaction.response.defer(ephemeral=False)
    
    embed = discord.Embed(title="ğŸ« TITAN LOTTERY KIOSK", color=0x2b2d31)
    embed.set_thumbnail(url=interaction.user.display_avatar.url)
    embed.description = (
        f"### ğŸ° TEST YOUR LUCK\n"
        f"Welcome {interaction.user.mention}! Choose your ticket tier below:\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"**ğŸŸ¢ SAFE TIERS ($5k Entry):**\n"
        f"No bombs. Pure luck. Win up to **$25,000**.\n\n"
        f"**ğŸ”´ BOMB TIERS ($20k Entry):**\n"
        f"High Risk! 1 Bomb is hidden. Match 3 symbols before hitting it to win up to **$100,000**!\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"ğŸ‘‡ *Select your preferred style from the dropdown:* "
    )
    # embed.set_image(url="https://media.tenor.com/images/13019d5e32047ed6f345c26bdf3b56a3/tenor.gif")
    
    view = ScratchMenuView(interaction.user)
    await interaction.followup.send(embed=embed, view=view)

import discord
from discord import app_commands
import random
import asyncio
import datetime as dt

# ==============================================================================
# ğŸš¨ ANTI-SPAM / FARMING DETECTOR
# ==============================================================================
tnd_cooldowns = {}

def check_spam(user_id: int) -> str:
    now = dt.datetime.now()
    user_data = tnd_cooldowns.get(user_id, {"strikes": [], "banned_until": None})
    
    if user_data["banned_until"]:
        if now < user_data["banned_until"]:
            time_left = str(user_data["banned_until"] - now).split('.')[0]
            return f"ğŸš« **SYSTEM BLOCK:** Suspicious activity! You are blocked for **{time_left}**."
        else:
            user_data["banned_until"] = None
            
    user_data["strikes"] = [t for t in user_data["strikes"] if now - t < dt.timedelta(minutes=5)]
    user_data["strikes"].append(now)
    
    if len(user_data["strikes"]) >= 3: # 3 attempts in 5 mins = 24h Ban
        user_data["banned_until"] = now + dt.timedelta(hours=24)
        tnd_cooldowns[user_id] = user_data
        return "ğŸš¨ **ANTI-FARMING TRIGGERED!**\nYou used this command too fast. **BLOCKED FOR 24 HOURS**!"
        
    tnd_cooldowns[user_id] = user_data
    return None

# ==============================================================================
# ğŸ“š PREMIUM VAULT (22+ SPICY TRUTHS & EXTREME DARES) ğŸŒš
# ==============================================================================
PREMIUM_TRUTHS = [
    "What is the biggest lie you've ever told on Discord?",
    "Who is your secret crush in this server? Name them.",
    "Have you ever scammed or betrayed a friend in a game?",
    "What is the most embarrassing thing in your browser history right now?",
    "Which server member do you secretly dislike the most?",
    "Have you ever faked being AFK to avoid someone?",
    "What is your biggest real-life regret?",
    "Have you ever snooped through someone else's phone or DMs?",
    "Have you ever masturbated? If yes, when was the last time you did it?",
    "If you had to kick one admin from the server, who would it be?",
    # ğŸ”¥ SPICY / NAUGHTY EXPANSION ğŸŒš
    "Who in this server would you date if you had absolutely no other choice?",
    "Have you ever sent a 'risky/naughty' text and immediately deleted it?",
    "What is your weirdest guilty pleasure or secret obsession?",
    "Have you ever stalked an ex or a crush on social media for hours?",
    "If you had to kiss one person in this Discord server, who is it?",
    "Have you ever had a naughty or wild dream about someone online?",
    "What is the most embarrassing text you've accidentally sent to the wrong person?",
    "Have you ever faked an illness just to stay home and text someone?",
    "If someone checked your 'Hidden' photo album right now, what would they find?",
    "Have you ever practiced kissing on your hand or a pillow?",
    "What is the wildest or craziest thing you've ever done to impress a crush?",
    "If you could invisibly spy on one person in this server for a day, who would it be?"
]

PREMIUM_DARES = [
    "Send a voice message barking like a dog for 10 seconds.",
    "Change your nickname to 'I am a clown' for the next hour.",
    "Ping the server owner and tell them their server is boring.",
    "Send the 5th picture from your phone's gallery in the chat.",
    "Confess your fake love to a random online member right now.",
    "Type your next 10 messages completely blindfolded.",
    "Beg a moderator for a VIP role in general chat.",
    "Sing a romantic song in a Voice Channel for 30 seconds.",
    "Post an embarrassing real-life selfie.",
    "Roast yourself brutally in 5 sentences.",
    # ğŸ”¥ EXTREME / SPICY EXPANSION ğŸ˜ˆ
    "Send a highly flirtatious DM to the 3rd person on the online list and screenshot it here.",
    "Moan loudly into the voice chat (or a voice note) for 5 seconds.",
    "Change your Discord status to 'I love [Random Admin's Name] <3' for 24 hours.",
    "Call a random friend and confess your undying love to them, then hang up immediately.",
    "Go to general chat and type 'I am a bad boy/girl who needs punishment' without context.",
    "Let the challenger choose your profile picture for the next 24 hours.",
    "Voice record yourself reading the weirdest text message you've sent recently.",
    "Flirt aggressively with the server owner in general chat for 2 minutes.",
    "Send a screenshot of your recent emoji keyboard list. No cheating!",
    "Do a sexy dance on camera (if in VC) OR describe your sexiest dance move in extreme detail.",
    "Change your bio to 'Single and desperate, DM me' for the rest of the day.",
    "Send a DM to your ex (or a fake ex) saying 'I miss us' and post the screenshot."
]

# ==============================================================================
# âœï¸ MODALS (POP-UP FORMS FOR TYPING)
# ==============================================================================
class QuestionModal(discord.ui.Modal):
    def __init__(self, mode: str, challenger: discord.Member, target: discord.Member):
        super().__init__(title=f"Custom {mode} for {target.name}")
        self.mode = mode
        self.challenger = challenger
        self.target = target
        
        self.custom_text = discord.ui.TextInput(
            label=f"Type your {mode} here:",
            style=discord.TextStyle.paragraph,
            placeholder=f"{mode} : " + ("Sach batao... ğŸŒš" if mode == "Truth" else "Ye task karke dikha... ğŸ˜ˆ"),
            required=True,
            max_length=500
        )
        self.add_item(self.custom_text)

    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.defer()
        await launch_task(interaction, self.mode, self.challenger, self.target, self.custom_text.value)

class AnswerModal(discord.ui.Modal, title="Your Honest Answer"):
    def __init__(self, challenger: discord.Member, target: discord.Member, question: str):
        super().__init__()
        self.challenger = challenger
        self.target = target
        self.question = question
        
        self.answer_text = discord.ui.TextInput(
            label="Type your answer:",
            style=discord.TextStyle.paragraph,
            placeholder="I confess that...",
            required=True
        )
        self.add_item(self.answer_text)

    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.defer()
        answer = self.answer_text.value
        
        embed = discord.Embed(title="ğŸ›ï¸ THE JURY HAS BEEN SUMMONED", color=0x9B59B6)
        embed.set_thumbnail(url=self.target.display_avatar.url)
        embed.description = (
            f"**Challenger:** {self.challenger.mention} | **Target:** {self.target.mention}\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"ğŸ—£ï¸ **The Question:** *{self.question}*\n\n"
            f"ğŸ’¬ **The Confession:**\n> *\"{answer}\"*\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"### ğŸ§‘â€âš–ï¸ JURY VOTING (60 SECONDS):\n"
            f"Is {self.target.name} telling the truth, or hiding something? Vote below!"
        )
        
        view = TnD_JuryView(self.target)
        msg = await interaction.followup.send(embed=embed, view=view, wait=True)
        
        # â³ 60 SECONDS TIMER LOGIC FOR TRUTH
        await asyncio.sleep(60)
        
        upvotes = len(view.upvotes)
        downvotes = len(view.downvotes)
        
        result_embed = discord.Embed(title="ğŸ›ï¸ THE JURY VERDICT IS IN!", color=0x2b2d31)
        result_embed.set_thumbnail(url="https://media.tenor.com/images/8051a8f9f603c4cbf03758b975e50529/tenor.gif")
        
        if upvotes > downvotes:
            await smart_reward(self.target.id, 10000) # ğŸ’¸ Safe Reward
            result_embed.color = 0x2ECC71
            result_embed.description = (
                f"### âœ… TRUTH VERIFIED!\n"
                f"The jury believed {self.target.mention}.\n"
                f"**Reward:** `+$10,000` added to bank!"
            )
        elif downvotes > upvotes:
            # ğŸ’³ Safe Penalty
            paid = await smart_charge(self.target.id, 10000)
            loss_txt = "`-$10,000`" if paid else "`BANKRUPT`"
            result_embed.color = 0xE74C3C
            result_embed.description = (
                f"### âŒ LIES DETECTED!\n"
                f"The jury thinks {self.target.mention} is lying!\n"
                f"**Penalty:** {loss_txt} deducted from bank!"
            )
        else:
            result_embed.color = 0xF1C40F
            result_embed.description = f"### âš–ï¸ HUNG JURY (TIE)\nThe votes were perfectly split. No money won or lost."
            
        result_embed.description += f"\n\nâ–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n**Final Votes:** ğŸ‘ `{upvotes}` | ğŸ‘ `{downvotes}`"
        
        # Disable buttons
        for child in view.children: child.disabled = True
        try: await msg.edit(embed=result_embed, view=view)
        except: pass

# ==============================================================================
# ğŸ® CORE GAME LOGIC HELPER
# ==============================================================================
async def launch_task(interaction, mode, challenger, target, question):
    if mode == "Truth":
        embed = discord.Embed(title="âš–ï¸ TRUTH REVEAL", color=0x3498DB)
        embed.description = (
            f"### ğŸ—£ï¸ Question from {challenger.mention}:\n"
            f"> *\"{question}\"*\n\n"
            f"**{target.mention}, click the button below to answer honestly!**"
        )
        view = TnD_AnswerButtonView(challenger, target, question)
    else:
        embed = discord.Embed(title="ğŸ˜ˆ DARE ACCEPTED", color=0xE74C3C)
        embed.description = (
            f"### ğŸ”¥ Dare from {challenger.mention}:\n"
            f"> *\"{question}\"*\n\n"
            f"**{target.mention}, perform this dare and upload proof in chat!**\n"
            f"Once done, click 'Proof Submitted'."
        )
        view = TnD_DareProofView(challenger, target)
        
    embed.set_thumbnail(url=target.display_avatar.url)
    try: await interaction.edit_original_response(embed=embed, view=view)
    except: await interaction.followup.send(embed=embed, view=view)


# ==============================================================================
# ğŸ® INTERACTIVE UI VIEWS
# ==============================================================================

# --- 1. TARGET CHOOSES T OR D ---
class TnD_ChoiceView(discord.ui.View):
    def __init__(self, challenger: discord.Member, target: discord.Member):
        super().__init__(timeout=120)
        self.challenger = challenger
        self.target = target

    async def handle_choice(self, interaction, mode):
        if interaction.user.id != self.target.id:
            return await interaction.response.send_message("âŒ **Guard:** This challenge is not for you!", ephemeral=True)
            
        await interaction.response.defer()
        
        embed = discord.Embed(title=f"ğŸ­ {mode.upper()} SELECTED!", color=0x2b2d31)
        embed.description = f"{self.target.mention} bravely chose **{mode}**!\n\n{self.challenger.mention}, how do you want to assign the task?"
        
        view = TnD_SourceView(self.challenger, self.target, mode)
        await interaction.edit_original_response(embed=embed, view=view)

    @discord.ui.button(label="TRUTH ($10k Risk)", emoji="ğŸ—£ï¸", style=discord.ButtonStyle.primary)
    async def btn_truth(self, i, b): await self.handle_choice(i, "Truth")

    @discord.ui.button(label="DARE ($1M Reward)", emoji="ğŸ˜ˆ", style=discord.ButtonStyle.danger)
    async def btn_dare(self, i, b): await self.handle_choice(i, "Dare")

# --- 2. CHALLENGER CHOOSES CUSTOM OR VAULT ---
class TnD_SourceView(discord.ui.View):
    def __init__(self, challenger, target, mode):
        super().__init__(timeout=120)
        self.challenger = challenger
        self.target = target
        self.mode = mode

    @discord.ui.button(label="âœï¸ Write Custom Task", style=discord.ButtonStyle.success)
    async def btn_custom(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.challenger.id: 
            return await interaction.response.send_message("âŒ Only the challenger can choose!", ephemeral=True)
        await interaction.response.send_modal(QuestionModal(self.mode, self.challenger, self.target))

    @discord.ui.button(label="ğŸ“š Open Premium Vault ğŸŒš", style=discord.ButtonStyle.primary)
    async def btn_vault(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.challenger.id: 
            return await interaction.response.send_message("âŒ Only the challenger can choose!", ephemeral=True)
        
        await interaction.response.defer()
        
        embed = discord.Embed(title=f"ğŸ“š PREMIUM {self.mode.upper()} VAULT", color=0xF1C40F)
        embed.description = "Select a hardcore/spicy prompt from the dropdown below:"
        
        view = discord.ui.View(timeout=120)
        view.add_item(TnD_PrePlannedSelect(self.mode, self.challenger, self.target))
        await interaction.edit_original_response(embed=embed, view=view)

# --- 2.5 THE PREMIUM VAULT DROPDOWN ---
class TnD_PrePlannedSelect(discord.ui.Select):
    def __init__(self, mode, challenger, target):
        self.mode = mode
        self.challenger = challenger
        self.target = target
        
        prompts = PREMIUM_TRUTHS if mode == "Truth" else PREMIUM_DARES
        # ğŸ› ï¸ FIX: Using value=str(i) for flawless indexing
        options = [discord.SelectOption(label=f"ğŸ”¥ {mode} {i+1}", description=p[:90]+"...", value=str(i)) for i, p in enumerate(prompts)]
        super().__init__(placeholder="Select a Premium Prompt ğŸŒš...", options=options)

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.challenger.id: 
            return await interaction.response.send_message("âŒ Not for you!", ephemeral=True)
        await interaction.response.defer()
        
        # Flawless Extraction
        idx = int(self.values[0])
        prompts = PREMIUM_TRUTHS if self.mode == "Truth" else PREMIUM_DARES
        selected_question = prompts[idx]
        
        await launch_task(interaction, self.mode, self.challenger, self.target, selected_question)


# --- 3. TARGET CLICKS TO ANSWER TRUTH ---
class TnD_AnswerButtonView(discord.ui.View):
    def __init__(self, challenger, target, question):
        super().__init__(timeout=120)
        self.challenger = challenger
        self.target = target
        self.question = question

    @discord.ui.button(label="ğŸ’¬ Answer Now", style=discord.ButtonStyle.primary)
    async def btn_ans(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.target.id: 
            return await interaction.response.send_message("âŒ It's not your turn to speak!", ephemeral=True)
        await interaction.response.send_modal(AnswerModal(self.challenger, self.target, self.question))


# --- 4. JURY POLLING (FOR TRUTH) ---
class TnD_JuryView(discord.ui.View):
    def __init__(self, target):
        super().__init__(timeout=None) # Timeout handled by asyncio in AnswerModal
        self.target = target
        self.upvotes = set()
        self.downvotes = set()

    @discord.ui.button(label="Real 0", emoji="ğŸ‘", style=discord.ButtonStyle.success)
    async def btn_real(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.upvotes.add(interaction.user.id)
        if interaction.user.id in self.downvotes: self.downvotes.remove(interaction.user.id)
        
        # ğŸ› ï¸ Safe Label Updating
        button.label = f"Real {len(self.upvotes)}"
        for child in self.children:
            if child.emoji.name == "ğŸ‘": child.label = f"Fake {len(self.downvotes)}"
            
        await interaction.response.edit_message(view=self)

    @discord.ui.button(label="Fake 0", emoji="ğŸ‘", style=discord.ButtonStyle.danger)
    async def btn_fake(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.downvotes.add(interaction.user.id)
        if interaction.user.id in self.upvotes: self.upvotes.remove(interaction.user.id)
        
        button.label = f"Fake {len(self.downvotes)}"
        for child in self.children:
            if child.emoji.name == "ğŸ‘": child.label = f"Real {len(self.upvotes)}"
            
        await interaction.response.edit_message(view=self)


# --- 5. TARGET CONFIRMS DARE PROOF SENT ---
class TnD_DareProofView(discord.ui.View):
    def __init__(self, challenger, target):
        super().__init__(timeout=300)
        self.challenger = challenger
        self.target = target

    @discord.ui.button(label="ğŸ“¸ Proof Submitted in Chat", style=discord.ButtonStyle.success)
    async def btn_proof(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.target.id: 
            return await interaction.response.send_message("âŒ Wait for the target!", ephemeral=True)
        await interaction.response.defer()
        
        embed = discord.Embed(title="ğŸ” VERIFICATION PENDING", color=0xF1C40F)
        embed.description = (
            f"### â³ WAITING FOR APPROVAL\n"
            f"{self.target.mention} claims they completed the dare!\n\n"
            f"{self.challenger.mention}, check the chat carefully. Did they really do it?\n"
            f"**Approve** or **Reject** below."
        )
        view = TnD_VerifyDareView(self.challenger, self.target)
        await interaction.edit_original_response(embed=embed, view=view)


# --- 6. CHALLENGER APPROVES OR REJECTS DARE ---
class TnD_VerifyDareView(discord.ui.View):
    def __init__(self, challenger, target):
        super().__init__(timeout=120)
        self.challenger = challenger
        self.target = target

    @discord.ui.button(label="APPROVE (Give $1M)", emoji="âœ…", style=discord.ButtonStyle.success)
    async def btn_approve(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.challenger.id: 
            return await interaction.response.send_message("âŒ ONLY the Challenger can verify this!", ephemeral=True)
        await interaction.response.defer()
        for child in self.children: child.disabled = True
        
        # ğŸ’¸ Safe $1M Payout
        await smart_reward(self.target.id, 1000000)
        
        embed = discord.Embed(title="ğŸ† DARE CONQUERED!", color=0x00FF00)
        embed.set_thumbnail(url=self.target.display_avatar.url)
        embed.description = (
            f"### ğŸ‰ ABSOLUTELY UNBELIEVABLE!\n"
            f"{self.challenger.mention} approved the dare!\n\n"
            f"{self.target.mention} just won **$1,000,000** for having guts of steel!"
        )
        embed.set_image(url="https://media.tenor.com/p7a8o1r5c8cAAAAC/money-rain.gif")
        await interaction.edit_original_response(embed=embed, view=self)

    @discord.ui.button(label="REJECT (Fake/Failed)", emoji="âŒ", style=discord.ButtonStyle.danger)
    async def btn_reject(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.challenger.id: 
            return await interaction.response.send_message("âŒ ONLY the Challenger can verify this!", ephemeral=True)
        await interaction.response.defer()
        for child in self.children: child.disabled = True
        
        embed = discord.Embed(title="ğŸ’€ DARE FAILED!", color=0xFF0000)
        embed.set_thumbnail(url=self.target.display_avatar.url)
        embed.description = (
            f"### âŒ REJECTED\n"
            f"{self.challenger.mention} rejected the proof.\n\n"
            f"{self.target.mention} failed the dare and gets absolutely NOTHING."
        )
        embed.set_image(url="https://media.tenor.com/d6-SreC3_p8AAAAC/wasted-gta5.gif")
        await interaction.edit_original_response(embed=embed, view=self)


# ==============================================================================
# ğŸ’» THE MAIN SLASH COMMAND
# ==============================================================================
@games_group.command(name="tnd", description="ğŸ­ Play Premium Truth or Dare! Expose secrets for $10k, or do insane dares for $1,000,000!")
@app_commands.describe(target="Select the player you want to challenge")
@check_seized()
async def tnd_cmd(interaction: discord.Interaction, target: discord.Member):
    # Anti-Spam Check
    spam_warning = check_spam(interaction.user.id)
    if spam_warning: 
        return await interaction.response.send_message(spam_warning, ephemeral=True)
        
    if target.bot or target.id == interaction.user.id:
        return await interaction.response.send_message("âŒ **Error:** You can't challenge bots or yourself!", ephemeral=True)

    embed = discord.Embed(title="ğŸ­ THE ULTIMATE TRUTH OR DARE", color=0x2b2d31)
    embed.description = (
        f"**Challenger:** {interaction.user.mention}\n"
        f"**Target:** {target.mention}\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"### {target.name.upper()}, MAKE YOUR CHOICE!\n"
        f"Will you reveal your darkest secrets for **$10,000**, or perform an insane physical/digital task for **$1,000,000**?\n\n"
        f"> *(Waiting for target to accept...)*"
    )
    embed.set_thumbnail(url="https://cdn-icons-png.flaticon.com/512/3855/3855833.png")
    
    view = TnD_ChoiceView(interaction.user, target)
    await interaction.response.send_message(content=f"Hey {target.mention}, you have been challenged!", embed=embed, view=view)

     
import discord
from discord import app_commands
import random
import asyncio
import string

# ==============================================================================
# ğŸ“ˆ 1. TITAN CRASH (The Multiplier Casino)
# ==============================================================================
import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# ğŸ“ˆ TITAN CASINO: CRASH (HIGH TENSION MULTIPLIER)
# ==============================================================================

class CrashView(discord.ui.View):
    def __init__(self, user: discord.Member, bet_amount: int):
        super().__init__(timeout=120) # â³ 2 Mins Max
        self.user = user
        self.bet_amount = bet_amount
        
        self.multiplier = 1.00
        self.cashed_out = False
        self.crashed = False
        self.message = None
        self.lock = asyncio.Lock() # ğŸ›¡ï¸ Prevents Race Conditions
        
        # ğŸ§  TRUE CASINO ALGORITHM (House Edge Included)
        # 10% Chance of INSTANT BUST (1.00x)
        if random.random() < 0.10:
            self.crash_point = 1.00
        else:
            # 90% Chance to go higher (Weighted: Most crash between 1.1x and 3.0x, few go 10x+)
            self.crash_point = round(random.uniform(1.01, 15.0) if random.random() > 0.3 else random.uniform(1.05, 3.0), 2)

    @discord.ui.button(label="CASH OUT", emoji="ğŸ’°", style=discord.ButtonStyle.success)
    async def cashout_btn(self, interaction: discord.Interaction, button: discord.ui.Button):
        # 1. Security Check
        if interaction.user.id != self.user.id:
            return await interaction.response.send_message("âŒ **Guard:** You can't cash out someone else's bet!", ephemeral=True)
            
        # 2. Lock & Check State
        async with self.lock:
            if self.cashed_out or self.crashed:
                return await interaction.response.defer() # Ignore if already ended
                
            self.cashed_out = True
            for child in self.children: child.disabled = True
            
            # 3. Calculate Winnings & Reward
            win_amount = int(self.bet_amount * self.multiplier)
            await smart_reward(self.user.id, win_amount) # ğŸ’¸ Safe DB Payout
            
            # 4. Premium Cashout Embed
            embed = discord.Embed(title="âœ… CASHED OUT SUCCESSFULLY!", color=0x2ECC71) # Green
            embed.set_thumbnail(url=self.user.display_avatar.url)
            embed.description = (
                f"### ğŸš ESCAPE SUCCESSFUL\n"
                f"You jumped out just in time!\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ“ˆ **Escape Multiplier:** `{self.multiplier:.2f}x`\n"
                f" â”£ ğŸ’µ **Initial Bet:** `${self.bet_amount:,}`\n"
                f" â”— ğŸ’° **Total Payout:** `+${win_amount:,}`\n\n"
                f"> *The rocket continued flying, but your money is safe.*"
            )
            embed.set_image(url="https://media.tenor.com/p7a8o1r5c8cAAAAC/money-rain.gif")
            
            await interaction.response.edit_message(embed=embed, view=self)

    async def start_crash(self):
        # Initial Suspense Delay
        await asyncio.sleep(2.0)
        
        while not self.cashed_out and not self.crashed:
            await asyncio.sleep(1.5) # Safe Discord API Interval
            
            async with self.lock:
                # If player cashed out during sleep, stop the loop
                if self.cashed_out: 
                    break
                
                # Jump multiplier dynamically (Faster as it goes higher)
                jump = random.uniform(0.15, 0.45) if self.multiplier < 3.0 else random.uniform(0.5, 1.5)
                self.multiplier = round(self.multiplier + jump, 2)
                
                # ğŸ’¥ CRASH TRIGGER
                if self.multiplier >= self.crash_point:
                    self.multiplier = self.crash_point # Cap exactly at crash point
                    self.crashed = True
                    for child in self.children: child.disabled = True
                    
                    embed = discord.Embed(title="ğŸ’¥ ROCKET CRASHED!", color=0xE74C3C) # Red
                    embed.set_thumbnail(url=self.user.display_avatar.url)
                    embed.description = (
                        f"### ğŸ“‰ TOTAL BUST\n"
                        f"You got greedy and went down with the ship!\n"
                        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                        f" â”£ ğŸ’¥ **Crashed At:** `{self.crash_point:.2f}x`\n"
                        f" â”— ğŸ’¸ **Lost Bet:** `-${self.bet_amount:,}`\n"
                    )
                    embed.set_image(url="https://media.tenor.com/1-11Yd6_QpYAAAAC/explosion-blast.gif")
                    
                    if self.message:
                        try: await self.message.edit(embed=embed, view=self)
                        except Exception as e: print(f"Crash Edit Error: {e}")
                    break
                
                # ğŸš€ NORMAL FLYING STATE
                embed = discord.Embed(title="ğŸš€ TITAN CRASH: FLYING...", color=0x3498DB) # Blue
                embed.description = (
                    f"### ğŸ“ˆ MULTIPLIER: {self.multiplier:.2f}x\n"
                    f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                    f"**Player:** {self.user.mention} | **Bet:** `${self.bet_amount:,}`\n\n"
                    f"> *Press **CASH OUT** before it blows up!*"
                )
                if self.message:
                    try: await self.message.edit(embed=embed, view=self)
                    except discord.HTTPException: pass # Ignore minor API stutters


# ==============================================================================
# ğŸ’» THE MAIN COMMAND
# ==============================================================================
@games_group.command(name="crash", description="ğŸ“ˆ Bet your money on the rising rocket! Cash out before it explodes!")
@app_commands.describe(bet="How much money to risk? (Max: $50,000)")
@check_seized()
async def crash_game(interaction: discord.Interaction, bet: int):
    # ğŸ›‘ 1. LIMITS & SECURITY
    MAX_BET = 50000
    if bet > MAX_BET:
        return await interaction.response.send_message(f"âŒ **Casino Rules:** Maximum bet allowed is `${MAX_BET:,}`!", ephemeral=True)
    if bet < 100:
        return await interaction.response.send_message("âŒ **Casino Rules:** Minimum bet is `$100`.", ephemeral=True)

    # â³ 2. SECURE DEFER
    await interaction.response.defer(ephemeral=False)
    
    # ğŸ’³ 3. SMART CHARGE (Deduct BEFORE takeoff)
    paid = await smart_charge(interaction.user.id, bet)
    if not paid:
        embed = discord.Embed(title="ğŸš¨ TRANSACTION DECLINED", color=0xE74C3C)
        embed.description = f"âŒ **Broke:** You need at least **${bet:,}** (Wallet + Bank) to ride the rocket."
        return await interaction.followup.send(embed=embed)

    # ğŸš€ 4. INITIATE LAUNCH
    view = CrashView(interaction.user, bet)
    
    embed = discord.Embed(title="ğŸš€ TITAN CRASH: PRE-FLIGHT CHECK", color=0xF1C40F) # Yellow
    embed.description = (
        f"### âš™ï¸ STARTING ENGINES...\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"**Player:** {interaction.user.mention} | **Bet:** `${bet:,}`\n\n"
        f"> *Get ready to hit the Cash Out button...*"
    )
    
    msg = await interaction.followup.send(embed=embed, view=view, wait=True)
    view.message = msg
    
    # ğŸš 5. WAKE UP THE BACKGROUND ENGINE
    asyncio.create_task(view.start_crash())



# ==============================================================================
# ğŸ¢ 2. TOWER OF DEATH (Push Your Luck)
# ==============================================================================
import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# ğŸ¢ TITAN CASINO: TOWER OF DEATH (HIGH STAKES SURVIVAL)
# ==============================================================================

TOWER_ENTRY_FEE = 5000

class TowerView(discord.ui.View):
    def __init__(self, user: discord.Member, message: discord.Message = None):
        super().__init__(timeout=60.0) # â³ 60 seconds per level decision
        self.user = user
        self.message = message
        self.level = 1
        self.max_level = 10
        self.base_reward = 5000
        self.current_reward = 0
        
        self.game_over = False
        self.lock = asyncio.Lock() # ğŸ›¡ï¸ Anti-Spam Click Lock
        
        self.build_level_ui()

    def build_level_ui(self):
        """Generates the 3 doors for the current level."""
        self.clear_items()
        
        # ğŸ² 2 Safe Doors, 1 Monster Door
        doors = [False, False, True] 
        random.shuffle(doors)
        
        # ğŸšª Add Door Buttons
        for idx, is_monster in enumerate(doors):
            btn = discord.ui.Button(label=f"DOOR {idx+1}", emoji="ğŸšª", style=discord.ButtonStyle.secondary, row=0, custom_id=f"door_{idx}")
            btn.callback = self.make_door_callback(is_monster, idx + 1)
            self.add_item(btn)
            
        # ğŸƒ Add Flee Button (Only show if they have accumulated loot)
        if self.current_reward > 0:
            flee_btn = discord.ui.Button(label=f"FLEE WITH ${self.current_reward:,}", emoji="ğŸƒ", style=discord.ButtonStyle.success, row=1)
            flee_btn.callback = self.flee_callback
            self.add_item(flee_btn)

    def make_door_callback(self, is_monster: bool, door_num: int):
        async def callback(interaction: discord.Interaction):
            if interaction.user.id != self.user.id: 
                return await interaction.response.send_message("âŒ **Guard:** This is not your tower run!", ephemeral=True)
            
            async with self.lock:
                if self.game_over: return await interaction.response.defer()
                await interaction.response.defer()
                
                # ==========================================
                # ğŸ’€ FATAL OUTCOME: MONSTER FOUND
                # ==========================================
                if is_monster:
                    self.game_over = True
                    for child in self.children: child.disabled = True
                    
                    embed = discord.Embed(title="ğŸ’€ TOWER OF DEATH: WASTED!", color=0xE74C3C) # Dark Red
                    embed.set_thumbnail(url=self.user.display_avatar.url)
                    embed.description = (
                        f"### ğŸ§Ÿ YOU OPENED DOOR {door_num}...\n"
                        f"A horrific monster was waiting in the shadows!\n"
                        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                        f" â”£ ğŸ¢ **Floors Climbed:** `Level {self.level}`\n"
                        f" â”£ ğŸ’¸ **Loot Lost:** `${self.current_reward:,}`\n"
                        f" â”— ğŸ©¸ **Status:** `Eaten Alive`\n\n"
                        f"> *Your body will serve as a warning to the next adventurer.*"
                    )
                    embed.set_image(url="https://media.tenor.com/d6-SreC3_p8AAAAC/wasted-gta5.gif")
                    return await interaction.edit_original_response(embed=embed, view=self)
                
                # ==========================================
                # âœ… SAFE OUTCOME: LEVEL PASSED
                # ==========================================
                # Calculate new reward (e.g. Lvl 1: 5k, Lvl 2: 10k, Lvl 3: 15k...)
                level_winnings = self.base_reward * self.level
                self.current_reward += level_winnings
                self.level += 1
                
                # ğŸ‘‘ MEGA JACKPOT: REACHED LEVEL 10
                if self.level > self.max_level:
                    self.game_over = True
                    for child in self.children: child.disabled = True
                    
                    await smart_reward(self.user.id, self.current_reward) # ğŸ’¸ Safe DB Payout
                    
                    embed = discord.Embed(title="ğŸ‘‘ TOWER CONQUERED!", color=0xFFD700) # Gold
                    embed.set_thumbnail(url=self.user.display_avatar.url)
                    embed.description = (
                        f"### ğŸ‰ LEGENDARY RUN!\n"
                        f"You reached the top of the Tower and found the King's Stash!\n"
                        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                        f" â”£ ğŸ¢ **Floors Cleared:** `10 / 10`\n"
                        f" â”£ ğŸŸï¸ **Entry Fee Paid:** `${TOWER_ENTRY_FEE:,}`\n"
                        f" â”— ğŸ’° **Total Winnings:** `+${self.current_reward:,}`\n"
                    )
                    embed.set_image(url="https://media.tenor.com/bXjOidvDvoQAAAAC/confetti-celebrate.gif")
                    return await interaction.edit_original_response(embed=embed, view=self)
                    
                # ğŸªœ CONTINUE CLIMBING
                self.build_level_ui()
                await interaction.edit_original_response(embed=self.get_embed(), view=self)

        return callback

    async def flee_callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.user.id: 
            return await interaction.response.send_message("âŒ **Guard:** You cannot flee from someone else's tower!", ephemeral=True)
            
        async with self.lock:
            if self.game_over: return await interaction.response.defer()
            self.game_over = True
            await interaction.response.defer()
            
            for child in self.children: child.disabled = True
            
            await smart_reward(self.user.id, self.current_reward) # ğŸ’¸ Safe DB Payout
            
            embed = discord.Embed(title="ğŸƒ ESCAPED THE TOWER", color=0x2ECC71) # Green
            embed.set_thumbnail(url=self.user.display_avatar.url)
            embed.description = (
                f"### ğŸ’¨ TACTICAL RETREAT\n"
                f"You smashed a window and escaped with the loot safely!\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ¢ **Floors Conquered:** `Level {self.level - 1}`\n"
                f" â”£ ğŸŸï¸ **Entry Fee:** `${TOWER_ENTRY_FEE:,}`\n"
                f" â”— ğŸ’° **Net Winnings:** `+${self.current_reward:,}`\n\n"
                f"> *Cowardly? Maybe. Rich? Absolutely.*"
            )
            await interaction.edit_original_response(embed=embed, view=self)

    async def on_timeout(self):
        if self.game_over: return
        self.game_over = True
        
        for child in self.children: child.disabled = True
        
        embed = discord.Embed(title="ğŸ’€ TOWER COLLAPSED!", color=0x8B0000) # Dark Red
        embed.description = (
            f"### â³ TIME EXPIRED\n"
            f"You stood frozen in fear for too long! The monster caught up to you.\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ¢ **Died on:** `Level {self.level}`\n"
            f" â”— ğŸ’¸ **Lost All Loot:** `${self.current_reward:,}`\n"
        )
        try:
            if self.message: await self.message.edit(embed=embed, view=self)
        except: pass

    def get_embed(self):
        embed = discord.Embed(title=f"ğŸ¢ TOWER OF DEATH: LEVEL {self.level}", color=0x9B59B6) # Deep Purple
        embed.set_thumbnail(url=self.user.display_avatar.url)
        embed.description = (
            f"### ğŸ©¸ CHOOSE YOUR DESTINY\n"
            f"There are 3 doors ahead. **Two** are safe, **One** hides a monster.\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ§— **Current Floor:** `{self.level} / {self.max_level}`\n"
            f" â”£ ğŸ’° **Secured Loot:** `${self.current_reward:,}`\n"
            f" â”— âš ï¸ **Risk vs Reward:** `Level {self.level} pays +${(self.base_reward * self.level):,}`\n\n"
            f"ğŸ‘‰ *Open a door to continue, or Flee to keep your current loot!*"
        )
        return embed


# ==============================================================================
# ğŸ’» MAIN COMMAND
# ==============================================================================
@games_group.command(name="tower", description=f"ğŸ¢ Climb the Tower of Death! Risk it all for massive loot! (Entry: ${TOWER_ENTRY_FEE:,})")
@check_seized()
async def tower_game(interaction: discord.Interaction):
    # â³ 1. SECURE INITIALIZATION
    await interaction.response.defer(ephemeral=False)
    
    # ğŸ’³ 2. SMART CHARGE ENTRY FEE
    paid = await smart_charge(interaction.user.id, TOWER_ENTRY_FEE)
    if not paid:
        embed = discord.Embed(title="ğŸš¨ ACCESS DENIED", color=0xE74C3C)
        embed.description = f"âŒ **Broke:** You need at least **${TOWER_ENTRY_FEE:,}** (Wallet + Bank) to enter the Tower."
        return await interaction.followup.send(embed=embed)

    # ğŸšª 3. INITIATE FIRST LEVEL
    view = TowerView(interaction.user)
    
    # We send the embed and view, then attach the message object for timeout handling
    msg = await interaction.followup.send(embed=view.get_embed(), view=view, wait=True)
    view.message = msg



# ==============================================================================
# ğŸ”« 3. SOLO RUSSIAN ROULETTE
# ==============================================================================
import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# ğŸ”« TITAN CASINO: RUSSIAN ROULETTE (HIGH TENSION SURVIVAL)
# ==============================================================================

class RouletteView(discord.ui.View):
    def __init__(self, user: discord.Member, bet: int, message: discord.Message = None):
        super().__init__(timeout=120) # â³ 2 Mins to decide
        self.user = user
        self.bet = bet
        self.message = message
        
        self.chambers = 6
        self.bullet_chamber = random.randint(1, 6)
        self.current_pull = 1
        self.pulls_survived = 0
        
        # ğŸ§  Balanced Casino Multipliers
        self.multipliers = {0: 1.0, 1: 1.2, 2: 1.5, 3: 2.0, 4: 3.0, 5: 5.0}
        
        self.game_over = False
        self.lock = asyncio.Lock() # ğŸ›¡ï¸ Anti-Spam

    @discord.ui.button(label="PULL TRIGGER", emoji="ğŸ¯", style=discord.ButtonStyle.danger, custom_id="pull_btn")
    async def pull_trigger(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user.id: 
            return await interaction.response.send_message("âŒ **Guard:** This is not your gun!", ephemeral=True)
            
        async with self.lock:
            if self.game_over: return await interaction.response.defer()
            await interaction.response.defer()
            
            # ğŸŒ€ Suspense Animation
            suspense_embed = discord.Embed(title="ğŸ”« RUSSIAN ROULETTE: SPINNING...", color=0xF1C40F)
            suspense_embed.description = f"### âš™ï¸ *Spinning the cylinder and pulling the trigger...*\n> Hold your breath..."
            await interaction.edit_original_response(embed=suspense_embed, view=self)
            
            await asyncio.sleep(1.5) # The wait of destiny
            
            # ==========================================
            # ğŸ’€ FATAL OUTCOME: THE BULLET
            # ==========================================
            if self.current_pull == self.bullet_chamber:
                self.game_over = True
                for child in self.children: child.disabled = True
                
                embed = discord.Embed(title="ğŸ’€ WASTED!", color=0xE74C3C) # Blood Red
                embed.set_thumbnail(url=self.user.display_avatar.url)
                embed.description = (
                    f"### ğŸ’¥ BANG!!!\n"
                    f"You found the bullet on pull **#{self.current_pull}**.\n"
                    f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                    f" â”£ ğŸ”« **Chamber:** `{self.current_pull} / 6`\n"
                    f" â”— ğŸ’¸ **Lost Bet:** `-${self.bet:,}`\n\n"
                    f"> *The casino cleaners are mopping up your mess.*"
                )
                embed.set_image(url="https://media.tenor.com/1-11Yd6_QpYAAAAC/explosion-blast.gif")
                return await interaction.edit_original_response(embed=embed, view=self)
                
            # ==========================================
            # âœ… SAFE OUTCOME: EMPTY CHAMBER
            # ==========================================
            self.pulls_survived += 1
            self.current_pull += 1
            current_mult = self.multipliers[self.pulls_survived]
            potential_win = int(self.bet * current_mult)
            
            # Enable the "Walk Away" button after surviving at least 1 pull
            walk_btn = [x for x in self.children if x.custom_id == "walk_btn"][0]
            walk_btn.disabled = False
            
            # If they survived 5 pulls, the next one is 100% death. Force cashout or let them be stupid? 
            # We'll just disable the pull button to save them.
            if self.pulls_survived == 5:
                button.disabled = True
            
            embed = discord.Embed(title="ğŸ”« RUSSIAN ROULETTE: SURVIVOR", color=0xE67E22) # Orange
            embed.set_thumbnail(url=self.user.display_avatar.url)
            embed.description = (
                f"### ğŸ’¨ *CLICK!* EMPTY CHAMBER.\n"
                f"You survived pull **#{self.pulls_survived}**.\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ“ˆ **Current Multiplier:** `{current_mult}x`\n"
                f" â”£ ğŸ’° **Current Value:** `${potential_win:,}`\n"
                f" â”— ğŸ”« **Chamber:** `{self.current_pull} is next...`\n\n"
                f"ğŸ‘‰ *Will you pull again, or take the money and run?*"
            )
            await interaction.edit_original_response(embed=embed, view=self)

    @discord.ui.button(label="WALK AWAY", emoji="ğŸƒ", style=discord.ButtonStyle.success, disabled=True, custom_id="walk_btn")
    async def walk_away(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user.id: 
            return await interaction.response.send_message("âŒ **Guard:** Not your game!", ephemeral=True)
            
        async with self.lock:
            if self.game_over: return await interaction.response.defer()
            self.game_over = True
            await interaction.response.defer()
            
            for child in self.children: child.disabled = True
            
            # Calculate final winnings
            final_mult = self.multipliers[self.pulls_survived]
            win_amount = int(self.bet * final_mult)
            
            # ğŸ’¸ Safe DB Reward
            await smart_reward(self.user.id, win_amount)
            
            embed = discord.Embed(title="ğŸƒ ESCAPE SUCCESSFUL", color=0x2ECC71) # Green
            embed.set_thumbnail(url=self.user.display_avatar.url)
            embed.description = (
                f"### ğŸ’¼ YOU WALKED AWAY\n"
                f"You put the gun down and took the cash.\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ”« **Pulls Survived:** `{self.pulls_survived}`\n"
                f" â”£ ğŸ“ˆ **Final Multiplier:** `{final_mult}x`\n"
                f" â”— ğŸ’° **Total Winnings:** `+${win_amount:,}`\n\n"
                f"> *Smart choice. The house always wins eventually.*"
            )
            embed.set_image(url="https://media.tenor.com/p7a8o1r5c8cAAAAC/money-rain.gif")
            await interaction.edit_original_response(embed=embed, view=self)

    async def on_timeout(self):
        """Auto-cashout if the player ghosts the game (assuming they survived at least 1 pull)."""
        if self.game_over: return
        self.game_over = True
        
        for child in self.children: child.disabled = True
        
        final_mult = self.multipliers[self.pulls_survived]
        win_amount = int(self.bet * final_mult)
        
        embed = discord.Embed(title="â³ TIME EXPIRED", color=0x95A5A6)
        embed.description = (
            f"### ğŸ•°ï¸ AUTO-CASHOUT\n"
            f"You hesitated for too long. The dealer took the gun away.\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”— ğŸ’° **Auto-Cashed Out:** `+${win_amount:,}`\n"
        )
        
        if win_amount > 0:
            await smart_reward(self.user.id, win_amount)
            
        try:
            if self.message: await self.message.edit(embed=embed, view=self)
        except: pass


# ==============================================================================
# ğŸ’» MAIN COMMAND
# ==============================================================================
@games_group.command(name="roulette", description="ğŸ”« Play Russian Roulette. 1 Bullet, 6 Chambers. Survive to multiply your bet!")
@app_commands.describe(bet="How much are you willing to risk? (Max: $50,000)")
@check_seized()
async def roulette_game(interaction: discord.Interaction, bet: int):
    # ğŸ›‘ 1. LIMITS & SECURITY
    MAX_BET = 50000
    if bet > MAX_BET:
        return await interaction.response.send_message(f"âŒ **Casino Rules:** Maximum bet allowed is `${MAX_BET:,}`!", ephemeral=True)
    if bet < 100:
        return await interaction.response.send_message("âŒ **Casino Rules:** Minimum bet is `$100`.", ephemeral=True)

    # â³ 2. SECURE DEFER
    await interaction.response.defer(ephemeral=False)
    
    # ğŸ’³ 3. SMART CHARGE ENTRY
    paid = await smart_charge(interaction.user.id, bet)
    if not paid:
        embed = discord.Embed(title="ğŸš¨ TRANSACTION DECLINED", color=0xE74C3C)
        embed.description = f"âŒ **Broke:** You need at least **${bet:,}** (Wallet + Bank) to sit at this table."
        return await interaction.followup.send(embed=embed)
    
    # ğŸ”« 4. INITIATE GAME
    embed = discord.Embed(title="ğŸ”« TITAN CASINO: RUSSIAN ROULETTE", color=0x2b2d31)
    embed.set_thumbnail(url=interaction.user.display_avatar.url)
    embed.description = (
        f"### ğŸ©¸ A DEADLY GAME\n"
        f"**Player:** {interaction.user.mention} | **Risking:** `${bet:,}`\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"**Rules:**\n"
        f"1 Bullet. 6 Chambers. Every empty click multiplies your money.\n"
        f"You MUST pull the trigger at least once to walk away.\n\n"
        f"ğŸ‘‰ *Do you have the guts to pull the trigger?*"
    )
    
    view = RouletteView(interaction.user, bet)
    msg = await interaction.followup.send(embed=embed, view=view, wait=True)
    view.message = msg # Connect message to view for timeout handling



# ==============================================================================
# ğŸ’£ 4. MINEFIELD RUNNER
# ==============================================================================
import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# ğŸ’£ TITAN CASINO: MINEFIELD (STAKE-STYLE MINES)
# ==============================================================================

class MinefieldView(discord.ui.View):
    def __init__(self, user: discord.Member, bet: int):
        super().__init__(timeout=120) # â³ 2 Mins to play
        self.user = user
        self.bet = bet
        
        self.safe_clicks = 0
        self.game_over = False
        self.lock = asyncio.Lock() # ğŸ›¡ï¸ Anti-Spam Lock
        
        # ğŸ’£ 20 Tiles (4x5), 4 Mines (20% Danger)
        self.total_tiles = 20
        self.mines = random.sample(range(self.total_tiles), 4) 
        
        # ğŸ“ˆ Authentic Casino Multipliers for 16 Safe Steps
        self.multipliers = [
            1.00, 1.15, 1.35, 1.60, 1.90, 
            2.30, 2.80, 3.50, 4.40, 5.60, 
            7.20, 9.50, 12.50, 17.00, 24.00, 
            35.00, 55.00 # Jackpot
        ]
        
        self.build_grid()

    def build_grid(self):
        self.clear_items()
        
        # ğŸ”² ROWS 0 to 3: The 20 Minefield Tiles
        for i in range(self.total_tiles):
            btn = discord.ui.Button(label="\u200b", emoji="â“", style=discord.ButtonStyle.secondary, row=i//5, custom_id=str(i))
            btn.callback = self.make_callback(i)
            self.add_item(btn)
            
        # ğŸ’° ROW 4: The Cash Out Button
        cashout_btn = discord.ui.Button(label="CASH OUT: $0", emoji="ğŸ’°", style=discord.ButtonStyle.success, row=4, custom_id="cashout", disabled=True)
        cashout_btn.callback = self.cashout_callback
        self.add_item(cashout_btn)

    def reveal_all(self, hit_mine_index: int = None):
        """Disables all buttons and reveals the mines."""
        for child in self.children:
            child.disabled = True
            if child.custom_id and child.custom_id.isdigit():
                idx = int(child.custom_id)
                if idx in self.mines:
                    child.emoji = "ğŸ’¥" if idx == hit_mine_index else "ğŸ’£"
                    child.style = discord.ButtonStyle.danger
                elif child.emoji.name == "â“":
                    # Show unclicked safe spots as faded
                    child.emoji = "ğŸ’"
                    child.style = discord.ButtonStyle.secondary

    def make_callback(self, index: int):
        async def callback(interaction: discord.Interaction):
            if interaction.user.id != self.user.id: 
                return await interaction.response.send_message("âŒ **Guard:** This is not your minefield!", ephemeral=True)
            
            async with self.lock:
                if self.game_over: return await interaction.response.defer()
                await interaction.response.defer()
                
                clicked_btn = [x for x in self.children if x.custom_id == str(index)][0]
                clicked_btn.disabled = True
                
                # ==========================================
                # ğŸ’¥ FATAL OUTCOME: STEPPED ON A MINE
                # ==========================================
                if index in self.mines:
                    self.game_over = True
                    self.reveal_all(hit_mine_index=index)
                    
                    embed = discord.Embed(title="ğŸ’¥ KABOOM! YOU HIT A MINE", color=0xE74C3C) # Red
                    embed.set_thumbnail(url=self.user.display_avatar.url)
                    embed.description = (
                        f"### ğŸ“‰ TOTAL BUST\n"
                        f"You got greedy and blew up!\n"
                        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                        f" â”£ ğŸ’£ **Safe Steps:** `{self.safe_clicks}`\n"
                        f" â”— ğŸ’¸ **Lost Bet:** `-${self.bet:,}`\n"
                    )
                    return await interaction.edit_original_response(embed=embed, view=self)
                
                # ==========================================
                # âœ… SAFE OUTCOME: FOUND A GEM
                # ==========================================
                self.safe_clicks += 1
                clicked_btn.emoji = "ğŸ’"
                clicked_btn.style = discord.ButtonStyle.success
                
                current_mult = self.multipliers[self.safe_clicks]
                current_win = int(self.bet * current_mult)
                
                # Update Cashout Button
                cashout_btn = [x for x in self.children if x.custom_id == "cashout"][0]
                cashout_btn.disabled = False
                cashout_btn.label = f"CASH OUT: ${current_win:,}"
                
                # ğŸ† MAX WIN (Cleared the board)
                if self.safe_clicks >= (self.total_tiles - len(self.mines)):
                    self.game_over = True
                    self.reveal_all()
                    
                    await smart_reward(self.user.id, current_win) # ğŸ’¸ Safe Payout
                    
                    embed = discord.Embed(title="ğŸ† MINEFIELD CLEARED!", color=0xFFD700) # Gold
                    embed.description = (
                        f"### ğŸ‰ PERFECT RUN!\n"
                        f"You found every single gem without hitting a bomb!\n"
                        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                        f" â”£ ğŸ“ˆ **Multiplier:** `{current_mult}x`\n"
                        f" â”— ğŸ’° **Total Winnings:** `+${current_win:,}`\n"
                    )
                    embed.set_image(url="https://media.tenor.com/bXjOidvDvoQAAAAC/confetti-celebrate.gif")
                    return await interaction.edit_original_response(embed=embed, view=self)
                    
                # ğŸ® CONTINUE PLAYING
                embed = discord.Embed(title="ğŸ’£ TITAN MINEFIELD", color=0x3498DB)
                embed.description = (
                    f"### ğŸ’ SAFE!\n"
                    f"**Player:** {self.user.mention}\n"
                    f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                    f" â”£ ğŸ“ˆ **Multiplier:** `{current_mult}x`\n"
                    f" â”£ ğŸ’° **Current Value:** `${current_win:,}`\n"
                    f" â”— âš ï¸ **Risk:** `4 Mines Remaining`\n\n"
                    f"> *Keep searching or Cash Out now!*"
                )
                await interaction.edit_original_response(embed=embed, view=self)

        return callback

    async def cashout_callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.user.id: 
            return await interaction.response.send_message("âŒ **Guard:** Not your game!", ephemeral=True)
            
        async with self.lock:
            if self.game_over: return await interaction.response.defer()
            self.game_over = True
            await interaction.response.defer()
            
            self.reveal_all()
            
            final_mult = self.multipliers[self.safe_clicks]
            final_win = int(self.bet * final_mult)
            
            await smart_reward(self.user.id, final_win) # ğŸ’¸ Safe Payout
            
            embed = discord.Embed(title="âœ… SECURED THE BAG", color=0x2ECC71) # Green
            embed.set_thumbnail(url=self.user.display_avatar.url)
            embed.description = (
                f"### ğŸ’¼ CASHED OUT\n"
                f"You played it safe and took the money!\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ’ **Gems Found:** `{self.safe_clicks}`\n"
                f" â”£ ğŸ“ˆ **Multiplier:** `{final_mult}x`\n"
                f" â”— ğŸ’° **Payout:** `+${final_win:,}`\n"
            )
            await interaction.edit_original_response(embed=embed, view=self)

    async def on_timeout(self):
        if self.game_over: return
        self.game_over = True
        
        # Auto-Cashout if they have safe clicks, else they lose
        if self.safe_clicks > 0:
            final_win = int(self.bet * self.multipliers[self.safe_clicks])
            await smart_reward(self.user.id, final_win)
        
        self.reveal_all()
        try:
            embed = discord.Embed(title="â³ TIME EXPIRED", description=f"Game closed due to inactivity. Winnings (if any) were auto-cashed out.", color=0x95A5A6)
            await self.message.edit(embed=embed, view=self) # Requires self.message to be set in command
        except: pass


# ==============================================================================
# ğŸ’» MAIN COMMAND
# ==============================================================================
@games_group.command(name="mines", description="ğŸ’£ Navigate the minefield! Find gems to multiply your bet, but avoid the bombs!")
@app_commands.describe(bet="How much are you willing to risk? (Max: $50k)")
@check_seized()
async def minefield_game(interaction: discord.Interaction, bet: int):
    # ğŸ›‘ 1. LIMITS & SECURITY
    MAX_BET = 50000
    if bet > MAX_BET:
        return await interaction.response.send_message(f"âŒ **Casino Rules:** Maximum bet allowed is `${MAX_BET:,}`!", ephemeral=True)
    if bet < 100:
        return await interaction.response.send_message("âŒ **Casino Rules:** Minimum bet is `$100`.", ephemeral=True)

    # â³ 2. SECURE DEFER
    await interaction.response.defer(ephemeral=False)
    
    # ğŸ’³ 3. SMART CHARGE ENTRY
    paid = await smart_charge(interaction.user.id, bet)
    if not paid:
        embed = discord.Embed(title="ğŸš¨ TRANSACTION DECLINED", color=0xE74C3C)
        embed.description = f"âŒ **Broke:** You need at least **${bet:,}** (Wallet + Bank) to enter the Minefield."
        return await interaction.followup.send(embed=embed)

    # ğŸ® 4. START GAME
    view = MinefieldView(interaction.user, bet)
    
    embed = discord.Embed(title="ğŸ’£ TITAN MINEFIELD", color=0x2b2d31)
    embed.set_thumbnail(url=interaction.user.display_avatar.url)
    embed.description = (
        f"### âš ï¸ ENTERING DANGER ZONE\n"
        f"**Player:** {interaction.user.mention} | **Bet:** `${bet:,}`\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"**Rules:**\n"
        f"There are **4 Bombs ğŸ’£** hidden in the grid.\n"
        f"Click the tiles to find **Gems ğŸ’** and increase your multiplier.\n"
        f"Press **CASH OUT** at any time to secure your winnings!\n\n"
        f"ğŸ‘‰ *Make your first move... if you dare.*"
    )
    
    msg = await interaction.followup.send(embed=embed, view=view, wait=True)
    view.message = msg # Connect for timeout handling


# ==============================================================================
# ğŸ’» 5. CYBER HACK (Fast Typing Reflex)
# ==============================================================================
import discord
from discord import app_commands
import random
import string
import asyncio
import time

# ==============================================================================
# ğŸ’» TITAN CASINO: CYBERHACK (MAINFRAME INFILTRATION)
# ==============================================================================

# --- 1. THE HACKING MODAL (POP-UP INPUT) ---
class CyberHackModal(discord.ui.Modal, title="ğŸ’» OVERRIDE TERMINAL"):
    def __init__(self, parent_view):
        super().__init__()
        self.parent_view = parent_view
        
        self.hack_input = discord.ui.TextInput(
            label="ENTER DECRYPTION KEY (Case Sensitive):",
            style=discord.TextStyle.short,
            placeholder="Type the exact code here...",
            min_length=8,
            max_length=8,
            required=True
        )
        self.add_item(self.hack_input)

    async def on_submit(self, interaction: discord.Interaction):
        await self.parent_view.process_hack(interaction, self.hack_input.value)


# --- 2. THE TERMINAL VIEW ---
class CyberHackView(discord.ui.View):
    def __init__(self, user: discord.Member, hack_code: str, message: discord.Message = None):
        super().__init__(timeout=15.0) # â³ STRICT 15 SECOND LIMIT
        self.user = user
        self.hack_code = hack_code
        self.message = message
        
        self.start_time = time.time() # Start the absolute timer
        self.game_over = False

    @discord.ui.button(label="ENTER TERMINAL", emoji="ğŸ’»", style=discord.ButtonStyle.danger)
    async def btn_hack(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user.id:
            return await interaction.response.send_message("âŒ **Firewall:** Unauthorized IP detected!", ephemeral=True)
            
        await interaction.response.send_modal(CyberHackModal(self))

    async def process_hack(self, interaction: discord.Interaction, user_input: str):
        if self.game_over: 
            return await interaction.response.defer()
            
        self.game_over = True
        self.stop()
        
        for child in self.children: child.disabled = True
        
        # â±ï¸ Absolute Time Check (Prevents keeping the modal open forever)
        elapsed_time = time.time() - self.start_time
        if elapsed_time > 15.5: # 0.5s grace period for network latency
            embed = discord.Embed(title="â³ CONNECTION LOST", color=0x8B0000) # Dark Red
            embed.set_thumbnail(url=self.user.display_avatar.url)
            embed.description = (
                f"### ğŸ”Œ FIREWALL BLOCKED YOUR IP\n"
                f"You took `{elapsed_time:.1f}s` to execute the code.\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ â±ï¸ **Time Limit:** `15.0s`\n"
                f" â”— ğŸ’¸ **Loot Secured:** `$0`\n\n"
                f"> *The cyber police have been alerted. Run!*"
            )
            return await interaction.response.edit_message(embed=embed, view=self)

        # ğŸ” Input Validation
        if user_input == self.hack_code:
            # ğŸ‰ VICTORY
            reward = random.randint(30000, 75000)
            await smart_reward(self.user.id, reward) # ğŸ’¸ Safe DB Payout
            
            embed = discord.Embed(title="ğŸ”“ VAULT BYPASSED SUCCESSFULLY", color=0x2ECC71) # Matrix Green
            embed.set_thumbnail(url=self.user.display_avatar.url)
            embed.description = (
                f"```diff\n"
                f"+ ACCESS GRANTED\n"
                f"+ SECURITY PROTOCOLS DISABLED\n"
                f"+ TRANSFERRING FUNDS...\n"
                f"```\n"
                f"### ğŸ’¸ HEIST COMPLETE\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ â±ï¸ **Time Taken:** `{elapsed_time:.1f}s`\n"
                f" â”— ğŸ’° **Stolen Loot:** `+${reward:,}`\n"
            )
            embed.set_image(url="https://media.tenor.com/p7a8o1r5c8cAAAAC/money-rain.gif")
            await interaction.response.edit_message(embed=embed, view=self)
            
        else:
            # âŒ DEFEAT (Wrong Code)
            embed = discord.Embed(title="ğŸš¨ SECURITY TRIGGERED", color=0xE74C3C) # Bright Red
            embed.set_thumbnail(url=self.user.display_avatar.url)
            embed.description = (
                f"```diff\n"
                f"- INVALID DECRYPTION KEY\n"
                f"- LOCKDOWN INITIATED\n"
                f"```\n"
                f"### ğŸ’€ HACK FAILED\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ¯ **Target Code:** `{self.hack_code}`\n"
                f" â”£ âŒ **Your Input:** `{user_input}`\n"
                f" â”— ğŸ’¸ **Loot Secured:** `$0`\n"
            )
            await interaction.response.edit_message(embed=embed, view=self)

    async def on_timeout(self):
        """If the user never clicks the button or ignores the modal."""
        if self.game_over: return
        self.game_over = True
        for child in self.children: child.disabled = True
        
        embed = discord.Embed(title="â³ CONNECTION TIMED OUT", color=0x8B0000)
        embed.description = "### ğŸ”Œ SESSION EXPIRED\nYou failed to infiltrate the system within 15 seconds."
        try:
            if self.message: await self.message.edit(embed=embed, view=self)
        except: pass


# ==============================================================================
# ğŸ’» MAIN COMMAND
# ==============================================================================
@games_group.command(name="cyberhack", description="ğŸ’» Hack the Central Vault! Type the exact security code in 15 seconds to steal cash.")
@app_commands.checks.cooldown(1, 120, key=lambda i: (i.guild_id, i.user.id)) # â³ 2 Min Cooldown to prevent farming
@check_seized()
async def cyberhack_game(interaction: discord.Interaction):
    # â³ SECURE DEFER
    await interaction.response.defer(ephemeral=False)
    
    # ğŸ² GENERATE COMPLEX 8-CHARACTER STRING
    chars = string.ascii_letters + string.digits + "!@#$"
    hack_code = "".join(random.choices(chars, k=8))
    
    # ğŸ–¥ï¸ INTRO UI
    embed = discord.Embed(title="ğŸ’» MAINFRAME INFILTRATION", color=0x3498DB) # Hacker Blue
    embed.set_thumbnail(url=interaction.user.display_avatar.url)
    embed.description = (
        f"### âš ï¸ VAULT SECURITY ACTIVE\n"
        f"**Agent:** {interaction.user.mention}\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"You have exactly **15 SECONDS** to bypass the firewall.\n"
        f"Memorize and type this exact key (Case Sensitive):\n\n"
        f"> # `{hack_code}`\n\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"ğŸ‘‰ *Click the terminal button below to start typing!*"
    )
    embed.set_image(url="https://media.tenor.com/GfSX-u7_NSAAAAAC/coding-hacker.gif")
    
    view = CyberHackView(interaction.user, hack_code)
    msg = await interaction.followup.send(embed=embed, view=view, wait=True)
    view.message = msg # Bind for timeout handling

# --- â³ COOLDOWN ERROR HANDLER ---
@cyberhack_game.error
async def cyberhack_error(interaction: discord.Interaction, error: app_commands.AppCommandError):
    if isinstance(error, app_commands.CommandOnCooldown):
        rem = int(error.retry_after)
        minutes, seconds = divmod(rem, 60)
        embed = discord.Embed(title="ğŸš” LAY LOW!", color=0xF39C12)
        embed.description = f"The cyber-police are actively tracing your last ping.\nWait `{minutes}m {seconds}s` before attempting another hack."
        await interaction.response.send_message(embed=embed, ephemeral=True)

        
import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# ğŸ’¼ TITAN CASINO: THE DEVIL'S BARGAIN
# ==============================================================================

class DevilsBargainView(discord.ui.View):
    def __init__(self, user: discord.Member, entry_fee: int):
        super().__init__(timeout=180) # â³ 3 Mins Max
        self.user = user
        self.entry_fee = entry_fee
        
        self.all_prizes = [1, 10000, 50000, 250000, 1000000]
        
        # ğŸ² Game State
        self.cases = {} 
        self.player_case = None
        self.opened_cases = []
        self.lifeline_used = False
        
        self.state = "CHOOSE_OWN" 
        self.cases_to_open = 0
        self.banker_offer = 0
        self.banker_taunt = ""
        
        self.lock = asyncio.Lock() # ğŸ›¡ï¸ Anti-Spam Lock
        
        self.build_case_buttons()

    def setup_secret_cases(self, chosen_case: int):
        """ ğŸ§  The Illusion Magic: True Casino House Edge """
        # Weights: $1 (60%), $10k (25%), $50k (11%), $250k (3.5%), $1M (0.5%)
        # It is incredibly rare to actually have the $1M in your own case!
        player_prize = random.choices(self.all_prizes, weights=[60.0, 25.0, 11.0, 3.5, 0.5], k=1)[0]
        
        remaining_prizes = self.all_prizes.copy()
        remaining_prizes.remove(player_prize)
        random.shuffle(remaining_prizes) # Shuffle the rest for the other cases
        
        idx = 0
        for i in range(5):
            if i == chosen_case:
                self.cases[i] = player_prize
            else:
                self.cases[i] = remaining_prizes[idx]
                idx += 1

    def build_case_buttons(self):
        self.clear_items()
        
        # 1ï¸âƒ£ Build Suitcases (Row 0 and 1)
        for i in range(5):
            btn = discord.ui.Button(
                label=f"Case {i+1}", emoji="ğŸ’¼", 
                style=discord.ButtonStyle.secondary, row=0 if i < 3 else 1, custom_id=f"case_{i}"
            )
            
            if i == self.player_case:
                btn.style = discord.ButtonStyle.primary
                btn.label = f"Your Case"
                btn.disabled = True
            elif i in self.opened_cases:
                val = self.cases[i]
                btn.label = f"${val:,}"
                btn.emoji = "âŒ"
                btn.style = discord.ButtonStyle.danger if val >= 50000 else discord.ButtonStyle.success
                btn.disabled = True
                
            btn.callback = self.make_case_callback(i)
            self.add_item(btn)

        # 2ï¸âƒ£ Banker Actions (Row 2)
        if self.state in ["BANKER_OFFER_1", "FINAL_OFFER"]:
            deal_btn = discord.ui.Button(label="ğŸ¤ DEAL", style=discord.ButtonStyle.success, row=2)
            deal_btn.callback = self.accept_deal
            self.add_item(deal_btn)
            
            no_deal_btn = discord.ui.Button(label="âŒ NO DEAL", style=discord.ButtonStyle.danger, row=2)
            no_deal_btn.callback = self.reject_deal
            self.add_item(no_deal_btn)
            
            # ğŸ”¥ THE LIFELINE FEATURE
            if not self.lifeline_used:
                eye_btn = discord.ui.Button(label="ğŸ‘ï¸ Devil's Eye ($5k)", style=discord.ButtonStyle.secondary, row=2)
                eye_btn.callback = self.use_lifeline
                self.add_item(eye_btn)
            
        # 3ï¸âƒ£ Final Reveal (Row 2)
        if self.state == "OPEN_OWN":
            open_btn = discord.ui.Button(label="ğŸ” REVEAL YOUR DESTINY", style=discord.ButtonStyle.success, row=2)
            open_btn.callback = self.open_final_case
            self.add_item(open_btn)

    def make_case_callback(self, case_index: int):
        async def callback(interaction: discord.Interaction):
            if interaction.user.id != self.user.id:
                return await interaction.response.send_message("âŒ **Guard:** This is not your game!", ephemeral=True)
                
            async with self.lock:
                await interaction.response.defer()
                
                if self.state == "CHOOSE_OWN":
                    self.player_case = case_index
                    self.setup_secret_cases(case_index) 
                    self.state = "OPEN_TWO"
                    self.cases_to_open = 2
                    
                elif self.state in ["OPEN_TWO", "OPEN_ONE"]:
                    self.opened_cases.append(case_index)
                    self.cases_to_open -= 1
                    
                    if self.cases_to_open == 0:
                        self.state = "BANKER_OFFER_1" if self.state == "OPEN_TWO" else "FINAL_OFFER"
                        self.calculate_banker_offer()

                self.build_case_buttons()
                await interaction.edit_original_response(embed=self.get_embed(), view=self)
        return callback

    async def use_lifeline(self, interaction: discord.Interaction):
        if interaction.user.id != self.user.id: return
        
        async with self.lock:
            # ğŸ’³ Smart Charge the $5k fee
            paid = await smart_charge(self.user.id, 5000)
            if not paid:
                return await interaction.response.send_message("âŒ **Broke:** You need `$5,000` (Wallet+Bank) to use the Devil's Eye!", ephemeral=True)
            
            await interaction.response.defer()
            self.lifeline_used = True
            
            # Logic: Find the lowest value case currently on the board
            unopened = [k for k in self.cases.keys() if k not in self.opened_cases and k != self.player_case]
            lowest_case = min(unopened, key=lambda k: self.cases[k])
            
            self.opened_cases.append(lowest_case) # Eliminate the worst case!
            self.calculate_banker_offer() # Recalculate offer since board changed
            
            self.build_case_buttons()
            
            msg = f"ğŸ‘ï¸ **THE DEVIL'S EYE ACTIVATED!**\n> *You paid $5,000. The Devil destroyed the lowest remaining case!*"
            await interaction.edit_original_response(embed=self.get_embed(msg), view=self)

    def calculate_banker_offer(self):
        """ ğŸ§  THE RUTHLESS BANKER ALGORITHM """
        unopened_vals = [self.cases[k] for k in self.cases if k not in self.opened_cases]
        avg_value = sum(unopened_vals) / len(unopened_vals)
        
        # Banker now only offers 40% to 60% of the mathematical average. Very greedy!
        self.banker_offer = int(avg_value * random.uniform(0.40, 0.60))
        
        # Dynamic Taunts
        if max(unopened_vals) == 1000000:
            self.banker_taunt = "*\"The Million is still out there... but is it in your case? Take the guaranteed cash.\"*"
        elif max(unopened_vals) <= 50000:
            self.banker_taunt = "*\"You knocked out the big ones! Quit now before you go home with $1.\"*"
        else:
            self.banker_taunt = "*\"A very fair offer for a very risky board...\"*"

    async def accept_deal(self, interaction: discord.Interaction):
        if interaction.user.id != self.user.id: return
        
        async with self.lock:
            await interaction.response.defer()
            for child in self.children: child.disabled = True
            self.state = "GAME_OVER"
            
            # ğŸ’¸ Safe DB Payout
            await smart_reward(self.user.id, self.banker_offer)
            
            in_player_case = self.cases[self.player_case]
            
            embed = discord.Embed(title="ğŸ¤ DEAL ACCEPTED!", color=0x2ECC71)
            embed.set_thumbnail(url=self.user.display_avatar.url)
            
            if self.banker_offer > in_player_case:
                embed.description = (
                    f"### ğŸ‰ MASTERSTROKE!\n"
                    f"You walked away with **${self.banker_offer:,}**!\n"
                    f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                    f"Your own case only had **${in_player_case:,}** inside!\n"
                    f"**Result:** `You scammed the Banker!`"
                )
            else:
                embed.color = 0xE74C3C
                embed.description = (
                    f"### ğŸ“‰ COWARD'S WAY OUT!\n"
                    f"You safely took **${self.banker_offer:,}**...\n"
                    f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                    f"But your own case had **${in_player_case:,}** inside!\n"
                    f"**Result:** `You missed the big payout!`"
                )
                
            embed.set_image(url="https://media.tenor.com/p7a8o1r5c8cAAAAC/money-rain.gif")
            await interaction.edit_original_response(embed=embed, view=self)

    async def reject_deal(self, interaction: discord.Interaction):
        if interaction.user.id != self.user.id: return
        
        async with self.lock:
            await interaction.response.defer()
            
            if self.state == "BANKER_OFFER_1":
                self.state = "OPEN_ONE"
                self.cases_to_open = 1
            elif self.state == "FINAL_OFFER":
                self.state = "OPEN_OWN"
                
            self.build_case_buttons()
            await interaction.edit_original_response(embed=self.get_embed(), view=self)

    async def open_final_case(self, interaction: discord.Interaction):
        if interaction.user.id != self.user.id: return
        
        async with self.lock:
            for child in self.children: child.disabled = True
            
            suspense = discord.Embed(title="ğŸ” UNLOCKING YOUR DESTINY...", color=0x2b2d31)
            suspense.set_image(url="https://media.tenor.com/y1_B0m0k_mUAAAAd/revolver-spin.gif")
            await interaction.response.edit_message(embed=suspense, view=None)
            
            await asyncio.sleep(4.0) # â³ Heartbeat suspense
            
            win_amount = self.cases[self.player_case]
            await smart_reward(self.user.id, win_amount) # ğŸ’¸ Safe DB Payout
            
            embed = discord.Embed()
            embed.set_thumbnail(url=self.user.display_avatar.url)
            
            if win_amount >= 250000:
                embed.title = "ğŸ† ABSOLUTE LEGEND!"
                embed.color = 0xFFD700
                embed.description = (
                    f"### ğŸ‰ MEGA JACKPOT!\n"
                    f"You rejected the Banker and held your nerve!\n"
                    f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                    f" â”— ğŸ’° **Won:** `+${win_amount:,}`"
                )
                embed.set_image(url="https://media.tenor.com/bXjOidvDvoQAAAAC/confetti-celebrate.gif")
            else:
                embed.title = "ğŸ’€ FATAL MISTAKE!"
                embed.color = 0xFF0000
                embed.description = (
                    f"### ğŸ“‰ BANKRUPT!\n"
                    f"You rejected the Banker's fair offer for THIS?!\n"
                    f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                    f" â”— ğŸ’¸ **Won:** `+${win_amount:,}` (Tragic)"
                )
                embed.set_image(url="https://media.tenor.com/d6-SreC3_p8AAAAC/wasted-gta5.gif")
                
            await interaction.edit_original_response(embed=embed, view=None)

    def get_embed(self, extra_msg: str = None):
        embed = discord.Embed(title="ğŸ’¼ THE DEVIL'S BARGAIN", color=0x2b2d31)
        embed.set_thumbnail(url=self.user.display_avatar.url)
        
        opened_vals = [self.cases[k] for k in self.opened_cases]
        board_str = ""
        for v in sorted(self.all_prizes):
            if v in opened_vals:
                board_str += f"~~${v:,}~~ âŒ\n"
            else:
                board_str += f"**${v:,}** ğŸ’¼\n"

        if self.state == "CHOOSE_OWN":
            desc = "### 1ï¸âƒ£ CHOOSE YOUR CASE\nSelect 1 briefcase to keep as your own. You will open it at the very end!"
            embed.color = 0x3498DB
        elif self.state in ["OPEN_TWO", "OPEN_ONE"]:
            desc = f"### 2ï¸âƒ£ ELIMINATE CASES\nOpen **{self.cases_to_open}** more case(s) to eliminate them. Pray you don't hit the Jackpot!"
            embed.color = 0xE67E22
        elif self.state in ["BANKER_OFFER_1", "FINAL_OFFER"]:
            desc = (
                f"### ğŸ“ THE BANKER IS CALLING...\n"
                f"{self.banker_taunt}\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f"ğŸ’° **Offer:** `${self.banker_offer:,}`\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f"ğŸ‘‰ Do you want to take the **DEAL**, or say **NO DEAL**?"
            )
            embed.color = 0xF1C40F
        elif self.state == "OPEN_OWN":
            desc = "### ğŸ” THE FINAL MOMENT\nYou rejected all offers. It's time to open your own case!"
            embed.color = 0x9B59B6

        if extra_msg: 
            desc = f"{extra_msg}\n\n" + desc
            
        embed.description = desc + "\n\n**REMAINING PRIZES ON BOARD:**\n" + board_str
        return embed

# ==============================================================================
# ğŸ’» MAIN COMMAND
# ==============================================================================
@games_group.command(name="deal", description="ğŸ’¼ Play The Devil's Bargain! Beat the ruthless Banker to win $1,000,000.")
@check_seized()
async def deal_game(interaction: discord.Interaction):
    # â³ SECURE INITIALIZATION
    await interaction.response.defer(ephemeral=False)
    
    entry_fee = 10000
    
    # ğŸ’³ SMART CHARGE ENTRY FEE
    paid = await smart_charge(interaction.user.id, entry_fee)
    if not paid:
        embed = discord.Embed(title="ğŸš¨ ACCESS DENIED", color=0xE74C3C)
        embed.description = f"âŒ **Bouncer:** Entry fee is **${entry_fee:,}**. You need more funds in your Wallet + Bank!"
        return await interaction.followup.send(embed=embed)

    # ğŸ® LAUNCH GAME
    view = DevilsBargainView(interaction.user, entry_fee)
    await interaction.followup.send(embed=view.get_embed(), view=view)
            
# à¤¨à¤¯à¤¾ à¤—à¥à¤°à¥à¤ª à¤¯à¤¹à¤¾à¤ à¤à¤¡ à¤•à¤°à¥‹
game_group = app_commands.Group(name="game", description="Ultra Premium VIP  Games")
bot.tree.add_command(game_group)


import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# ğŸ” TITAN CASINO: THE VAULT CRACKER (MASTERMIND LOGIC)
# ==============================================================================

class VaultDigitSelect(discord.ui.Select):
    def __init__(self, position: int, current_val: int):
        self.position = position
        options = [discord.SelectOption(label=f"Digit: {i}", value=str(i)) for i in range(10)]
        
        # ğŸ¨ Dynamic Placeholder to show current selection
        if current_val is None:
            placeholder = f"ğŸ”¢ Select Digit {position + 1}..."
        else:
            placeholder = f"âœ… Digit {position + 1} Selected: [ {current_val} ]"
            
        super().__init__(
            placeholder=placeholder, 
            min_values=1, 
            max_values=1, 
            options=options, 
            row=position
        )

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.view.user.id:
            return await interaction.response.send_message("âŒ **Guard:** Hands off the keyboard! This is not your hack.", ephemeral=True)
            
        # Update the specific digit in the view's current guess
        self.view.current_guess[self.position] = int(self.values[0])
        
        # ğŸ”„ Rebuild UI to update the dropdown placeholders dynamically
        self.view.build_ui()
        await interaction.response.edit_message(view=self.view)


class VaultCrackerView(discord.ui.View):
    def __init__(self, user: discord.Member, entry_fee: int):
        super().__init__(timeout=300) # â³ 5 Mins to crack
        self.user = user
        self.entry_fee = entry_fee
        
        # ğŸ² Game State
        self.secret_code = [random.randint(0, 9) for _ in range(3)]
        self.current_guess = [None, None, None]
        self.attempts = 0
        self.max_attempts = 5
        self.history = [] 
        
        self.game_over = False
        self.lock = asyncio.Lock() # ğŸ›¡ï¸ Anti-Spam Lock
        
        self.build_ui()

    def build_ui(self):
        self.clear_items()
        
        # ğŸ›ï¸ 3 Dropdowns for 3 Digits (Rows 0, 1, 2)
        for i in range(3):
            self.add_item(VaultDigitSelect(position=i, current_val=self.current_guess[i]))
            
        # âš¡ Submit Button (Row 3)
        submit_btn = discord.ui.Button(label="INJECT CODE", emoji="âš¡", style=discord.ButtonStyle.success, row=3)
        submit_btn.callback = self.submit_guess
        self.add_item(submit_btn)

    async def submit_guess(self, interaction: discord.Interaction):
        if interaction.user.id != self.user.id:
            return await interaction.response.send_message("âŒ **Guard:** Hands off!", ephemeral=True)
            
        async with self.lock:
            if self.game_over: return await interaction.response.defer()
            
            if None in self.current_guess:
                return await interaction.response.send_message("âš ï¸ **System:** You must select all 3 digits before injecting the code!", ephemeral=True)
                
            await interaction.response.defer()
            self.attempts += 1
            
            # ==========================================
            # ğŸ§  MASTERMIND ALGORITHM (Flawless Logic)
            # ==========================================
            guess = self.current_guess.copy()
            secret = self.secret_code.copy()
            feedback = ["ğŸ”´", "ğŸ”´", "ğŸ”´"] # Default to Miss
            
            # ğŸŸ¢ First Pass: Check for Exact Matches (Right Number, Right Place)
            for i in range(3):
                if guess[i] == secret[i]:
                    feedback[i] = "ğŸŸ¢"
                    secret[i] = None # Mark as used so it doesn't trigger yellow later
                    guess[i] = -1    # Mark guess as processed
                    
            # ğŸŸ¡ Second Pass: Check for Partial Matches (Right Number, Wrong Place)
            for i in range(3):
                if feedback[i] == "ğŸ”´" and guess[i] != -1: 
                    if guess[i] in secret:
                        feedback[i] = "ğŸŸ¡"
                        secret[secret.index(guess[i])] = None # Mark the matched secret as used
                        
            # ğŸ“œ Format History Log
            guess_str = f"{self.current_guess[0]} {self.current_guess[1]} {self.current_guess[2]}"
            feedback_str = "".join(feedback)
            self.history.append(f"`[{self.attempts}/{self.max_attempts}]` | `{guess_str}` â” {feedback_str}")
            
            # Reset current guess for the next round (Optional: you can keep them selected)
            self.current_guess = [None, None, None] 
            
            # ==========================================
            # ğŸ† WIN / LOSS CONDITIONS
            # ==========================================
            if feedback == ["ğŸŸ¢", "ğŸŸ¢", "ğŸŸ¢"]:
                await self.end_game(interaction, won=True)
            elif self.attempts >= self.max_attempts:
                await self.end_game(interaction, won=False)
            else:
                # ğŸ”„ Continue Hacking
                self.build_ui()
                await interaction.edit_original_response(embed=self.get_embed(), view=self)

    async def end_game(self, interaction: discord.Interaction, won: bool):
        self.game_over = True
        for child in self.children: child.disabled = True
        
        embed = discord.Embed()
        embed.set_thumbnail(url=self.user.display_avatar.url)
        secret_str = f"{self.secret_code[0]} {self.secret_code[1]} {self.secret_code[2]}"
        
        history_text = "\n".join(self.history)
        
        if won:
            # ğŸ’° Reward scaling based on intelligence/speed
            rewards = {1: 150000, 2: 75000, 3: 35000, 4: 15000, 5: 7500}
            win_amount = rewards[self.attempts]
            
            await smart_reward(self.user.id, win_amount) # ğŸ’¸ Safe DB Payout
            
            embed.title = "ğŸ”“ VAULT BYPASSED!"
            embed.color = 0x2ECC71 # Green
            embed.description = (
                f"### ğŸ‰ HACK SUCCESSFUL!\n"
                f"You cracked the mainframe in `{self.attempts}` attempts!\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ”¢ **The Secret PIN:** `{secret_str}`\n"
                f" â”— ğŸ’° **Loot Secured:** `+${win_amount:,}`\n\n"
                f"**TERMINAL LOG:**\n{history_text}"
            )
            embed.set_image(url="https://media.tenor.com/E0lQ-J9YpKwAAAAC/chest-open.gif")
        else:
            embed.title = "ğŸš¨ ALARM TRIGGERED!"
            embed.color = 0xE74C3C # Red
            embed.description = (
                f"### ğŸ’¥ SYSTEM LOCKDOWN!\n"
                f"Maximum attempts reached. The vault is permanently sealed.\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ”¢ **The Secret PIN:** `{secret_str}`\n"
                f" â”— ğŸ’¸ **Lost Fee:** `-${self.entry_fee:,}`\n\n"
                f"**TERMINAL LOG:**\n{history_text}"
            )
            embed.set_image(url="https://media.tenor.com/1-11Yd6_QpYAAAAC/explosion-blast.gif")
            
        await interaction.edit_original_response(embed=embed, view=self)

    def get_embed(self):
        embed = discord.Embed(title="ğŸ” TITAN VAULT CRACKER", color=0x2b2d31)
        
        instructions = (
            f"**Agent:** {self.user.mention}\n"
            f"**Objective:** Deduce the 3-digit PIN.\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"ğŸŸ¢ = Right Number, Right Place\n"
            f"ğŸŸ¡ = Right Number, Wrong Place\n"
            f"ğŸ”´ = Completely Wrong Number\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        )
        
        history_text = "\n".join(self.history) if self.history else "> *Waiting for first injection...*"
        
        embed.description = f"{instructions}### ğŸ’» SYSTEM TERMINAL:\n{history_text}\n\nâš ï¸ *Alarms trigger after {self.max_attempts} failed attempts!*"
        embed.set_thumbnail(url="https://media.tenor.com/GfSX-u7_NSAAAAAC/coding-hacker.gif")
        return embed


# ==============================================================================
# ğŸ’» MAIN COMMAND
# ==============================================================================
@game_group.command(name="vault", description="ğŸ” Hack the 3-digit PIN to crack the vault! Pure logic Mastermind game.")
@check_seized()
async def vault_cmd(interaction: discord.Interaction):
    # â³ 1. SECURE INITIALIZATION
    await interaction.response.defer(ephemeral=False)
    
    entry_fee = 5000
    
    # ğŸ’³ 2. SMART CHARGE ENTRY FEE
    paid = await smart_charge(interaction.user.id, entry_fee)
    if not paid:
        embed = discord.Embed(title="ğŸš¨ INSUFFICIENT FUNDS", color=0xE74C3C)
        embed.description = f"âŒ **Broke:** You need at least **${entry_fee:,}** (Wallet + Bank) to buy the hacking software."
        return await interaction.followup.send(embed=embed)

    # ğŸ® 3. LAUNCH GAME
    view = VaultCrackerView(interaction.user, entry_fee)
    await interaction.followup.send(embed=view.get_embed(), view=view)
                

import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# ğŸš“ TITAN CASINO: UNDERWORLD SMUGGLER (LIVE BLACK MARKET)
# ==============================================================================

class SmugglerView(discord.ui.View):
    def __init__(self, user: discord.Member, entry_fee: int):
        super().__init__(timeout=90.0) # â³ 90 Seconds Max Survival
        self.user = user
        self.entry_fee = entry_fee
        
        # ğŸ’¼ Player State
        self.cash = entry_fee # Starts with Entry Fee as "Street Cash"
        
        # ğŸ“¦ Inventory & Market Data (Volatility: How wild the price swings)
        self.inventory = {
            "magic": {"name": "ğŸ’Š Blue Magic", "qty": 0, "price": 500, "trend": "â–", "volatility": 0.35},
            "diamonds": {"name": "ğŸ’ Blood Diamonds", "qty": 0, "price": 2500, "trend": "â–", "volatility": 0.25},
            "weapons": {"name": "ğŸ”« Smuggled Arms", "qty": 0, "price": 8000, "trend": "â–", "volatility": 0.15}
        }
        
        # â±ï¸ Game State
        self.time_left = 60
        self.fbi_threat = 5 # Starts at 5% chance of raid
        self.escaped = False
        self.busted = False
        self.message = None
        self.lock = asyncio.Lock() # ğŸ›¡ï¸ Protection against rapid clicks
        
        self.build_ui()

    def build_ui(self):
        """Builds the 7 UI Buttons dynamically"""
        self.clear_items()
        
        # ğŸ›’ Row 0: BUY BUTTONS
        for i, key in enumerate(self.inventory.keys()):
            btn = discord.ui.Button(label=f"BUY {key.upper()}", style=discord.ButtonStyle.secondary, row=0, custom_id=f"buy_{key}")
            btn.callback = self.make_trade_callback("buy", key)
            self.add_item(btn)
            
        # ğŸ’¸ Row 1: SELL BUTTONS
        for i, key in enumerate(self.inventory.keys()):
            btn = discord.ui.Button(label=f"SELL {key.upper()}", style=discord.ButtonStyle.success, row=1, custom_id=f"sell_{key}")
            btn.callback = self.make_trade_callback("sell", key)
            self.add_item(btn)
        
        # ğŸƒ Row 2: ESCAPE BUTTON
        escape_btn = discord.ui.Button(label="ğŸƒ ESCAPE & CASH OUT", emoji="ğŸ’°", style=discord.ButtonStyle.danger, row=2)
        escape_btn.callback = self.escape_market
        self.add_item(escape_btn)

    def make_trade_callback(self, action: str, item_key: str):
        """Creates a dedicated callback for each Buy/Sell button"""
        async def callback(interaction: discord.Interaction):
            if interaction.user.id != self.user.id:
                return await interaction.response.send_message("âŒ **Guard:** Back off! This is not your market session.", ephemeral=True)
                
            async with self.lock:
                if self.escaped or self.busted: 
                    return await interaction.response.defer()
                
                item = self.inventory[item_key]
                
                if action == "buy":
                    # Buy Max possible
                    max_qty = self.cash // item["price"]
                    if max_qty <= 0:
                        return await interaction.response.send_message(f"âš ï¸ You don't have enough Street Cash to buy **{item['name']}**!", ephemeral=True)
                    
                    self.cash -= (max_qty * item["price"])
                    item["qty"] += max_qty
                    
                elif action == "sell":
                    # Sell All
                    if item["qty"] <= 0:
                        return await interaction.response.send_message(f"âš ï¸ You don't have any **{item['name']}** to sell!", ephemeral=True)
                        
                    revenue = item["qty"] * item["price"]
                    self.cash += revenue
                    item["qty"] = 0

                # ğŸ”„ Update UI immediately for responsive feel
                try: 
                    await interaction.response.edit_message(embed=self.get_active_embed(), view=self)
                except discord.HTTPException: 
                    pass # Ignore rare API stutters
        return callback

    async def escape_market(self, interaction: discord.Interaction):
        if interaction.user.id != self.user.id: return
        
        async with self.lock:
            if self.escaped or self.busted: return
            
            await interaction.response.defer()
            self.escaped = True
            for child in self.children: child.disabled = True
            
            # ğŸ’¸ Transfer Street Cash back to Real Bank
            if self.cash > 0:
                await smart_reward(self.user.id, self.cash)
            
            try: await interaction.edit_original_response(embed=self.get_endgame_embed(), view=self)
            except: pass

    # --- ğŸ“ˆ THE MARKET ENGINE (BACKGROUND LOOP) ---
    async def start_market(self):
        await asyncio.sleep(2) # Initial read time
        
        while self.time_left > 0 and not self.escaped and not self.busted:
            await asyncio.sleep(4.0) # Market ticks every 4 seconds
            
            async with self.lock:
                if self.escaped or self.busted: break
                
                # 1ï¸âƒ£ FBI Raid Check (Probability check)
                if random.randint(1, 100) <= self.fbi_threat:
                    self.busted = True
                    for child in self.children: child.disabled = True
                    if self.message:
                        try: await self.message.edit(embed=self.get_endgame_embed(), view=self)
                        except: pass
                    break # Exit loop!
                
                # 2ï¸âƒ£ Update Prices (Live Volatility Engine)
                for key, data in self.inventory.items():
                    old_price = data["price"]
                    
                    # 30% chance of a "Market Hype" (Big pump), 70% normal volatility
                    if random.random() < 0.30:
                        swing = random.uniform(0.1, data["volatility"] * 1.5) # Forced Pump
                    else:
                        swing = random.uniform(-data["volatility"], data["volatility"])
                        
                    new_price = int(old_price * (1 + swing))
                    
                    # Hard limits so economy doesn't break
                    new_price = max(50, min(new_price, 75000)) 
                    
                    data["price"] = new_price
                    data["trend"] = "ğŸ“ˆ" if new_price > old_price else "ğŸ“‰" if new_price < old_price else "â–"
                
                # 3ï¸âƒ£ Increase Tension & Threat
                self.time_left -= 4
                self.fbi_threat += random.randint(3, 8) # Threat increases by 3-8% every 4 seconds
                
                # 4ï¸âƒ£ Update Discord Message
                if self.message and not self.escaped and not self.busted:
                    try: await self.message.edit(embed=self.get_active_embed(), view=self)
                    except discord.HTTPException: pass
            
        # â³ Auto-Bust if time runs out and player didn't escape
        if self.time_left <= 0 and not self.escaped and not self.busted:
            async with self.lock:
                self.busted = True
                for child in self.children: child.disabled = True
                if self.message:
                    try: await self.message.edit(embed=self.get_endgame_embed(), view=self)
                    except: pass

    # --- ğŸ¨ DYNAMIC UI EMBEDS ---
    def get_active_embed(self):
        embed = discord.Embed(title="ğŸš“ THE BLACK MARKET: LIVE TRADING", color=0x2b2d31)
        embed.set_thumbnail(url=self.user.display_avatar.url)
        
        # Format Market Board
        market_str = "â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        for key, data in self.inventory.items():
            market_str += f"**{data['name']}**\n"
            market_str += f" â”£ ğŸ’µ **Price:** `${data['price']:,}` {data['trend']}\n"
            market_str += f" â”— ğŸ“¦ **Owned:** `{data['qty']}`\n\n"
        market_str += "â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬"
        
        # Threat Color Coding
        threat_emoji = "ğŸŸ¢" if self.fbi_threat < 20 else "ğŸŸ¡" if self.fbi_threat < 50 else "ğŸ”´"
        
        embed.description = (
            f"**Smuggler:** {self.user.mention} | â±ï¸ **Time Left:** `{self.time_left}s`\n"
            f"ğŸ’° **Street Cash:** `${self.cash:,}`\n"
            f"ğŸš¨ **FBI Threat Level:** {threat_emoji} `{self.fbi_threat}%`\n\n"
            f"{market_str}\n"
            f"> âš ï¸ *Buy Low, Sell High! Click **ESCAPE** before the FBI raids!*"
        )
        return embed

    def get_endgame_embed(self):
        embed = discord.Embed()
        embed.set_thumbnail(url=self.user.display_avatar.url)
        
        if self.busted:
            embed.title = "ğŸš¨ FBI RAID! YOU GOT BUSTED!"
            embed.color = 0xE74C3C # Red
            embed.description = (
                f"### ğŸ’¥ WASTED!\n"
                f"The FBI kicked down the door!\n"
                f"All your Street Cash and illegal goods were seized.\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸŸï¸ **Initial Investment:** `${self.entry_fee:,}`\n"
                f" â”— ğŸ’¸ **Total Loss:** `-${self.entry_fee:,}` (Total Wipeout)\n\n"
                f"> *You'll be spending a long time behind bars.*"
            )
            embed.set_image(url="https://media.tenor.com/1-11Yd6_QpYAAAAC/explosion-blast.gif")
            
        elif self.escaped:
            profit = self.cash - self.entry_fee
            embed.title = "ğŸƒ SUCCESSFUL ESCAPE!" if profit >= 0 else "ğŸƒ BARELY ESCAPED!"
            embed.color = 0x2ECC71 if profit >= 0 else 0xF1C40F # Green or Yellow
            
            status = "PROFIT" if profit >= 0 else "LOSS"
            sign = "+" if profit >= 0 else ""
            
            embed.description = (
                f"### ğŸ’° CASHED OUT!\n"
                f"You escaped the black market before the raid hit.\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ’¼ **Initial Investment:** `${self.entry_fee:,}`\n"
                f" â”£ ğŸ’µ **Final Street Cash:** `${self.cash:,}`\n"
                f" â”— ğŸ“ˆ **Net {status}:** `{sign}${profit:,}`\n\n"
                f"> *You clean the money and put it safely into your Bank.*"
            )
            embed.set_image(url="https://media.tenor.com/p7a8o1r5c8cAAAAC/money-rain.gif")
            
        return embed


# ==============================================================================
# ğŸ’» THE MAIN COMMAND
# ==============================================================================
@game_group.command(name="smuggler", description="ğŸš“ Trade illegal goods in the live Black Market! Buy low, sell high, and escape before the FBI raids!")
@app_commands.checks.cooldown(1, 30, key=lambda i: (i.guild_id, i.user.id))
@check_seized()
async def smuggler_game(interaction: discord.Interaction):
    # â³ 1. SECURE INITIALIZATION
    await interaction.response.defer(ephemeral=False)
    
    entry_fee = 25000
    
    # ğŸ’³ 2. SMART CHARGE ENTRY FEE
    paid = await smart_charge(interaction.user.id, entry_fee)
    if not paid:
        embed = discord.Embed(title="ğŸš¨ ACCESS DENIED", color=0xE74C3C)
        embed.description = f"âŒ **Bouncer:** You need exactly **${entry_fee:,}** (Wallet + Bank) to enter the Black Market."
        return await interaction.followup.send(embed=embed)

    # ğŸ® 3. INITIALIZE GAME ENGINE
    view = SmugglerView(interaction.user, entry_fee)
    
    # ğŸ¬ 4. SUSPENSE INTRO
    embed = discord.Embed(title="ğŸš“ ENTERING THE BLACK MARKET...", color=0x3498DB)
    embed.description = (
        f"### ğŸ’¼ LAUNDERING FUNDS\n"
        f"Converting your `${entry_fee:,}` into untraceable **Street Cash**...\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"âš ï¸ **WARNING:** The FBI is actively patrolling the area.\n"
        f"Watch the Threat Level and escape before it hits 100%!"
    )
    
    msg = await interaction.followup.send(embed=embed, view=view, wait=True)
    view.message = msg # Bind message to view for the background loop
    
    # â±ï¸ 5. WAKE UP THE MARKET ALGORITHM
    asyncio.create_task(view.start_market())


import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# âš”ï¸ TITAN CASINO: THE ENDLESS COLOSSEUM (RPG SURVIVAL)
# ==============================================================================

class ColosseumView(discord.ui.View):
    def __init__(self, user: discord.Member, entry_fee: int):
        super().__init__(timeout=180) # â³ 3 Min inactivity timeout
        self.user = user
        self.entry_fee = entry_fee
        
        # ğŸ‘¤ Player Stats
        self.player_max_hp = 100
        self.player_hp = 100
        self.potions = 3
        self.total_loot = 0
        
        # ğŸ‘¹ Game State
        self.level = 1
        self.combat_log = ["*Welcome to the Colosseum. The steel gates slam shut behind you...*"]
        self.game_over = False
        self.escaped = False
        self.lock = asyncio.Lock() # ğŸ›¡ï¸ Anti-Spam Lock
        
        self.spawn_enemy()
        self.build_ui()

    def spawn_enemy(self):
        """Generates a progressively harder enemy"""
        enemies = [
            "ğŸŸ¢ Sickly Goblin", "ğŸ’€ Skeleton Warrior", "ğŸ‘º Savage Orc", 
            "ğŸ¦‡ Vampire Lord", "ğŸŒ‘ Dark Knight", "ğŸ”¥ Hell Demon", 
            "ğŸ‰ Ancient Dragon", "ğŸ‘‘ TITAN OF DEATH"
        ]
        
        # Scale difficulty based on level
        idx = min(self.level - 1, len(enemies) - 1)
        name = enemies[idx]
        
        if self.level > len(enemies):
            name = f"ğŸŒŒ Awakened God LVL {self.level}"
            
        self.enemy_name = name
        # HP scales wildly: 30 base + (Level * 20 * variance)
        self.enemy_max_hp = int(30 + (self.level * 20 * random.uniform(0.8, 1.2)))
        self.enemy_hp = self.enemy_max_hp
        
        # Enemy Damage (Min, Max)
        self.enemy_dmg = (int(self.level * 3), int(self.level * 8 + 5))
        
        # Reward for beating this specific level
        self.level_loot = int(self.level * random.randint(5000, 10000))

    def make_hp_bar(self, current_hp: int, max_hp: int, length: int = 10):
        """Creates a dynamic visual health bar"""
        current_hp = max(0, current_hp) # Prevent negative visual HP
        ratio = current_hp / max_hp
        
        filled = int(ratio * length)
        empty = length - filled
        
        color = "ğŸŸ©" if ratio > 0.5 else "ğŸŸ¨" if ratio > 0.25 else "ğŸŸ¥"
        return f"`[{color * filled}{'â¬›' * empty}]` **{current_hp}/{max_hp}**"

    def build_ui(self):
        """Builds the combat interface dynamically"""
        self.clear_items()
        
        # âš”ï¸ Row 0: Combat Actions
        btn_attack = discord.ui.Button(label="ATTACK", emoji="âš”ï¸", style=discord.ButtonStyle.danger, row=0, custom_id="action_attack")
        btn_defend = discord.ui.Button(label="DEFEND", emoji="ğŸ›¡ï¸", style=discord.ButtonStyle.primary, row=0, custom_id="action_defend")
        btn_heal = discord.ui.Button(label=f"HEAL ({self.potions})", emoji="ğŸ§ª", style=discord.ButtonStyle.success, row=0, custom_id="action_heal", disabled=(self.potions <= 0))
        
        btn_attack.callback = self.handle_combat
        btn_defend.callback = self.handle_combat
        btn_heal.callback = self.handle_combat
        
        self.add_item(btn_attack)
        self.add_item(btn_defend)
        self.add_item(btn_heal)
        
        # ğŸƒ Row 1: Flee / Escape
        escape_btn = discord.ui.Button(label=f"FLEE WITH ${self.total_loot:,}", emoji="ğŸƒ", style=discord.ButtonStyle.secondary, row=1)
        escape_btn.callback = self.flee_colosseum
        if self.total_loot == 0: 
            escape_btn.disabled = True # Can't flee with 0 money
        self.add_item(escape_btn)

    async def handle_combat(self, interaction: discord.Interaction):
        if interaction.user.id != self.user.id:
            return await interaction.response.send_message("âŒ **Guard:** You are not the gladiator in the arena!", ephemeral=True)
            
        async with self.lock:
            if self.game_over: return await interaction.response.defer()
            await interaction.response.defer()
            
            action = interaction.data["custom_id"].split("_")[1]
            self.combat_log = [] # Clear old log for the new turn
            
            # ==========================================
            # ğŸ§‘â€ğŸ¤â€ğŸ§‘ PLAYER TURN
            # ==========================================
            if action == "attack":
                dmg = random.randint(15, 30)
                # 15% chance for Critical Hit
                if random.randint(1, 100) <= 15:
                    dmg = int(dmg * 1.5)
                    self.combat_log.append(f"ğŸ’¥ **CRITICAL HIT!** You dealt `{dmg}` DMG to {self.enemy_name}!")
                else:
                    self.combat_log.append(f"âš”ï¸ You slashed the {self.enemy_name} for `{dmg}` DMG.")
                self.enemy_hp -= dmg
                
            elif action == "defend":
                self.combat_log.append(f"ğŸ›¡ï¸ You raised your shield! Incoming damage heavily reduced.")
                
            elif action == "heal":
                if self.potions > 0:
                    self.potions -= 1
                    heal_amt = random.randint(40, 60)
                    self.player_hp = min(self.player_max_hp, self.player_hp + heal_amt)
                    self.combat_log.append(f"ğŸ§ª You drank a health potion and restored `{heal_amt}` HP!")

            # ==========================================
            # ğŸ’€ CHECK ENEMY DEATH
            # ==========================================
            if self.enemy_hp <= 0:
                self.enemy_hp = 0
                self.total_loot += self.level_loot
                self.combat_log.append(f"ğŸ’€ **{self.enemy_name.upper()} SLAIN!** You looted `${self.level_loot:,}`.")
                
                # Level Up & Spawn Next Enemy
                self.level += 1
                self.spawn_enemy()
                
                # Bonus chance to find a potion
                if random.random() < 0.30:
                    self.potions += 1
                    self.combat_log.append(f"âœ¨ *You found a dropped potion on the corpse!*")
                    
                self.combat_log.append(f"âš ï¸ **A NEW CHALLENGER APPEARS:** The {self.enemy_name} steps into the arena!")
                
            # ==========================================
            # ğŸ‘¹ ENEMY TURN (If still alive)
            # ==========================================
            else:
                e_dmg = random.randint(self.enemy_dmg[0], self.enemy_dmg[1])
                
                if action == "defend":
                    e_dmg = int(e_dmg * 0.3) # 70% damage reduction when defending
                    counter = random.randint(10, 20)
                    self.enemy_hp -= counter
                    self.combat_log.append(f"ğŸ—¡ï¸ You bashed with your shield for `{counter}` DMG!")
                    
                self.player_hp -= e_dmg
                self.combat_log.append(f"ğŸ©¸ The {self.enemy_name} hit you for `{e_dmg}` DMG!")
                
                # ğŸ’€ CHECK PLAYER DEATH
                if self.player_hp <= 0:
                    self.player_hp = 0
                    self.game_over = True
                    await self.end_game(interaction, status="DIED")
                    return

            # ğŸ”„ Rebuild UI and Update Turn
            self.build_ui()
            await interaction.edit_original_response(embed=self.get_embed(), view=self)

    async def flee_colosseum(self, interaction: discord.Interaction):
        if interaction.user.id != self.user.id: 
            return await interaction.response.send_message("âŒ **Guard:** You cannot flee someone else's battle!", ephemeral=True)
            
        async with self.lock:
            if self.game_over: return await interaction.response.defer()
            await interaction.response.defer()
            
            self.escaped = True
            self.game_over = True
            
            # ğŸ’¸ Safe DB Payout
            await smart_reward(self.user.id, self.total_loot)
            
            await self.end_game(interaction, status="ESCAPED")

    async def end_game(self, interaction: discord.Interaction, status: str):
        for child in self.children: child.disabled = True
        
        embed = discord.Embed()
        embed.set_thumbnail(url=self.user.display_avatar.url)
        
        if status == "DIED":
            embed.title = "ğŸ’€ WASTED IN THE ARENA"
            embed.color = 0x8B0000 # Dark Red
            embed.description = (
                f"### ğŸ©¸ FATAL BLOW!\n"
                f"You died fighting the **{self.enemy_name}** on Level {self.level}!\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸŸï¸ **Entry Fee Lost:** `${self.entry_fee:,}`\n"
                f" â”— ğŸ’¸ **Dropped Loot:** `${self.total_loot:,}` (Stolen by scavengers)\n\n"
                f"> *The crowd cheers as your body is dragged away.*"
            )
            embed.set_image(url="https://media.tenor.com/d6-SreC3_p8AAAAC/wasted-gta5.gif")
        else:
            embed.title = "ğŸƒ TACTICAL RETREAT"
            embed.color = 0x2ECC71 # Green
            embed.description = (
                f"### ğŸ’° ESCAPED ALIVE!\n"
                f"You fled the arena at Level {self.level} before things got too bloody.\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸŸï¸ **Entry Fee Paid:** `${self.entry_fee:,}`\n"
                f" â”— ğŸ’µ **Winnings Secured:** `+${self.total_loot:,}`\n\n"
                f"> *Cowardly? Yes. Rich? Also yes.*"
            )
            embed.set_image(url="https://media.tenor.com/p7a8o1r5c8cAAAAC/money-rain.gif")
            
        try: await interaction.edit_original_response(embed=embed, view=self)
        except: pass

    def get_embed(self):
        embed = discord.Embed(title=f"âš”ï¸ THE ENDLESS COLOSSEUM", color=0x2b2d31)
        embed.set_thumbnail(url=self.user.display_avatar.url)
        
        # Format Combat Log
        log_str = "\n".join([f"> {line}" for line in self.combat_log])
        
        embed.description = (
            f"**Gladiator:** {self.user.mention}\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"ğŸ† **Current Wave:** `Level {self.level}`\n"
            f"ğŸ’° **Secured Loot Pool:** `${self.total_loot:,}`\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"ğŸ‘¤ **YOUR STATUS:**\n"
            f"â¤ï¸ HP: {self.make_hp_bar(self.player_hp, self.player_max_hp)}\n"
            f"ğŸ§ª Potions: `{self.potions} Left`\n\n"
            f"ğŸ‘¹ **ENEMY STATUS:** [{self.enemy_name}]\n"
            f"ğŸ–¤ HP: {self.make_hp_bar(self.enemy_hp, self.enemy_max_hp)}\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"ğŸ“œ **COMBAT LOG:**\n{log_str}"
        )
        return embed

# ==============================================================================
# ğŸ’» THE MAIN COMMAND
# ==============================================================================
@game_group.command(name="colosseum", description="âš”ï¸ Fight monsters in the endless arena! Attack, Defend, and Heal to survive.")
@check_seized()
async def colosseum_cmd(interaction: discord.Interaction):
    # â³ 1. SECURE INITIALIZATION
    await interaction.response.defer(ephemeral=False)
    
    entry_fee = 10000
    
    # ğŸ’³ 2. SMART CHARGE ENTRY FEE
    paid = await smart_charge(interaction.user.id, entry_fee)
    if not paid:
        embed = discord.Embed(title="ğŸš¨ ENTRY DENIED", color=0xE74C3C)
        embed.description = f"âŒ **Broke:** The arena guards demand **${entry_fee:,}** (Wallet + Bank) for entry."
        return await interaction.followup.send(embed=embed)

    # ğŸ® 3. LAUNCH ARENA
    view = ColosseumView(interaction.user, entry_fee)
    await interaction.followup.send(embed=view.get_embed(), view=view)


import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# ğŸ° TITAN CASINO: THE DEVIL'S SLOTS (RUTHLESS PROBABILITY)
# ==============================================================================

class DevilsSlotsView(discord.ui.View):
    def __init__(self, user: discord.Member):
        super().__init__(timeout=120) # â³ 2 Mins Session
        self.user = user
        self.emojis = ["ğŸ", "ğŸ’", "ğŸ‡", "ğŸ””", "ğŸ’", "ğŸ‹", "ğŸ‰", "ğŸ’€"]
        
        self.is_spinning = False
        self.lock = asyncio.Lock() # ğŸ›¡ï¸ Prevents rapid-click exploits

    def generate_slots(self, is_win: bool):
        """Generates the 3 slot emojis based on a strict win/loss condition."""
        if is_win:
            # 100% Matching if win is triggered mathematically
            sym = random.choice(self.emojis[:-1]) # Exclude the Skull (ğŸ’€) for normal wins
            return [sym, sym, sym]
        else:
            # Guarantee a mismatch (to strictly enforce loss)
            slots = [random.choice(self.emojis) for _ in range(3)]
            while slots[0] == slots[1] == slots[2]: # If accidentally matched, reroll the last one
                slots[2] = random.choice(self.emojis)
            
            # 50% chance to put a Skull to mock the player
            if random.random() > 0.5:
                slots[random.randint(0, 2)] = "ğŸ’€"
            return slots

    def get_spin_embed(self, slots: list, status: str = "SPINNING", mode: str = "NORMAL", amount: int = 0):
        embed = discord.Embed()
        embed.set_thumbnail(url=self.user.display_avatar.url)
        
        # ğŸ° Authentic Slot Visual formatting
        slot_str = f"## ğŸ° [ {slots[0]} | {slots[1]} | {slots[2]} ] ğŸ°"
        
        if status == "SPINNING":
            embed.title = "ğŸ° THE DEVIL'S MACHINE: SPINNING..."
            embed.color = 0xF1C40F # Yellow/Gold
            embed.description = f"{slot_str}\n\n> *The reels are turning at blinding speed...*"
            
        elif status == "WON":
            embed.title = "ğŸ† MIRACLE JACKPOT HIT!"
            embed.color = 0x2ECC71 # Green
            embed.description = (
                f"{slot_str}\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f"### ğŸ‰ YOU BEAT THE ODDS!\n"
                f"The devil is furious. You just won **${amount:,}**!\n"
                f"ğŸ’° **Status:** `Funds deposited to Bank`"
            )
            embed.set_image(url="https://media.tenor.com/bXjOidvDvoQAAAAC/confetti-celebrate.gif")
            
        elif status == "LOST":
            embed.title = "ğŸ’€ THE HOUSE ALWAYS WINS"
            embed.color = 0x8B0000 # Dark Red
            
            if mode == "NORMAL":
                embed.description = (
                    f"{slot_str}\n"
                    f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                    f"### ğŸ“‰ MISMATCH!\n"
                    f"You lost your $10,000 bet. Better luck next time.\n"
                    f"ğŸ’¸ **Status:** `Funds seized by the Casino`"
                )
            else:
                embed.description = (
                    f"{slot_str}\n"
                    f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                    f"### ğŸ”¥ SOUL CONSUMED!\n"
                    f"You played with fire and burned your wallet!\n"
                    f"The Devil just took **50% of your net worth** (`-${amount:,}`)!\n"
                    f"ğŸ’¸ **Status:** `Bankrupting Sequence Initiated`"
                )
            embed.set_image(url="https://media.tenor.com/d6-SreC3_p8AAAAC/wasted-gta5.gif")

        embed.set_footer(text=f"House Edge Active â€¢ Titan Casino", icon_url="https://cdn-icons-png.flaticon.com/512/805/805273.png")
        return embed

    async def run_spin_animation(self, interaction: discord.Interaction, mode: str, is_win: bool, win_amount: int = 0, loss_amount: int = 0):
        # ğŸ”’ Disable buttons during the spin sequence
        for child in self.children: child.disabled = True
        
        # ğŸŒ€ Animation Loop (3 frames for suspense)
        for _ in range(3):
            random_slots = [random.choice(self.emojis) for _ in range(3)]
            temp_embed = self.get_spin_embed(random_slots, "SPINNING")
            try: 
                await interaction.edit_original_response(embed=temp_embed, view=None)
            except discord.HTTPException: 
                pass # Ignore rate limits on rapid edits
            await asyncio.sleep(0.8)

        # ğŸ›‘ Final Result Processing
        final_slots = self.generate_slots(is_win)
        
        if is_win:
            # ğŸ’¸ Safe DB Payout
            await smart_reward(self.user.id, win_amount)
            final_embed = self.get_spin_embed(final_slots, "WON", mode, win_amount)
        else:
            if mode == "SOUL" and loss_amount > 0:
                # ğŸ’¸ Brutal 50% Deduction
                await smart_charge(self.user.id, loss_amount)
            final_embed = self.get_spin_embed(final_slots, "LOST", mode, loss_amount)
            
        # ğŸ”“ Re-enable buttons for the next spin
        for child in self.children: child.disabled = False
        self.is_spinning = False
        
        try: await interaction.edit_original_response(embed=final_embed, view=self)
        except: pass


    @discord.ui.button(label="NORMAL SPIN ($10k)", emoji="ğŸ°", style=discord.ButtonStyle.primary, custom_id="spin_normal")
    async def btn_normal(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user.id: 
            return await interaction.response.send_message("âŒ **Guard:** This is not your machine!", ephemeral=True)
            
        async with self.lock:
            if self.is_spinning: return await interaction.response.defer()
            await interaction.response.defer()
            
            # ğŸ’³ SMART CHARGE $10k
            cost = 10000
            paid = await smart_charge(self.user.id, cost)
            if not paid:
                return await interaction.followup.send(f"âŒ **Broke:** You need at least `${cost:,}` to pull this lever.", ephemeral=True)

            self.is_spinning = True
            
            # ğŸ§  STRICT 10% WIN RATE LOGIC
            is_win = random.randint(1, 100) <= 10 # 1 to 10 = Win, 11 to 100 = Lose
            
            await self.run_spin_animation(interaction, mode="NORMAL", is_win=is_win, win_amount=50000)

    @discord.ui.button(label="SOUL SPIN (Risk 50% Bank)", emoji="ğŸ”¥", style=discord.ButtonStyle.danger, custom_id="spin_soul")
    async def btn_soul(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user.id: 
            return await interaction.response.send_message("âŒ **Guard:** Step away from the cursed machine.", ephemeral=True)
            
        async with self.lock:
            if self.is_spinning: return await interaction.response.defer()
            await interaction.response.defer()
            
            # ğŸ“Š FETCH CURRENT BALANCE FOR 50% CALCULATION
            wallet, bank = await get_balance(self.user.id)
            total_wealth = wallet + bank
            
            if total_wealth < 10000:
                return await interaction.followup.send(f"âŒ **The Devil Speaks:** *\"I don't deal with peasants. Come back when you have at least $10,000 net worth.\"*", ephemeral=True)

            self.is_spinning = True
            
            # ğŸ§  STRICT 5% WIN RATE FOR SOUL SPIN (Extremely rare!)
            is_win = random.randint(1, 100) <= 5
            loss_amount = int(total_wealth * 0.50) # ğŸ”ª Lose exactly half of net worth!
            
            await self.run_spin_animation(interaction, mode="SOUL", is_win=is_win, win_amount=1000000, loss_amount=loss_amount)


# ==============================================================================
# ğŸ’» THE MAIN COMMAND
# ==============================================================================
@game_group.command(name="slots", description="ğŸ° Spin the Devil's Slots! Low win rate, but massive payouts including the Soul Spin!")
@check_seized()
async def slots_cmd(interaction: discord.Interaction):
    # â³ SECURE DEFER
    await interaction.response.defer(ephemeral=False)
    
    embed = discord.Embed(title="ğŸ° THE DEVIL'S SLOTS", color=0x2b2d31)
    embed.set_thumbnail(url=interaction.user.display_avatar.url)
    embed.description = (
        f"### ğŸ©¸ WELCOME TO HELL\n"
        f"Welcome {interaction.user.mention}, to the most brutal slot machine in the underworld.\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"**ğŸ”µ NORMAL SPIN:**\n"
        f"> Costs `$10,000`. Win `$50,000`. (10% Chance)\n\n"
        f"**ğŸ”¥ SOUL SPIN:**\n"
        f"> Free to spin! Win **`$1,000,000`**.\n"
        f"> **BUT** if you lose, the devil takes **50% of your total net worth**! (5% Chance)\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"âš ï¸ *(The house always wins. Play at your own risk.)*"
    )
    # embed.set_image(url="https://media.tenor.com/images/13019d5e32047ed6f345c26bdf3b56a3/tenor.gif")
    
    view = DevilsSlotsView(interaction.user)
    await interaction.followup.send(embed=embed, view=view)



import discord
from discord import app_commands
import random
import asyncio
import datetime as dt

# ==============================================================================
# ğŸ”¨ TITAN CASINO: BLACK MARKET LIVE AUCTION (MULTI-PLAYER)
# ==============================================================================

class AuctionView(discord.ui.View):
    def __init__(self, host: discord.Member):
        super().__init__(timeout=300) # â³ 5 minutes absolute max
        self.host = host
        self.current_bid = 0
        self.highest_bidder = None
        self.end_time = dt.datetime.now() + dt.timedelta(seconds=20) # â³ Initial 20s
        
        self.auction_active = True
        self.message = None
        self.lock = asyncio.Lock() # ğŸ›¡ï¸ Anti-Collision Lock

        # ğŸ“¦ Mystery Flavors
        self.mystery_items = [
            "ğŸ“¦ Seized Shipping Container #402",
            "ğŸ‘œ An Ex-Billionaire's 'Lost' Luggage",
            "ğŸº Ancient Artifact smuggled from Egypt",
            "ğŸ’» A Hacker's Encrypted Hard Drive",
            "ğŸ¨ Stolen Renaissance Painting",
            "ğŸ§° Abandoned Bank Safety Deposit Box"
        ]
        self.item_name = random.choice(self.mystery_items)

    def get_auction_embed(self):
        now = dt.datetime.now()
        time_left = max(0, int((self.end_time - now).total_seconds()))
        
        if not self.auction_active:
            # ğŸ›‘ AUCTION ENDED STATE
            embed = discord.Embed(title="ğŸ”¨ AUCTION CLOSED!", color=0xF1C40F) # Gold
            winner_text = self.highest_bidder.mention if self.highest_bidder else "No Bids"
            embed.description = (
                f"### ğŸ“¦ {self.item_name}\n"
                f"**Final Price:** `${self.current_bid:,}`\n"
                f"**Winner:** {winner_text}\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f"> *Prying open the crate locks...*"
            )
            embed.set_thumbnail(url="https://media.tenor.com/GfSX-u7_NSAAAAAC/coding-hacker.gif") 
            return embed

        # ğŸŸ¢ ACTIVE BIDDING STATE
        embed = discord.Embed(title=f"ğŸ”¨ LIVE AUCTION: THE BLACK MARKET", color=0x3498DB) # Blue
        leader_text = self.highest_bidder.mention if self.highest_bidder else "*Waiting for first bid...*"
        
        embed.description = (
            f"### {self.item_name}\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"ğŸ’° **CURRENT HIGHEST BID:** `${self.current_bid:,}`\n"
            f"ğŸ‘‘ **Leading Bidder:** {leader_text}\n"
            f"â±ï¸ **Time Remaining:** `{time_left}s` *(Resets on new bid)*\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"âš ï¸ **Warning:** The contents are completely unknown.\n"
            f"ğŸ‘‰ *Tap a button below to place your bid!*"
        )
        embed.set_thumbnail(url="https://cdn-icons-png.flaticon.com/512/7379/7379278.png")
        return embed

    async def place_bid(self, interaction: discord.Interaction, amount: int):
        async with self.lock:
            # 1. State Checks
            if not self.auction_active:
                return await interaction.response.send_message("âŒ **Too Slow!** The auction just ended!", ephemeral=True)
                 
            if interaction.user == self.highest_bidder:
                return await interaction.response.send_message("âŒ You are already the highest bidder! Stop bidding against yourself.", ephemeral=True)

            # 2. Balance Check (Doesn't deduct yet, just checks)
            required_funds = self.current_bid + amount
            wallet, bank = await get_balance(interaction.user.id)
            total_wealth = wallet + bank
            
            if total_wealth < required_funds:
                return await interaction.response.send_message(f"âŒ **Broke!** You need at least `${required_funds:,}` to place this bid.", ephemeral=True)

            # 3. Process Bid
            await interaction.response.defer()
            self.current_bid += amount
            self.highest_bidder = interaction.user
            
            # â±ï¸ Reset Timer to 15s from NOW (More intense than 20s)
            self.end_time = dt.datetime.now() + dt.timedelta(seconds=15)
            
            # Update UI immediately
            try: await self.message.edit(embed=self.get_auction_embed(), view=self)
            except: pass

    # ğŸ›ï¸ UI BUTTONS
    @discord.ui.button(label="Bid +$5k", emoji="ğŸ’µ", style=discord.ButtonStyle.primary, row=0)
    async def bid_small(self, i, b): await self.place_bid(i, 5000)

    @discord.ui.button(label="Bid +$25k", emoji="ğŸ’°", style=discord.ButtonStyle.success, row=0)
    async def bid_medium(self, i, b): await self.place_bid(i, 25000)

    @discord.ui.button(label="Bid +$100k", emoji="ğŸš¨", style=discord.ButtonStyle.danger, row=1)
    async def bid_large(self, i, b): await self.place_bid(i, 100000)

    async def end_auction(self):
        self.auction_active = False
        for child in self.children: child.disabled = True
        
        # Lock in the 'SOLD' UI
        try: await self.message.edit(embed=self.get_auction_embed(), view=self)
        except: pass
        
        # ==========================================
        # ğŸ“¦ NO BIDS PLACED
        # ==========================================
        if not self.highest_bidder:
            no_bid_embed = discord.Embed(title="ğŸ”¨ AUCTION FAILED", color=0x95A5A6)
            no_bid_embed.description = "No one placed a bid. The item was thrown into the incinerator."
            try: await self.message.edit(embed=no_bid_embed, view=None)
            except: pass
            return

        # ==========================================
        # ğŸ† WINNER PROCESSING
        # ==========================================
        # 1. Deduct Winning Bid Amount securely!
        paid = await smart_charge(self.highest_bidder.id, self.current_bid)
        
        if not paid:
            # If they transferred money out mid-auction to cheat
            cheat_embed = discord.Embed(title="ğŸš¨ FRAUD DETECTED!", color=0x8B0000)
            cheat_embed.description = f"### ğŸš” ARRESTED!\n{self.highest_bidder.mention} could not pay the `${self.current_bid:,}` they bid!\nThe guards have seized the item and blacklisted them."
            try: await self.message.edit(embed=cheat_embed, view=None)
            except: pass
            return

        # 2. Suspense Pause
        await asyncio.sleep(4.0) 
        
        # 3. DETERMINE ACTUAL VALUE (The 90% Scam Rule)
        luck = random.randint(1, 100)
        
        if luck <= 90:
            # ğŸ“‰ SCAM: Box contains junk (10% to 80% of bid value)
            multiplier = random.uniform(0.1, 0.8)
            actual_value = int(self.current_bid * multiplier)
            profit_loss = actual_value - self.current_bid
            
            color = 0xE74C3C # Red
            title = "ğŸ“‰ SCAMMED!"
            desc_text = f"The crate contained literal garbage worth only **${actual_value:,}**.\nYou drastically overpaid and lost **${abs(profit_loss):,}**!"
            thumb = "https://media.tenor.com/d6-SreC3_p8AAAAC/wasted-gta5.gif"
        else:
            # ğŸ‰ JACKPOT: Box contains rare items (150% to 350% of bid value)
            multiplier = random.uniform(1.5, 3.5)
            actual_value = int(self.current_bid * multiplier)
            profit_loss = actual_value - self.current_bid
            
            color = 0x2ECC71 # Green
            title = "ğŸ‰ JACKPOT FIND!"
            desc_text = f"Unbelievable! The crate held rare contraband worth **${actual_value:,}**.\nYou made a pure profit of **+${profit_loss:,}**!"
            thumb = "https://media.tenor.com/p7a8o1r5c8cAAAAC/money-rain.gif"

        # 4. Safe Payout of the Box's Value
        await smart_reward(self.highest_bidder.id, actual_value)

        # 5. Final Reveal Embed
        final_embed = discord.Embed(title=f"ğŸ”¨ REVEAL: {title}", color=color)
        final_embed.set_thumbnail(url=self.highest_bidder.display_avatar.url)
        final_embed.description = (
            f"**Buyer:** {self.highest_bidder.mention}\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"ğŸ’¸ **Bid Paid:** `${self.current_bid:,}`\n"
            f"ğŸ“¦ **Crate Value:** `${actual_value:,}`\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"### {desc_text}"
        )
        final_embed.set_image(url=thumb)
        
        try: await self.message.edit(embed=final_embed, view=None)
        except: pass


    async def timer_loop(self):
        """Background engine that monitors the clock without spamming the Discord API."""
        await asyncio.sleep(1.0)
        
        while self.auction_active:
            now = dt.datetime.now()
            
            # Check if time ran out
            if now >= self.end_time:
                await self.end_auction()
                break
            
            # Update UI every 3 seconds to show time ticking down
            # Using 3 seconds prevents HTTP 429 Rate Limit errors
            if int((self.end_time - now).total_seconds()) % 3 == 0:
                try: 
                    await self.message.edit(embed=self.get_auction_embed(), view=self)
                except discord.HTTPException: 
                    pass 
                 
            await asyncio.sleep(1.0)


# ==============================================================================
# ğŸ’» MAIN COMMAND
# ==============================================================================
@game_group.command(name="auction", description="ğŸ”¨ Start a Live Black Market Auction! Outbid the server for mystery crates.")
@app_commands.checks.cooldown(1, 180, key=lambda i: i.guild_id) # â³ 3 Min Cooldown per server
@check_seized()
async def auction_cmd(interaction: discord.Interaction):
    # Optional: Restrict to admins/mods if you don't want normal users spamming it
    # if not interaction.user.guild_permissions.manage_messages:
    #    return await interaction.response.send_message("âŒ Only server moderators can host an auction.", ephemeral=True)
        
    await interaction.response.defer(ephemeral=False)
    
    view = AuctionView(interaction.user)
    
    # Send UI and capture message object
    msg = await interaction.followup.send(embed=view.get_auction_embed(), view=view, wait=True)
    view.message = msg
    
    # â±ï¸ Wake up the background timer
    asyncio.create_task(view.timer_loop())

# --- â³ COOLDOWN ERROR HANDLER ---
@auction_cmd.error
async def auction_error(interaction: discord.Interaction, error: app_commands.AppCommandError):
    if isinstance(error, app_commands.CommandOnCooldown):
        rem = int(error.retry_after)
        minutes, seconds = divmod(rem, 60)
        embed = discord.Embed(title="â³ AUCTION HOUSE CLOSED", color=0xF39C12)
        embed.description = f"The auctioneers are taking a break.\nNext auction opens in `{minutes}m {seconds}s`."
        await interaction.response.send_message(embed=embed, ephemeral=True)

        
import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# ğŸ¦ TITAN CASINO: THE SYNDICATE HEIST (MULTIPLAYER)
# ==============================================================================

HEIST_ENTRY_FEE = 50000
HEIST_PAYOUT = 500000

class HeistLobbyView(discord.ui.View):
    def __init__(self, host: discord.Member, entry_fee: int):
        super().__init__(timeout=120.0) # â³ 2 Minutes to gather the crew
        self.host = host
        self.entry_fee = entry_fee
        
        self.crew = [host] # List of Member objects
        self.max_crew = 4
        
        self.heist_started = False
        self.message = None
        self.lock = asyncio.Lock() # ğŸ›¡ï¸ Anti-Spam & Race Condition Lock

    def get_lobby_embed(self):
        embed = discord.Embed(title="ğŸ¦ THE SYNDICATE HEIST: LOBBY", color=0x2b2d31)
        
        # ğŸ‘¥ Format Crew List
        crew_list = ""
        for i, member in enumerate(self.crew):
            role_icon = "ğŸ‘‘" if i == 0 else "ğŸ‘¤"
            crew_list += f" â”£ {role_icon} **{member.display_name}** `[ READY ]`\n"
        crew_list += f" â”— *Waiting for {self.max_crew - len(self.crew)} more...*" if len(self.crew) < self.max_crew else " â”— *Crew is Full!*"

        embed.description = (
            f"### ğŸ¯ TARGET: THE CENTRAL VAULT\n"
            f"**Mastermind:** {self.host.mention}\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"ğŸ’° **Buy-in (Gear Cost):** `${self.entry_fee:,}` per person\n"
            f"ğŸ† **Potential Payout:** `${HEIST_PAYOUT:,}` per survivor!\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"**THE CREW ({len(self.crew)}/{self.max_crew}):**\n"
            f"{crew_list}\n\n"
            f"> *Hit 'Join Crew' to gear up. Mastermind clicks 'Start' when ready.*"
        )
        embed.set_thumbnail(url="https://media.tenor.com/images/13019d5e32047ed6f345c26bdf3b56a3/tenor.gif")
        return embed

    @discord.ui.button(label="JOIN CREW ($50k)", emoji="ğŸ”«", style=discord.ButtonStyle.primary, custom_id="join_crew")
    async def btn_join(self, interaction: discord.Interaction, button: discord.ui.Button):
        async with self.lock:
            if self.heist_started: 
                return await interaction.response.defer()
            
            if interaction.user in self.crew:
                return await interaction.response.send_message("âŒ **Guard:** You are already in the getaway van!", ephemeral=True)
                
            if len(self.crew) >= self.max_crew:
                return await interaction.response.send_message("âŒ **Full:** The getaway van has no more seats!", ephemeral=True)

            await interaction.response.defer()
            
            # ğŸ’³ SMART CHARGE: Deduct entry fee upfront safely
            paid = await smart_charge(interaction.user.id, self.entry_fee)
            if not paid:
                return await interaction.followup.send(f"âŒ **Broke:** You need at least `${self.entry_fee:,}` (Wallet + Bank) to buy your heist gear.", ephemeral=True)

            # âœ… Add to crew & Update Lobby
            self.crew.append(interaction.user)
            
            # If crew is full, disable the join button
            if len(self.crew) >= self.max_crew:
                button.disabled = True
                
            try: await interaction.edit_original_response(embed=self.get_lobby_embed(), view=self)
            except discord.HTTPException: pass

    @discord.ui.button(label="START HEIST", emoji="ğŸš€", style=discord.ButtonStyle.danger, custom_id="start_heist")
    async def btn_start(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.host.id:
            return await interaction.response.send_message("âŒ Only the **Mastermind** can initiate the breach!", ephemeral=True)
            
        async with self.lock:
            if self.heist_started: return
            
            self.heist_started = True
            for child in self.children: child.disabled = True
            
            await interaction.response.defer()
            await self.execute_heist(interaction)

    async def execute_heist(self, interaction: discord.Interaction):
        # ğŸ¬ 1. SUSPENSE PHASE
        suspense_embed = discord.Embed(title="ğŸ¥· INFILTRATING THE BANK...", color=0x3498DB)
        suspense_embed.description = (
            f"### ğŸ”Œ CUTTING THE POWER\n"
            f"The crew approaches the back entrance.\n"
            f"Cameras disabled. Entering through the roof vents...\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"> *Assigning tactical roles...*"
        )
        suspense_embed.set_image(url="https://media.tenor.com/GfSX-u7_NSAAAAAC/coding-hacker.gif")
        
        try: await interaction.edit_original_response(embed=suspense_embed, view=None)
        except: pass
        
        await asyncio.sleep(4.5) # The wait of destiny

        # ğŸ­ 2. ASSIGN ROLES DYNAMICALLY
        all_roles = ["ğŸ’» The Hacker", "ğŸ”« The Muscle", "ğŸï¸ The Driver", "ğŸ¥· The Ghost"]
        random.shuffle(all_roles)
        role_assignments = {member: all_roles[i] for i, member in enumerate(self.crew)}
        
        crew_roles_str = "â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        for member, role in role_assignments.items():
            crew_roles_str += f" â”£ {role} : {member.mention}\n"
        crew_roles_str += "â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"

        # ğŸ§  3. STRICT 10% WIN RATE CALCULATION
        is_success = random.randint(1, 100) <= 10
        
        if is_success:
            # ğŸ† SUCCESS SCENARIO (10%)
            for member in self.crew:
                await smart_reward(member.id, HEIST_PAYOUT) # ğŸ’¸ Safe Multi-Payout
                
            final_embed = discord.Embed(title="ğŸ’° HEIST SUCCESSFUL!", color=0x2ECC71)
            final_embed.description = (
                f"### ğŸ‰ FLAWLESS EXECUTION!\n"
                f"The crew bypassed the vault, grabbed the gold, and vanished into the night.\n"
                f"{crew_roles_str}"
                f"ğŸ’¸ **PAYOUT:** `+${HEIST_PAYOUT:,}` added to everyone's bank!"
            )
            final_embed.set_image(url="https://media.tenor.com/p7a8o1r5c8cAAAAC/money-rain.gif")
            
        else:
            # ğŸ’€ BUSTED SCENARIO (90%)
            blamed_member = random.choice(self.crew)
            blamed_role = role_assignments[blamed_member]
            
            # Dynamic fail reasons based on role
            fail_reasons = {
                "ğŸ’» The Hacker": "forgot to loop the thermal cameras. The FBI saw everything!",
                "ğŸ”« The Muscle": "sneezed loudly and woke up the guard dogs!",
                "ğŸï¸ The Driver": "fell asleep at the wheel. The getaway van got towed!",
                "ğŸ¥· The Ghost": "tripped the laser alarm while trying to take a selfie!"
            }
            reason = fail_reasons.get(blamed_role, "completely messed up the entire plan.")

            final_embed = discord.Embed(title="ğŸš¨ BUSTED! HEIST FAILED!", color=0xE74C3C)
            final_embed.description = (
                f"### ğŸ’¥ DISASTER STRUCK!\n"
                f"The heist was going perfectly until {blamed_member.mention} ({blamed_role}) {reason}\n"
                f"{crew_roles_str}"
                f"ğŸ’¸ **LOSS:** Everyone lost their `${self.entry_fee:,}` buy-in.\n\n"
                f"> *The crew scatters as police sirens approach...*"
            )
            final_embed.set_image(url="https://media.tenor.com/1-11Yd6_QpYAAAAC/explosion-blast.gif")

        try: await interaction.edit_original_response(embed=final_embed, view=None)
        except: pass

    async def on_timeout(self):
        """ ğŸ›¡ï¸ SAFE REFUND: If host ghosts the lobby, give everyone their money back. """
        if self.heist_started: return
        self.heist_started = True # Prevent late joins
        
        for child in self.children: child.disabled = True
        
        # ğŸ’¸ Refund everyone in the crew safely
        for member in self.crew:
            await smart_reward(member.id, self.entry_fee)
            
        embed = discord.Embed(title="â³ LOBBY EXPIRED", color=0x95A5A6)
        embed.description = (
            f"### ğŸ›‘ OPERATION CANCELLED\n"
            f"The Mastermind took too long to start the heist.\n"
            f"The crew got nervous and went home.\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"ğŸ’° **Status:** `${self.entry_fee:,}` has been fully refunded to all crew members."
        )
        try:
            if self.message: await self.message.edit(embed=embed, view=self)
        except: pass


# ==============================================================================
# ğŸ’» THE SLASH COMMAND
# ==============================================================================
@game_group.command(name="heist", description=f"ğŸ¦ Gather a crew and rob the Syndicate Bank! Win ${HEIST_PAYOUT:,} each! (Multiplayer)")
@app_commands.checks.cooldown(1, 300, key=lambda i: (i.guild_id, i.user.id)) # 5 Min Cooldown
@check_seized()
async def heist_cmd(interaction: discord.Interaction):
    # â³ SECURE INITIALIZATION
    await interaction.response.defer(ephemeral=False)
    
    # ğŸ’³ 1. SMART CHARGE MASTERMIND'S ENTRY FEE
    paid = await smart_charge(interaction.user.id, HEIST_ENTRY_FEE)
    if not paid:
        embed = discord.Embed(title="ğŸš¨ MISSION ABORTED", color=0xE74C3C)
        embed.description = f"âŒ **Mastermind is broke!** You need at least `${HEIST_ENTRY_FEE:,}` (Wallet+Bank) to fund this operation."
        return await interaction.followup.send(embed=embed)

    # ğŸ® 2. LAUNCH MULTIPLAYER LOBBY
    view = HeistLobbyView(interaction.user, HEIST_ENTRY_FEE)
    
    msg = await interaction.followup.send(embed=view.get_lobby_embed(), view=view, wait=True)
    view.message = msg # Bind message for Timeout Refund Logic

# --- â³ COOLDOWN ERROR HANDLER ---
@heist_cmd.error
async def heist_error(interaction: discord.Interaction, error: app_commands.AppCommandError):
    if isinstance(error, app_commands.CommandOnCooldown):
        rem = int(error.retry_after)
        m, s = divmod(rem, 60)
        embed = discord.Embed(title="ğŸš” HEAT LEVEL HIGH", color=0xF39C12)
        embed.description = f"The cops are patrolling your neighborhood after your last heist attempt.\nWait `{m}m {s}s` before planning another job."
        await interaction.response.send_message(embed=embed, ephemeral=True)



import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# ğŸ¤  TITAN CASINO: THE MEXICAN STANDOFF (PvP SHOOTOUT)
# ==============================================================================

STANDOFF_FEE = 50000

class StandoffLobbyView(discord.ui.View):
    def __init__(self, host: discord.Member, entry_fee: int):
        super().__init__(timeout=120.0) # â³ 2 Minutes to gather players
        self.host = host
        self.entry_fee = entry_fee
        
        self.players = [host] # List of Member objects
        self.max_players = 6
        
        self.started = False
        self.message = None
        self.lock = asyncio.Lock() # ğŸ›¡ï¸ Anti-Collision Lock

    def get_lobby_embed(self):
        embed = discord.Embed(title="ğŸ¤  THE MEXICAN STANDOFF", color=0xE67E22) # Orange/Desert theme
        
        # ğŸ‘¥ Format Gunslinger List
        player_list = ""
        for i, p in enumerate(self.players):
            role_icon = "ğŸ‘‘" if i == 0 else "ğŸ”«"
            player_list += f" â”£ {role_icon} **{p.display_name}** `[ AIMING ]`\n"
            
        current_pot = len(self.players) * self.entry_fee
        
        embed.description = (
            f"### ğŸœï¸ HIGH NOON IN THE DESERT\n"
            f"**Host:** {self.host.mention}\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"ğŸ’° **Buy-in:** `${self.entry_fee:,}` per player\n"
            f"ğŸ† **Current Pot:** `${current_pot:,}`\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"**GUNSLINGERS ({len(self.players)}/{self.max_players}):**\n"
            f"{player_list}\n\n"
            f"> *Host, click START when you are ready to draw your weapons!*"
        )
        embed.set_thumbnail(url="https://media.tenor.com/y1_B0m0k_mUAAAAd/revolver-spin.gif")
        return embed

    @discord.ui.button(label="JOIN STANDOFF ($50k)", emoji="ğŸ¤ ", style=discord.ButtonStyle.success, custom_id="join_standoff")
    async def btn_join(self, interaction: discord.Interaction, button: discord.ui.Button):
        async with self.lock:
            if self.started: 
                return await interaction.response.defer()
            
            if interaction.user in self.players:
                return await interaction.response.send_message("âŒ **Guard:** You are already in the circle!", ephemeral=True)
                
            if len(self.players) >= self.max_players:
                return await interaction.response.send_message("âŒ **Full:** The circle is full! (Max 6 players)", ephemeral=True)

            await interaction.response.defer()
            
            # ğŸ’³ SMART CHARGE: Deduct buy-in upfront
            paid = await smart_charge(interaction.user.id, self.entry_fee)
            if not paid:
                return await interaction.followup.send(f"âŒ **Broke:** You need at least `${self.entry_fee:,}` (Wallet + Bank) to buy bullets.", ephemeral=True)

            self.players.append(interaction.user)
            
            if len(self.players) >= self.max_players:
                button.disabled = True
                
            try: await interaction.edit_original_response(embed=self.get_lobby_embed(), view=self)
            except discord.HTTPException: pass

    @discord.ui.button(label="START SHOOTOUT", emoji="ğŸ”¥", style=discord.ButtonStyle.danger, custom_id="start_shootout")
    async def btn_start(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.host.id:
            return await interaction.response.send_message("âŒ Only the **Host** can fire the first shot!", ephemeral=True)
            
        async with self.lock:
            if self.started: return
            
            if len(self.players) < 2:
                return await interaction.response.send_message("âŒ You need at least 2 players to start a standoff!", ephemeral=True)
                
            self.started = True
            for child in self.children: child.disabled = True
            
            await interaction.response.defer()
            await self.execute_shootout(interaction)

    async def execute_shootout(self, interaction: discord.Interaction):
        pot_amount = len(self.players) * self.entry_fee
        survivors = self.players.copy()
        dead = []
        
        # ğŸ¬ 1. SUSPENSE PHASE
        embed = discord.Embed(title="ğŸ•› HIGH NOON...", color=0x2b2d31)
        embed.description = (
            f"### ğŸœï¸ THE WIND BLOWS...\n"
            f"Fingers are on the triggers. Sweat dripping down their faces.\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"> *Nobody move...*"
        )
        # Using a dramatic gun GIF instead of Squid Game for better theme matching
        embed.set_image(url="https://media.tenor.com/Psh5n4-XlYQAAAAC/squid-game-dalgona.gif") 
        
        try: await interaction.edit_original_response(embed=embed, view=None)
        except: pass
        
        await asyncio.sleep(4.0)

        # ğŸ”« 2. THE ELIMINATION LOOP
        while len(survivors) > 1:
            victim = random.choice(survivors)
            survivors.remove(victim)
            dead.append(victim)
            
            embed.color = 0xE74C3C # Red for blood
            embed.title = "ğŸ’¥ BANG!"
            embed.description = (
                f"### ğŸ©¸ FATAL SHOT!\n"
                f"**{victim.mention}** was shot down in the dust!\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f"ğŸ‘¥ **Remaining Survivors:** `{len(survivors)}`"
            )
            
            try: await interaction.edit_original_response(embed=embed)
            except discord.HTTPException: pass
            
            await asyncio.sleep(3.0) # â³ Safe API Delay

        # ğŸ† 3. THE SOLE SURVIVOR
        winner = survivors[0]
        
        # ğŸ§  4. THE CARTEL TWIST (10% WIN RATE)
        is_safe = random.randint(1, 100) <= 10 # Only 10% chance to actually keep the money!
        
        final_embed = discord.Embed()
        final_embed.set_thumbnail(url=winner.display_avatar.url)
        
        if is_safe:
            # ğŸ‰ PURE PROFIT
            await smart_reward(winner.id, pot_amount) # ğŸ’¸ Safe Payout
            
            final_embed.title = "ğŸ† THE LONE SURVIVOR!"
            final_embed.color = 0x2ECC71 # Green
            final_embed.description = (
                f"### ğŸ‰ {winner.display_name.upper()} STANDS TALL!\n"
                f"The smoke clears. Everyone else is down in the dirt.\n"
                f"You grab the duffel bag and escape the desert!\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f"ğŸ’° **JACKPOT WON:** `+${pot_amount:,}`"
            )
            final_embed.set_image(url="https://media.tenor.com/p7a8o1r5c8cAAAAC/money-rain.gif")
        else:
            # ğŸš¨ CARTEL ROBBERY
            final_embed.title = "ğŸš¨ CARTEL AMBUSH!"
            final_embed.color = 0x000000 # Black
            final_embed.description = (
                f"### ğŸ’¥ {winner.display_name.upper()} SURVIVED, BUT...\n"
                f"Just as you reach for the `${pot_amount:,}` bag, heavily armed Cartel members surround you!\n"
                f"They took all the money. You barely escaped with your life.\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f"ğŸ’¸ **POT LOST TO THE CARTEL!** The house takes it all."
            )
            final_embed.set_image(url="https://media.tenor.com/d6-SreC3_p8AAAAC/wasted-gta5.gif")

        dead_str = ", ".join([p.name for p in dead])
        final_embed.set_footer(text=f"Fallen Gunslingers: {dead_str}")
        
        try: await interaction.edit_original_response(embed=final_embed)
        except: pass

    async def on_timeout(self):
        """ ğŸ›¡ï¸ SAFE REFUND: If host goes AFK, give everyone their buy-in back. """
        if self.started: return
        self.started = True 
        
        for child in self.children: child.disabled = True
        
        # ğŸ’¸ Refund everyone
        for p in self.players:
            await smart_reward(p.id, self.entry_fee)
            
        embed = discord.Embed(title="â³ STANDOFF CANCELLED", color=0x95A5A6)
        embed.description = (
            f"### ğŸ›‘ COPS ARRIVED\n"
            f"The Sheriff broke up the standoff before it could start.\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"ğŸ’° **Status:** `${self.entry_fee:,}` has been fully refunded to all players."
        )
        try:
            if self.message: await self.message.edit(embed=embed, view=self)
        except: pass


# ==============================================================================
# ğŸ’» MAIN COMMAND
# ==============================================================================
@game_group.command(name="standoff", description=f"ğŸ¤  Start a PvP Mexican Standoff! Win the entire pot... if the Cartel doesn't rob you!")
@app_commands.checks.cooldown(1, 120, key=lambda i: (i.guild_id, i.user.id)) # 2 Min Cooldown
@check_seized()
async def standoff_cmd(interaction: discord.Interaction):
    # â³ SECURE INITIALIZATION
    await interaction.response.defer(ephemeral=False)
    
    # ğŸ’³ SMART CHARGE HOST'S ENTRY FEE
    paid = await smart_charge(interaction.user.id, STANDOFF_FEE)
    if not paid:
        embed = discord.Embed(title="ğŸš¨ NO AMMO", color=0xE74C3C)
        embed.description = f"âŒ **Broke:** You need at least `${STANDOFF_FEE:,}` (Wallet+Bank) to buy bullets."
        return await interaction.followup.send(embed=embed)

    # ğŸ® LAUNCH MULTIPLAYER LOBBY
    view = StandoffLobbyView(interaction.user, STANDOFF_FEE)
    
    msg = await interaction.followup.send(embed=view.get_lobby_embed(), view=view, wait=True)
    view.message = msg # Bind message for Timeout Refund Logic

# --- â³ COOLDOWN ERROR HANDLER ---
@standoff_cmd.error
async def standoff_error(interaction: discord.Interaction, error: app_commands.AppCommandError):
    if isinstance(error, app_commands.CommandOnCooldown):
        rem = int(error.retry_after)
        m, s = divmod(rem, 60)
        embed = discord.Embed(title="ğŸš” HEAT LEVEL HIGH", color=0xF39C12)
        embed.description = f"The Sheriff is watching you closely.\nWait `{m}m {s}s` before starting another shootout."
        await interaction.response.send_message(embed=embed, ephemeral=True)


import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# ğŸ•µï¸ TITAN CASINO: UNDERGROUND BOUNTY CONTRACTS
# ==============================================================================

class BountyApproachView(discord.ui.View):
    def __init__(self, user: discord.Member, target_name: str, reward: int, win_rate: int):
        super().__init__(timeout=120) # â³ 2 Mins to plan the approach
        self.user = user
        self.target_name = target_name
        self.reward = reward
        self.win_rate = win_rate
        
        self.game_over = False
        self.lock = asyncio.Lock()

    def get_approach_embed(self):
        embed = discord.Embed(title="ğŸ•µï¸ TARGET ACQUIRED: CHOOSE APPROACH", color=0x3498DB)
        embed.set_thumbnail(url="https://media.tenor.com/images/13019d5e32047ed6f345c26bdf3b56a3/tenor.gif")
        embed.description = (
            f"### ğŸ¯ DOSSIER LOADED\n"
            f"**Contract:** `{self.target_name}`\n"
            f"ğŸ’° **Bounty:** `${self.reward:,}`\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"You tracked the target to an abandoned warehouse.\n"
            f"Heavily armed guards are patrolling the perimeter.\n\n"
            f"**HOW DO YOU WANT TO EXECUTE THE HIT?**\n"
            f"> ğŸ—¡ï¸ **Stealth:** Sneak in quietly through the vents.\n"
            f"> ğŸ¯ **Sniper:** Take the shot from a rooftop 500m away.\n"
            f"> ğŸ’¥ **Guns Blazing:** Kick the front door and start shooting!\n\n"
            f"ğŸ‘‰ *Make your choice below...*"
        )
        return embed

    async def execute_hit(self, interaction: discord.Interaction, approach: str):
        if interaction.user.id != self.user.id:
            return await interaction.response.send_message("âŒ **Guard:** This is not your contract!", ephemeral=True)
            
        async with self.lock:
            if self.game_over: return await interaction.response.defer()
            self.game_over = True
            
            await interaction.response.defer()
            for child in self.children: child.disabled = True
            
            # ğŸ¬ 1. Cinematic Suspense Animation
            suspense_embed = discord.Embed(title=f"âš”ï¸ EXECUTING HIT: {approach.upper()}", color=0x2b2d31)
            
            if approach == "Stealth":
                suspense_embed.description = "### ğŸ¥· GOING DARK...\n> *Crawling through the ventilation shafts...*\n> *Bypassing laser grids... approaching the target...*"
            elif approach == "Sniper":
                suspense_embed.description = "### ğŸ¯ TAKING AIM...\n> *Adjusting the scope... accounting for wind speed...*\n> *Finger on the trigger... taking a deep breath...*"
            else:
                suspense_embed.description = "### ğŸ’¥ LOUD & CLEAR...\n> *Kicking the reinforced door open!*\n> *Brrtttt! Bullets flying everywhere!*"
                
            suspense_embed.set_image(url="https://media.tenor.com/y1_B0m0k_mUAAAAd/revolver-spin.gif")
            await interaction.edit_original_response(embed=suspense_embed, view=None)
            
            await asyncio.sleep(4.0) # â³ The Wait of Destiny

            # ğŸ§  2. STRICT ANTI-LOOT MATH
            is_success = random.randint(1, 100) <= self.win_rate
            
            final_embed = discord.Embed()
            final_embed.set_thumbnail(url=self.user.display_avatar.url)
            
            if is_success:
                # ğŸ† WIN SCENARIO (Rare)
                await smart_reward(self.user.id, self.reward) # ğŸ’¸ Safe Payout
                
                final_embed.title = "ğŸ† TARGET ELIMINATED!"
                final_embed.color = 0x2ECC71 # Green
                final_embed.description = (
                    f"### ğŸ‰ FLAWLESS HIT!\n"
                    f"Your **{approach}** approach worked perfectly. The `{self.target_name}` didn't even see it coming.\n"
                    f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                    f" â”£ ğŸ¯ **Target:** `{self.target_name}`\n"
                    f" â”— ğŸ’° **Bounty Collected:** `+${self.reward:,}`\n"
                )
                final_embed.set_image(url="https://media.tenor.com/p7a8o1r5c8cAAAAC/money-rain.gif")
                
            else:
                # ğŸ’€ LOSS SCENARIO (High Chance)
                fine = int(self.reward * 0.1) # Fine is 10% of the bounty reward
                paid = await smart_charge(self.user.id, fine) # ğŸ’³ Safe DB Charge
                
                loss_text = f"`-${fine:,}`" if paid else "`BANKRUPT` (All assets seized)"
                
                # ğŸ­ Funny Fail Stories
                fail_stories = {
                    "Stealth": [
                        "You stepped on a squeaky toy. The guards heard you and beat you up.",
                        "You got stuck in the air vent because you ate too much pizza.",
                        "You sneaked up perfectly, but forgot to bring your knife. Awkward."
                    ],
                    "Sniper": [
                        "You took the shot, but hit a flying pigeon instead. The target escaped.",
                        "You forgot to take the lens cover off your scope. You are an idiot.",
                        "The wind blew your bullet right into a police car. They traced it back to you."
                    ],
                    "Guns Blazing": [
                        "You kicked the door, but it was a 'Pull' door. You broke your leg.",
                        "You ran in screaming, but tripped over a wire and shot the ceiling.",
                        "The target had a minigun. You brought a pistol. Bad idea."
                    ]
                }
                story = random.choice(fail_stories[approach])
                
                final_embed.title = "ğŸš¨ BUSTED! MISSION FAILED!"
                final_embed.color = 0xE74C3C # Red
                final_embed.description = (
                    f"### ğŸ’¥ TOTAL DISASTER!\n"
                    f"{story}\n"
                    f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                    f" â”£ ğŸ¯ **Target:** `{self.target_name}` (Escaped)\n"
                    f" â”— ğŸ’¸ **Hospital/Bail Fine:** {loss_text}\n\n"
                    f"> *The underworld is laughing at you.*"
                )
                final_embed.set_image(url="https://media.tenor.com/d6-SreC3_p8AAAAC/wasted-gta5.gif")

            await interaction.edit_original_response(embed=final_embed)

    @discord.ui.button(label="Stealth", emoji="ğŸ—¡ï¸", style=discord.ButtonStyle.secondary, row=0)
    async def btn_stealth(self, i, b): await self.execute_hit(i, "Stealth")

    @discord.ui.button(label="Sniper", emoji="ğŸ¯", style=discord.ButtonStyle.success, row=0)
    async def btn_sniper(self, i, b): await self.execute_hit(i, "Sniper")

    @discord.ui.button(label="Guns Blazing", emoji="ğŸ’¥", style=discord.ButtonStyle.danger, row=0)
    async def btn_loud(self, i, b): await self.execute_hit(i, "Guns Blazing")


# --- THE LOBBY SELECTION MENU ---
class BountySelect(discord.ui.Select):
    def __init__(self):
        options = [
            discord.SelectOption(label="Street Thug", description="Reward: $50k | Danger: Normal (8% Win)", emoji="ğŸŸ¢", value="THUG"),
            discord.SelectOption(label="Mafia Boss", description="Reward: $200k | Danger: Hard (5% Win)", emoji="ğŸ”´", value="BOSS"),
            discord.SelectOption(label="Ghost Assassin", description="Reward: $1M | Danger: IMPOSSIBLE (2% Win)", emoji="ğŸ’€", value="GHOST")
        ]
        super().__init__(placeholder="ğŸ“‚ Select a Bounty Contract...", min_values=1, max_values=1, options=options)

    async def callback(self, interaction: discord.Interaction):
        if interaction.user.id != self.view.user.id:
            return await interaction.response.send_message("âŒ Get your own contract from the broker!", ephemeral=True)
            
        choice = self.values[0]
        await interaction.response.defer()
        
        # ğŸ”’ Lock Dropdown to prevent multiple selections
        self.disabled = True
        
        # ğŸ“Š Strict Win Rates
        if choice == "THUG":
            target_name, reward, win_rate = "Local Street Thug", 50000, 8
        elif choice == "BOSS":
            target_name, reward, win_rate = "Don Salieri (Mafia Boss)", 200000, 5
        else:
            target_name, reward, win_rate = "The Phantom (Ghost Assassin)", 1000000, 2
            
        # Transition to the next view
        approach_view = BountyApproachView(self.view.user, target_name, reward, win_rate)
        await interaction.edit_original_response(embed=approach_view.get_approach_embed(), view=approach_view)

class BountyLobbyView(discord.ui.View):
    def __init__(self, user: discord.Member):
        super().__init__(timeout=60)
        self.user = user
        self.add_item(BountySelect())


# ==============================================================================
# ğŸ’» THE MAIN COMMAND
# ==============================================================================
@game_group.command(name="bounty", description="ğŸ•µï¸ Accept a hitman contract! Very high risk, very low win rate.")
@app_commands.checks.cooldown(1, 60, key=lambda i: (i.guild_id, i.user.id)) # 1 min cooldown
@check_seized()
async def bounty_cmd(interaction: discord.Interaction):
    # â³ SECURE INITIALIZATION
    await interaction.response.defer(ephemeral=False)
    
    intel_fee = 5000
    
    # ğŸ’³ SMART CHARGE INTEL FEE
    paid = await smart_charge(interaction.user.id, intel_fee)
    if not paid:
        embed = discord.Embed(title="ğŸš¨ INTEL DENIED", color=0xE74C3C)
        embed.description = f"âŒ **Broke:** The Information Broker demands `${intel_fee:,}` upfront."
        return await interaction.followup.send(embed=embed)

    embed = discord.Embed(title="ğŸ•µï¸ THE UNDERGROUND BROKER", color=0x2b2d31)
    embed.set_thumbnail(url="https://cdn-icons-png.flaticon.com/512/2855/2855630.png")
    embed.description = (
        f"### ğŸ“‚ FILES SECURED\n"
        f"Welcome to the shadows, {interaction.user.mention}. I have three contracts available today.\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"âš ï¸ **WARNING:**\n"
        f"Choose your target wisely. If you fail the hit, the police will catch you, and you will pay a massive **Bail Fine (10% of the bounty)!**\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"ğŸ‘‡ *(Select a target from the dropdown below to plan your approach)*"
    )
    
    view = BountyLobbyView(interaction.user)
    await interaction.followup.send(embed=embed, view=view)

# --- â³ COOLDOWN ERROR HANDLER ---
@bounty_cmd.error
async def bounty_error(interaction: discord.Interaction, error: app_commands.AppCommandError):
    if isinstance(error, app_commands.CommandOnCooldown):
        embed = discord.Embed(title="ğŸš” HEAT LEVEL ACTIVE", color=0xF39C12)
        embed.description = f"The cops are looking for you. Lay low for `{int(error.retry_after)}s` before visiting the broker again."
        await interaction.response.send_message(embed=embed, ephemeral=True)


import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# ğŸ± TITAN CASINO: PvP CUSTOM BINGO (HIGH STAKES DEATHMATCH)
# ==============================================================================

def check_bingo_lines(marked_grid):
    """Checks all Rows, Columns, and Diagonals for 5 consecutive marks."""
    lines = 0
    # Check Rows
    for i in range(5):
        if all(marked_grid[i][j] for j in range(5)): lines += 1
    # Check Columns
    for j in range(5):
        if all(marked_grid[j][i] for i in range(5)): lines += 1
    # Check Diagonals
    if all(marked_grid[i][i] for i in range(5)): lines += 1
    if all(marked_grid[i][4-i] for i in range(5)): lines += 1
    return lines

# --- 5. LIVE BOARD VIEWER (Turns Green Automatically) ---
class LiveBoardView(discord.ui.View):
    def __init__(self, game, user_id):
        super().__init__(timeout=None) # Ephemeral, no timeout needed
        self.game = game
        grid = game.grids[user_id]
        marked = game.marked[user_id]
        
        # Build the 5x5 board dynamically
        for r in range(5):
            for c in range(5):
                num = grid[r][c]
                is_marked = marked[r][c]
                
                # ğŸŸ© GREEN if called, â¬› GREY if not called
                style = discord.ButtonStyle.success if is_marked else discord.ButtonStyle.secondary
                btn = discord.ui.Button(label=str(num), style=style, row=r, disabled=True)
                self.add_item(btn)

class MainGameView(discord.ui.View):
    def __init__(self, game):
        super().__init__(timeout=None)
        self.game = game

    @discord.ui.button(label="VIEW MY SECRET BOARD", style=discord.ButtonStyle.primary, emoji="ğŸ‘ï¸")
    async def btn_view_board(self, interaction: discord.Interaction, button: discord.ui.Button):
        # Security Check
        if interaction.user.id not in [self.game.p1.id, self.game.p2.id]:
            return await interaction.response.send_message("âŒ **Guard:** You are not playing at this table!", ephemeral=True)
            
        board_view = LiveBoardView(self.game, interaction.user.id)
        
        # Premium Ephemeral Embed
        embed = discord.Embed(title="ğŸ” YOUR LIVE BINGO BOARD", color=0x3498DB)
        embed.description = (
            f"### ğŸ¯ Lines Completed: `{self.game.lines[interaction.user.id]} / 5`\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"> *(Numbers in ğŸŸ© GREEN have already been called.)*"
        )
        await interaction.response.send_message(embed=embed, view=board_view, ephemeral=True)

# --- 4. THE RPS PHASE (Rock, Paper, Scissors) ---
class RPSView(discord.ui.View):
    def __init__(self, p1, p2, game_session):
        super().__init__(timeout=None) # Take your time to pick
        self.p1 = p1
        self.p2 = p2
        self.game = game_session
        self.choices = {p1.id: None, p2.id: None}

    async def handle_choice(self, interaction: discord.Interaction, choice: str):
        if interaction.user.id not in [self.p1.id, self.p2.id]:
            return await interaction.response.send_message("âŒ This RPS match is not yours!", ephemeral=True)
            
        self.choices[interaction.user.id] = choice
        await interaction.response.send_message(f"âœ… You securely locked in: **{choice}**! Waiting for opponent...", ephemeral=True)
        
        # If both players have chosen, stop the view
        if self.choices[self.p1.id] and self.choices[self.p2.id]:
            for child in self.children: child.disabled = True
            await interaction.message.edit(view=self)
            self.stop()

    @discord.ui.button(emoji="ğŸª¨", style=discord.ButtonStyle.secondary)
    async def btn_rock(self, i, b): await self.handle_choice(i, "Rock")
    @discord.ui.button(emoji="ğŸ“„", style=discord.ButtonStyle.secondary)
    async def btn_paper(self, i, b): await self.handle_choice(i, "Paper")
    @discord.ui.button(emoji="âœ‚ï¸", style=discord.ButtonStyle.secondary)
    async def btn_scissors(self, i, b): await self.handle_choice(i, "Scissors")

# --- 3. THE 25-BUTTON SECRET GRID BUILDER (NO TIME LIMIT) ---
class GridButton(discord.ui.Button):
    def __init__(self, row, col):
        super().__init__(style=discord.ButtonStyle.secondary, label="â“", row=row)
        self.grid_row = row
        self.grid_col = col

    async def callback(self, interaction: discord.Interaction):
        view: BingoGridBuilderView = self.view
        
        # Assign number and change color to blue
        self.label = str(view.current_num)
        self.style = discord.ButtonStyle.primary
        self.disabled = True
        
        view.grid_data[self.grid_row][self.grid_col] = view.current_num
        view.current_num += 1

        if view.current_num > 25:
            view.game.set_grid(interaction.user.id, view.grid_data)
            
            # Premium Success Message
            final_embed = discord.Embed(title="âœ… GRID SECURELY LOCKED!", color=0x2ECC71)
            final_embed.description = "### ğŸ” SETUP COMPLETE\nYour secret 5x5 board is perfectly registered.\n\n> *Return to the main chat and wait for the RPS phase!*"
            await interaction.response.edit_message(embed=final_embed, view=view)
            
            # Wake up the main thread if both are done
            if view.game.grids[view.game.p1.id] and view.game.grids[view.game.p2.id]:
                view.game.setup_complete.set()
        else:
            # Update the prompt dynamically
            embed = discord.Embed(title="ğŸ” SECRET GRID BUILDER", color=0x3498DB)
            embed.description = (
                f"### ğŸ”² PLACING NUMBER: [ {view.current_num} ]\n"
                f"Tap any `â“` box to place this number permanently."
            )
            try: await interaction.response.edit_message(embed=embed, view=view)
            except discord.HTTPException: pass # Ignore rapid click API stutters

class BingoGridBuilderView(discord.ui.View):
    def __init__(self, game_session):
        super().__init__(timeout=None) # â³ UNLIMITED TIME TO BUILD
        self.game = game_session
        self.current_num = 1
        self.grid_data = [[0]*5 for _ in range(5)]
        
        # Create exactly 25 Buttons
        for r in range(5):
            for c in range(5):
                self.add_item(GridButton(r, c))

class GridSetupPromptView(discord.ui.View):
    def __init__(self, game_session):
        super().__init__(timeout=None)
        self.game = game_session

    @discord.ui.button(label="BUILD MY SECRET GRID", style=discord.ButtonStyle.success, emoji="ğŸ“")
    async def btn_setup(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id not in [self.game.p1.id, self.game.p2.id]:
            return await interaction.response.send_message("âŒ **Guard:** This is not your match!", ephemeral=True)
            
        if self.game.grids[interaction.user.id] is not None:
            return await interaction.response.send_message("âœ… You have already locked your grid! Wait for your opponent.", ephemeral=True)
            
        builder_view = BingoGridBuilderView(self.game)
        embed = discord.Embed(title="ğŸ” SECRET GRID BUILDER", color=0x3498DB)
        embed.description = (
            f"### ğŸ”² PLACING NUMBER: [ {builder_view.current_num} ]\n"
            f"Tap any `â“` box to place this number.\n\n"
            f"> *(Take your time. There is no time limit to build this.)*"
        )
        await interaction.response.send_message(embed=embed, view=builder_view, ephemeral=True)

# --- 2. CHALLENGE ACCEPTANCE LOBBY ---
class BingoLobbyView(discord.ui.View):
    def __init__(self, host, opponent, bet):
        super().__init__(timeout=60)
        self.host = host
        self.opponent = opponent
        self.bet = bet
        self.accepted = False

    @discord.ui.button(label="ACCEPT CHALLENGE", style=discord.ButtonStyle.success, emoji="âœ…")
    async def btn_accept(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.opponent.id:
            return await interaction.response.send_message("âŒ Only the challenged player can accept!", ephemeral=True)
            
        await interaction.response.defer()
        
        # ğŸ’³ SMART CHARGE: Opponent pays their half
        paid = await smart_charge(self.opponent.id, self.bet)
        if not paid:
            return await interaction.followup.send(f"âŒ You need `${self.bet:,}` (Wallet+Bank) to match the bet!", ephemeral=True)

        self.accepted = True
        for child in self.children: child.disabled = True
        await interaction.message.edit(view=self)
        self.stop()


# --- 1. THE MAIN BINGO ENGINE ---
class BingoGame:
    def __init__(self, p1, p2, bet, channel):
        self.p1 = p1
        self.p2 = p2
        self.bet = bet
        self.channel = channel
        
        self.grids = {p1.id: None, p2.id: None}
        self.marked = {p1.id: [[False]*5 for _ in range(5)], p2.id: [[False]*5 for _ in range(5)]}
        self.lines = {p1.id: 0, p2.id: 0}
        self.called_numbers = []
        self.setup_complete = asyncio.Event()

    def set_grid(self, user_id, grid):
        self.grids[user_id] = grid

    def mark_number(self, num):
        self.called_numbers.append(num)
        for uid in [self.p1.id, self.p2.id]:
            for r in range(5):
                for c in range(5):
                    if self.grids[uid][r][c] == num:
                        self.marked[uid][r][c] = True
            # Re-check lines dynamically
            self.lines[uid] = check_bingo_lines(self.marked[uid])

    def get_game_embed(self, current_turn_player, message=None):
        embed = discord.Embed(title="ğŸ± TITAN BINGO: DEATHMATCH", color=0x2b2d31)
        
        desc = (
            f"ğŸ’° **Total Pot:** `${self.bet * 2:,}`\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸ‘¤ **{self.p1.name}** Lines: `{self.lines[self.p1.id]} / 5`\n"
            f" â”— ğŸ‘¤ **{self.p2.name}** Lines: `{self.lines[self.p2.id]} / 5`\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        )
        
        if message: 
            desc += f"### {message}\n"
        
        desc += f"\nğŸ—£ï¸ **{current_turn_player.mention}'s Turn!**\n> *Type a number (1-25) in the chat...*"
        embed.description = desc
        
        called_str = ", ".join(map(str, self.called_numbers[-5:])) if self.called_numbers else "None"
        embed.set_footer(text=f"Last 5 numbers called: {called_str}")
        return embed

# --- ğŸ’» THE SLASH COMMAND ---
@game_group.command(name="bingo_pvp", description="ğŸ± Challenge someone to a custom PvP Bingo Match! (Live Tracking)")
@app_commands.describe(opponent="The player you want to crush", bet="Amount of money to wager")
@check_seized()
async def bingo_pvp_cmd(interaction: discord.Interaction, opponent: discord.Member, bet: int):
    # ğŸ›‘ Validation
    if opponent.bot or opponent.id == interaction.user.id:
        return await interaction.response.send_message("âŒ **Invalid:** You can't play against a bot or yourself.", ephemeral=True)
    if bet < 1000:
        return await interaction.response.send_message("âŒ **Bouncer:** Minimum bet is `$1,000`.", ephemeral=True)

    await interaction.response.defer(ephemeral=False)

    # ğŸ’³ 1. SMART CHARGE THE HOST FIRST
    paid = await smart_charge(interaction.user.id, bet)
    if not paid:
        return await interaction.followup.send("âŒ **Broke:** You don't have enough money for this bet!", ephemeral=True)

    # ==========================================
    # PHASE 1: THE LOBBY
    # ==========================================
    lobby_view = BingoLobbyView(interaction.user, opponent, bet)
    embed = discord.Embed(title="ğŸ± BINGO DEATHMATCH!", color=0xE67E22)
    embed.description = (
        f"### âš”ï¸ CHALLENGE ISSUED\n"
        f"{interaction.user.mention} challenged {opponent.mention} to a high-stakes match!\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f" â”£ ğŸ’° **Bet:** `${bet:,}`\n"
        f" â”— ğŸ† **Winner Pot:** `${bet * 2:,}`\n\n"
        f"> *Opponent has 60 seconds to accept...*"
    )
    embed.set_thumbnail(url="https://media.tenor.com/Psh5n4-XlYQAAAAC/squid-game-dalgona.gif") 
    
    await interaction.followup.send(content=opponent.mention, embed=embed, view=lobby_view)
    
    # â³ Wait for acceptance or timeout
    await lobby_view.wait()
    
    if not lobby_view.accepted:
        # ğŸ›¡ï¸ ANTI-SCAM REFUND: If opponent ignores, give host their money back!
        await smart_reward(interaction.user.id, bet)
        return await interaction.channel.send(f"âŒ The match was cancelled. {opponent.display_name} chickened out. (Bet safely refunded)")

    # ==========================================
    # PHASE 2: GRID SETUP (NO TIMEOUT)
    # ==========================================
    game = BingoGame(interaction.user, opponent, bet, interaction.channel)

    setup_view = GridSetupPromptView(game)
    setup_embed = discord.Embed(title="ğŸ“ GRID SETUP PHASE", color=0x3498DB)
    setup_embed.description = (
        f"### ğŸ” SECURE YOUR BOARDS\n"
        f"Both players, click the button below to build your **100% Secret** 5x5 Grid!\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"> *(Take your time, there is no timer. The game will automatically resume once both grids are locked!)*"
    )
    await interaction.channel.send(embed=setup_embed, view=setup_view)

    # â³ THIS PAUSES THE COMMAND UNTIL BOTH GRIDS ARE BUILT
    await game.setup_complete.wait() 

    # ==========================================
    # PHASE 3: RPS TOSS (NO TIMEOUT)
    # ==========================================
    rps_embed = discord.Embed(title="âœŒï¸ ROCK PAPER SCISSORS", color=0x9B59B6)
    rps_embed.description = "### ğŸ² THE TOSS\nBoth grids are locked securely! Let's play RPS to decide who calls the first number!"
    
    rps_view = RPSView(interaction.user, opponent, game)
    await interaction.channel.send(embed=rps_embed, view=rps_view)
    
    await rps_view.wait()

    c1, c2 = rps_view.choices[interaction.user.id], rps_view.choices[opponent.id]
    beats = {"Rock": "Scissors", "Paper": "Rock", "Scissors": "Paper"}
    
    if not c1 or not c2 or c1 == c2: 
        turn_player = random.choice([interaction.user, opponent])
    elif beats[c1] == c2: 
        turn_player = interaction.user
    else: 
        turn_player = opponent

    await interaction.channel.send(f"ğŸ² **{turn_player.mention}** won the RPS Toss and gets to go first!")

    # ==========================================
    # PHASE 4: MAIN GAME LOOP (CHAT DETECTION)
    # ==========================================
    game_active = True
    current_turn = turn_player
    main_game_view = MainGameView(game) 
    
    game_msg = await interaction.channel.send(embed=game.get_game_embed(current_turn, "Game Started!"), view=main_game_view)

    def check_msg(m): 
        # Detects messages only from the current turn player containing a valid digit
        return m.channel == interaction.channel and m.author.id == current_turn.id and m.content.isdigit()

    while game_active:
        # â³ WAITS FOR CHAT INPUT FOREVER
        msg = await interaction.client.wait_for('message', check=check_msg)
        num = int(msg.content)
        
        # ğŸ§¹ Auto-Delete player's chat message to keep the channel clean
        try: await msg.delete()
        except: pass

        # ğŸ›‘ Validation checks
        if num < 1 or num > 25:
            warning = await interaction.channel.send(f"âš ï¸ {current_turn.mention}, the number must be exactly between 1 and 25!")
            await asyncio.sleep(3)
            try: await warning.delete()
            except: pass
            continue
            
        if num in game.called_numbers:
            warning = await interaction.channel.send(f"âš ï¸ {current_turn.mention}, `{num}` has already been called! Pick another.")
            await asyncio.sleep(3)
            try: await warning.delete()
            except: pass
            continue

        # âœ… Mark the number! (Turns it GREEN in the secret board view)
        game.mark_number(num) 
        
        win_p1 = game.lines[game.p1.id] >= 5
        win_p2 = game.lines[game.p2.id] >= 5
        
        # ==========================================
        # PHASE 5: GAME OVER / PAYOUT
        # ==========================================
        if win_p1 or win_p2:
            game_active = False
            pot = bet * 2
            final_embed = discord.Embed(title="ğŸ† BINGO! WE HAVE A WINNER!", color=0x2ECC71)
            
            if win_p1 and win_p2:
                # ğŸ¤ Tie Scenario (Refund both)
                await smart_reward(game.p1.id, bet)
                await smart_reward(game.p2.id, bet)
                final_embed.description = "### ğŸ˜± IT'S A TIE!\nBoth players hit 5 lines at the exact same time! Bets have been safely refunded."
                final_embed.color = 0xF1C40F
            else:
                # ğŸ‰ Pure Win Scenario
                winner = game.p1 if win_p1 else game.p2
                await smart_reward(winner.id, pot)
                final_embed.description = (
                    f"### ğŸ‰ BINGOOOOOO!\n"
                    f"**{winner.mention}** completed 5 lines and crushed their opponent!\n"
                    f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                    f"ğŸ’° **Total Pot Secured:** `${pot:,}`"
                )
                final_embed.set_thumbnail(url="https://media.tenor.com/bXjOidvDvoQAAAAC/confetti-celebrate.gif")
            
            # End Game: Edit final message & remove buttons
            await game_msg.edit(embed=final_embed, view=None) 
            break

        # ğŸ”„ Switch turns
        current_turn = game.p2 if current_turn.id == game.p1.id else game.p1
        
        # ğŸ“Š Update the Live Embed
        await game_msg.edit(embed=game.get_game_embed(current_turn, f"ğŸ¯ Number Called: **[ {num} ]**"), view=main_game_view)


import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# ğŸŒ TITAN CASINO: THE GLASS BRIDGE (SQUID GAME SURVIVAL)
# ==============================================================================

class GlassBridgeView(discord.ui.View):
    def __init__(self, user: discord.Member, entry_fee: int):
        super().__init__(timeout=120) # â³ 2 Mins total timeout
        self.user = user
        self.entry_fee = entry_fee
        
        # ğŸ² Bridge Generation (10 Steps)
        self.total_steps = 10
        self.current_step = 0
        
        # 0 = Left is Safe, 1 = Right is Safe
        self.path = [random.choice([0, 1]) for _ in range(self.total_steps)]
        
        # ğŸ’ Player Data & Economy
        self.hints_left = 3
        self.hint_cost = 17460
        self.jackpot = 5000000 # ğŸ’° $5 Million!
        
        self.game_over = False
        self.lock = asyncio.Lock() # ğŸ›¡ï¸ Anti-Spam Lock
        
        self.update_buttons()

    def update_buttons(self):
        """Builds the interaction buttons dynamically"""
        self.clear_items()
        
        # â¬…ï¸ Jump Left Button
        left_btn = discord.ui.Button(label="JUMP LEFT", emoji="â¬…ï¸", style=discord.ButtonStyle.primary, row=0)
        left_btn.callback = self.jump_left
        self.add_item(left_btn)
        
        # â¡ï¸ Jump Right Button
        right_btn = discord.ui.Button(label="JUMP RIGHT", emoji="â¡ï¸", style=discord.ButtonStyle.primary, row=0)
        right_btn.callback = self.jump_right
        self.add_item(right_btn)
        
        # ğŸ‘ï¸ The Devil's Eye (Hint Button)
        if self.hints_left > 0:
            hint_btn = discord.ui.Button(
                label=f"PEEK GLASS (${self.hint_cost/1000:.2f}k) [{self.hints_left} Left]", 
                emoji="ğŸ‘ï¸", 
                style=discord.ButtonStyle.secondary, 
                row=1
            )
            hint_btn.callback = self.use_hint
            self.add_item(hint_btn)

    async def use_hint(self, interaction: discord.Interaction):
        if interaction.user.id != self.user.id:
            return await interaction.response.send_message("âŒ **Guard:** Focus on your own bridge!", ephemeral=True)
            
        async with self.lock:
            if self.game_over: return await interaction.response.defer()
            
            if self.hints_left <= 0:
                return await interaction.response.send_message("âŒ **System:** You have exhausted all your hints!", ephemeral=True)
                
            # ğŸ’³ SMART CHARGE: Deduct $17,460 Hint Cost
            paid = await smart_charge(self.user.id, self.hint_cost)
            if not paid:
                return await interaction.response.send_message(f"âŒ **Broke:** You need exactly `${self.hint_cost:,}` to use the Devil's Eye!", ephemeral=True)

            await interaction.response.defer()
            
            self.hints_left -= 1
            safe_side = "LEFT â¬…ï¸" if self.path[self.current_step] == 0 else "RIGHT â¡ï¸"
            
            # ğŸ¤« Ephemeral Hint Message (Only the player sees this)
            embed = discord.Embed(title="ğŸ‘ï¸ THE DEVIL'S EYE ACTIVATED", color=0x3498DB)
            embed.description = (
                f"### ğŸ” GLASS SCANNED\n"
                f"You paid `${self.hint_cost:,}` to the guards.\n"
                f"The tempered (safe) glass for **Step {self.current_step + 1}** is on the **{safe_side}**!"
            )
            await interaction.followup.send(embed=embed, ephemeral=True)
            
            # ğŸ”„ Update UI to reflect used hint
            self.update_buttons()
            try: await interaction.edit_original_response(view=self)
            except discord.HTTPException: pass

    async def process_jump(self, interaction: discord.Interaction, choice: int):
        if interaction.user.id != self.user.id: 
            return await interaction.response.send_message("âŒ **Guard:** Not your turn to die!", ephemeral=True)
            
        async with self.lock:
            if self.game_over: return await interaction.response.defer()
            await interaction.response.defer()
            
            # ğŸ§  Check if choice matches the safe path
            is_safe = (self.path[self.current_step] == choice)
            
            if is_safe:
                self.current_step += 1
                
                # ğŸ† Check if they crossed the entire bridge
                if self.current_step == self.total_steps:
                    self.game_over = True
                    await self.win_game(interaction)
                else:
                    self.update_buttons()
                    try: await interaction.edit_original_response(embed=self.get_bridge_embed(), view=self)
                    except discord.HTTPException: pass
            else:
                # ğŸ’€ Stepped on normal glass
                self.game_over = True
                await self.lose_game(interaction, choice)

    # ğŸ›ï¸ Button Handlers
    async def jump_left(self, interaction: discord.Interaction): await self.process_jump(interaction, 0)
    async def jump_right(self, interaction: discord.Interaction): await self.process_jump(interaction, 1)

    async def win_game(self, interaction: discord.Interaction):
        for child in self.children: child.disabled = True
        
        # ğŸ’¸ Safe DB Payout for the $5M Jackpot!
        await smart_reward(self.user.id, self.jackpot)
        
        embed = self.get_bridge_embed(win=True)
        embed.title = "ğŸ† SURVIVOR: THE BRIDGE CONQUERED!"
        embed.color = 0x2ECC71 # Green
        embed.description = (
            f"### ğŸ‰ YOU DEFIED DEATH!\n"
            f"You successfully crossed all 10 steps of the Glass Bridge!\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”— ğŸ’° **Jackpot Secured:** `+${self.jackpot:,}`"
        )
        embed.set_image(url="https://media.tenor.com/bXjOidvDvoQAAAAC/confetti-celebrate.gif")
        
        try: await interaction.edit_original_response(embed=embed, view=None)
        except: pass

    async def lose_game(self, interaction: discord.Interaction, fatal_choice: int):
        for child in self.children: child.disabled = True
        
        embed = self.get_bridge_embed(loss_choice=fatal_choice)
        embed.title = "ğŸ’€ THE GLASS SHATTERED!"
        embed.color = 0xE74C3C # Red
        embed.description = (
            f"### ğŸ“‰ YOU FELL TO YOUR DOOM!\n"
            f"You stepped on the normal glass at **Step {self.current_step + 1}**.\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f" â”£ ğŸŸï¸ **Entry Fee Lost:** `-${self.entry_fee:,}`\n"
            f" â”— ğŸ‘ï¸ **Hint Money Spent:** `Lost Forever`\n\n"
            f"> *The guards are cleaning up what's left of you.*"
        )
        embed.set_image(url="https://media.tenor.com/d6-SreC3_p8AAAAC/wasted-gta5.gif")
        
        try: await interaction.edit_original_response(embed=embed, view=None)
        except: pass

    def get_bridge_embed(self, win: bool = False, loss_choice: int = None):
        embed = discord.Embed(title="ğŸŒ THE GLASS BRIDGE", color=0x2b2d31)
        embed.set_thumbnail(url=self.user.display_avatar.url)
        
        board = []
        # ğŸ—ï¸ Build the visual bridge from top (Step 10) to bottom (Step 1)
        for i in range(self.total_steps - 1, -1, -1):
            if i > self.current_step:
                # Future steps (Unknown)
                board.append(f"`Step {i+1:02d}` ğŸ”² â– ğŸ”²")
            elif i == self.current_step:
                # Current step being played
                if loss_choice is not None:
                    # They just died here
                    if loss_choice == 0: board.append(f"`Step {i+1:02d}` ğŸ’¥ â– ğŸ”²")
                    else: board.append(f"`Step {i+1:02d}` ğŸ”² â– ğŸ’¥")
                elif win:
                    # They won the final step
                    if self.path[i] == 0: board.append(f"`Step {i+1:02d}` ğŸŸ© â– â˜ï¸")
                    else: board.append(f"`Step {i+1:02d}` â˜ï¸ â– ğŸŸ©")
                else:
                    # Currently standing before jumping
                    board.append(f"`Step {i+1:02d}` â“ â– â“  ğŸ‘ˆ *You are here*")
            else:
                # Past completed safe steps
                if self.path[i] == 0: board.append(f"`Step {i+1:02d}` ğŸŸ© â– â˜ï¸")
                else: board.append(f"`Step {i+1:02d}` â˜ï¸ â– ğŸŸ©")

        visual_bridge = "\n".join(board)
        
        desc = (
            f"**Player:** {self.user.mention}\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"ğŸ† **Grand Prize:** `${self.jackpot:,}`\n"
            f"ğŸ‘ï¸ **Hints Remaining:** `{self.hints_left} / 3`\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"{visual_bridge}\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        )
        if not win and loss_choice is None:
            desc += "ğŸ‘‰ *Will you jump LEFT or RIGHT? One is tempered glass, the other will break...*"
            
        embed.description = desc
        return embed

# ==============================================================================
# ğŸ’» THE MAIN COMMAND
# ==============================================================================
@game_group.command(name="bridge", description="ğŸŒ Cross the 10-Step Glass Bridge! Survive to win the $5,000,000 Jackpot.")
@app_commands.checks.cooldown(1, 60, key=lambda i: (i.guild_id, i.user.id)) # 1 min cooldown
@check_seized()
async def bridge_game(interaction: discord.Interaction):
    # â³ SECURE INITIALIZATION
    await interaction.response.defer(ephemeral=False)
    
    entry_fee = 25000 # ğŸŒ‰ Bridge entry fee
    
    # ğŸ’³ SMART CHARGE ENTRY FEE
    paid = await smart_charge(interaction.user.id, entry_fee)
    if not paid:
        embed = discord.Embed(title="ğŸš¨ ACCESS DENIED", color=0xE74C3C)
        embed.description = f"âŒ **Broke:** The VIP VIP guards demand exactly **${entry_fee:,}** (Wallet+Bank) for entry to the games."
        return await interaction.followup.send(embed=embed)

    # ğŸ® LAUNCH GAME
    view = GlassBridgeView(interaction.user, entry_fee)
    await interaction.followup.send(embed=view.get_bridge_embed(), view=view)

# --- â³ COOLDOWN ERROR HANDLER ---
@bridge_game.error
async def bridge_error(interaction: discord.Interaction, error: app_commands.AppCommandError):
    if isinstance(error, app_commands.CommandOnCooldown):
        embed = discord.Embed(title="â³ RESTING PHASE", color=0xF39C12)
        embed.description = f"The VIPs are cleaning the broken glass from your last run.\nWait `{int(error.retry_after)}s` before jumping again."
        await interaction.response.send_message(embed=embed, ephemeral=True)



import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# ğŸ“ˆ TITAN CASINO: MARKET CRASH (THE WOLF OF WALL STREET)
# ==============================================================================

class MarketCrashView(discord.ui.View):
    def __init__(self, user: discord.Member, bet: int):
        super().__init__(timeout=None) # â³ Loop handles termination
        self.user = user
        self.bet = bet
        
        # ğŸ§  THE RUTHLESS CASINO ALGORITHM (HOUSE EDGE)
        luck = random.randint(1, 100)
        if luck <= 30:
            self.crash_point = round(random.uniform(1.00, 1.25), 2) # Instant Rug
        elif luck <= 80:
            self.crash_point = round(random.uniform(1.26, 2.49), 2) # Normal Range
        elif luck <= 95:
            self.crash_point = round(random.uniform(2.50, 4.00), 2) # High Risk
        else:
            self.crash_point = round(random.uniform(4.50, 12.00), 2) # Moon Mission

        self.current_mult = 1.00
        self.is_cashed_out = False
        self.is_crashed = False
        self.message = None
        self.lock = asyncio.Lock() 

    def get_crash_embed(self, status: str = "LIVE"):
        embed = discord.Embed()
        embed.set_thumbnail(url=self.user.display_avatar.url)
        
        if status == "LIVE":
            embed.title = "ğŸ“ˆ THE MARKET IS PUMPING..."
            
            # Dynamic Color & Title based on Multiplier
            if self.current_mult < 1.5:
                embed.color = 0x3498DB # Blue
            elif self.current_mult < 2.5:
                embed.color = 0xF1C40F # Yellow
                embed.title = "âš ï¸ MARKET VOLATILITY INCREASING..."
            elif self.current_mult < 4.0:
                embed.color = 0xE67E22 # Orange
                embed.title = "ğŸ”¥ EXTREME MOMENTUM!"
            else:
                embed.color = 0x9B59B6 # Purple (Moon)
                embed.title = "ğŸš€ TO THE MOON!"

            embed.description = (
                f"### ğŸš€ MULTIPLIER: `{self.current_mult:.2f}x`\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ’µ **Your Investment:** `${self.bet:,}`\n"
                f" â”— ğŸ’° **Current Value:** `${int(self.bet * self.current_mult):,}`\n\n"
                f"> âš ï¸ *Click **CASH OUT** before the bubble bursts!*"
            )
            
        elif status == "CASHED_OUT":
            payout = int(self.bet * self.current_mult)
            profit = payout - self.bet
            embed.title = "ğŸ¤ PROFIT SECURED!"
            embed.color = 0x2ECC71 # Green
            embed.description = (
                f"### ğŸ‰ YOU JUMPED AT `{self.current_mult:.2f}x`!\n"
                f"You escaped the market before the disaster.\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”£ ğŸ“ˆ **Net Profit:** `+${profit:,}`\n"
                f" â”— ğŸ’¸ **Total Payout:** `${payout:,}`\n\n"
                f"> *(Real crash happened at `{self.crash_point:.2f}x`)*"
            )
            embed.set_image(url="https://media.tenor.com/p7a8o1r5c8cAAAAC/money-rain.gif")
            
        elif status == "CRASHED":
            embed.title = "ğŸ“‰ MARKET TOTAL CRASH!"
            embed.color = 0xE74C3C # Red
            embed.description = (
                f"### ğŸ’¥ BUSTED AT `{self.crash_point:.2f}x`\n"
                f"The bubble burst and your money vanished!\n"
                f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
                f" â”— ğŸ’¸ **Total Loss:** `-${self.bet:,}`\n\n"
                f"> *Don't let greed blind you next time.*"
            )
            embed.set_image(url="https://media.tenor.com/d6-SreC3_p8AAAAC/wasted-gta5.gif")

        embed.set_footer(text=f"Titan Exchange â€¢ ID: {random.randint(1000, 9999)}", icon_url="https://cdn-icons-png.flaticon.com/512/805/805273.png")
        return embed

    @discord.ui.button(label="ğŸ’° CASH OUT", style=discord.ButtonStyle.success, emoji="ğŸ¦")
    async def cashout_btn(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user.id:
            return await interaction.response.send_message("âŒ This is not your trade!", ephemeral=True)
            
        async with self.lock:
            if self.is_cashed_out or self.is_crashed:
                return await interaction.response.defer() 
                
            self.is_cashed_out = True
            self.stop()
            
            for child in self.children: child.disabled = True
            
            payout = int(self.bet * self.current_mult)
            await smart_reward(self.user.id, payout) # ğŸ’¸ Safe Atomic Payout
            
            await interaction.response.edit_message(embed=self.get_crash_embed("CASHED_OUT"), view=self)

    async def run_market_loop(self):
        await asyncio.sleep(2.5) # Pre-flight suspense
        
        while not self.is_cashed_out and not self.is_crashed:
            await asyncio.sleep(1.4) # Safe Heartbeat
            
            async with self.lock:
                if self.is_cashed_out: break
                
                # Exponential Growth Simulation
                if self.current_mult < 2.0:
                    increment = random.uniform(0.05, 0.15)
                elif self.current_mult < 4.0:
                    increment = random.uniform(0.20, 0.45)
                else:
                    increment = random.uniform(0.60, 1.20)
                    
                next_mult = round(self.current_mult + increment, 2)
                
                # ğŸ’¥ CRASH ENGINE
                if next_mult >= self.crash_point:
                    self.is_crashed = True
                    self.current_mult = self.crash_point 
                    self.stop()
                    
                    for child in self.children: child.disabled = True
                    
                    if self.message:
                        try: await self.message.edit(embed=self.get_crash_embed("CRASHED"), view=self)
                        except: pass
                    break
                    
                # ğŸ“ˆ TICK UPDATE
                self.current_mult = next_mult
                if self.message and not self.is_cashed_out:
                    try: await self.message.edit(embed=self.get_crash_embed("LIVE"))
                    except discord.HTTPException: pass


# ==============================================================================
# ğŸ’» MAIN COMMAND
# ==============================================================================
@game_group.command(name="crash", description="ğŸ“ˆ Bet on the market and cash out before the rug pull!")
@app_commands.describe(bet="Amount to risk (Max: $50,000)")
@app_commands.checks.cooldown(1, 10, key=lambda i: (i.guild_id, i.user.id))
@check_seized()
async def crash_game(interaction: discord.Interaction, bet: int):
    # ğŸ›‘ 1. CASINO COMPLIANCE
    MAX_LIMIT = 50000
    if bet > MAX_LIMIT:
        return await interaction.response.send_message(f"âŒ **Market Limit:** Maximum bet is `${MAX_LIMIT:,}`.", ephemeral=True)
    if bet < 1000:
        return await interaction.response.send_message("âŒ **Broker:** Minimum investment is `$1,000`.", ephemeral=True)

    await interaction.response.defer(ephemeral=False)
    
    # ğŸ’³ 2. SMART ESCROW (Deduct Upfront)
    paid = await smart_charge(interaction.user.id, bet)
    if not paid:
        embed = discord.Embed(title="ğŸš¨ TRANSACTION REJECTED", color=0xE74C3C)
        embed.description = f"âŒ **Broke:** You need at least **${bet:,}** in your account to open this trade."
        return await interaction.followup.send(embed=embed)

    # ğŸ® 3. INITIALIZE TERMINAL
    view = MarketCrashView(interaction.user, bet)
    
    embed = discord.Embed(title="ğŸ“ˆ OPENING TRADE POSITION...", color=0x2b2d31)
    embed.set_thumbnail(url=interaction.user.display_avatar.url)
    embed.description = (
        f"**Investor:** {interaction.user.mention}\n"
        f"**Capital:** `${bet:,}`\n"
        f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        f"> *Analyzing market data... Prepare to Cash Out!*"
    )
    
    msg = await interaction.followup.send(embed=embed, view=view, wait=True)
    view.message = msg
    
    # ğŸš€ 4. START ENGINE
    asyncio.create_task(view.run_market_loop())


import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# ğŸ•µï¸ TITAN CASINO: THE BLACK MARKET RUN (ULTRA PREMIUM)
# ==============================================================================

class BlackMarketView(discord.ui.View):
    def __init__(self, user: discord.Member, entry_fee: int):
        super().__init__(timeout=120)
        self.user = user
        self.entry_fee = entry_fee
        
        # ğŸ§  Dynamic Premium Loot Generation
        loots = [
            "ğŸ“¦ 100x Apple Vision Pro (Smuggled)",
            "ğŸ’» Crate of Unlocked Snapdragon 8 Gen 4 Chips",
            "ğŸ“± Prototype Oppo Rollable Devices",
            "ğŸ’ Stolen Blood Diamonds (Cartel Stock)"
        ]
        self.loot_name = random.choice(loots)
        
        self.current_value = 250000 
        self.current_checkpoint = 1
        self.total_checkpoints = 4
        self.bribe_cost = 30000 
        
        self.game_over = False
        self.lock = asyncio.Lock() # ğŸ›¡ï¸ Anti-Spam Lock
        self.build_buttons()

    def build_buttons(self):
        self.clear_items()
        
        # ğŸ’° Safe Route
        btn_bribe = discord.ui.Button(label=f"Bribe Guard (${self.bribe_cost//1000}k)", emoji="ğŸ’°", style=discord.ButtonStyle.success, row=0)
        btn_bribe.callback = self.action_bribe
        
        # ğŸ—£ï¸ 50/50 Route
        btn_talk = discord.ui.Button(label="Smooth Talk (Luck)", emoji="ğŸ—£ï¸", style=discord.ButtonStyle.primary, row=0)
        btn_talk.callback = self.action_talk
        
        # ğŸï¸ High Risk Route
        btn_run = discord.ui.Button(label="Flee on Bike (Risky)", emoji="ğŸï¸", style=discord.ButtonStyle.danger, row=1)
        btn_run.callback = self.action_run
        
        self.add_item(btn_bribe)
        self.add_item(btn_talk)
        self.add_item(btn_run)

    async def advance_checkpoint(self, interaction: discord.Interaction, action_msg: str):
        self.current_checkpoint += 1
        self.bribe_cost += 15000 
        
        if self.current_checkpoint > self.total_checkpoints:
            self.game_over = True
            await self.win_game(interaction, action_msg)
        else:
            self.build_buttons()
            await interaction.edit_original_response(embed=self.get_embed(action_msg), view=self)

    # --- ğŸ› ï¸ CORE ACTIONS ---

    async def action_bribe(self, interaction: discord.Interaction):
        if interaction.user.id != self.user.id: return
        async with self.lock:
            await interaction.response.defer()
            
            # Check if bribe is affordable from cargo value
            if self.current_value <= self.bribe_cost + 10000:
                return await interaction.followup.send("âš ï¸ **Broker:** Cargo value is too low to sustain more bribes! You must take a risk!", ephemeral=True)

            self.current_value -= self.bribe_cost
            msg = f"âœ… **BRIBE ACCEPTED:** You slipped the guard `${self.bribe_cost:,}`. The gate is open."
            await self.advance_checkpoint(interaction, msg)

    async def action_talk(self, interaction: discord.Interaction):
        if interaction.user.id != self.user.id: return
        async with self.lock:
            await interaction.response.defer()
            
            if random.randint(1, 100) <= 45: # 45% Success
                msg = "âœ… **SMOOTH TALKER:** You convinced them you're a government official. Passed for free!"
            else:
                lost_val = int(self.current_value * 0.4)
                self.current_value -= lost_val
                msg = f"âš ï¸ **CAUGHT LYING:** The guard didn't buy it! He seized some cargo (Lost `${lost_val:,}`)."
            
            await self.advance_checkpoint(interaction, msg)

    async def action_run(self, interaction: discord.Interaction):
        if interaction.user.id != self.user.id: return
        async with self.lock:
            await interaction.response.defer()
            
            # 65% chance to escape
            if random.randint(1, 100) <= 65:
                msg = "ğŸï¸ **NARROW ESCAPE:** You drifted past the spikes! Cops were too slow."
                await self.advance_checkpoint(interaction, msg)
            else:
                self.game_over = True
                await self.lose_game(interaction)

    # --- ğŸ ENDINGS ---

    async def win_game(self, interaction: discord.Interaction, final_msg: str):
        for child in self.children: child.disabled = True
        
        # ğŸ’¸ Safe DB Payout
        await smart_reward(self.user.id, self.current_value)
        
        embed = discord.Embed(title="ğŸ† SMUGGLING MISSION COMPLETE", color=0x2ECC71)
        embed.set_thumbnail(url=self.user.display_avatar.url)
        embed.description = (
            f"### ğŸ‰ CARGO DELIVERED!\n"
            f"{final_msg}\n\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"ğŸ“¦ **Loot:** `{self.loot_name}`\n"
            f"ğŸ’° **FINAL PAYOUT:** `+${self.current_value:,}`\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"> *The Underground thanks you. Go get some rest.*"
        )
        embed.set_image(url="https://media.tenor.com/bXjOidvDvoQAAAAC/confetti-celebrate.gif")
        await interaction.edit_original_response(embed=embed, view=None)

    async def lose_game(self, interaction: discord.Interaction):
        self.game_over = True
        for child in self.children: child.disabled = True
        
        embed = discord.Embed(title="ğŸš¨ BUSTED BY THE AUTHORITIES!", color=0xE74C3C)
        embed.description = (
            f"### ğŸ’¥ ROADBLOCK CRASH!\n"
            f"You tried to outrun the cops, but a sniper took out your tires!\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"âŒ **Cargo Seized:** `{self.loot_name}`\n"
            f"ğŸ’¸ **TOTAL LOSS:** `-${self.entry_fee:,}`\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"> *You'll be spending the night in the lockup.*"
        )
        embed.set_image(url="https://media.tenor.com/d6-SreC3_p8AAAAC/wasted-gta5.gif")
        await interaction.edit_original_response(embed=embed, view=None)

    def get_embed(self, status_msg=None):
        embed = discord.Embed(title="ğŸ•µï¸ TITAN BLACK MARKET RUN", color=0x2b2d31)
        embed.set_thumbnail(url=self.user.display_avatar.url)
        
        # Progress Bar Logic
        progress = "ğŸŸ©" * self.current_checkpoint + "â¬œ" * (self.total_checkpoints - self.current_checkpoint)
        
        desc = (
            f"**Agent:** {self.user.mention}\n"
            f"**Cargo:** `{self.loot_name}`\n"
            f"**Street Value:** `${self.current_value:,}`\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        )
        
        if status_msg:
            desc += f"> {status_msg}\nâ–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            
        desc += (
            f"### ğŸ›‘ CHECKPOINT {self.current_checkpoint} / {self.total_checkpoints}\n"
            f"**Progress:** {progress}\n\n"
            f"ğŸ‘‰ *The Border Patrol is searching trucks ahead. Decision?*"
        )
        
        embed.description = desc
        return embed

# ==============================================================================
# ğŸ’» MAIN COMMAND
# ==============================================================================

@game_group.command(name="smuggle", description="ğŸ•µï¸ Past 4 checkpoints to deliver illegal cargo and earn up to $250k!")
@app_commands.checks.cooldown(1, 60, key=lambda i: (i.guild_id, i.user.id))
@check_seized()
async def smuggle_game(interaction: discord.Interaction):
    await interaction.response.defer(ephemeral=False)
    
    entry_fee = 25000 
    
    # ğŸ’³ Secure Charge
    paid = await smart_charge(interaction.user.id, entry_fee)
    if not paid:
        embed = discord.Embed(title="ğŸš¨ TRANSACTION DENIED", color=0xE74C3C)
        embed.description = f"âŒ **Broker:** You need at least **${entry_fee:,}** to buy the cargo."
        return await interaction.followup.send(embed=embed)

    view = BlackMarketView(interaction.user, entry_fee)
    start_msg = "ğŸšš You loaded the goods and hit the highway. Stay cool."
    await interaction.followup.send(embed=view.get_embed(start_msg), view=view)

        
import discord
from discord import app_commands
import random
import asyncio

# ==============================================================================
# ğŸï¸ TITAN CASINO: UNDERGROUND DRAG RACE (MULTIPLAYER)
# ==============================================================================

class RaceLobbyView(discord.ui.View):
    def __init__(self, host: discord.Member, bet_amount: int):
        super().__init__(timeout=120.0) # â³ 2 Mins to gather racers
        self.host = host
        self.bet_amount = bet_amount
        
        self.players = {host.id: host} # Dict for fast lookup
        self.max_players = 4
        self.race_started = False
        self.message = None

    def update_buttons(self):
        self.clear_items()
        
        # ğŸŸï¸ JOIN BUTTON
        join_btn = discord.ui.Button(
            label=f"JOIN RACE (${self.bet_amount//1000}k)", 
            emoji="ğŸŸï¸", 
            style=discord.ButtonStyle.success, 
            disabled=len(self.players) >= self.max_players
        )
        join_btn.callback = self.join_race
        self.add_item(join_btn)
        
        # ğŸ START BUTTON (Host Only)
        start_btn = discord.ui.Button(
            label="START RACE", 
            emoji="ğŸ", 
            style=discord.ButtonStyle.primary, 
            disabled=len(self.players) < 2
        )
        start_btn.callback = self.start_race
        self.add_item(start_btn)

    async def join_race(self, interaction: discord.Interaction):
        if interaction.user.id in self.players:
            return await interaction.response.send_message("âŒ **Guard:** You are already at the starting line!", ephemeral=True)
            
        await interaction.response.defer()
        
        # ğŸ’³ SMART CHARGE: Securely deduct entry fee
        paid = await smart_charge(interaction.user.id, self.bet_amount)
        if not paid:
            return await interaction.followup.send(f"âŒ **Broke:** You need `${self.bet_amount:,}` (Wallet+Bank) to enter this race.", ephemeral=True)

        self.players[interaction.user.id] = interaction.user
        
        self.update_buttons()
        try: await interaction.edit_original_response(embed=self.get_lobby_embed(), view=self)
        except: pass

    async def start_race(self, interaction: discord.Interaction):
        if interaction.user.id != self.host.id:
            return await interaction.response.send_message("âŒ Only the **Host** can drop the flag!", ephemeral=True)
            
        self.race_started = True
        self.stop()
        
        for child in self.children: child.disabled = True
        await interaction.response.edit_message(embed=self.get_lobby_embed(starting=True), view=self)

    async def on_timeout(self):
        """ ğŸ›¡ï¸ SAFE REFUND: If host goes AFK, refund everyone's buy-in. """
        if self.race_started: return
        self.race_started = True # Stop further joins
        
        for p_id in self.players.keys():
            await smart_reward(p_id, self.bet_amount) # Give back entry fee
            
        embed = discord.Embed(title="â³ RACE CANCELLED", color=0x95A5A6)
        embed.description = "The racers got tired of waiting for the host and left. All entries were fully refunded."
        try:
            if self.message: await self.message.edit(embed=embed, view=None)
        except: pass

    def get_lobby_embed(self, starting=False):
        embed = discord.Embed(title="ğŸï¸ TITAN DRAG RACE: LOBBY", color=0xE67E22)
        pot_size = len(self.players) * self.bet_amount
        
        racers_str = ""
        for p in self.players.values():
            racers_str += f" â”£ ğŸï¸ **{p.display_name}**\n"
        racers_str += f" â”— *Waiting for {self.max_players - len(self.players)} more...*" if len(self.players) < self.max_players else " â”— *Lobby is Full!*"

        embed.description = (
            f"### ğŸš¥ READY FOR THE STRIP?\n"
            f"**Host:** {self.host.mention}\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"ğŸ’° **Entry Fee:** `${self.bet_amount:,}`\n"
            f"ğŸ† **Winner Pot:** `${pot_size:,}`\n"
            f"â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
            f"**THE LINEUP ({len(self.players)}/{self.max_players}):**\n"
            f"{racers_str}\n\n"
            f"> *Press JOIN to participate. Host clicks START to begin!*"
        )
        # 
        embed.set_thumbnail(url="https://media.tenor.com/bW_xQ63s570AAAAC/fast-and-furious-race.gif")
        if starting:
            embed.color = 0x2ECC71
            embed.description += "\n\nğŸš¨ **ENGINES REVVING! STARTING IN 3 SECONDS...**"
        return embed


# --- PHASE 2: ACTIVE RACE ENGINE ---

class ActiveRaceView(discord.ui.View):
    def __init__(self, players_dict, bet_amount):
        super().__init__(timeout=300.0)
        self.players = list(players_dict.values())
        self.bet_amount = bet_amount
        self.pot_size = len(self.players) * bet_amount
        
        self.target_distance = 100
        self.distances = {p.id: 0 for p in self.players}
        self.status = {p.id: "RACING" for p in self.players} # RACING, BUSTED, FINISHED
        
        self.race_active = True
        self.winner = None
        self.lock = asyncio.Lock() # ğŸ›¡ï¸ Anti-Collision Shield
        
        self.cars = ["ğŸï¸", "ğŸš™", "ğŸš“", "ğŸš•"]

    @discord.ui.button(label="HIT NITRO", emoji="ğŸ’¥", style=discord.ButtonStyle.danger)
    async def nitro_btn(self, interaction: discord.Interaction, button: discord.ui.Button):
        user_id = interaction.user.id
        if user_id not in self.distances:
            return await interaction.response.send_message("âŒ **Guard:** You're just a spectator! Get back to the stands.", ephemeral=True)
            
        async with self.lock:
            if self.status[user_id] == "BUSTED":
                return await interaction.response.send_message("ğŸ’€ **WASTED:** Your engine is a pile of scrap metal!", ephemeral=True)
                
            if not self.race_active or self.status[user_id] == "FINISHED":
                return await interaction.response.defer()

            # ğŸ”¥ THE NITRO GAMBLE (20% EXPLOSION RISK)
            if random.randint(1, 100) <= 20:
                self.status[user_id] = "BUSTED"
                await interaction.response.send_message("ğŸ’¥ **ENGINE BLOWN!** You pushed the Nitro too hard! You're out!", ephemeral=True)
            else:
                boost = random.randint(18, 30)
                self.distances[user_id] += boost
                await interaction.response.send_message(f"ğŸš€ **BOOST!** You shot forward `{boost}m`!", ephemeral=True)

    def generate_track(self, user_id, index):
        """ Creates the visual track: â–¬â–¬â–¬ğŸï¸â–¬â–¬â–¬â–¬â–¬ğŸ """
        dist = self.distances[user_id]
        state = self.status[user_id]
        car_emoji = self.cars[index % len(self.cars)]
        
        if state == "BUSTED": car_emoji = "ğŸ’¥"
            
        track_length = 15
        # Calculate relative position on a scale of 0 to track_length
        pos = int((dist / self.target_distance) * track_length)
        pos = max(0, min(pos, track_length))
        
        track_list = ["â–¬"] * track_length
        if pos < track_length:
            track_list[pos] = car_emoji
        
        finish_line = "ğŸ†" if state == "FINISHED" else "ğŸ"
        track_str = "".join(track_list) + finish_line
        
        return f"â”£ `{self.players[index].display_name[:10]:<10}` {track_str} `{dist}m`"

    def get_race_embed(self, final=False):
        embed = discord.Embed(title="ğŸš¥ LIVE DRAG RACE: THE STRIP", color=0x3498DB)
        
        track_display = "â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        for i, p in enumerate(self.players):
            track_display += self.generate_track(p.id, i) + "\n"
        track_display += "â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬â–¬\n"
        
        if not final:
            embed.description = (
                f"ğŸ’° **Total Pot:** `${self.pot_size:,}`\n\n"
                f"{track_display}\n"
                f"ğŸ’¡ *Cars move automatically every 3s. Click **NITRO** for a massive boost, but don't blow your engine!*"
            )
        else:
            if self.winner:
                embed.title = "ğŸ† RACE FINISHED: CHAMPION CROWNED!"
                embed.color = 0xFFD700
                embed.description = (
                    f"### ğŸ‰ {self.winner.mention} WON THE RACE!\n"
                    f"They took home the entire **${self.pot_size:,}** pot!\n\n"
                    f"{track_display}"
                )
                embed.set_image(url="https://media.tenor.com/bXjOidvDvoQAAAAC/confetti-celebrate.gif")
            else:
                embed.title = "ğŸ’€ DISASTER! NO SURVIVORS!"
                embed.color = 0x8B0000
                embed.description = (
                    f"### ğŸ’¥ TOTAL CARNAGE\n"
                    f"Every single racer blew their engine. The House keeps the **${self.pot_size:,}** pot!\n\n"
                    f"{track_display}"
                )
                embed.set_image(url="https://media.tenor.com/d6-SreC3_p8AAAAC/wasted-gta5.gif")
        return embed

    async def start_live_loop(self, message: discord.Message):
        await asyncio.sleep(3.0) # Countdown buffer
        
        while self.race_active:
            async with self.lock:
                all_busted = True
                
                # ğŸï¸ Passive movement for all racers
                for p in self.players:
                    if self.status[p.id] == "RACING":
                        all_busted = False
                        speed = random.randint(5, 14)
                        self.distances[p.id] += speed
                        
                        # ğŸ† Check for Winner
                        if self.distances[p.id] >= self.target_distance:
                            self.distances[p.id] = self.target_distance
                            self.status[p.id] = "FINISHED"
                            if not self.winner:
                                self.winner = p
                                self.race_active = False

                # ğŸ›‘ End if everyone blew up
                if all_busted and not self.winner:
                    self.race_active = False
                    
                # ğŸ”„ Refresh Visuals
                try:
                    if self.race_active:
                        await message.edit(embed=self.get_race_embed())
                    else:
                        for child in self.children: child.disabled = True
                        await message.edit(embed=self.get_race_embed(final=True), view=self)
                except discord.HTTPException: 
                    pass # Ignore rare API lags
            
            await asyncio.sleep(2.8) # Tick speed (Suspenseful & API safe)
            
        # ğŸ’¸ Payout Sequence
        if self.winner:
            await smart_reward(self.winner.id, self.pot_size)


# ==============================================================================
# ğŸ’» MAIN SLASH COMMAND
# ==============================================================================

@game_group.command(name="race", description="ğŸï¸ Host a Multiplayer Drag Race! Win the whole pot!")
@app_commands.describe(bet="Entry fee for each racer (Min: $5,000)")
@check_seized()
async def race_game(interaction: discord.Interaction, bet: int):
    if bet < 5000:
        return await interaction.response.send_message("âŒ **Casino Rule:** Minimum entry fee is `$5,000`.", ephemeral=True)
        
    await interaction.response.defer(ephemeral=False)
    
    # ğŸ’³ SMART CHARGE: Charge Host upfront
    paid = await smart_charge(interaction.user.id, bet)
    if not paid:
        embed = discord.Embed(title="ğŸš¨ TRANSACTION DENIED", color=0xE74C3C)
        embed.description = f"âŒ **Broke:** You need at least **${bet:,}** in your account to host this race."
        return await interaction.followup.send(embed=embed)

    # ğŸš¦ 1. START LOBBY
    lobby_view = RaceLobbyView(interaction.user, bet)
    msg = await interaction.followup.send(embed=lobby_view.get_lobby_embed(), view=lobby_view)
    lobby_view.message = msg
    
    # â³ Wait for host to start or lobby to timeout
    await lobby_view.wait()
    
    # ğŸï¸ 2. TRANSITION TO ACTIVE RACE
    if lobby_view.race_started:
        race_view = ActiveRaceView(lobby_view.players, bet)
        
        countdown_embed = discord.Embed(title="ğŸš¦ RACERS READY!", color=0xF1C40F)
        countdown_embed.description = "### ğŸ ALL SET\nThe track is hot! Engines are screaming...\n> *The race begins in **3 seconds**!*"
        
        race_msg = await interaction.channel.send(embed=countdown_embed, view=race_view)
        
        # ğŸ”¥ 3. FIRE UP THE ENGINE
        asyncio.create_task(race_view.start_live_loop(race_msg))


          
# ================== OPTIMIZED FLASK BACKEND ==================
import os
import time
import threading
from datetime import datetime
from flask import Flask, jsonify, render_template, request, session, redirect
import discord
from discord.ext import commands
from discord import app_commands
from supabase import create_client, Client
from flask_socketio import SocketIO, emit
from threading import Thread, Event
import random
import eventlet 

# Initialize Flask
app = Flask(__name__)
 # Ye line aapke paas pehle se hogi
app.config['SECRET_KEY'] = 'vikas_bhai_op_secret_key' # Security ke liye

# 'threading' mode discord bot ke saath compatible hai
socketio = SocketIO(app, async_mode='threading', cors_allowed_origins="*")

# --- 2. OPTIMIZED CACHE SYSTEM (FROM YOUR CODE) ---
USER_CACHE_TTL = 25
SETTINGS_CACHE_TTL = 20

user_cache = {}
settings_cache = {"data": None, "time": 0}

# --- 3. HELPER FUNCTIONS (FROM YOUR CODE) ---

# ğŸ‘‡ YAHAN AAPKE SAARE LINKS ADD KAR DIYE HAIN
CHANNEL_MAP = {
    "Season_1": "https://t.me/doraemonimporter",
    "Season_2": "https://t.me/doraemonimporter2",
    "Season_3": "https://t.me/doraemonimporter3",
    "Season_4": "https://t.me/doraemonimporter4",
    "Season_5": "https://t.me/doraemonimporter5",
    "Season_6": "https://t.me/doraemonimporter6",
    "Season_7": "https://t.me/doraemonimporter7",
    "Season_8": "https://t.me/+H0S4dcZfvWJkZjBl",
    "Season_9": "https://t.me/+s1Q7lien4j0wNGRl",
    "Season_10": "https://t.me/+Da7V7Zoelxs2MzVl",
    "Season_11": "https://t.me/+1JLgDh_S_AYyZGRl",
    "Season_12": "https://t.me/+ag7M_eA_mlYwNGI1",
    "Season_13": "https://t.me/+FAnoHipijfNiZmNl",
    "Season_14": "https://t.me/+hJXp65I7YQdjMDZl",
    "Season_15": "https://t.me/+1WbDmdyiqs0wZGZl",
    "Season_16": "https://t.me/+dSkYCxBJscllYjg1",
    "Season_17": "https://t.me/+2B5WiUpHj-ZiNzZl",
    "Season_18": "https://t.me/+MS78sAhlmUNhM2E9",
    "Season_19": "https://t.me/+uhjzHp7eKY9iYzE1",
    "Season_20": "https://t.me/+mjmJA7qi7wMxOThl",
    "Season_21": "https://t.me/+uXVZyC6Ew3c3YWJl",
    "all_movies": "https://t.me/+Xrz0CfDOEX83NDI1",
    "special": "https://t.me/+dhKaXxGWvC03OTM9",
    "classic": "https://t.me/+xmcyFMf9tn44Mjdl",
    "default": "https://t.me/doraemonimporter" # Backup Link
}

# ========= SAFE QUERY =========
import asyncio

async def safe_query(table, **filters):
    """
    Titan-Grade safe_query: 
    Fitted with non-blocking db_call (lambda) logic to prevent Flask/Discord freezing.
    """
    try:
        def db_operation():
            q = supabase.table(table).select("*")
            for k, v in filters.items():
                q = q.eq(k, v)
            return q.execute().data
            
        # Using the Titan-Standard db_call to execute the lambda
        result = await db_call(lambda: db_operation())
        return result
    except Exception as e:
        print(f"DB ERROR IN {table}: {e}")
        return None

# ========= SETTINGS CACHE =========
import asyncio
import time

async def get_settings():
    global settings_cache
    now = time.time()

    # Cache Logic (Same as original)
    if settings_cache["data"] and now - settings_cache["time"] < SETTINGS_CACHE_TTL:
        return settings_cache["data"]

    maintenance = False
    access_enabled = True

    try:
        # 100% Same Logic with Lambda Fix
        def db_operation():
            return supabase.table("bot_settings").select("*").execute().data

        rows = await db_call(lambda: db_operation())
        
        if rows:
            for x in rows:
                if x["key"] == "maintenance":
                    maintenance = (x["value"] == "true")
                if x["key"] == "access_enabled":
                    access_enabled = (x["value"] == "true")
                    
    except Exception as e:
        print("SETTINGS ERROR:", e)

    settings_cache["data"] = {
        "maintenance": maintenance,
        "access_enabled": access_enabled
    }
    settings_cache["time"] = now
    return settings_cache["data"]

# ========= USER STATUS BUILDER =========
import asyncio
import time
from datetime import datetime

async def build_status(user_id):
    now = time.time()

    # -------- USE CACHE IF FRESH --------
    if user_id in user_cache and now - user_cache[user_id]["time"] < USER_CACHE_TTL:
        return user_cache[user_id]["data"]

    try:
        # async logic applied to get_settings
        settings = await get_settings()

        # ===== ACCESS CHECK =====
        whitelisted = True
        if settings["access_enabled"]:
            # async logic applied to safe_query
            a = await safe_query("access_users", user_id=user_id)

            # SUPABASE FAIL â†’ SAFE MODE (Don't kick)
            if a is None:
                whitelisted = True
            else:
                whitelisted = True if a else False

        # ===== BAN CHECK =====
        banned = False
        temp = False
        reason = "None"
        left = 0

        bans = await safe_query("bans", user_id=user_id)

        # Fail safe ban system
        if bans is not None:
            if bans:
                b = bans[0]
                if b["perm"]:
                    banned = True
                    reason = b["reason"]
                else:
                    if float(b["expire"]) > now:
                        banned = True
                        temp = True
                        reason = b["reason"]
                        left = int((float(b["expire"]) - now) / 60)
                    else:
                        # Non-blocking delete using lambda
                        await db_call(lambda: supabase.table("bans").delete().eq("user_id", user_id).execute())

        # ===== KICK CHECK =====
        kick_now = False
        kick_reason = "None"

        kick = await safe_query("kick_flags", user_id=user_id)
        if kick is not None and kick:
            kick_now = True
            kick_reason = kick[0].get("reason", "No Reason")
            # Non-blocking delete using lambda
            await db_call(lambda: supabase.table("kick_flags").delete().eq("user_id", user_id).execute())

        data = {
            "user_id": user_id,
            "maintenance": settings["maintenance"],
            "access": whitelisted,
            "banned": banned,
            "tempban": temp,
            "ban_reason": reason,
            "minutes_left": left,
            "kick": kick_now,
            "kick_reason": kick_reason,
            "timestamp": datetime.utcnow().isoformat()
        }

        user_cache[user_id] = {"data": data, "time": now}
        return data

    except Exception as e:
        print("STATUS FAIL:", e)

        # FAIL SAFE MODE â†’ NEVER KICK VERIFIED
        if user_id in user_cache:
            return user_cache[user_id]["data"]

        return {
            "user_id": user_id,
            "maintenance": False,
            "access": True,
            "banned": False,
            "kick": False
        }


# --- 4. FLASK ROUTES (EXACTLY AS REQUESTED) ---

# --- ğŸ”’ SECURITY GATEKEEPER ---
import asyncio
from flask import request, session, redirect, url_for

# --- ğŸ”’ SECURITY GATEKEEPER ---
@app.before_request
def check_user_status():
    # 1. endpoints allowed to avoid loops (Logic: 100% Same)
    if request.endpoint in ['static', 'account_seized', 'login', 'discord_login', 'callback']:
        return

    # 2. Check if user is logged in
    if 'user_info' in session:
        uid = session['user_info']['id']
        
        try:
            # Using Lambda logic to prevent blocking
            def fetch_seized_status():
                return db.supabase.table("economy").select("is_seized").eq("user_id", str(uid)).execute().data
            
            # Titan-Standard non-blocking call
            data = asyncio.run(db_call(lambda: fetch_seized_status()))
            
            if data:
                is_locked = data[0].get('is_seized', False)
                
                # 3. IF SEIZED -> REDIRECT TO BLOCK PAGE (Logic: 100% Same)
                if is_locked is True:
                    return redirect(url_for('account_seized'))
                    
        except Exception as e:
            print(f"Security Check Error for UID {uid}: {e}")

@app.route("/status/<uid>")
def status(uid):
    return jsonify(build_status(uid))

@app.route("/ping")
def ping():
    return "pong"

import asyncio
from flask import jsonify

@app.route("/fakecheck/<uid>")
def fakecheck(uid):
    try:
        # 1. Fetching Initial Data (Logic: 100% Same)
        def fetch_fake_data():
            return supabase.table("fake_warnings").select("*").eq("user_id", uid).execute().data

        r = asyncio.run(db_call(lambda: fetch_fake_data()))

        if not r:
            return jsonify({"fake": False})

        row = r[0]
        username = row.get("username")
        display = row.get("display_name")

        # ===== AUTO FETCH USERNAME IF EMPTY =====
        if not username or not display:

            # 1ï¸âƒ£ Try Access Users
            def fetch_access_user():
                return supabase.table("access_users").select("*").eq("user_id", uid).execute().data
            
            acc = asyncio.run(db_call(lambda: fetch_access_user()))
            if acc:
                username = acc[0].get("username") or username
                display = acc[0].get("display_name") or display

            # 2ï¸âƒ£ Otherwise Try Verify Logs
            if not username or not display:
                def fetch_verify_logs():
                    return supabase.table("verify_logs").select("*").eq("roblox_id", uid).execute().data
                
                v = asyncio.run(db_call(lambda: fetch_verify_logs()))
                if v:
                    username = v[0].get("username") or username
                    display  = v[0].get("display_name") or display

        # ===== DELETE AFTER SHOWING (ONE-TIME) =====
        # Logic: Ensuring the warning is removed after it's been processed
        def delete_warning():
            return supabase.table("fake_warnings").delete().eq("user_id", uid).execute()
        
        asyncio.run(db_call(lambda: delete_warning()))

        return jsonify({
            "fake": True,
            "user_id": uid,
            "username": username or "Unknown",
            "display": display or "Unknown",
            "message": row.get(
                "message",
                "ğŸš« Account Action Required\n\n"
                "Your account has been temporarily restricted.\n\n"
                "Reason: Suspicious Exploit Activity Detected\n"
                "Duration: 3 Days\n\n"
                "If you believe this is a mistake, contact admin.\n\n"
                "System Reference: #SEC-9043X"
            )
        })

    except Exception as e:
        print(f"FAKE ERROR for UID {uid}: {e}")
        return jsonify({"fake": False})

import asyncio
from flask import jsonify

@app.route("/stopstatus")
def stopstatus():
    try:
        # 1. Database fetch logic (100% Same)
        def fetch_stop_setting():
            return supabase.table("bot_settings").select("value").eq("key", "stop_enabled").execute().data

        # Titan-Standard async execution
        data = asyncio.run(db_call(lambda: fetch_stop_setting()))

        if not data:
            return jsonify({"stop": False})   # Fail-safe allow (Logic Same)

        # 2. Return the boolean status
        return jsonify({"stop": (data[0]["value"] == "true")})

    except Exception as e:
        print(f"STOP CHECK ERROR: {e}")
        return jsonify({"stop": False})       # Fail-safe allow (Logic Same)

import asyncio
from flask import render_template, request

@app.route('/library/doraemon')
def doraemon_library():
    # 1. URL se season check karo (Logic: 100% Same)
    season_query = request.args.get('season', 'movies')
    
    # 2. Database se episode nikalo (Titan-Grade Fix)
    try:
        def fetch_doraemon_content():
            return supabase.table("doraemon_episodes")\
                .select("*")\
                .eq("season", season_query)\
                .order("id", desc=False)\
                .execute().data
        
        # Async execution within Flask route
        episodes_list = asyncio.run(db_call(lambda: fetch_doraemon_content()))
        
        if episodes_list is None:
            episodes_list = []
            
    except Exception as e:
        print(f"Doraemon Library Error: {e}")
        episodes_list = []

    # 3. Display Name (Ex: season_1 -> SEASON 1)
    display_name = season_query.replace('_', ' ').upper()
    
    # 4. ğŸ”¥ SMART LINK LOGIC: Sahi channel ka link nikalo
    current_invite_link = CHANNEL_MAP.get(season_query, CHANNEL_MAP["default"])
    
    # 5. HTML ko bhejo (Logic: 100% Same)
    return render_template('library.html', 
                         episodes=episodes_list, 
                         current_season=display_name,
                         invite_link=current_invite_link)


import discord
from discord import app_commands
from discord.ext import commands
import aiohttp
import os
import datetime
from supabase import create_client, Client
from flask import Flask, request, jsonify
from threading import Thread

# --- âš™ï¸ CONFIGURATION âš™ï¸ ---
MY_MASTER_ID = "804687084249284618"  # Hardcoded Master ID
LOG_CHANNEL_ID = 1450514760276774967 # Log Channel ID (Integer)


# --- ğŸµ SOUND LIST ---
SOUND_MAP = {
    "Screamer": "139918501762915",
    "Error Sound": "12221967",
    "Bruh Sound": "5164264387",
    "ğŸ’€ Daadi ji op": "129697356456437",    # Verified Scream
    "ğŸ¤£ Rick Roll (Public)": "1838457617",  # Famous ID
    "ğŸ”¥ tununununu": "108820459035129", # Riff          # Classic
    "ğŸ‘½ song" : "140479714896324",
    "ğŸ’£ Vine Boom": "6308606116"   
}

# --- ğŸ”’ SECURITY: ADVANCED OWNER CHECK ---
def check_owner(interaction: discord.Interaction) -> bool:
    user_id = str(interaction.user.id)
    
    # 1. Check Master ID (Fastest)
    if user_id == MY_MASTER_ID:
        return True
    
    # 2. Check Supabase 'bot_admins' Table
    try:
        if supabase:
            response = supabase.table('bot_admins').select('user_id').eq('user_id', user_id).execute()
            if response.data and len(response.data) > 0:
                return True
    except Exception as e:
        print(f"âš ï¸ Auth Check Error: {e}")
        
    return False

# --- ğŸ¨ HELPER: ULTRA PREMIUM EMBED BUILDER ---
def create_premium_embed(title, description, color, fields=None, thumbnail_url=None, footer_text="Titan Security â€¢ System Active"):
    embed = discord.Embed(
        title=title,
        description=description,
        color=color,
        timestamp=discord.utils.utcnow()
    )
    
    if thumbnail_url:
        embed.set_thumbnail(url=thumbnail_url)
    
    if fields:
        for name, value, inline in fields:
            embed.add_field(name=name, value=value, inline=inline)
            
    embed.set_footer(text=footer_text, icon_url="https://cdn-icons-png.flaticon.com/512/906/906334.png")
    return embed

# --- ğŸ“ HELPER: ADVANCED LOGGING SYSTEM ---
import discord

async def send_log(interaction: discord.Interaction, command_type: str, target_data: tuple, extra_details: str):
    try:
        log_channel = bot.get_channel(LOG_CHANNEL_ID)
        if not log_channel:
            print(f"âŒ Log Channel ID {LOG_CHANNEL_ID} not found!")
            return

        tid, tuser, tdisplay, tavatar = target_data
        
        # Log Embed Design
        embed = discord.Embed(
            title=f"ğŸš¨ COMMAND EXECUTED: {command_type}",
            description="**Authorized Admin Action Detected**",
            color=0xff4500, # Orange-Red
            timestamp=discord.utils.utcnow()
        )
        
        # Executor Info
        embed.add_field(
            name="ğŸ‘® Executor (Admin)",
            value=f"**User:** {interaction.user.mention}\n**ID:** `{interaction.user.id}`",
            inline=True
        )
        
        # Target Info with Profile Link
        profile_link = f"https://www.roblox.com/users/{tid}/profile"
        embed.add_field(
            name="ğŸ¯ Target (Victim)",
            value=f"**Name:** {tuser} (@{tdisplay})\n**ID:** `{tid}`\n[View Profile]({profile_link})",
            inline=True
        )
        
        # Details
        embed.add_field(name="âš™ï¸ Action Details", value=f"```{extra_details}```", inline=False)
        
        # Visuals
        if tavatar: 
            embed.set_thumbnail(url=tavatar)
            
        embed.set_footer(
            text="Titan Logging Facility", 
            icon_url=interaction.user.avatar.url if interaction.user.avatar else None
        )
        
        await log_channel.send(embed=embed)
        print("âœ… Log Sent Successfully")
        
    except Exception as e:
        print(f"âš ï¸ Logging Failed: {e}") 

# --- ğŸ” HELPER: ROBLOX USER RESOLVER ---
import aiohttp

async def resolve_roblox_user(user_input: str):
    user_input = str(user_input).strip()
    target_id = None
    username = "Unknown"
    display_name = "Unknown"
    avatar_url = "https://tr.rbxcdn.com/53eb9b17fe1432a809c73a1329d58c6e/150/150/Image/Png"

    async with aiohttp.ClientSession() as session:
        # 1. ID Check
        if user_input.isdigit():
            target_id = user_input
        else:
            # 2. Username to ID
            payload = {"usernames": [user_input], "excludeBannedUsers": True}
            async with session.post("https://users.roblox.com/v1/usernames/users", json=payload) as resp:
                if resp.status == 200:
                    data = await resp.json()
                    if data["data"]:
                        target_id = str(data["data"][0]["id"])
                    else:
                        return None 

        # 3. Fetch Details
        if target_id:
            async with session.get(f"https://users.roblox.com/v1/users/{target_id}") as resp:
                if resp.status == 200:
                    data = await resp.json()
                    username = data.get("name", "Unknown")
                    display_name = data.get("displayName", "Unknown")

            # Avatar Headshot
            async with session.get(f"https://thumbnails.roblox.com/v1/users/avatar-headshot?userIds={target_id}&size=420x420&format=Png&isCircular=false") as av_resp:
                if av_resp.status == 200:
                    av_data = await av_resp.json()
                    if av_data["data"]:
                        avatar_url = av_data["data"][0]["imageUrl"]
            
            return target_id, username, display_name, avatar_url
            
    return None

roblox_group = app_commands.Group(name="roblox", description="Roblox Admin & Troll Commands")


# --- ğŸ§ COMMAND 1: AUDIO ---
import discord

@roblox_group.command(name="audio", description="Play loud audio on a player (Owner Only)")
async def audio(interaction: discord.Interaction, player: str):
    # Fixed: Added 'await' to check_owner since it is an async function
    if not await check_owner(interaction):
        return await interaction.response.send_message("âŒ **Access Denied:** You are not in the database.", ephemeral=True)

    await interaction.response.defer()
    target = await resolve_roblox_user(player)
    
    if not target:
        return await interaction.followup.send(embed=create_premium_embed("âŒ Error", f"Player `{player}` not found.", 0x000000))

    # Dropdown View
    select = discord.ui.Select(placeholder="ğŸµ Select a Track to Inject...", options=[discord.SelectOption(label=k, emoji="ğŸ’¿") for k in SOUND_MAP.keys()])
    
    async def callback(interaction_select: discord.Interaction):
        # Fixed: Added 'await' to check_owner
        if not await check_owner(interaction_select): 
            return await interaction_select.response.send_message("âŒ Access Denied.", ephemeral=True)
        
        sound_name = select.values[0]
        sound_id = SOUND_MAP[sound_name]
        
        try:
            # Fixed: Wrapped Supabase insert in Titan-grade db_call(lambda)
            def insert_audio_command():
                return supabase.table('troll_commands').insert({
                    "target_id": target[0], 
                    "command_type": "audio", 
                    "payload": {"id": sound_id}, 
                    "status": "pending"
                }).execute().data
                
            await db_call(lambda: insert_audio_command())
            
            # Log & Reply
            await send_log(interaction_select, "AUDIO", target, f"Track: {sound_name}\nID: {sound_id}")
            
            success_embed = create_premium_embed(
                title="âœ… Audio Injection Active",
                description="Command successfully queued to database.",
                color=0x00ff00,
                fields=[
                    ("ğŸ¯ Target", f"**{target[1]}**", True),
                    ("ğŸµ Track", f"**{sound_name}**", True)
                ],
                thumbnail_url=target[3]
            )
            await interaction_select.response.edit_message(content="", embed=success_embed, view=None)
            
        except Exception as e:
            await interaction_select.response.send_message(f"Database Error: {e}", ephemeral=True)

    select.callback = callback
    view = discord.ui.View()
    view.add_item(select)
    
    await interaction.followup.send(embed=create_premium_embed("ğŸµ Audio Panel", f"Target: **{target[1]}**\nSelect a sound below.", 0x2b2d31, thumbnail_url=target[3]), view=view)

# --- ğŸ‘» COMMAND 2: JUMPSCARE ---
import discord

@roblox_group.command(name="scare", description="Jumpscare a player (Owner Only)")
async def scare(interaction: discord.Interaction, player: str):
    # Fixed: Added 'await' to check_owner
    if not await check_owner(interaction):
        return await interaction.response.send_message("âŒ **Access Denied**", ephemeral=True)

    await interaction.response.defer()
    
    target = await resolve_roblox_user(player)
    if not target: 
        return await interaction.followup.send("âŒ Player not found.")

    try:
        # Fixed: Wrapped Supabase insert in Titan-grade db_call(lambda)
        def insert_scare_command():
            return supabase.table('troll_commands').insert({
                "target_id": target[0], 
                "command_type": "jumpscare", 
                "payload": {"sound_id": "139918501762915"}, 
                "status": "pending"
            }).execute().data
            
        await db_call(lambda: insert_scare_command())
        
        await send_log(interaction, "JUMPSCARE", target, "Type: Screamer (Default)")
        
        embed = create_premium_embed(
            title="ğŸ‘» Jumpscare Triggered",
            description="Target will receive a loud screamer.",
            color=0xff0000,
            fields=[("ğŸ¯ Target", f"**{target[1]}** (`{target[0]}`)", True)],
            thumbnail_url=target[3]
        )
        await interaction.followup.send(embed=embed)
        
    except Exception as e:
        await interaction.followup.send(f"Error: {e}")


# --- ğŸ’¬ COMMAND 3: SPAM ---
import discord

@roblox_group.command(name="spam", description="Spam chat on a player (Owner Only)")
async def spam(interaction: discord.Interaction, player: str, message: str, amount: int):
    # Fixed: Added 'await' to check_owner
    if not await check_owner(interaction):
        return await interaction.response.send_message("âŒ **Access Denied**", ephemeral=True)

    await interaction.response.defer()
    
    target = await resolve_roblox_user(player)
    if not target: 
        return await interaction.followup.send("âŒ Player not found.")

    try:
        # Fixed: Wrapped Supabase insert in Titan-grade db_call(lambda)
        def insert_spam_command():
            return supabase.table('troll_commands').insert({
                "target_id": target[0], 
                "command_type": "spam", 
                "payload": {"msg": message, "limit": amount}, 
                "status": "pending"
            }).execute().data
            
        await db_call(lambda: insert_spam_command())
        
        await send_log(interaction, "CHAT SPAM", target, f"Message: {message}\nCount: {amount}")
        
        embed = create_premium_embed(
            title="ğŸ’¬ Spam Attack Started",
            description="Flooding target's chat history.",
            color=0x00aaff,
            fields=[
                ("ğŸ¯ Target", f"**{target[1]}**", True),
                ("ğŸ“ Message", f"`{message}`", True),
                ("ğŸ”¢ Count", f"**{amount}x**", True)
            ],
            thumbnail_url=target[3]
        )
        await interaction.followup.send(embed=embed)
        
    except Exception as e:
        await interaction.followup.send(f"Error: {e}")


@app.route('/api/get_command', methods=['GET'])
def get_command():
    user_id = request.args.get('userid')
    if not user_id: return jsonify({"type": "none"})

    try:
        response = supabase.table('troll_commands').select("*").eq('target_id', user_id).eq('status', 'pending').limit(1).execute()
        
        if response.data:
            cmd = response.data[0]
            supabase.table('troll_commands').update({'status': 'executed'}).eq('id', cmd['id']).execute()
            return jsonify({"type": cmd['command_type'], "payload": cmd['payload']})
            
    except Exception as e:
        print(f"API Error: {e}")
        return jsonify({"type": "none"}) 
    
    return jsonify({"type": "none"})

        
# ================= ğŸŒ NEW FLASK ROUTE (RECEIVE DATA) =================
@app.route('/api/report_spy', methods=['POST'])
def report_spy():
    try:
        data = request.json
        user_id = str(data.get('userid'))
        
        # Data Save kar lo memory mein
        live_spy_data[user_id] = {
            "health": data.get('health', 'Unknown'),
            "max_health": data.get('max_health', 100),
            "tool": data.get('tool', 'None'),
            "loc": data.get('loc', 'Unknown'),
            "activity": data.get('activity', 'Standing')
        }
        return jsonify({"status": "received"})
    except Exception as e:
        return jsonify({"error": str(e)})

from dateutil import parser
import datetime

# ================= ğŸ’“ ROUTE: HEARTBEAT (WITH SESSION TRACKING) =================
import asyncio
from flask import request, jsonify

@app.route('/api/heartbeat', methods=['POST'])
def heartbeat():
    try:
        data = request.json
        user_id = str(data.get('userid'))
        username = data.get('username')
        display = data.get('display')
        is_first_run = data.get('first_run', False) # Lua se aayega
        
        current_time = "now()"
        
        # Logic: Agar pehli baar chala hai (Re-execute), to session_start ko update karo.
        # Agar sirf ping hai, to sirf last_seen update karo.
        
        if is_first_run:
            # Full Reset (New Session)
            def new_session():
                return supabase.table('active_users').upsert({
                    "user_id": user_id,
                    "username": username,
                    "display_name": display,
                    "last_seen": current_time,
                    "session_start": current_time # Reset Timer
                }).execute()
                
            # Titan-Standard non-blocking call
            asyncio.run(db_call(lambda: new_session()))
            
        else:
            # Only Ping (Keep Timer Running)
            # Hum session_start ko update nahi karenge taaki purana time bana rahe
            def ping_session():
                return supabase.table('active_users').update({
                    "last_seen": current_time,
                    "username": username, # Just in case name change ho
                    "display_name": display
                }).eq("user_id", user_id).execute()
                
            # Titan-Standard non-blocking call
            asyncio.run(db_call(lambda: ping_session()))
        
        return jsonify({"status": "updated"})
        
    except Exception as e:
        return jsonify({"error": str(e)})

# Is line ko top par rehne dena agar nahi hai
from dateutil import parser
import discord

# ================= ğŸŸ¢ COMMAND: ACTIVE USERS (FIXED) =================
@roblox_group.command(name="active", description="Show Real-Time Players with Session Duration")
async def active(interaction: discord.Interaction):
    # Fixed: Added 'await' to check_owner
    if not await check_owner(interaction):
        return await interaction.response.send_message("âŒ **Access Denied**", ephemeral=True)

    await interaction.response.defer()

    try:
        # Fixed: Wrapped Supabase select in Titan-grade db_call(lambda)
        def fetch_active_users():
            return supabase.table('active_users').select("*").execute().data
            
        data = await db_call(lambda: fetch_active_users())
        
        active_list = []
        
        # ğŸ”¥ FIX: 'datetime.datetime.now' hata kar 'discord.utils.utcnow()' lagaya hai
        now = discord.utils.utcnow()
        
        count = 0
        
        if data:
            for user in data:
                # 1. Check Offline/Online
                last_seen = parser.isoparse(user['last_seen'])
                diff = now - last_seen
                
                # Agar 60s se kam hai, tabhi active hai
                if diff.total_seconds() < 60:
                    count += 1
                    
                    # 2. Calculate Duration
                    session_start = parser.isoparse(user['session_start'])
                    session_duration = now - session_start
                    
                    # Format: HH:MM:SS
                    total_seconds = int(session_duration.total_seconds())
                    hours, remainder = divmod(total_seconds, 3600)
                    minutes, seconds = divmod(remainder, 60)
                    
                    time_str = f"{minutes}m {seconds}s"
                    if hours > 0:
                        time_str = f"{hours}h {minutes}m {seconds}s"

                    # 3. Add to List
                    active_list.append(
                        f"ğŸŸ¢ **{user['display_name']}** (@{user['username']})\n"
                        f"â•° ğŸ†” `{user['user_id']}`\n"
                        f"â•° â±ï¸ Active For: **{time_str}**"
                    )

        # 4. Final Embed
        if not active_list:
            embed = create_premium_embed("ğŸŒ Active Uplinks", "No active sessions detected.", 0x808080)
        else:
            desc = "\n\n".join(active_list)
            embed = create_premium_embed(
                title=f"ğŸŒ Global Live Sessions ({count})",
                description=f"**Tracking Real-Time Executions:**\n\n{desc}",
                color=0x00ff00, # Matrix Green
                thumbnail_url="https://cdn-icons-png.flaticon.com/512/2921/2921226.png", 
                footer_text="Titan Security â€¢ Live Tracker"
            )
            
        await interaction.followup.send(embed=embed)

    except Exception as e:
        await interaction.followup.send(f"âš ï¸ Error: {e}")


        
# ========= DISABLE SPAM LOG =========
import logging
logging.getLogger("werkzeug").disabled = True

# ğŸ‘‡ ISKO SABSE NEECHE ADD KARO ğŸ‘‡

@bot.event
async def on_command_error(ctx, error):
    if isinstance(error, commands.CommandNotFound):
        return
    print(f"âš ï¸ Command Error: {error}")

# ğŸ‘‡ ISKO UPDATE KARO (Purana hata kar ye lagao)
async def roblox_info(uid):
    url = f"https://users.roblox.com/v1/users/{uid}"
    try:
        # ğŸ‘‡ DHYAN DEIN: Yahan hum 'bot.session' use kar rahe hain
        async with bot.session.get(url) as response:
            if response.status == 200:
                data = await response.json()
                return data.get("name", "Unknown"), data.get("displayName", "Unknown")
            else:
                return "Invalid ID", "Invalid ID"
    except Exception as e:
        print(f"API Error: {e}")
        # Agar bot.session fail ho jaye to backup (Safety)
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(url) as response:
                     if response.status == 200:
                        data = await response.json()
                        return data.get("name", "Unknown"), data.get("displayName", "Unknown")
        except:
            pass
        return "Unknown", "Unknown"
        

# ğŸ’° PURE ECONOMY & WEB SHOP SYSTEM (NO EXTRA GAMES)


# ================== âš™ï¸ CONFIGURATION ==================
LOG_CHANNEL_ID = 1451973589342621791  

# Premium Colors
C_GOLD = 0xFFD700
C_RED = 0xFF0000
C_GREEN = 0x00FF00
C_DARK = 0x2B2D31

# ================== ğŸŒ WEBSITE BACKEND ==================
# ==========================================
# ğŸš€ NEW BUSINESS SYSTEM ROUTES ADDED BELOW
# ==========================================
from flask import Flask, session, render_template, redirect, request, jsonify, url_for
import os
import requests
import urllib.parse
import random 
import db # Database connection
import time # For Business logic
from business_config import BUSINESSES # Import Business Settings

# --- âš™ï¸ CONFIGURATION ---
app.secret_key = os.getenv("FLASK_SECRET_KEY", "vikas_bhai_super_secure_key_786")
CLIENT_ID = os.getenv("DISCORD_CLIENT_ID", "1451451135813746700")
CLIENT_SECRET = os.getenv("DISCORD_CLIENT_SECRET") 
REDIRECT_URI = os.getenv("DISCORD_REDIRECT_URI", "https://testingbot-8pb1.onrender.com/callback")
API_ENDPOINT = 'https://discord.com/api/v10'
LOG_CHANNEL_ID = "1457066104819028089" 
GUILD_ID = "1257403231127076915"


# ==========================================
# ğŸ  STANDARD ROUTES (DASHBOARD, SHOP, GAMES)
# ==========================================

# --- 1. HOME ROUTE ---
import urllib.parse
import asyncio
from flask import session, render_template

@app.route('/')
def home():
    # 1. Login Link Setup
    encoded_redirect = urllib.parse.quote(REDIRECT_URI)
    login_url = f"https://discord.com/api/oauth2/authorize?client_id={CLIENT_ID}&redirect_uri={encoded_redirect}&response_type=code&scope=identify"

    # ğŸ”¥ Live Market Event Nikalo (Time based)
    active_event = get_current_event()

    # 2. Agar user login nahi hai
    if 'user_info' not in session:
        try:
            return render_template('dashboard.html', 
                                   user=None, 
                                   login_url=login_url, 
                                   market_event=active_event) # Event pass kiya guest ke liye bhi
        except Exception as e:
            return f"<h1>Error: Dashboard File Missing!</h1><p>Details: {e}</p>"

    # 3. Agar User Login hai
    try:
        user_id = session['user_info']['id']
        
        # ğŸ¦ Database se Pura Data Nikalo (Balance, Heat, Dirty Money)
        # Hum 'get_user_balance' ki jagah direct query karenge taaki Heat bhi mile
        def fetch_dashboard_data():
            return db.supabase.table("economy").select("*").eq("user_id", user_id).execute().data
            
        # Titan-Standard non-blocking call for Flask
        data = asyncio.run(db_call(lambda: fetch_dashboard_data()))
        
        if data:
            user_data = data[0]
            current_balance = user_data.get('balance', 0)
            current_heat = user_data.get('heat', 0)       # ğŸš” Police Heat
            dirty_cash = user_data.get('dirty_money', 0)  # ğŸ§¼ Black Money
        else:
            # Agar naya user hai
            current_balance = 0
            current_heat = 0
            dirty_cash = 0

        # Session update
        session['user_info']['balance'] = current_balance

        # ğŸš€ Template Render (Sab kuch pass kar rahe hain)
        return render_template('dashboard.html', 
                               user=session['user_info'], 
                               balance=current_balance, 
                               heat=current_heat,          # UI me Red Bar dikhane ke liye
                               dirty_money=dirty_cash,     # Laundering ke liye
                               market_event=active_event)  # Market Tab ke liye

    except Exception as e:
        return f"<h1>Dashboard Error</h1><p>{e}</p>"


# --- ğŸš« THE BLOCKED PAGE ROUTE ---
@app.route('/seized')
def account_seized():
    # Ye wo page hai jo block hone par dikhega
    return render_template('seized.html')

# --- IMPORTS (Agar pehle se nahi hai to add kar lena) ---
from flask import render_template

# ==========================================
# ğŸ“œ COMMANDS WEBSITE ROUTE
# ==========================================
@app.route('/commands')
def commands_page():
    # Ye 'templates' folder ke andar 'commands.html' dhundega
    return render_template('commands.html')

# --- 2. SHOP ROUTE ---
import asyncio
from flask import request, session, redirect, render_template

@app.route('/shop')
def shop():
    if 'user_info' not in session: 
        return redirect('/') 
        
    user_id = session['user_info']['id']
    cid_from_url = request.args.get('cid') 
    
    # Titan-Standard non-blocking call for Flask
    try:
        def fetch_balance():
            return db.get_user_balance(user_id)
            
        current_balance = asyncio.run(db_call(lambda: fetch_balance()))
        
        # Fallback agar balance None aaye
        if current_balance is None:
            current_balance = 0
            
    except Exception as e:
        print(f"Shop Balance Error for UID {user_id}: {e}")
        current_balance = 0
        
    return render_template('index.html', user=session['user_info'], balance=current_balance, cid=cid_from_url)

# --- 3. GAME LIST ---
import asyncio
from flask import session, redirect, render_template

@app.route('/games')
def gamelist():
    if 'user_info' not in session: 
        return redirect('/')
        
    user_id = session['user_info']['id']
    
    # Titan-Standard non-blocking call for Flask
    try:
        def fetch_balance():
            return db.get_user_balance(user_id)
            
        balance = asyncio.run(db_call(lambda: fetch_balance()))
        
        # Fallback agar balance None aaye
        if balance is None:
            balance = 0
            
    except Exception as e:
        print(f"Games Balance Error for UID {user_id}: {e}")
        balance = 0
        
    return render_template('gamelist.html', balance=balance)

from flask import Flask, render_template, request, jsonify, session, redirect
from PIL import Image, ImageDraw, ImageFont
import io
import base64
import random
import string
import textwrap # Long text ko todne ke liye
import time  # <--- Ye line sabse upar imports me honi chahiye


# --- âš™ï¸ 20 LEVELS CONFIGURATION (ULTIMATE SCALING) ---
HACKER_LEVELS = {}

# Base Config
START_FEE = 1000
START_PRIZE = 2000

for i in range(1, 21):
    # --- LOGIC TO GENERATE 20 UNIQUE LEVELS ---
    
    if i <= 5: 
        # BEGINNER (Levels 1-5)
        length = 5 + i         # 6 to 10 chars
        time_limit = 60 - (i*5) # 55s to 35s
        fee = START_FEE * i
        prize = fee * 2 
        label = "SCRIPT KIDDIE"
        
    elif i <= 10:
        # INTERMEDIATE (Levels 6-10)
        length = 15 + ((i-5) * 3) # 18 to 30 chars
        time_limit = 50
        fee = START_FEE * i * 2
        prize = fee * 2.5
        label = "CODE BREAKER"

    elif i <= 15:
        # PROFESSIONAL (Levels 11-15)
        length = 40 + ((i-10) * 10) # 50 to 90 chars
        time_limit = 90 # Time badhaya kyunki text lamba hai
        fee = START_FEE * i * 5
        prize = fee * 3
        label = "BLACK HAT"

    elif i < 20:
        # ELITE (Levels 16-19)
        length = 100 + ((i-15) * 20) # 120 to 180 chars
        time_limit = 180 # 3 Minutes
        fee = START_FEE * i * 10
        prize = fee * 4
        label = "ELITE HACKER"

    else:
        # LEVEL 20: GOD MODE
        length = 250 # 250 Characters!!
        time_limit = 300 # 5 Minutes
        fee = 5000000 # 50 Lakh Entry
        prize = 50000000 # 5 Crore Reward
        label = "GOD MODE (ANONYMOUS)"

    HACKER_LEVELS[i] = {
        "id": i,
        "len": length,
        "time": time_limit,
        "fee": fee,
        "prize": int(prize),
        "label": f"LVL {i}: {label}"
    }

# --- ğŸ–¼ï¸ CLEAN & SECURE IMAGE GENERATOR (FIXED) ---
def generate_secure_image(text):
    # 1. Setup Canvas (Bada Size)
    width = 900
    wrapper = textwrap.TextWrapper(width=35) 
    lines = wrapper.wrap(text)
    
    line_height = 60 # Line gap badhaya
    height = 150 + (len(lines) * line_height)
    
    bg_color = (5, 5, 8) # Deep Black-Blue
    text_color = (0, 255, 65) # Bright Neon Green

    image = Image.new('RGB', (width, height), color=bg_color)
    draw = ImageDraw.Draw(image)
    
    # 2. Font Setup (Bada aur Saaf)
    try:
        # Bold font try karenge, nahi to default bada karenge
        font = ImageFont.truetype("arialbd.ttf", 50) 
    except:
        try:
            font = ImageFont.truetype("arial.ttf", 50)
        except:
            font = ImageFont.load_default() 

    # 3. Background Noise (Text ke PEECHE - Faint)
    # Kam lines, aur dark color taaki text na chupe
    for _ in range(20):
        x1, y1 = random.randint(0, width), random.randint(0, height)
        x2, y2 = random.randint(0, width), random.randint(0, height)
        draw.line([(x1, y1), (x2, y2)], fill=(0, 40, 0), width=1) # Bahut halki lines

    for _ in range(50):
        x, y = random.randint(0, width), random.randint(0, height)
        char = random.choice("01")
        draw.text((x, y), char, font=font, fill=(0, 30, 0)) # Background numbers

    # 4. Draw Main Text (Text sabse UPAR - Bright)
    current_y = 60
    for line in lines:
        try:
            bbox = draw.textbbox((0, 0), line, font=font)
            text_w = bbox[2] - bbox[0]
            x = (width - text_w) / 2
        except:
            x = 50

        # Glitch Effect (Halka sa, taaki padha ja sake)
        # Red Shadow (Peeche)
        draw.text((x+2, current_y+2), line, font=font, fill=(100, 0, 0)) 
        
        # Main Bright Text (Upar)
        draw.text((x, current_y), line, font=font, fill=text_color)
        
        # Glow Effect (Text ko repeat karke bold look)
        draw.text((x+1, current_y), line, font=font, fill=text_color)

        current_y += line_height

    # 5. Convert to Base64
    buffer = io.BytesIO()
    image.save(buffer, format='PNG')
    img_str = base64.b64encode(buffer.getvalue()).decode()
    return f"data:image/png;base64,{img_str}"


# --- ROUTES ---

import asyncio
from flask import session, redirect, render_template

@app.route('/games/hacker')
def hacker_page():
    if 'user_info' not in session: 
        return redirect('/')
        
    user = session['user_info']
    
    # Titan-Standard non-blocking call for Flask
    try:
        def fetch_hacker_balance():
            return db.get_user_balance(user['id'])
            
        balance = asyncio.run(db_call(lambda: fetch_hacker_balance()))
        
        # Fallback agar balance None aaye
        if balance is None:
            balance = 0
            
    except Exception as e:
        print(f"Hacker Game Balance Error for UID {user['id']}: {e}")
        balance = 0
        
    return render_template('hacker.html', user=user, balance=balance, levels=HACKER_LEVELS)

import asyncio
import time
import random
import string
from flask import session, request, jsonify

@app.route('/api/hacker/start', methods=['POST'])
def start_hack():
    if 'user_info' not in session: 
        return jsonify({"status":"error", "msg":"Login First"})
    
    user_id = session['user_info']['id']
    try:
        level = int(request.json.get('level'))
    except:
        return jsonify({"status":"error", "msg":"Invalid Level"})

    config = HACKER_LEVELS.get(level)
    if not config: 
        return jsonify({"status":"error", "msg":"Level not found"})
    
    # ğŸ’° Balance Check (Titan-Grade Non-Blocking)
    try:
        def fetch_hacker_balance():
            return db.get_user_balance(user_id)
            
        current_bal = asyncio.run(db_call(lambda: fetch_hacker_balance()))
        
        if current_bal is None:
            current_bal = 0
            
    except Exception as e:
        print(f"Hacker Start Balance Error for UID {user_id}: {e}")
        return jsonify({"status":"error", "msg":"Database Error"})
        
    if current_bal < config['fee']:
        return jsonify({"status":"error", "msg": f"Need ${config['fee']:,} to Hack!"})
    
    # ğŸ’¸ Deduct Fee (Titan-Grade Non-Blocking)
    try:
        def deduct_fee():
            return db.update_balance(user_id, -config['fee'])
            
        asyncio.run(db_call(lambda: deduct_fee()))
        
    except Exception as e:
        print(f"Hacker Fee Deduction Error for UID {user_id}: {e}")
        return jsonify({"status":"error", "msg":"Transaction Failed"})
    
    # ğŸ” Generate Complex Code
    chars = string.ascii_uppercase + string.digits
    if level > 15: 
        chars += "!@#$%" 
    
    secret_code = ''.join(random.choice(chars) for _ in range(config['len']))
    
    # Store in Session (Server Side Security)
    session['hack_code'] = secret_code
    session['hack_level'] = level
    
    # --- âœ… FIXED LINE IS HERE ---
    session['hack_start_time'] = time.time()  # import_time hata kar sirf time.time() kar diya hai
    
    # Generate Image
    img_data = generate_secure_image(secret_code)
    
    

    return jsonify({
        "status": "success",
        "image": img_data,
        "time": config['time'],
        "len": config['len'],
        "new_balance": current_bal - config['fee']
    })


import asyncio
from flask import session, request, jsonify

@app.route('/api/hacker/submit', methods=['POST'])
def submit_hack():
    if 'user_info' not in session: 
        return jsonify({"status":"error", "msg":"Login First"})
    
    user_input = request.json.get('code', '').strip()
    actual_code = session.get('hack_code')
    level = session.get('hack_level')
    user_id = session['user_info']['id']
    
    if not actual_code or not level:
        return jsonify({"status":"error", "msg":"Session Expired. Try Again."})
    
    config = HACKER_LEVELS[level]
    
    if user_input == actual_code:
        # ğŸ‰ WINNER
        try:
            # 1. Add Prize Money (Titan-Grade Non-Blocking)
            def add_prize():
                return db.update_balance(user_id, config['prize'])
            asyncio.run(db_call(lambda: add_prize()))
            
            # 2. Fetch New Balance (Titan-Grade Non-Blocking)
            def fetch_new_balance():
                return db.get_user_balance(user_id)
            new_balance = asyncio.run(db_call(lambda: fetch_new_balance()))
            
            if new_balance is None:
                new_balance = 0
                
        except Exception as e:
            print(f"Hacker Submit Win Error for UID {user_id}: {e}")
            return jsonify({"status":"error", "msg":"Transaction Failed due to database error."})

        session.pop('hack_code', None) # Clear session to prevent replay
        
        return jsonify({
            "status": "win",
            "prize": config['prize'],
            "new_balance": new_balance
        })
    else:
        # ğŸ’€ LOSER
        session.pop('hack_code', None) # Code expire
        return jsonify({"status":"lose", "msg":"HASH MISMATCH. ACCESS DENIED."})


# --- 4. CASINO ---
import asyncio
from flask import session, redirect, render_template

@app.route('/games/casino')
def casino():
    if 'user_info' not in session: 
        return redirect('/')
        
    user_id = session['user_info']['id']
    
    # Titan-Standard non-blocking call for Flask
    try:
        def fetch_casino_balance():
            return db.get_user_balance(user_id)
            
        balance = asyncio.run(db_call(lambda: fetch_casino_balance()))
        
        # Fallback agar balance None aaye
        if balance is None:
            balance = 0
            
    except Exception as e:
        print(f"Casino Balance Error for UID {user_id}: {e}")
        balance = 0
        
    return render_template('casino.html', username=session['user_info']['username'], balance=balance)

# --- 5. AUTH CALLBACK ---
@app.route('/callback')
def callback():
    code = request.args.get('code')
    if not code: return "Error: No login code from Discord."

    data = {
        'client_id': CLIENT_ID,
        'client_secret': CLIENT_SECRET,
        'grant_type': 'authorization_code',
        'code': code,
        'redirect_uri': REDIRECT_URI,
        'scope': 'identify'
    }
    
    try:
        r = requests.post('https://discord.com/api/oauth2/token', data=data)
        r.raise_for_status()
        token_data = r.json()
        access_token = token_data.get('access_token')

        user_req = requests.get('https://discord.com/api/users/@me', headers={'Authorization': f'Bearer {access_token}'})
        user_data = user_req.json()
        user_id = str(user_data['id'])

        user_balance = db.get_user_balance(user_id)

        session['user_info'] = {
            'id': user_id,
            'username': user_data['username'],
            'avatar': f"https://cdn.discordapp.com/avatars/{user_id}/{user_data['avatar']}.png",
            'balance': user_balance
        }
        return redirect('/') 
        
    except Exception as e:
        return f"Login Failed: {str(e)} <br> Tip: Check Client Secret in Render."

# --- 6. API: SPIN (FIXED & SECURE) ---
import asyncio
import random
from flask import session, request, jsonify

@app.route('/api/spin', methods=['POST'])
def spin():
    if 'user_info' not in session: 
        return jsonify({"status":"error", "msg":"Login First"})
    
    user_id = session['user_info']['id']
    cost = 50000 # Fixed Cost
    
    # 1ï¸âƒ£ BALANCE CHECK (Strict & Non-Blocking)
    try:
        def fetch_spin_balance():
            return db.get_user_balance(user_id)
        current_bal = asyncio.run(db_call(lambda: fetch_spin_balance()))
        
        if current_bal is None:
            current_bal = 0
    except Exception as e:
        print(f"Spin Balance Fetch Error for UID {user_id}: {e}")
        return jsonify({"status":"error", "msg":"Database Timeout. Try Again."})
        
    if current_bal < cost: 
        return jsonify({"status":"error", "msg":"Insufficient Funds!"})
    
    # 2ï¸âƒ£ DEDUCT MONEY FIRST (Atomic Flow - Non-Blocking)
    try:
        def deduct_spin_cost():
            return db.update_balance(user_id, -cost)
        asyncio.run(db_call(lambda: deduct_spin_cost()))
    except Exception as e:
        print(f"Spin Cost Deduction Error for UID {user_id}: {e}")
        return jsonify({"status":"error", "msg":"Transaction Failed. Try Again."})
    
    # --- GAME LOGIC (100% UNTOUCHED) ---
    items = ["ğŸ’", "ğŸ†", "ğŸ˜ˆ", "ğŸ", "ğŸ¥­", "ğŸ’©"]
    # Adjusted weights for better gameplay balance
    weights = [1, 3, 5, 15, 15, 61] 
    result = random.choices(items, weights=weights, k=1)[0]
    
    win = 0
    is_jackpot = False
    slots = [result, result, result]
    msg = ""

    if result == "ğŸ’©":
        # Lose: Show random mismatched fruits
        slots = random.sample(["ğŸ", "ğŸ¥­", "ğŸ‡", "ğŸ’©", "ğŸ’"], 3)
        msg = "Bad Luck! You Lost."
    elif result == "ğŸ’":
        win = 10000000; is_jackpot=True; msg="JACKPOT! DIAMOND HANDS!"
    elif result == "ğŸ†":
        win = 500000; msg="BIG WIN! GOLD TROPHY!"
    elif result == "ğŸ˜ˆ":
        # Devil gives nothing but shows slots
        msg="Devil Unlocked! (No Reward)"
    elif result == "ğŸ" or result == "ğŸ¥­":
        win = 100000; msg=f"Juicy Win! +$100,000"
        
    # 3ï¸âƒ£ Add Winnings (Non-Blocking)
    if win > 0: 
        try:
            def add_spin_win():
                return db.update_balance(user_id, win)
            asyncio.run(db_call(lambda: add_spin_win()))
        except Exception as e:
            print(f"Spin Win Addition Error for UID {user_id}: {e}")
            
    # 4ï¸âƒ£ Get Final Balance for UI (Non-Blocking)
    try:
        def fetch_final_balance():
            return db.get_user_balance(user_id)
        final_balance = asyncio.run(db_call(lambda: fetch_final_balance()))
        
        if final_balance is None:
            final_balance = current_bal - cost + win # Fallback calculation
    except Exception as e:
        print(f"Spin Final Balance Error for UID {user_id}: {e}")
        final_balance = current_bal - cost + win # Fallback calculation

    

    return jsonify({
        "status":"success", 
        "slots":slots, 
        "balance": final_balance, 
        "win":win, 
        "jackpot":is_jackpot, 
        "msg":msg
    })


# --- 7. API: SATTA (FIXED & SECURE) ---
import asyncio
import random
from flask import session, request, jsonify

@app.route('/api/satta', methods=['POST'])
def satta():
    if 'user_info' not in session: 
        return jsonify({"status":"error", "msg":"Login First"})
    
    user_id = session['user_info']['id']
    data = request.json
    
    # 1ï¸âƒ£ INPUT VALIDATION (Bahut Zaruri Hai)
    try:
        bet_amount = int(data.get('amount', 0))
        multiplier = int(data.get('multiplier', 2))
    except (ValueError, TypeError):
        return jsonify({"status":"error", "msg":"Invalid input!"})

    # 2ï¸âƒ£ SECURITY: Negative Bet Prevention
    if bet_amount <= 0:
        return jsonify({"status":"error", "msg":"Bet amount must be positive!"})
        
    if multiplier not in [2, 3, 5, 10]:
        return jsonify({"status":"error", "msg":"Invalid Multiplier!"})
    
    # 3ï¸âƒ£ BALANCE CHECK (Titan-Grade Non-Blocking)
    try:
        def fetch_satta_balance():
            return db.get_user_balance(user_id)
        current_bal = asyncio.run(db_call(lambda: fetch_satta_balance()))
        
        if current_bal is None:
            current_bal = 0
    except Exception as e:
        print(f"Satta Balance Fetch Error for UID {user_id}: {e}")
        return jsonify({"status":"error", "msg":"Database Timeout. Try Again."})
        
    if current_bal < bet_amount: 
        return jsonify({"status":"error", "msg":"Garib! Balance nahi hai."})
    
    # 4ï¸âƒ£ DEDUCT MONEY FIRST (Atomic Flow - Non-Blocking)
    try:
        def deduct_satta_bet():
            return db.update_balance(user_id, -bet_amount)
        asyncio.run(db_call(lambda: deduct_satta_bet()))
    except Exception as e:
        print(f"Satta Bet Deduction Error for UID {user_id}: {e}")
        return jsonify({"status":"error", "msg":"Transaction Failed. Try Again."})
    
    # --- GAME LOGIC (100% UNTOUCHED) ---
    chance_map = {2: 45, 3: 30, 5: 15, 10: 8} # Adjusted odds slightly for fairness
    win_chance = chance_map.get(multiplier, 0)
    
    roll = random.randint(1, 100)
    won = roll <= win_chance
    
    msg = ""
    win_amt = 0 # Fallback tracking ke liye
    
    if won:
        win_amt = bet_amount * multiplier
        # 5ï¸âƒ£ ADD WINNINGS (Non-Blocking)
        try:
            def add_satta_win():
                return db.update_balance(user_id, win_amt)
            asyncio.run(db_call(lambda: add_satta_win()))
        except Exception as e:
            print(f"Satta Win Addition Error for UID {user_id}: {e}")
            
        msg = f"WON! +${win_amt:,}"
    else:
        msg = f"LOST -${bet_amount:,}"
        
    # 6ï¸âƒ£ GET FINAL BALANCE FOR UI (Non-Blocking)
    try:
        def fetch_final_satta_balance():
            return db.get_user_balance(user_id)
        final_balance = asyncio.run(db_call(lambda: fetch_final_satta_balance()))
        
        if final_balance is None:
            final_balance = current_bal - bet_amount + win_amt
    except Exception as e:
        print(f"Satta Final Balance Error for UID {user_id}: {e}")
        final_balance = current_bal - bet_amount + win_amt # Mathematical Fallback
        
    

    return jsonify({
        "status":"success", 
        "won":won, 
        "balance": final_balance, 
        "msg":msg
    })


# --- MEMORY GAME CONFIG ---
MEMORY_REWARDS = {
    1: 500, 2: 1000, 3: 2000, 4: 5000, 5: 10000, 
    6: 20000, 7: 40000, 8: 75000, 9: 150000,
    10: 500000, 11: 1000000, 12: 5000000
}

# Roles for Levels 10, 11, 12
SPECIAL_ROLES = {
    10: {"name": "ğŸ§  MEMORY MASTER", "color": 0x9b59b6}, # Purple
    11: {"name": "ğŸ’£ BOMB SQUAD ELITE", "color": 0xe67e22}, # Orange
    12: {"name": "ğŸ‘‘ GOD OF MINDS", "color": 0xffd700} # Gold
}

import asyncio
from flask import session, redirect, render_template

@app.route('/games/memory')
def memory_game_page():
    if 'user_info' not in session: 
        return redirect('/')
        
    user_id = session['user_info']['id']
    
    # Titan-Standard non-blocking call for Flask
    try:
        def fetch_memory_balance():
            return db.get_user_balance(user_id)
            
        balance = asyncio.run(db_call(lambda: fetch_memory_balance()))
        
        # Fallback agar balance None aaye
        if balance is None:
            balance = 0
            
    except Exception as e:
        print(f"Memory Game Balance Error for UID {user_id}: {e}")
        balance = 0
        
    return render_template('memory.html', user=session['user_info'], balance=balance)

import asyncio
from flask import session, request, jsonify

@app.route('/api/games/memory/complete', methods=['POST'])
def memory_complete():
    if 'user_info' not in session: 
        return jsonify({"status":"error", "msg":"Login First"})
    
    user_id = session['user_info']['id']
    
    try:
        level = int(request.json.get('level'))
        won = request.json.get('won')
    except Exception:
        return jsonify({"status":"error", "msg":"Invalid Data"})
    
    if not won:
        return jsonify({"status":"success", "msg":"Game Over"})

    # 1. Money Reward (Titan-Grade Non-Blocking)
    prize = MEMORY_REWARDS.get(level, 0)
    
    try:
        def add_memory_prize():
            return db.update_balance(user_id, prize)
        asyncio.run(db_call(lambda: add_memory_prize()))
    except Exception as e:
        print(f"Memory Prize Error for UID {user_id}: {e}")
        
    msg = f"Level {level} Cleared! Won ${prize:,}"

    # 2. Special Role Logic (Level 10, 11, 12) - (100% UNTOUCHED LOGIC)
    if level in SPECIAL_ROLES:
        role_data = SPECIAL_ROLES[level]
        guild = bot.get_guild(int(GUILD_ID)) # Make sure GUILD_ID is set in config
        
        if guild:
            member = guild.get_member(int(user_id))
            if member:
                # Run async bot task in thread-safe way
                asyncio.run_coroutine_threadsafe(assign_memory_role(guild, member, role_data), bot.loop)
                msg += f" + ROLE: {role_data['name']}"

    # 3. Get New Balance for UI (Titan-Grade Non-Blocking)
    try:
        def fetch_memory_final_balance():
            return db.get_user_balance(user_id)
        new_balance = asyncio.run(db_call(lambda: fetch_memory_final_balance()))
        
        if new_balance is None:
            new_balance = 0
            
    except Exception as e:
        print(f"Memory Final Balance Error for UID {user_id}: {e}")
        new_balance = 0

    return jsonify({"status":"success", "msg": msg, "new_balance": new_balance})

# --- ASYNC ROLE FUNCTION ---
async def assign_memory_role(guild, member, role_data):
    # Check if role exists
    role = discord.utils.get(guild.roles, name=role_data['name'])
    
    # If not, create it
    if not role:
        try:
            role = await guild.create_role(
                name=role_data['name'], 
                color=discord.Color(role_data['color']),
                reason="Auto-created by Memory Game"
            )
        except Exception as e:
            print(f"Role create error: {e}")
            return

    # Assign to user
    if role not in member.roles:
        try:
            await member.add_roles(role)
        except Exception as e:
            print(f"Role assign error: {e}")

import os
import random
from datetime import datetime # Dhyan dena yahan
from flask import Flask, render_template, request, jsonify, session

# --- BAKI IMPORTS AUR CONFIGURATION ---

# --- ğŸ’° PRIZE CONFIGURATION ---
LEVEL_PRIZES = {
    1: 100, 2: 250, 3: 500, 4: 1000, 5: 2500,
    6: 5000, 7: 10000, 8: 25000, 9: 50000, 10: 100000
}

import asyncio
from flask import session, render_template

@app.route('/play-game')
def game_page():
    # 1. Login Check
    if 'user_info' not in session: 
        return "Please Login First" # Ya redirect('/') kar do
    
    user = session['user_info']
    user_id = user['id']

    # 2. Database se latest Balance lao (Titan-Grade Non-Blocking)
    try:
        def fetch_paheli_balance():
            return db.supabase.table("economy").select("balance").eq("user_id", user_id).execute().data
            
        data = asyncio.run(db_call(lambda: fetch_paheli_balance()))
        
        current_balance = 0
        if data:
            current_balance = data[0].get('balance', 0)
            
    except Exception as e:
        print(f"Paheli Game Balance Error for UID {user_id}: {e}")
        current_balance = 0

    # 3. HTML ko data bhejo (Name, ID, Balance)
    return render_template('paheli.html', 
                           user=user, 
                           balance=current_balance)


# --- 2. API: GET RIDDLE (Pheli laane ke liye) ---
import os
import json
import random
import asyncio
from flask import request, jsonify

@app.route('/api/get_riddle', methods=['POST'])
def get_riddle():
    data = request.json
    user_id = data.get('user_id')
    level = data.get('level')

    if not user_id or not level:
        return jsonify({"status": "error", "msg": "Missing data"})

    try:
        # JSON file load karna (100% Same Logic)
        json_path = os.path.join('riddles', f'level{level}.json')
        with open(json_path, 'r', encoding='utf-8') as f:
            all_riddles = json.load(f)
    except FileNotFoundError:
        return jsonify({"status": "error", "msg": "Level not found"})

    # User ki progress check karna (Titan-Grade Non-Blocking)
    solved_ids = []
    try:
        def fetch_solved_riddles():
            return supabase.table("user_progress").select("solved_riddles").eq("user_id", user_id).execute().data
            
        user_data = asyncio.run(db_call(lambda: fetch_solved_riddles()))
        
        if user_data:
            solved_ids = user_data[0].get('solved_riddles', []) or []
            
    except Exception as e:
        print(f"Riddle Progress Fetch Error for UID {user_id}: {e}")
        # Agar DB lag hai, toh fallback empty list (takleef na ho)

    # Jo solve nahi hui, unhe filter karna (100% Same Logic)
    available_riddles = [r for r in all_riddles if r['id'] not in solved_ids]

    if not available_riddles:
        return jsonify({"status": "completed", "msg": "Level Complete!"})

    # Random paheli bhejna (100% Same Logic)
    selected_riddle = random.choice(available_riddles)
    
    return jsonify({"status": "success", "riddle": selected_riddle})



import asyncio
from flask import request, jsonify

@app.route('/api/submit_answer', methods=['POST'])
def submit_answer():
    data = request.json
    user_id = data.get('user_id')
    
    try:
        riddle_id = int(data.get('riddle_id'))
    except (ValueError, TypeError):
        return jsonify({"status": "error", "msg": "Invalid Riddle ID"})
        
    is_correct = data.get('is_correct')

    # Agar jawab galat hai to kuch mat karo
    if not is_correct:
        return jsonify({"status": "ignored", "msg": "Wrong Answer"})

    # --- SAVE PROGRESS (Titan-Grade Non-Blocking) ---
    first_time = False
    
    try:
        def fetch_user_progress():
            return supabase.table("user_progress").select("*").eq("user_id", user_id).execute().data
        user_data = asyncio.run(db_call(lambda: fetch_user_progress()))
    except Exception as e:
        print(f"Submit Answer Progress Fetch Error UID {user_id}: {e}")
        return jsonify({"status": "error", "msg": "Database Timeout"})

    if not user_data:
        # New User Entry
        try:
            def insert_user_progress():
                return supabase.table("user_progress").insert({
                    "user_id": user_id,
                    "solved_riddles": [riddle_id]
                }).execute()
            asyncio.run(db_call(lambda: insert_user_progress()))
            first_time = True
        except Exception as e:
            print(f"Insert Progress Error UID {user_id}: {e}")
    else:
        current_solved = user_data[0].get('solved_riddles', []) or []
        if riddle_id not in current_solved:
            current_solved.append(riddle_id)
            try:
                def update_user_progress():
                    return supabase.table("user_progress").update({
                        "solved_riddles": current_solved
                    }).eq("user_id", user_id).execute()
                asyncio.run(db_call(lambda: update_user_progress()))
                first_time = True
            except Exception as e:
                print(f"Update Progress Error UID {user_id}: {e}")
        else:
            first_time = False

    # --- GIVE MONEY (Sirf agar pehli baar solve kiya ho) ---
    if first_time:
        # Level detection logic from ID (100% Same Logic)
        if riddle_id >= 1000: level = 10
        elif riddle_id >= 100: level = int(str(riddle_id)[0])
        else: level = 1 

        prize_amount = LEVEL_PRIZES.get(level, 100)

        # Economy update (Titan-Grade Non-Blocking)
        try:
            def fetch_paheli_econ():
                return supabase.table("economy").select("balance").eq("user_id", user_id).execute().data
            econ_data = asyncio.run(db_call(lambda: fetch_paheli_econ()))
            
            if econ_data:
                current_bal = econ_data[0].get('balance', 0)
                new_bal = current_bal + prize_amount
                
                def update_paheli_econ():
                    return supabase.table("economy").update({"balance": new_bal}).eq("user_id", user_id).execute()
                asyncio.run(db_call(lambda: update_paheli_econ()))

                return jsonify({
                    "status": "success", 
                    "msg": f"Correct! Won â‚¹{prize_amount:,}", 
                    "new_balance": new_bal
                })
        except Exception as e:
            print(f"Submit Answer Economy Error UID {user_id}: {e}")
            return jsonify({"status": "error", "msg": "Answer Correct but failed to add prize."})

    return jsonify({"status": "success", "msg": "Already Solved (No Money)"})


# ==========================================
# ğŸ HORSE RACING BACKEND (10/10 Casino Logic)
# ==========================================

import asyncio
from flask import session, redirect, render_template

@app.route('/games/horses')
def horse_race():
    if 'user_info' not in session: 
        return redirect('/')
    
    # User Data Fetch
    uid = session['user_info']['id']
    
    # Titan-Grade Non-Blocking DB Call
    try:
        def fetch_horse_balance():
            return db.supabase.table("economy").select("*").eq("user_id", str(uid)).execute().data
            
        data = asyncio.run(db_call(lambda: fetch_horse_balance()))
        
        if data:
            # Safe parsing
            balance = data[0].get('balance', 0)
        else:
            balance = 0
            
    except Exception as e:
        print(f"Horse Race Balance Error for UID {uid}: {e}")
        balance = 0
        
    return render_template('horse.html', user=session['user_info'], balance=balance)

import asyncio
import random
from flask import session, request
from flask_socketio import emit

@socketio.on('start_horse_race')
def handle_horse_race(data):
    # Added safety check just in case session drops
    if 'user_info' not in session:
        return socketio.emit('race_error', {'msg': 'Login Required'}, to=request.sid)
        
    uid = session['user_info']['id']
    
    # 1. Validation check
    try:
        bet_amount = int(data['amount'])
        selected_horse = data['horse_name']
    except:
        return socketio.emit('race_error', {'msg': 'Invalid Input'}, to=request.sid)

    # 2. Min Bet Check (New Logic)
    if bet_amount < 1000:
        return socketio.emit('race_error', {'msg': 'âš ï¸ Minimum Bet is $1,000!'}, to=request.sid)

    # 3. Balance Check (Titan-Grade Non-Blocking)
    try:
        def fetch_race_balance():
            return db.supabase.table("economy").select("balance").eq("user_id", str(uid)).execute().data
        user_data = asyncio.run(db_call(lambda: fetch_race_balance()))
        
        if user_data:
            current_bal = user_data[0].get('balance', 0)
        else:
            current_bal = 0
    except Exception as e:
        print(f"Horse Race Balance Fetch Error for UID {uid}: {e}")
        return socketio.emit('race_error', {'msg': 'Database Timeout. Try Again.'}, to=request.sid)
    
    if current_bal < bet_amount:
        return socketio.emit('race_error', {'msg': 'âŒ Gareeb! Balance nahi hai.'}, to=request.sid)

    # 4. Deduct Money (Secure Transaction - Non-Blocking)
    new_bal = current_bal - bet_amount
    try:
        def deduct_race_bet():
            return db.supabase.table("economy").update({"balance": new_bal}).eq("user_id", str(uid)).execute()
        asyncio.run(db_call(lambda: deduct_race_bet()))
        
        socketio.emit('balance_update', {'balance': new_bal}, to=request.sid)
    except Exception as e:
        print(f"Horse Race Bet Deduction Error for UID {uid}: {e}")
        return socketio.emit('race_error', {'msg': 'Transaction Failed. Try Again.'}, to=request.sid)

    # 5. Race Logic (Fair Shuffle)
    horses = ['Saksham', 'Muskan', 'Zoro', 'Dev', 'Subhu', 'Chemical', 'Cutiee', 'Snackieee', 'Mayan', 'Haru']
    
    ranking = horses.copy()
    random.shuffle(ranking) # Result server pe decide hota hai
    
    # 6. Payout Calculation
    win_amount = 0
    multiplier = 0
    
    # Fallback to avoid error if client sends invalid horse
    if selected_horse in ranking:
        rank = ranking.index(selected_horse) + 1 
    else:
        rank = 10 

    if rank == 1:
        multiplier = 5.0
        win_amount = int(bet_amount * 5)
    elif rank == 2:
        multiplier = 2.0
        win_amount = int(bet_amount * 2)
    elif rank == 3:
        multiplier = 1.2
        win_amount = int(bet_amount * 1.2)
    
    # 7. Update Database (If Won) (Non-Blocking)
    final_bal = new_bal
    if win_amount > 0:
        final_bal = new_bal + win_amount
        try:
            def add_race_win():
                return db.supabase.table("economy").update({"balance": final_bal}).eq("user_id", str(uid)).execute()
            asyncio.run(db_call(lambda: add_race_win()))
        except Exception as e:
            print(f"Horse Race Win Addition Error for UID {uid}: {e}")
            # Even if DB fails here, the game moves forward (Fail-safe)
        
    # 8. Send Result
    # Client ko hum abhi bata denge kon jeeta, lekin client 60 second tak animation dikhayega
    socketio.emit('race_result', {
        'ranking': ranking,
        'winner': ranking[0],
        'user_rank': rank,
        'win_amount': win_amount,
        'final_balance': final_bal,
        'multiplier': multiplier
    }, to=request.sid)


import random
import string
from flask import request, session, redirect, render_template

# --- CONFIGURATION ---
# ğŸ”´ Yahan apni saari Server IDs comma (,) laga kar daal do
ALLOWED_GUILD_IDS = [
    1431694952080871566,  # Server 1
    1257403231127076915,  # Server 2
    555555555555555555   # Server 3 (Aur bhi add kar sakte ho)
]

ENTRY_FEE = 50000  # QR Generate karne ki fees

# --- 1. QR PAGE ROUTE (Entry Fee Logic) ---
import asyncio
from flask import session, redirect, render_template, request

@app.route('/games/qr_gen')
def qr_generator():
    if 'user_info' not in session: 
        return redirect('/')
    
    uid = session['user_info']['id']
    
    try:
        # 1. Check Balance (Titan-Grade Non-Blocking)
        def fetch_qr_balance():
            return db.supabase.table("economy").select("balance").eq("user_id", str(uid)).execute().data
            
        data = asyncio.run(db_call(lambda: fetch_qr_balance()))
        
        if not data:
            # Agar user DB me nahi hai
            return f"<h1 style='color:red; text-align:center;'>âŒ Account Not Found! Type /start in Discord.</h1>"
            
        current_balance = data[0].get('balance', 0)
        
        # 2. Check Sufficient Funds
        if current_balance < ENTRY_FEE:
            return f"""
            <body style="background:#000; color:white; font-family:sans-serif; text-align:center; padding-top:100px;">
                <h1 style="color:#ff0000; font-size:3rem;">âŒ INSUFFICIENT FUNDS</h1>
                <p>You need <b>${ENTRY_FEE:,}</b> to generate a Quantum QR.</p>
                <p>Your Balance: ${current_balance:,}</p>
                <a href="/" style="color:#00f3ff;">Go Back</a>
            </body>
            """

        # 3. Deduct Fee (50k kaat lo - Atomic Update)
        new_balance = current_balance - ENTRY_FEE
        
        def deduct_qr_fee():
            return db.supabase.table("economy").update({"balance": new_balance}).eq("user_id", str(uid)).execute()
            
        asyncio.run(db_call(lambda: deduct_qr_fee()))

    except Exception as e:
        print(f"Error in QR Gen for UID {uid}: {e}")
        return "Database Error - Please try again later."

    # 4. Generate Link & Render Page (100% Same Logic)
    # (Ab user ke paise kat gaye hain, to QR dikha do)
    scan_url = f"{request.url_root}api/scan_reward/{uid}"
    
    return render_template('qr.html', 
                           user=session['user_info'], 
                           balance=new_balance, 
                           scan_url=scan_url)


# --- 2. THE SCAN & CLAIM API (Probability Logic) ---
import asyncio
import random
import discord
from flask import request

@app.route('/api/scan_reward/<target_id>')
async def claim_reward_scan(target_id):
    # --- TRACKING (100% Same Logic) ---
    user_ip = request.remote_addr
    platform = request.user_agent.platform or "Unknown"
    browser = request.user_agent.browser or "Unknown"
    print(f"ğŸš¨ SCAN: Target {target_id} | IP: {user_ip} | Device: {platform}")

    # --- PROBABILITY LOGIC (100% Same) ---
    luck_roll = random.randint(1, 100)
    has_won_money = (luck_roll <= 10) 

    role_roll = random.randint(1, 10000)
    is_rare_win = (role_roll == 1)

    status_html = ""
    amount = 0
    role_msg = ""

    try:
        # DB Data fetch (Titan-Grade Non-Blocking)
        def fetch_target_econ():
            return db.supabase.table("economy").select("*").eq("user_id", str(target_id)).execute().data
        
        # Async route hai isliye seedha await db_call use karenge
        data = await db_call(lambda: fetch_target_econ())
        
        if not data: 
            return "âŒ User ID Invalid."
        
        current_bal = data[0].get('balance', 0)

        # --- A. MONEY LOGIC ---
        if has_won_money:
            amount = random.randint(10_000, 1_000_000) 
            new_bal = current_bal + amount
            
            # Update DB (Non-Blocking)
            def update_scan_bal():
                return db.supabase.table("economy").update({"balance": new_bal}).eq("user_id", str(target_id)).execute()
            
            await db_call(lambda: update_scan_bal())
            
            status_html = f"""
                <h1 style="color:#00ff00; font-size:3rem;">ğŸ‰ YOU WON!</h1>
                <h2 style="color:#f1c40f; font-size:4rem; text-shadow:0 0 20px #f1c40f;">+${amount:,}</h2>
                <p style="color:#ccc;">Added to account balance.</p>
            """
        else:
            status_html = f"""
                <h1 style="color:#ff5555; font-size:3rem;">âŒ EMPTY SCAN</h1>
                <p style="color:#ccc; font-size:1.5rem;">Better luck next time!</p>
                <p style="color:#555;">(10% Chance to Win Money)</p>
            """

        # --- B. RARE ROLE LOGIC (Multi-Guild) - (100% Same Logic) ---
        if is_rare_win:
            role_name = "ğŸ’ The Chosen One"
            role_given_count = 0
            
            for guild_id in ALLOWED_GUILD_IDS:
                guild = bot.get_guild(guild_id)
                if guild:
                    try:
                        member = await guild.fetch_member(int(target_id))
                        if member:
                            role = discord.utils.get(guild.roles, name=role_name)
                            if not role:
                                role = await guild.create_role(
                                    name=role_name, 
                                    color=discord.Color.gold(), 
                                    reason="QR Jackpot"
                                )
                            
                            if role not in member.roles:
                                await member.add_roles(role)
                                role_given_count += 1
                    except Exception as e:
                        print(f"User not in guild {guild_id}: {e}")

            if role_given_count > 0:
                role_msg = f"""
                <div style="margin-top:30px; padding:20px; border:2px solid gold; border-radius:10px; background:rgba(255, 215, 0, 0.1);">
                    <h2 style="color:gold; margin:0;">ğŸ‘‘ JACKPOT HIT!</h2>
                    <p style="color:#fff;"><b>0.01% LEGENDARY DROP</b></p>
                    <p style="color:#ccc;">'The Chosen One' Role added in {role_given_count} Server(s).</p>
                </div>
                """

    except Exception as e:
        print(f"Reward Error for UID {target_id}: {e}")
        return "Server Error"

    # --- FINAL HTML RETURN (100% Same Styles) ---
    return f"""
    <html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <style>
            body {{ background:#050505; color:white; font-family:'Courier New', monospace; text-align:center; padding:20px; display:flex; flex-direction:column; justify-content:center; height:100vh; margin:0; }}
            .container {{ border: 1px solid #333; padding: 20px; border-radius: 20px; background: #0a0a0a; box-shadow: 0 0 50px rgba(0,0,0,0.8); }}
            .device-info {{ font-size: 0.8rem; color: #444; margin-top: 20px; }}
        </style>
    </head>
    <body>
        <div class="container">
            {status_html}
            {role_msg}
            <div class="device-info">
                Scanner ID: {target_id} <br>
                Device: {platform} | Browser: {browser}
            </div>
        </div>
    </body>
    </html>
    """


# --- PLINKO GAME ROUTES ---

import asyncio
from flask import session, redirect, render_template

@app.route('/games/plinko')
def plinko_game():
    if 'user_info' not in session: 
        return redirect('/')
    
    # Fetch Balance (Titan-Grade Non-Blocking)
    uid = session['user_info']['id']
    try:
        def fetch_plinko_balance():
            return db.supabase.table("economy").select("balance").eq("user_id", str(uid)).execute().data
            
        data = asyncio.run(db_call(lambda: fetch_plinko_balance()))
        
        # Safe balance extraction
        balance = data[0].get('balance', 0) if data else 0
    except Exception as e:
        print(f"Plinko Balance Fetch Error for UID {uid}: {e}")
        balance = 0

    return render_template('plinko.html', user=session['user_info'], balance=balance)

import asyncio
from flask import session, request, jsonify

@app.route('/api/plinko/result', methods=['POST'])
async def plinko_result():
    # Frontend se data aayega: { "bet": 1000, "multiplier": 10 } (100% Same Logic)
    data = request.json
    if 'user_info' not in session:
        return jsonify({"status": "error", "msg": "Login First"})
        
    uid = session['user_info']['id']
    
    try:
        bet_amount = int(data.get('bet', 0))
        multiplier = float(data.get('multiplier', 0))
    except (ValueError, TypeError):
        return jsonify({"status": "error", "msg": "Invalid Data"})
    
    if bet_amount <= 0: 
        return jsonify({"status": "error", "msg": "Invalid Bet"})

    try:
        # 1. Get Current Balance (Titan-Grade Non-Blocking)
        def fetch_plinko_bal():
            return db.supabase.table("economy").select("balance").eq("user_id", str(uid)).execute().data
        
        user_data = await db_call(lambda: fetch_plinko_bal())
        
        if not user_data: 
            return jsonify({"status": "error", "msg": "User not found"})
        
        current_bal = user_data[0].get('balance', 0)
        
        # 2. Check Funds
        if current_bal < bet_amount:
            return jsonify({"status": "error", "msg": "Insufficient Funds"})
            
        # 3. Calculate Win/Loss (100% Same Logic)
        # Pehle bet kaato
        temp_bal = current_bal - bet_amount
        
        # Phir win add karo (Agar 0.2x hai to loss hoga, 10x hai to profit)
        winnings = int(bet_amount * multiplier)
        final_bal = temp_bal + winnings
        
        # 4. Update Database (Titan-Grade Non-Blocking)
        def update_plinko_bal():
            return db.supabase.table("economy").update({"balance": final_bal}).eq("user_id", str(uid)).execute()
        
        await db_call(lambda: update_plinko_bal())
        
        

        return jsonify({
            "status": "success", 
            "new_balance": final_bal, 
            "won": winnings
        })
        
    except Exception as e:
        print(f"Plinko API Error for UID {uid}: {e}")
        return jsonify({"status": "error", "msg": "Database Transaction Failed"})


# --- CIRCLE GAME ROUTES ---

import asyncio
from flask import session, redirect, render_template

@app.route('/games/circle')
def circle_game():
    if 'user_info' not in session: 
        return redirect('/')
    
    # Fetch Balance (Titan-Grade Non-Blocking)
    uid = session['user_info']['id']
    try:
        def fetch_circle_balance():
            return db.supabase.table("economy").select("balance").eq("user_id", str(uid)).execute().data
            
        data = asyncio.run(db_call(lambda: fetch_circle_balance()))
        
        # Safe balance extraction
        balance = data[0].get('balance', 0) if data else 0
    except Exception as e:
        print(f"Circle Game Balance Fetch Error for UID {uid}: {e}")
        balance = 0

    return render_template('circle.html', user=session['user_info'], balance=balance)


import asyncio
from flask import session, request, jsonify

@app.route('/api/circle/bet', methods=['POST'])
def circle_bet():
    if 'user_info' not in session:
        return jsonify({"status": "error", "msg": "Login First"})
        
    data = request.json
    uid = session['user_info']['id']
    
    try:
        bet_amount = int(data.get('bet', 0))
    except (ValueError, TypeError):
        return jsonify({"status": "error", "msg": "Invalid Bet Amount"})

    if bet_amount <= 0:
        return jsonify({"status": "error", "msg": "Bet must be positive"})

    try:
        # 1. Fetch Current Balance (Non-Blocking)
        def fetch_circle_bal():
            return db.supabase.table("economy").select("balance").eq("user_id", str(uid)).execute().data
        
        user_data = asyncio.run(db_call(lambda: fetch_circle_bal()))
        
        if not user_data:
            return jsonify({"status": "error", "msg": "User not found"})
            
        current_bal = user_data[0].get('balance', 0)

        # 2. Check Funds
        if current_bal < bet_amount:
            return jsonify({"status": "error", "msg": "Low Balance"})

        # 3. Deduct Money (Atomic Update - Non-Blocking)
        new_bal = current_bal - bet_amount
        
        def update_circle_bal():
            return db.supabase.table("economy").update({"balance": new_bal}).eq("user_id", str(uid)).execute()
        
        asyncio.run(db_call(lambda: update_circle_bal()))
        
        

        return jsonify({
            "status": "success", 
            "new_balance": new_bal
        })

    except Exception as e:
        print(f"Circle Bet API Error for UID {uid}: {e}")
        return jsonify({"status": "error", "msg": "Database Transaction Failed"})

import asyncio
from flask import session, request, jsonify

@app.route('/api/circle/win', methods=['POST'])
def circle_win():
    if 'user_info' not in session:
        return jsonify({"status": "error", "msg": "Login First"})
        
    data = request.json
    uid = session['user_info']['id']
    
    try:
        amount = int(data.get('amount', 0))
    except (ValueError, TypeError):
        return jsonify({"status": "error", "msg": "Invalid Amount"})

    if amount < 0:
        return jsonify({"status": "error", "msg": "Cheating detected!"})

    try:
        # 1. Fetch Current Balance (Titan-Grade Non-Blocking)
        def fetch_circle_win_bal():
            return db.supabase.table("economy").select("balance").eq("user_id", str(uid)).execute().data
        
        user_data = asyncio.run(db_call(lambda: fetch_circle_win_bal()))
        
        if not user_data:
            return jsonify({"status": "error", "msg": "User not found"})
            
        current_bal = user_data[0].get('balance', 0)

        # 2. Add Winnings (Atomic Update - Non-Blocking)
        new_bal = current_bal + amount
        
        def update_circle_win_bal():
            return db.supabase.table("economy").update({"balance": new_bal}).eq("user_id", str(uid)).execute()
        
        asyncio.run(db_call(lambda: update_circle_win_bal()))
        
        

        return jsonify({
            "status": "success", 
            "new_balance": new_bal
        })

    except Exception as e:
        print(f"Circle Win API Error for UID {uid}: {e}")
        return jsonify({"status": "error", "msg": "Database Transaction Failed"})




# ==========================================
# ğŸš€ ULTIMATE BUSINESS SYSTEM (UPDATED)
# ==========================================
import asyncio
import time
from flask import session, redirect, render_template

@app.route('/business')
def business_dashboard():
    # 1. Auth Check
    if 'user_info' not in session: 
        return redirect('/')
    user_id = session['user_info']['id']
    
    # 2. Fetch Data (Titan-Grade Non-Blocking)
    try:
        def fetch_biz_data():
            return db.supabase.table("economy").select("*").eq("user_id", user_id).execute().data
            
        data = asyncio.run(db_call(lambda: fetch_biz_data()))
        
        if not data: 
            return "Error: User Data Not Found"
            
        user_data = data[0]
        balance = user_data.get('balance', 0)
        owned_businesses = user_data.get('businesses') or {} 
        
        # ğŸ”¥ Variables Fetch
        current_heat = user_data.get('heat', 0)
        current_dirty = user_data.get('dirty_money', 0)
        current_time = int(time.time())

    except Exception as e:
        print(f"Business Dashboard Fetch Error: {e}")
        return "Database Error - Try Again Later"

    # ğŸ“Š Live Market Event Calculation (Logic Intact)
    active_event = get_current_event()

    # --- ADVANCED PASSIVE INCOME & CONSUMPTION (100% SAME LOGIC) ---
    for biz_id, biz in owned_businesses.items():
        
        # ğŸ”´ Safety Patch
        if 'delivery_time' not in biz: biz['delivery_time'] = 0
        if 'supplies' not in biz: biz['supplies'] = 0
        if 'stock' not in biz: biz['stock'] = 0
        if 'popularity' not in biz: biz['popularity'] = 100
        if 'last_check' not in biz: biz['last_check'] = current_time
        if 'has_manager' not in biz: biz['has_manager'] = False 

        # A. Truck Delivery Check
        if biz['delivery_time'] > 0:
            if current_time >= biz['delivery_time']:
                biz['supplies'] = 100
                biz['delivery_time'] = 0 
        
        # B. Passive Income & Manager Logic
        last_check = biz.get('last_check', current_time)
        hours_passed = (current_time - last_check) / 3600
        
        if hours_passed > 0:
            # --- ğŸ”´ MANAGER SALARY LOGIC (100% SAME) ---
            if biz['has_manager']:
                biz['supplies'] = 100
                biz['delivery_time'] = 0
                
                income_rate = BUSINESSES.get(biz_id, {}).get('income_per_hr', 0)
                # Formula: (Income * 0.70) * hours
                salary_cut = int((income_rate * 0.70) * hours_passed) 
                balance -= salary_cut

            # Variable Consumption Logic
            if biz_id in BUSINESSES:
                price = BUSINESSES[biz_id]['price']
                consumption_rate = 20 if price < 150000000 else 5 if price > 500000000 else 10
            else:
                consumption_rate = 10 

            supplies = biz.get('supplies', 0)
            
            # Production Logic (Only if supplies > 0 OR Manager is active)
            if supplies > 0 or biz['has_manager']:
                rate = BUSINESSES.get(biz_id, {}).get('income_per_hr', 0)
                production = int(rate * hours_passed * (biz.get('popularity', 100)/100))
                max_st = BUSINESSES.get(biz_id, {}).get('max_stock', 1000000)
                
                # Update Stock
                biz['stock'] = min(biz.get('stock', 0) + production, max_st)
                
                # Consume supplies (If NO manager)
                if not biz['has_manager']:
                    biz['supplies'] = max(0, supplies - int(hours_passed * consumption_rate))
                
                # Decrease Popularity
                biz['popularity'] = max(0, int(biz.get('popularity', 100) - hours_passed))
                
                # Update Check Time
                biz['last_check'] = current_time

    # 3. Save Updates to Database (Titan-Grade Non-Blocking)
    try:
        def update_biz_state():
            return db.supabase.table("economy").update({
                "businesses": owned_businesses,
                "balance": balance 
            }).eq("user_id", user_id).execute()
            
        asyncio.run(db_call(lambda: update_biz_state()))
    except Exception as e:
        print(f"Business State Save Error: {e}")
        # Agar yahan error aata hai toh return mat karo, render hone do

    

    # 4. Render Template (Logic Intact)
    return render_template('business.html', 
                           user=session['user_info'], 
                           balance=balance, 
                           owned=owned_businesses, 
                           all_biz=BUSINESSES, 
                           now=current_time,
                           market_event=active_event,
                           heat=current_heat,
                           dirty_money=current_dirty,
                           manager_prices=MANAGER_PRICES)


# --- BUY BUSINESS ---
import asyncio
import time
from flask import session, request, jsonify

@app.route('/api/business/buy', methods=['POST'])
def buy_business():
    if 'user_info' not in session:
        return jsonify({"status":"error", "msg":"Login First"})
        
    user_id = session['user_info']['id']
    biz_id = request.json.get('biz_id')
    
    if not biz_id or biz_id not in BUSINESSES:
        return jsonify({"status":"error", "msg":"Invalid Business ID"})

    # 1. Fetch Current Balance & Assets (Non-Blocking)
    try:
        def fetch_buy_data():
            return db.supabase.table("economy").select("balance, businesses").eq("user_id", user_id).execute().data
            
        data = asyncio.run(db_call(lambda: fetch_buy_data()))
        
        if not data:
            return jsonify({"status":"error", "msg":"User data not found"})
            
        current_bal = data[0].get('balance', 0)
        owned = data[0].get('businesses') or {}
        
    except Exception as e:
        print(f"Buy Biz Fetch Error for UID {user_id}: {e}")
        return jsonify({"status":"error", "msg":"Database Timeout"})

    # 2. Validation Logic (100% Same)
    if biz_id in owned: 
        return jsonify({"status":"error", "msg":"Already Owned"})
        
    cost = BUSINESSES[biz_id]['price']
    
    if current_bal < cost: 
        return jsonify({"status":"error", "msg":"Insufficient Funds"})
    
    # 3. New Structure with Multiple Investors list (100% Same Logic)
    owned[biz_id] = {
        "stock": 0, 
        "supplies": 100, 
        "popularity": 100, 
        "level": 1, 
        "security": 1, 
        "last_check": int(time.time()), 
        "investment_open": False, 
        "investors": {} # Dictionary: {user_id: equity_percent}
    }
    
    # 4. Save Changes (Non-Blocking & Secure)
    try:
        new_balance = current_bal - cost
        
        def update_buy_state():
            return db.supabase.table("economy").update({
                "balance": new_balance, 
                "businesses": owned
            }).eq("user_id", user_id).execute()
            
        asyncio.run(db_call(lambda: update_buy_state()))
        
    except Exception as e:
        print(f"Buy Biz Save Error for UID {user_id}: {e}")
        return jsonify({"status":"error", "msg":"Transaction Failed. Balance not deducted."})

    return jsonify({
        "status":"success", 
        "msg":"Business Purchased!",
        "new_balance": new_balance
    })

# --- ORDER SUPPLIES (Dynamic Cost & 10x Instant) ---
import asyncio
import time
from flask import session, request, jsonify

@app.route('/api/business/order', methods=['POST'])
def order_supplies():
    try:
        if 'user_info' not in session:
            return jsonify({"status": "error", "msg": "Login First"})
            
        user_id = session['user_info']['id']
        
        # Frontend se data lo (100% Same Logic)
        req_data = request.json
        biz_id = req_data.get('biz_id')
        order_type = req_data.get('type') # 'instant' ya 'normal'

        # 1. Config Check
        if biz_id not in BUSINESSES:
            return jsonify({"status": "error", "msg": "Invalid Business"})
            
        base_cost = BUSINESSES[biz_id]['supply_cost']
        biz_name = BUSINESSES[biz_id]['name']

        # 2. Database se Data Fetch (Titan-Grade Non-Blocking)
        try:
            def fetch_order_data():
                return db.supabase.table("economy").select("balance, businesses").eq("user_id", user_id).execute().data
            
            data = asyncio.run(db_call(lambda: fetch_order_data()))
            
            if not data: 
                return jsonify({"status": "error", "msg": "User not found"})
            
            owned = data[0].get('businesses') or {}
            current_bal = int(data[0].get('balance', 0))
            
        except Exception as e:
            print(f"Order Fetch Error for UID {user_id}: {e}")
            return jsonify({"status": "error", "msg": "Database Timeout"})

        # 3. Validation Logic (100% Same)
        if biz_id not in owned:
            return jsonify({"status": "error", "msg": "You don't own this business"})

        # Check: Truck en route? (Logic Intact)
        current_time = int(time.time())
        if order_type != 'instant' and owned[biz_id].get('delivery_time', 0) > current_time: 
            return jsonify({"status":"error", "msg":"Truck already en route!"})

        # --- COST & TIME LOGIC (100% SAME) ---
        final_cost = 0
        wait_time = 0
        msg_success = ""

        if order_type == 'instant':
            # ğŸ”¥ INSTANT = 10x COST
            final_cost = base_cost * 10
            wait_time = 0   
            msg_success = f"âš¡ INSTANT! {biz_name} Supplies Arrived!"
            
            # Instant me supplies turant full kar do
            owned[biz_id]['supplies'] = 100
            owned[biz_id]['delivery_time'] = 0
        else:
            # ğŸš› NORMAL = ORIGINAL COST
            final_cost = base_cost
            wait_time = 3 * 3600 # 3 Hours
            msg_success = f"ğŸš› {biz_name} Supplies Ordered (3hrs)"
            
            # Delivery time set karo
            owned[biz_id]['delivery_time'] = current_time + wait_time

        # --- BALANCE CHECK ---
        if current_bal < final_cost:
            return jsonify({"status":"error", "msg": f"Need ${final_cost:,} for this order!"})

        # --- UPDATE DATABASE (Titan-Grade Non-Blocking) ---
        new_bal = current_bal - final_cost
        
        try:
            def update_order_state():
                return db.supabase.table("economy").update({
                    "balance": new_bal, 
                    "businesses": owned
                }).eq("user_id", user_id).execute()
                
            asyncio.run(db_call(lambda: update_order_state()))
            
        except Exception as e:
            print(f"Order Save Error for UID {user_id}: {e}")
            return jsonify({"status": "error", "msg": "Transaction Failed"})

        return jsonify({
            "status":"success", 
            "msg": msg_success, 
            "new_balance": new_bal
        })

    except Exception as e:
        print(f"Critical Order Error: {e}")
        return jsonify({"status": "error", "msg": "Server Error"})

# ==========================================
# 1. ğŸ‘® POLICE HEAT & BRIBE SYSTEM
# ==========================================
import asyncio
from flask import session, jsonify

@app.route('/api/police/bribe', methods=['POST'])
def bribe_police():
    if 'user_info' not in session:
        return jsonify({"status":"error", "msg":"Login First"})
        
    user_id = session['user_info']['id']
    
    # 1. Fetch Heat & Balance (Titan-Grade Non-Blocking)
    try:
        def fetch_bribe_data():
            return db.supabase.table("economy").select("balance, heat").eq("user_id", user_id).execute().data
            
        data = asyncio.run(db_call(lambda: fetch_bribe_data()))
        
        if not data:
            return jsonify({"status":"error", "msg":"User data not found"})
            
        current_heat = data[0].get('heat', 0)
        current_bal = data[0].get('balance', 0)
        
    except Exception as e:
        print(f"Bribe Fetch Error for UID {user_id}: {e}")
        return jsonify({"status":"error", "msg":"Police Station is busy. Try again!"})

    # 2. Bribe Calculation (100% Same Logic)
    bribe_cost = current_heat * 100000 # Example: 50 Heat = $5M
    
    if current_heat <= 0:
        return jsonify({"status":"error", "msg": "You have no heat! No need to bribe."})

    if current_bal < bribe_cost:
        return jsonify({"status":"error", "msg": f"Need ${bribe_cost:,} to bribe commissioner!"})
    
    # 3. Heat Reset & Money Deduct (Atomic Update - Non-Blocking)
    try:
        new_balance = current_bal - bribe_cost
        
        def update_bribe_state():
            return db.supabase.table("economy").update({
                "balance": new_balance,
                "heat": 0
            }).eq("user_id", user_id).execute()
            
        asyncio.run(db_call(lambda: update_bribe_state()))
        
    except Exception as e:
        print(f"Bribe Update Error for UID {user_id}: {e}")
        return jsonify({"status":"error", "msg":"Transaction Failed. Commissioner refused!"})
    
    return jsonify({
        "status":"success", 
        "msg": "ğŸ‘® Commissioner Bribed! Heat is now 0%.",
        "new_balance": new_balance
    })


# ==========================================
# 2. ğŸ¤– HIRE MANAGER (AUTO-RESTOCK)
# ==========================================
import asyncio
from flask import session, request, jsonify

@app.route('/api/business/hire_manager', methods=['POST'])
def hire_manager():
    if 'user_info' not in session:
        return jsonify({"status":"error", "msg":"Login First"})
        
    user_id = session['user_info']['id']
    biz_id = request.json.get('biz_id')
    
    if not biz_id:
        return jsonify({"status":"error", "msg":"Business ID missing"})

    # 1. Fetch Balance & Businesses (Titan-Grade Non-Blocking)
    try:
        def fetch_hiring_data():
            return db.supabase.table("economy").select("balance, businesses").eq("user_id", user_id).execute().data
            
        data = asyncio.run(db_call(lambda: fetch_hiring_data()))
        
        if not data:
            return jsonify({"status":"error", "msg":"User data not found"})
            
        owned = data[0].get('businesses') or {}
        balance = data[0].get('balance', 0)
        
    except Exception as e:
        print(f"Manager Hire Fetch Error for UID {user_id}: {e}")
        return jsonify({"status":"error", "msg":"HR Department is busy. Try again!"})

    # 2. Validation Logic (100% Same)
    if biz_id not in owned:
        return jsonify({"status":"error", "msg": "You don't own this business!"})

    if owned[biz_id].get('has_manager'):
        return jsonify({"status":"error", "msg": "Manager already hired!"})

    # Get price from config
    cost = MANAGER_PRICES.get(biz_id, MANAGER_PRICES.get('default', 10000000))
    
    if balance < cost:
        return jsonify({"status":"error", "msg": f"Manager demands ${cost:,} upfront!"})
        
    # 3. Update State (Hire Manager)
    owned[biz_id]['has_manager'] = True
    new_balance = balance - cost
    biz_name = BUSINESSES.get(biz_id, {}).get('name', 'Business')
    
    # 4. Save Updates (Atomic Update - Non-Blocking)
    try:
        def update_hiring_state():
            return db.supabase.table("economy").update({
                "balance": new_balance,
                "businesses": owned
            }).eq("user_id", user_id).execute()
            
        asyncio.run(db_call(lambda: update_hiring_state()))
        
    except Exception as e:
        print(f"Manager Hire Update Error for UID {user_id}: {e}")
        return jsonify({"status":"error", "msg":"Transaction Failed. Manager walked away!"})
    
    return jsonify({
        "status":"success", 
        "msg": f"ğŸ¤– Manager Hired for {biz_name}!",
        "new_balance": new_balance
    })



# ==========================================
# 3. ğŸ° MONEY LAUNDERING (CLEAN DIRTY MONEY)
# ==========================================
import asyncio
from flask import session, jsonify

@app.route('/api/laundry/clean', methods=['POST'])
def clean_money():
    if 'user_info' not in session:
        return jsonify({"status":"error", "msg":"Login First"})
        
    user_id = session['user_info']['id']
    
    # 1. Fetch Money Data (Titan-Grade Non-Blocking)
    try:
        def fetch_laundry_data():
            return db.supabase.table("economy").select("balance, dirty_money").eq("user_id", user_id).execute().data
            
        data = asyncio.run(db_call(lambda: fetch_laundry_data()))
        
        if not data:
            return jsonify({"status":"error", "msg":"User data not found"})
            
        dirty = data[0].get('dirty_money', 0)
        current_bal = data[0].get('balance', 0)
        
    except Exception as e:
        print(f"Laundry Fetch Error for UID {user_id}: {e}")
        return jsonify({"status":"error", "msg":"Laundromat is under police surveillance. Try again!"})

    # 2. Validation & Math (100% Same Logic)
    if dirty <= 0:
        return jsonify({"status":"error", "msg": "No dirty money to clean!"})
        
    # Laundering Fee (20% cut)
    tax = int(dirty * 0.2)
    cleaned_amount = dirty - tax
    new_balance = current_bal + cleaned_amount
    
    # 3. Save Updates (Atomic Transaction - Non-Blocking)
    try:
        def update_laundry_state():
            return db.supabase.table("economy").update({
                "balance": new_balance,
                "dirty_money": 0
            }).eq("user_id", user_id).execute()
            
        asyncio.run(db_call(lambda: update_laundry_state()))
        
    except Exception as e:
        print(f"Laundry Update Error for UID {user_id}: {e}")
        return jsonify({"status":"error", "msg":"Transaction Failed. Money got stuck in the machine!"})
    
    return jsonify({
        "status":"success", 
        "msg": f"ğŸ§¼ Laundered ${dirty:,}. Paid ${tax:,} in fees. Added ${cleaned_amount:,} to bank.",
        "new_balance": new_balance
    })


# ==========================================
# 4. ğŸ”ª BOUNTY SYSTEM (SET TARGET)
# ==========================================
import asyncio
from flask import session, request, jsonify

@app.route('/api/bounty/set', methods=['POST'])
def set_bounty():
    if 'user_info' not in session:
        return jsonify({"status":"error", "msg":"Login First"})
        
    user_id = session['user_info']['id']
    
    try:
        target_id = request.json.get('target_id')
        amount = int(request.json.get('amount', 0))
    except (ValueError, TypeError):
        return jsonify({"status":"error", "msg":"Invalid Input Data"})
    
    # 1. Validation (100% Same Logic)
    if not target_id:
        return jsonify({"status":"error", "msg": "Target ID is required"})
        
    if amount < 1000000: 
        return jsonify({"status":"error", "msg": "Minimum bounty is $1M"})
    
    # 2. Balance Check (Titan-Grade Non-Blocking)
    try:
        def fetch_bounty_balance():
            return db.supabase.table("economy").select("balance").eq("user_id", user_id).execute().data
            
        data = asyncio.run(db_call(lambda: fetch_bounty_balance()))
        
        if not data:
            return jsonify({"status":"error", "msg":"User data not found"})
            
        current_bal = data[0].get('balance', 0)
        
    except Exception as e:
        print(f"Bounty Fetch Error for UID {user_id}: {e}")
        return jsonify({"status":"error", "msg":"Bounty Office is busy. Try again!"})

    if current_bal < amount:
        return jsonify({"status":"error", "msg": "Insufficient funds for bounty!"})
        
    # 3. Deduct Money (Atomic Update - Non-Blocking)
    try:
        new_balance = current_bal - amount
        
        def update_bounty_state():
            return db.supabase.table("economy").update({
                "balance": new_balance
            }).eq("user_id", user_id).execute()
            
        asyncio.run(db_call(lambda: update_bounty_state()))
        
    except Exception as e:
        print(f"Bounty Deduction Error for UID {user_id}: {e}")
        return jsonify({"status":"error", "msg":"Transaction Failed. Target got lucky!"})
    
    return jsonify({
        "status":"success", 
        "msg": f"ğŸ’€ Bounty of ${amount:,} set on target!",
        "new_balance": new_balance
    })


# --- ROB TRUCK (NEW FEATURE) ---
import asyncio
import time
import random
from flask import session, request, jsonify

@app.route('/api/business/rob_truck', methods=['POST'])
def rob_truck():
    attacker_id = session['user_info']['id']
    target_id = request.json.get('target_id')
    biz_id = request.json.get('biz_id')
    
    if not target_id or not biz_id:
        return jsonify({"status":"error", "msg":"Target or Business ID missing"})

    # 1. Fetch Target Data (Titan-Grade Non-Blocking)
    try:
        def fetch_target_biz():
            return db.supabase.table("economy").select("businesses").eq("user_id", target_id).execute().data
            
        t_data = asyncio.run(db_call(lambda: fetch_target_biz()))
        
        if not t_data:
            return jsonify({"status":"error", "msg":"Target user not found"})
            
        t_biz = t_data[0].get('businesses', {})
        
    except Exception as e:
        print(f"Rob Truck Fetch Error: {e}")
        return jsonify({"status":"error", "msg":"Police interference! Try again later."})

    # 2. Validation (100% Same Logic)
    if biz_id not in t_biz:
        return jsonify({"status":"error", "msg":"Target doesn't own this business"})

    current_time = time.time()
    delivery_time = t_biz[biz_id].get('delivery_time', 0)
    
    if delivery_time == 0 or delivery_time < current_time:
        return jsonify({"status":"error", "msg":"No truck found or already arrived!"})
        
    # 3. Attack Logic (High Risk - 100% Same Logic)
    security = t_biz[biz_id].get('security', 1)
    # Success Chance calculation (Logic intact)
    chance = 0.5 - (security * 0.05) 
    
    if random.random() < chance:
        # --- âœ… SUCCESS: HIJACK ---
        loot = 75000 # Value of supplies
        
        try:
            # Update Attacker Balance (Non-Blocking)
            def add_loot():
                return db.update_balance(attacker_id, loot)
            asyncio.run(db_call(lambda: add_loot()))
            
            # Target loses delivery
            t_biz[biz_id]['delivery_time'] = 0 
            t_biz[biz_id]['supplies'] = 0 # Empty
            
            # Update Target's Business State (Non-Blocking)
            def update_target_loss():
                return db.supabase.table("economy").update({"businesses": t_biz}).eq("user_id", target_id).execute()
            asyncio.run(db_call(lambda: update_target_loss()))
            
        except Exception as e:
            print(f"Rob Success Update Error: {e}")
            return jsonify({"status":"error", "msg":"Hijack partially failed. No loot gained."})
        
        return jsonify({
            "status":"success", 
            "msg": f"HIJACK SUCCESS! Stole supplies worth ${loot:,}"
        })
    else:
        # --- âŒ FAIL: FINE ---
        fine = 50000
        try:
            def deduct_fine():
                return db.update_balance(attacker_id, -fine)
            asyncio.run(db_call(lambda: deduct_fine()))
        except Exception as e:
            print(f"Rob Fine Error: {e}")
            
        return jsonify({
            "status":"fail", 
            "msg": f"HIJACK FAILED! Security fined you ${fine:,}"
        })


# --- SELL STOCK (UPDATED WITH MULTI-INVESTOR & DISCORD LOG) ---
import requests
import json
from datetime import datetime

# ğŸ‘‡ YAHAN APNA WEBHOOK URL DALO
DISCORD_WEBHOOK_URL = "https://discord.com/api/webhooks/1474290910199287818/ruRGVf9kmgolsJlRob3QYdRXAHmHXDIVEUd_-2jTTvmzkcifVRfM7gPCJG5SIPLTrZWQ"

# --- SELL STOCK (UPDATED WITH HEAT, MARKET, LAUNDRY & INVESTORS) ---
import asyncio
from flask import session, request, jsonify
from datetime import datetime

@app.route('/api/business/action', methods=['POST'])
async def biz_action():
    if 'user_info' not in session: 
        return jsonify({"status":"error", "msg":"Login First"})
        
    user_id = session['user_info']['id']
    user_name = session['user_info']['username'] 

    req = request.json
    action = req.get('action')
    biz_id = req.get('biz_id')
    
    # 1. ğŸ”¥ DATA FETCH (Titan-Grade Non-Blocking)
    try:
        def fetch_biz_action_data():
            return db.supabase.table("economy").select("balance, businesses, heat, dirty_money").eq("user_id", user_id).execute().data
        
        data = await db_call(lambda: fetch_biz_action_data())
        
        if not data: 
            return jsonify({"status":"error", "msg":"User data not found"})
        
        user_data = data[0]
        owned = user_data.get('businesses', {})
        if biz_id not in owned:
            return jsonify({"status":"error", "msg":"Business not found"})
            
        biz = owned[biz_id]
        current_heat = user_data.get('heat', 0)
        current_dirty = user_data.get('dirty_money', 0)
        current_bal = user_data.get('balance', 0)

    except Exception as e:
        print(f"Biz Action Fetch Error: {e}")
        return jsonify({"status":"error", "msg":"Database Lag! Try again."})
    
    msg = "" 

    # --- ACTION: PROMOTE ---
    if action == 'promote':
        if current_bal < 10000: 
            return jsonify({"status":"error", "msg": "Need $10,000 to promote!"})
        
        current_bal -= 10000
        biz['popularity'] = 100
        msg = "ğŸš€ Business Promoted! Popularity is now 100%."
        
    # --- ACTION: SELL STOCK ---
    elif action == 'sell_stock':
        raw_stock = biz.get('stock', 0)
        if raw_stock <= 0: 
            return jsonify({"status":"error", "msg":"No Stock to sell!"})
        
        # 1. ğŸ“Š MARKET EVENT CHECK
        active_event = get_current_event()
        stock_val = int(raw_stock * active_event['multiplier'])
        
        # 2. ğŸ‘® POLICE RAID CHECK (Logic Intact)
        raid_result = check_police_raid(current_heat, user_id, stock_val)
        
        if raid_result['raided']:
            biz['stock'] = 0
            new_heat = max(0, current_heat - 50)
            
            def update_raid_loss():
                return db.supabase.table("economy").update({
                    "businesses": owned, 
                    "heat": new_heat
                }).eq("user_id", user_id).execute()
            
            await db_call(lambda: update_raid_loss())
            return jsonify({"status":"error", "msg": raid_result['msg']})
        
        # --- INVESTOR PAYOUT LOGIC (100% SAME) ---
        investors = biz.get('investors', {})
        total_payout = 0
        investor_log_str = ""
        
        if investors:
            investor_log_str = "\n**ğŸ‘¥ Investors Share:**\n"
            for inv_id, equity in investors.items():
                share = int(stock_val * equity)
                percentage = int(equity * 100)
                
                if share > 0:
                    # Non-blocking payout to investors
                    await db_call(lambda: db.update_balance(inv_id, share))
                    total_payout += share
                    investor_log_str += f"> <@{inv_id}> ({percentage}%): **${share:,}**\n"
            
        owner_share = stock_val - total_payout
        
        # 3. ğŸ§¼ DIRTY MONEY vs CLEAN MONEY CHECK
        is_illegal = biz_id in ILLEGAL_BIZ
        money_type_msg = "Clean Cash"
        
        if is_illegal:
            current_dirty += owner_share
            new_heat = min(100, current_heat + 10)
            user_data['heat'] = new_heat
            user_data['dirty_money'] = current_dirty
            
            money_type_msg = "Dirty Money ğŸ§¼ (Heat +10%)"
            msg = f"ğŸ’° Sold on Black Market! +${owner_share:,} added to Dirty Money."
        else:
            current_bal += owner_share
            msg = f"âœ… Sold! You kept ${owner_share:,} in your bank."

        biz['stock'] = 0 
        
        # --- ğŸ’ ULTRA PREMIUM WEBHOOK LOG ---
        biz_name = BUSINESSES.get(biz_id, {}).get('name', biz_id.title())
        
        embed = {
            "title": "ğŸ’¸ GLOBAL MARKET TRANSACTION",
            "description": f"**Business Tycoon:** {user_name} (<@{user_id}>)\n**Enterprise:** `{biz_name}`",
            "color": 0xE74C3C if is_illegal else 0x2ECC71,
            "fields": [
                {"name": "ğŸ“Š Market Event", "value": f"**{active_event['name']}** ({active_event['multiplier']}x)", "inline": True},
                {"name": "ğŸ“¦ Stock Liquidated", "value": f"`{raw_stock:,} units`", "inline": True},
                {"name": "ğŸ’° Total Revenue", "value": f"```py\n${stock_val:,}```", "inline": False},
                {"name": "ğŸ‘‘ Owner Net Profit", "value": f"**${owner_share:,}**\n*({money_type_msg})*", "inline": True},
                {"name": "ğŸ‘¥ Investor Payouts", "value": f"**${total_payout:,}**", "inline": True}
            ],
            "footer": {"text": "Quantum Economy Systems â€¢ " + datetime.utcnow().strftime('%H:%M:%S')},
            "timestamp": datetime.utcnow().isoformat()
        }

        if total_payout > 0:
            embed["fields"].append({"name": "ğŸ“œ Distribution Ledger", "value": investor_log_str, "inline": False})

        try: requests.post(DISCORD_WEBHOOK_URL, json={"embeds": [embed]})
        except Exception as e: print(f"Webhook Error: {e}")

    # 4. ğŸ”¥ FINAL DB UPDATE (Atomic & Secure)
    try:
        def save_final_biz_action():
            return db.supabase.table("economy").update({
                "balance": current_bal, 
                "businesses": owned,
                "heat": user_data.get('heat', 0),
                "dirty_money": user_data.get('dirty_money', 0)
            }).eq("user_id", user_id).execute()
        
        await db_call(lambda: save_final_biz_action())
    except Exception as e:
        print(f"Final Biz Save Error: {e}")
        return jsonify({"status":"error", "msg":"Transaction failed during final save."})
    
    return jsonify({
        "status":"success", 
        "msg": msg, 
        "new_bal": current_bal,
        "new_dirty": user_data.get('dirty_money', 0),
        "new_heat": user_data.get('heat', 0)
    })

# --- SECURITY ---
import asyncio
from flask import session, request, jsonify

@app.route('/api/business/security', methods=['POST'])
def buy_security():
    if 'user_info' not in session:
        return jsonify({"status":"error", "msg":"Login First"})
        
    user_id = session['user_info']['id']
    biz_id = request.json.get('biz_id')
    
    if not biz_id:
        return jsonify({"status":"error", "msg":"Business ID missing"})

    # 1. Fetch Data (Titan-Grade Non-Blocking)
    try:
        def fetch_security_data():
            return db.supabase.table("economy").select("balance, businesses").eq("user_id", user_id).execute().data
            
        data = asyncio.run(db_call(lambda: fetch_security_data()))
        
        if not data:
            return jsonify({"status":"error", "msg":"User data not found"})
            
        current_bal = data[0].get('balance', 0)
        owned = data[0].get('businesses') or {}
        
    except Exception as e:
        print(f"Security Fetch Error for UID {user_id}: {e}")
        return jsonify({"status":"error", "msg":"Database Lag! Try again."})

    # 2. Validation Logic (100% Same Logic)
    if biz_id not in owned:
        return jsonify({"status":"error", "msg":"You don't own this business"})
        
    biz = owned[biz_id]
    # Ensure 'security' key exists
    lvl = biz.get('security', 1)
    
    if lvl >= 5: 
        return jsonify({"status":"error", "msg":"Max Security Level (5) reached!"})
        
    cost = 500000 * lvl # Level 1=500k, 2=1M, 3=1.5M, 4=2M
    
    if current_bal < cost: 
        return jsonify({"status":"error", "msg": f"Need ${cost:,} for next upgrade!"})
    
    # 3. Upgrade & Save (Atomic Update - Non-Blocking)
    try:
        owned[biz_id]['security'] = lvl + 1
        new_balance = current_bal - cost
        
        def update_security_state():
            return db.supabase.table("economy").update({
                "balance": new_balance, 
                "businesses": owned
            }).eq("user_id", user_id).execute()
            
        asyncio.run(db_call(lambda: update_security_state()))
        
    except Exception as e:
        print(f"Security Save Error for UID {user_id}: {e}")
        return jsonify({"status":"error", "msg":"Upgrade failed. Transaction Error."})

    return jsonify({
        "status":"success", 
        "msg": f"ğŸ›¡ï¸ Security Upgraded to Level {lvl + 1}!",
        "new_balance": new_balance
    })


# --- INVESTMENT: LISTING & MULTIPLE INVESTORS ---
# --- 16. API: OPEN IPO (Listing 10% Equity) ---
import asyncio
from flask import session, request, jsonify

@app.route('/api/business/open_investment', methods=['POST'])
def open_investment():
    if 'user_info' not in session: 
        return jsonify({"status":"error", "msg":"Login Required"})

    user_id = session['user_info']['id']
    biz_id = request.json.get('biz_id')

    # 1. Data Fetch (Titan-Grade Non-Blocking)
    try:
        def fetch_ipo_data():
            return db.supabase.table("economy").select("businesses").eq("user_id", user_id).execute().data
            
        data = asyncio.run(db_call(lambda: fetch_ipo_data()))
        
        if not data: 
            return jsonify({"status":"error", "msg":"User data error"})
        
        owned = data[0].get('businesses') or {}

    except Exception as e:
        print(f"IPO Fetch Error for UID {user_id}: {e}")
        return jsonify({"status":"error", "msg":"Market is closed. Try again later."})

    # 2. Validation: Business Ownership (Logic Intact)
    if biz_id not in owned:
        return jsonify({"status":"error", "msg":"Business not found in portfolio"})

    biz = owned[biz_id]

    # 3. Safety: Investors Dict check
    if 'investors' not in biz:
        biz['investors'] = {}

    # 4. Validation: Already Open?
    if biz.get('investment_open'):
        return jsonify({"status":"error", "msg":"IPO is already live!"})

    # 5. Check Equity Limit (Max 49% Sold - 100% Same Logic)
    # investors.values() ka sum nikalo (e.g. 0.1 + 0.1 = 0.2)
    current_equity_sold = sum(biz['investors'].values())
    
    if current_equity_sold >= 0.49: 
        return jsonify({"status":"error", "msg":"Majority Stake Warning! You cannot sell more than 49%."})

    # 6. Price Calculation (Premium Pricing: 10% Equity = 20% Price)
    base_price = BUSINESSES.get(biz_id, {}).get('price', 100000000)
    listing_price = int(base_price * 0.20) 

    # 7. Update State (Atomic Update - Non-Blocking)
    biz['investment_open'] = True
    biz['invest_price'] = listing_price # Price save kar liya taaki buyer ko pata chale
    
    try:
        def save_ipo_state():
            return db.supabase.table("economy").update({"businesses": owned}).eq("user_id", user_id).execute()
            
        asyncio.run(db_call(lambda: save_ipo_state()))
        
    except Exception as e:
        print(f"IPO Save Error for UID {user_id}: {e}")
        return jsonify({"status":"error", "msg":"Failed to list IPO. Transaction Error."})
    
    return jsonify({
        "status":"success", 
        "msg": f"ğŸ“ˆ IPO Live! Listed 10% Equity for ${listing_price:,}",
        "listing_price": listing_price
    })


# --- 17. API: INVEST MONEY (Buying Shares) ---
import asyncio
from flask import session, request, jsonify

@app.route('/api/business/invest_now', methods=['POST'])
async def invest_now():
    if 'user_info' not in session: 
        return jsonify({"status":"error", "msg":"Login Required"})

    investor_id = session['user_info']['id']
    req = request.json
    target_id = req.get('target_id')
    biz_id = req.get('biz_id')
    
    # 1. Self Investment Block (100% Same Logic)
    if investor_id == target_id: 
        return jsonify({"status":"error", "msg":"You cannot invest in your own business here!"})
    
    # 2. Fetch Data (Investor & Target) - Titan-Grade Non-Blocking
    try:
        def fetch_inv_data():
            return db.supabase.table("economy").select("balance").eq("user_id", investor_id).execute().data
            
        def fetch_target_data():
            return db.supabase.table("economy").select("balance, businesses").eq("user_id", target_id).execute().data
            
        inv_data = await db_call(lambda: fetch_inv_data())
        target_data = await db_call(lambda: fetch_target_data())
        
        if not inv_data or not target_data: 
            return jsonify({"status":"error", "msg":"User data not found"})
            
    except Exception as e:
        print(f"Investment Fetch Error: {e}")
        return jsonify({"status":"error", "msg":"Market Lag! Try again."})
    
    # 3. Validation Logic
    target_biz = target_data[0].get('businesses', {})
    if biz_id not in target_biz: 
        return jsonify({"status":"error", "msg":"Business not found"})
    
    biz = target_biz[biz_id]
    
    # Check Open Status
    if not biz.get('investment_open'): 
        return jsonify({"status":"error", "msg":"IPO is Closed or Sold Out!"})
    
    if 'investors' not in biz: 
        biz['investors'] = {}
    
    # 4. Check Equity Limit (Max 49% - Logic Intact)
    current_sold = sum(biz['investors'].values())
    
    if round(current_sold, 2) >= 0.49:
        biz['investment_open'] = False # Auto Close
        
        def emergency_close():
            return db.supabase.table("economy").update({"businesses": target_biz}).eq("user_id", target_id).execute()
        
        await db_call(lambda: emergency_close())
        return jsonify({"status":"error", "msg":"Investment Round Full (Max 49% Sold)"})

    # 5. Money Check (100% Same Pricing Logic)
    cost = biz.get('invest_price', 0)
    
    if cost == 0:
        base_price = BUSINESSES.get(biz_id, {}).get('price', 100000000)
        cost = int(base_price * 0.20)

    investor_bal = inv_data[0].get('balance', 0)
    if investor_bal < cost: 
        return jsonify({"status":"error", "msg": f"Insufficient Funds! Need ${cost:,}"})
    
    # ==========================================
    # ğŸ’° TRANSACTION EXECUTION
    # ==========================================
    
    # A. Investor se paisa lo
    new_inv_bal = investor_bal - cost
    
    # B. Target ko paisa do
    target_bal = target_data[0].get('balance', 0)
    new_target_bal = target_bal + cost
    
    # C. Equity Assign karo (+10%)
    current_share = biz['investors'].get(investor_id, 0)
    new_share = round(current_share + 0.10, 2) 
    biz['investors'][investor_id] = new_share
    
    biz['has_investor'] = True
    
    # D. Auto-Close if Full (Ab agar 49% ho gaya to band kar do)
    total_after_sale = sum(biz['investors'].values())
    if round(total_after_sale, 2) >= 0.49:
        biz['investment_open'] = False
    
    # ==========================================
    # ğŸ’¾ DB SAVE (Titan-Grade Non-Blocking)
    # ==========================================
    try:
        # Update Investor Balance
        def save_investor():
            return db.supabase.table("economy").update({"balance": new_inv_bal}).eq("user_id", investor_id).execute()
        
        # Update Target Balance & Business Data
        def save_target():
            return db.supabase.table("economy").update({
                "balance": new_target_bal, 
                "businesses": target_biz
            }).eq("user_id", target_id).execute()
            
        # Dono ko execute karo
        await db_call(lambda: save_investor())
        await db_call(lambda: save_target())
        
    except Exception as e:
        print(f"Investment Transaction Error: {e}")
        return jsonify({"status":"error", "msg":"Transaction failed. Funds are safe."})
    
    return jsonify({
        "status":"success", 
        "msg": f"âœ… Invested! You now own {int(new_share*100)}% equity.",
        "new_balance": new_inv_bal
    })

# --- 18. API: KICK / LEAVE INVESTMENT (Manage Shareholders) ---
import asyncio
from flask import session, request, jsonify

@app.route('/api/business/manage_investor', methods=['POST'])
async def manage_investor():
    if 'user_info' not in session: 
        return jsonify({"status":"error", "msg":"Login Required"})
    
    user_id = session['user_info']['id']
    req = request.json
    action = req.get('action')
    biz_id = req.get('biz_id')
    
    # ==========================================
    # 1. ACTION: KICK (Owner kicks investor + MANDATORY REFUND)
    # ==========================================
    if action == 'kick': 
        target_inv_id = req.get('target_inv')
        
        # Owner à¤”à¤° Investor à¤¦à¥‹à¤¨à¥‹à¤‚ à¤•à¤¾ à¤¡à¥‡à¤Ÿà¤¾ à¤à¤• à¤¸à¤¾à¤¥ à¤‰à¤ à¤¾à¤“ (Titan-Grade Fetch)
        try:
            def fetch_kick_data():
                owner = db.supabase.table("economy").select("balance, businesses").eq("user_id", user_id).execute().data
                investor = db.supabase.table("economy").select("balance").eq("user_id", target_inv_id).execute().data
                return owner, investor
            
            owner_res, inv_res = await db_call(lambda: fetch_kick_data())
            
            if not owner_res or not inv_res:
                return jsonify({"status":"error", "msg":"Data fetch failed"})
                
            owned = owner_res[0].get('businesses', {})
            owner_bal = owner_res[0].get('balance', 0)
            inv_bal = inv_res[0].get('balance', 0)

        except Exception as e:
            print(f"Kick Fetch Error: {e}")
            return jsonify({"status":"error", "msg":"Database Lag! Try again."})

        # Logic Check
        if biz_id in owned and 'investors' in owned[biz_id]:
            if target_inv_id in owned[biz_id]['investors']:
                
                # --- ğŸ”¥ REFUND CALCULATION ---
                # Kitni equity thi uske paas? (e.g. 0.1)
                equity_share = owned[biz_id]['investors'][target_inv_id]
                
                # Original Invested Price (Jo IPO ke waqt set thi)
                # Agar invest_price nahi milti to 20% of base price fallback
                refund_amount = owned[biz_id].get('invest_price', 0)
                
                if refund_amount == 0:
                    base_price = BUSINESSES.get(biz_id, {}).get('price', 100000000)
                    refund_amount = int(base_price * 0.20)
                
                # Total refund: Jitni 10% ki units usne kharidi thi
                # Agar 0.2 equity hai to 2 units ka refund (2 * refund_price)
                total_refund = int((equity_share / 0.1) * refund_amount)

                # --- ğŸ’¸ MONEY TRANSFER ---
                new_owner_bal = owner_bal - total_refund # Ye Minus me ja sakta hai (Logic Intact)
                new_inv_bal = inv_bal + total_refund

                # Remove Investor
                del owned[biz_id]['investors'][target_inv_id]
                if not owned[biz_id]['investors']:
                    owned[biz_id]['has_investor'] = False
                
                # --- ğŸ’¾ DB UPDATE (Titan-Grade Non-Blocking) ---
                try:
                    def save_kick_result():
                        # Owner ka data update
                        db.supabase.table("economy").update({
                            "businesses": owned,
                            "balance": new_owner_bal
                        }).eq("user_id", user_id).execute()
                        
                        # Investor ko refund dena
                        db.supabase.table("economy").update({
                            "balance": new_inv_bal
                        }).eq("user_id", target_inv_id).execute()
                        
                    await db_call(lambda: save_kick_result())
                    
                    return jsonify({
                        "status":"success", 
                        "msg": f"ğŸš« Investor Kicked! Refund of ${total_refund:,} deducted from your account."
                    })
                except Exception as e:
                    print(f"Kick Save Error: {e}")
                    return jsonify({"status":"error", "msg":"Transaction failed."})
            else:
                return jsonify({"status":"error", "msg":"Investor not found in list"})
        else:
            return jsonify({"status":"error", "msg":"Business or Investors not found"})

    # ==========================================
    # 2. ACTION: LEAVE (Investor dumps shares - NO REFUND)
    # ==========================================
    elif action == 'leave': 
        owner_id = req.get('owner_id')
        if not owner_id: 
            return jsonify({"status":"error", "msg":"Owner ID missing"})
        
        try:
            def fetch_leave_data():
                return db.supabase.table("economy").select("businesses").eq("user_id", owner_id).execute().data
            
            owner_data = await db_call(lambda: fetch_leave_data())
            if not owner_data: return jsonify({"status":"error", "msg":"Business Owner not found"})
            
            owned = owner_data[0].get('businesses', {})
            
            if biz_id in owned and 'investors' in owned[biz_id]:
                if user_id in owned[biz_id]['investors']:
                    
                    # Remove Self (Investor ki apni marzi hai, isliye refund nahi milega)
                    del owned[biz_id]['investors'][user_id]
                    
                    if not owned[biz_id]['investors']:
                        owned[biz_id]['has_investor'] = False
                        
                    def save_leave_result():
                        return db.supabase.table("economy").update({"businesses": owned}).eq("user_id", owner_id).execute()
                        
                    await db_call(lambda: save_leave_result())
                    return jsonify({"status":"success", "msg":"ğŸ“‰ You dumped your shares! (Investment Lost)"})
                else:
                    return jsonify({"status":"error", "msg":"You are not an investor here"})
            else:
                return jsonify({"status":"error", "msg":"Business details changed"})

        except Exception as e:
            print(f"Leave Error: {e}")
            return jsonify({"status":"error", "msg":"Transaction Error"})

    return jsonify({"status":"error", "msg":"Invalid Action"})



# --- GET TARGETS (Attack Truck / Invest / Portfolio / Bounty) ---
import asyncio
import time
from flask import session, jsonify

@app.route('/api/business/targets', methods=['GET'])
def get_targets():
    if 'user_info' not in session: 
        return jsonify({"portfolio":[], "targets":[]})
    
    my_id = session['user_info']['id']
    
    # 1. Fetch Data (Titan-Grade Non-Blocking)
    try:
        def fetch_all_biz_targets():
            # Added 'head_bounty' and filtered empty business objects
            return db.supabase.table("economy")\
                .select("user_id, businesses, head_bounty")\
                .neq("businesses", "{}")\
                .limit(30)\
                .execute().data
            
        all_users = asyncio.run(db_call(lambda: fetch_all_biz_targets()))
        
        if not all_users:
            return jsonify({"portfolio":[], "targets":[]})

    except Exception as e:
        print(f"Targets Fetch Error: {e}")
        return jsonify({"portfolio":[], "targets":[], "error": "Database busy"})

    data = {
        "targets": [],  # For Heist/Invest/Bounty
        "portfolio": [] # My Investments
    }
    
    current_time = time.time()

    for u in all_users:
        uid = u['user_id']
        user_bounty = u.get('head_bounty', 0) # Bounty logic (100% Same)
        
        # User ke saare businesses check karo
        businesses = u.get('businesses', {})
        for b_id, b_data in businesses.items():
            
            # A. Check if I am an investor (Portfolio - Logic Intact)
            investors = b_data.get('investors', {})
            if my_id in investors:
                # Business Name config se nikalo
                biz_name = BUSINESSES.get(b_id, {}).get('name', b_id)
                
                data['portfolio'].append({
                    "owner_id": uid,
                    "biz_name": biz_name,
                    "biz_id": b_id,
                    "equity": int(investors[my_id] * 100) # 0.10 -> 10%
                })
            
            # B. Add to Targets List (Exclude Self)
            if uid != my_id:
                biz_name = BUSINESSES.get(b_id, {}).get('name', b_id)
                
                data['targets'].append({
                    "user_id": uid,
                    "biz_name": biz_name,
                    "biz_id": b_id,
                    "stock": b_data.get('stock', 0),
                    "security": b_data.get('security', 1),
                    "investment_open": b_data.get('investment_open', False),
                    "truck_active": b_data.get('delivery_time', 0) > current_time,
                    "head_bounty": user_bounty # âœ… Added Bounty Here
                })
                
    return jsonify(data)



# --- 14. API: HEIST EXECUTION (UPDATED WITH BOUNTY, HEAT & LOGS) ---

import asyncio
import random
import requests
from flask import session, request, jsonify
from datetime import datetime

@app.route('/api/business/heist', methods=['POST'])
async def execute_heist():
    if 'user_info' not in session: 
        return jsonify({"status":"error", "msg":"Login Required"})
    
    hacker_id = session['user_info']['id']
    hacker_name = session['user_info']['username']
    
    req = request.json
    target_id = req.get('target_id')
    biz_id = req.get('biz_id')
    step_success = req.get('success') # From UI minigame
    
    # 1. FETCH DATA (Titan-Grade Non-Blocking)
    try:
        def fetch_heist_data():
            hacker = db.supabase.table("economy").select("*").eq("user_id", hacker_id).execute().data
            target = db.supabase.table("economy").select("*").eq("user_id", target_id).execute().data
            return hacker, target
        
        h_res, t_res = await db_call(lambda: fetch_heist_data())
        
        if not h_res or not t_res: 
            return jsonify({"status":"error", "msg":"One of the users not found"})
        
        hacker = h_res[0]
        target = t_res[0]
        
    except Exception as e:
        print(f"Heist Data Fetch Error: {e}")
        return jsonify({"status":"error", "msg":"Database Lag! Heist aborted."})
    
    # 2. ENTRY FEE CHECK ($100M - 100% Same Logic)
    cost = 100000000
    current_h_bal = hacker.get('balance', 0)
    
    if current_h_bal < cost: 
        return jsonify({"status":"error", "msg":"Insufficient Funds for Heist Kit ($100M)"})

    # 3. Target Business Check
    target_biz_list = target.get('businesses', {})
    if biz_id not in target_biz_list:
        return jsonify({"status":"error", "msg":"Business already moved, sold or stolen!"})

    target_biz_obj = target_biz_list[biz_id]
    biz_name = target_biz_obj.get('name', 'Unknown Business')
    
    # Risk Deduct: Paise pehle hi kaat lo (Logic Intact)
    current_h_bal -= cost

    # --- FAIL CONDITION 1: UI GAME FAILED ---
    if not step_success:
        h_heat = min(100, hacker.get('heat', 0) + 5)
        
        def save_fail_minigame():
            return db.supabase.table("economy").update({"balance": current_h_bal, "heat": h_heat}).eq("user_id", hacker_id).execute()
        
        await db_call(lambda: save_fail_minigame())
        send_heist_log(hacker_name, target_id, biz_name, "FAILED (Minigame)", 0)
        return jsonify({"status":"fail", "msg":"HACK FAILED! Firewall detected your patterns. Lost $100M Kit."})

    # --- FAIL CONDITION 2: SECURITY RNG CHECK ---
    security_lvl = target_biz_obj.get('security', 1)
    fail_chance = min(0.90, security_lvl * 0.15) 
    
    if random.random() < fail_chance:
        h_heat = min(100, hacker.get('heat', 0) + 10)
        
        def save_fail_security():
            return db.supabase.table("economy").update({"balance": current_h_bal, "heat": h_heat}).eq("user_id", hacker_id).execute()
        
        await db_call(lambda: save_fail_security())
        send_heist_log(hacker_name, target_id, biz_name, f"BLOCKED (Security Lvl {security_lvl})", 0)
        return jsonify({"status":"fail", "msg": f"Target Security (Level {security_lvl}) blocked your breach! Kit destroyed."})

    # ==========================================
    # âœ… SUCCESS: TRANSFER OWNERSHIP (No Sticking Fix)
    # ==========================================
    
    # 1. Remove from Target
    stolen_data = target_biz_list.pop(biz_id)
    # Reset Investors & Status (Safety first)
    stolen_data['has_investor'] = False 
    stolen_data['investment_open'] = False
    stolen_data['investors'] = {}
    stolen_data['last_check'] = int(datetime.utcnow().timestamp()) # Time reset
    
    # 2. Add to Hacker
    hacker_biz_list = hacker.get('businesses', {})
    hacker_biz_list[biz_id] = stolen_data
    
    # 3. ğŸ’€ BOUNTY CLAIM CHECK
    bounty_reward = target.get('head_bounty', 0)
    target_new_bounty = 0
    bounty_msg = ""
    if bounty_reward > 0:
        current_h_bal += bounty_reward
        target_new_bounty = 0
        bounty_msg = f" + ğŸ’€ CLAIMED ${bounty_reward:,} BOUNTY!"

    # 4. Heat Update
    new_h_heat = min(100, hacker.get('heat', 0) + 25)
    
    # 5. DB Save (Dual User Atomic Update)
    try:
        def save_heist_success():
            # Update Hacker
            db.supabase.table("economy").update({
                "balance": current_h_bal, 
                "businesses": hacker_biz_list,
                "heat": new_h_heat
            }).eq("user_id", hacker_id).execute()
            
            # Update Target
            db.supabase.table("economy").update({
                "businesses": target_biz_list,
                "head_bounty": target_new_bounty
            }).eq("user_id", target_id).execute()
            
        await db_call(lambda: save_heist_success())
        
    except Exception as e:
        print(f"Heist Final Save Error: {e}")
        return jsonify({"status":"error", "msg":"Transfer Interrupted by FBI! Try again."})
    
    # 6. Discord Log (Success)
    send_heist_log(hacker_name, target_id, biz_name, "SUCCESS", bounty_reward)
    
    return jsonify({
        "status":"success", 
        "msg":f"ğŸ’» SYSTEM BREACHED! Ownership transferred to you.{bounty_msg}",
        "new_bal": current_h_bal
    })

# --- HELPER: DISCORD LOG (100% SAME LOGIC, ULTRA PREMIUM) ---
def send_heist_log(hacker_name, target_id, biz_name, status, bounty):
    color = 0x2ECC71 if status == "SUCCESS" else 0xE74C3C
    desc = f"**Hacker:** `{hacker_name}`\n**Target:** <@{target_id}>\n**Asset:** `{biz_name}`\n**Final Status:** `{status}`"
    
    if bounty > 0:
        desc += f"\n\nğŸ’€ **Bounty Collected:** `${bounty:,}`"

    embed = {
        "title": "ğŸ”Œ QUANTUM HEIST: BREACH ALERT",
        "description": desc,
        "color": color,
        "footer": {"text": "Network Log â€¢ Quantum Security"},
        "timestamp": datetime.utcnow().isoformat()
    }
    try: requests.post(DISCORD_WEBHOOK_URL, json={"embeds": [embed]})
    except: pass

# --- 18. RUNNER GAME ROUTE (SUBWAY SURF STYLE) ---
import asyncio
from flask import session, redirect, render_template

@app.route('/games/runner')
def runner_game():
    if 'user_info' not in session: 
        return redirect('/')
    
    user_id = session['user_info']['id']
    
    # Titan-Grade Non-Blocking Fetch
    try:
        # Purane get_user_balance ko db_call me wrap kiya
        def fetch_runner_bal():
            return db.get_user_balance(user_id)
            
        balance = asyncio.run(db_call(lambda: fetch_runner_bal()))
        
        # Safe fallback if balance is None
        if balance is None:
            balance = 0
            
    except Exception as e:
        print(f"Runner Game Balance Error for UID {user_id}: {e}")
        balance = 0

    return render_template('runner.html', balance=balance)


# --- 19. API: RUNNER PAYOUT ---
import asyncio
from flask import session, request, jsonify

@app.route('/api/games/runner/payout', methods=['POST'])
def runner_payout():
    if 'user_info' not in session: 
        return jsonify({"status":"error", "msg":"Login First"})
        
    user_id = session['user_info']['id']
    
    # 1. User se coins ka data lo
    try:
        coins_collected = int(request.json.get('coins', 0))
    except (ValueError, TypeError):
        return jsonify({"status":"error", "msg":"Invalid data received"})
    
    # 2. Updated Rate: 1 Coin = $1,000 (As per your request)
    reward = coins_collected * 1000
    
    # 3. Maximum Cap (Security: Ek baar me $50,000 se zyada nahi - Logic Intact)
    if reward > 50000: 
        reward = 50000 
    
    # 4. Transaction Execution (Titan-Grade Non-Blocking)
    msg = ""
    new_bal = 0
    
    try:
        def execute_runner_payout():
            if reward > 0:
                # Paise add karo
                db.update_balance(user_id, reward)
            
            # Naya balance fetch karo
            return db.get_user_balance(user_id)

        # Asyncio se DB call ko safe kiya
        new_bal = asyncio.run(db_call(lambda: execute_runner_payout()))
        
        if reward > 0:
            msg = f"Awesome Run! Added ${reward:,} to wallet."
        else:
            msg = "No coins collected. Try again!"
            
    except Exception as e:
        print(f"Runner Payout Error for UID {user_id}: {e}")
        return jsonify({"status":"error", "msg":"Database Error. Points not saved."})
    
    return jsonify({
        "status":"success", 
        "msg": msg, 
        "new_balance": new_bal, 
        "earned": reward
    })

# --- 20. DICE GAME ROUTE (PAGE RENDER) ---
import asyncio
from flask import session, redirect, render_template

@app.route('/games/dice')
def dice_game():
    if 'user_info' not in session: 
        return redirect('/')
    
    user_id = session['user_info']['id']
    
    # Titan-Grade Non-Blocking Fetch
    try:
        # DB call à¤•à¥‹ lambda à¤®à¥‡à¤‚ wrap à¤•à¤¿à¤¯à¤¾ à¤¤à¤¾à¤•à¤¿ UI à¤¬à¥à¤²à¥‰à¤• à¤¨ à¤¹à¥‹
        def fetch_dice_bal():
            return db.get_user_balance(user_id)
            
        balance = asyncio.run(db_call(lambda: fetch_dice_bal()))
        
        # Safe fallback if balance is None
        if balance is None:
            balance = 0
            
    except Exception as e:
        print(f"Dice Game Balance Fetch Error (UID: {user_id}): {e}")
        balance = 0

    return render_template('dice.html', balance=balance)

# --- 21. API: DICE ROLL (FIXED & SECURE) ---
import asyncio
import random
from flask import session, request, jsonify

@app.route('/api/games/dice/play', methods=['POST'])
async def play_dice():
    if 'user_info' not in session: 
        return jsonify({"status":"error", "msg":"Login First"})
    
    user_id = session['user_info']['id']
    data = request.json
    
    # 1ï¸âƒ£ VALIDATION: Check if bet is a valid number
    try:
        bet = int(data.get('bet', 0))
    except (ValueError, TypeError):
        return jsonify({"status":"error", "msg":"Invalid bet amount!"})

    # 2ï¸âƒ£ SECURITY: Prevent Negative or Zero Bets
    if bet <= 0:
        return jsonify({"status":"error", "msg":"Bet must be greater than 0!"})

    choice = data.get('choice') # 'under', 'seven', 'over'
    if choice not in ['under', 'seven', 'over']:
        return jsonify({"status":"error", "msg":"Invalid choice!"})

    # 3ï¸âƒ£ BALANCE CHECK & DEDUCTION (Titan-Grade Non-Blocking)
    try:
        def fetch_and_deduct():
            # Current balance check
            bal = db.get_user_balance(user_id)
            if bal < bet:
                return None
            # Deduct money FIRST to prevent exploit (Logic Intact)
            db.update_balance(user_id, -bet)
            return bal - bet

        current_bal_after_bet = await db_call(lambda: fetch_and_deduct())
        
        if current_bal_after_bet is None:
            return jsonify({"status":"error", "msg":"Insufficient Funds!"})

    except Exception as e:
        print(f"Dice Transaction Error: {e}")
        return jsonify({"status":"error", "msg":"Bank is busy. Try again!"})

    # --- ğŸ² GAME LOGIC (100% Same) ---
    d1 = random.randint(1, 6)
    d2 = random.randint(1, 6)
    total = d1 + d2
    
    winnings = 0
    won = False
    
    # Under 7 (2x), Over 7 (2x), Exact 7 (5x)
    if choice == 'under' and total < 7:
        winnings = bet * 2
        won = True
    elif choice == 'over' and total > 7:
        winnings = bet * 2
        won = True
    elif choice == 'seven' and total == 7:
        winnings = bet * 5
        won = True
        
    # 4ï¸âƒ£ FINAL SETTLEMENT (Atomic Save)
    try:
        if won: 
            await db_call(lambda: db.update_balance(user_id, winnings))
            msg = f"Rolled {total} ({d1}+{d2})! {'LUCKY 7! JACKPOT' if choice == 'seven' else 'YOU WON'} ${winnings:,}"
        else:
            msg = f"Rolled {total} ({d1}+{d2}). Better luck next time!"
            
        # Get Final Balance (Safe Sync)
        new_bal = await db_call(lambda: db.get_user_balance(user_id))
        
    except Exception as e:
        print(f"Dice Reward Error: {e}")
        return jsonify({"status":"error", "msg":"Reward sync failed. Admin will check."})
    
    return jsonify({
        "status":"success", 
        "d1":d1, "d2":d2, "total":total, 
        "won":won, 
        "balance":new_bal, 
        "msg":msg
    })


import json

# --- PIXEL WAR CONFIG ---
GRID_SIZE = 50 # 50x50 Grid
pixel_grid = [["#111" for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)] # Default Black
pixel_history = [] # Logs

# Teams
TEAMS = {
    "neon": {"color": "#00f3ff", "name": "TEAM NEON"},
    "cyber": {"color": "#ff00de", "name": "TEAM CYBER"}
}

# --- ROUTES ---

from flask import session, redirect, render_template

@app.route('/games/pixelwar')
def pixelwar_page():
    # 1. Auth Check
    if 'user_info' not in session: 
        return redirect('/')
    
    user = session['user_info']
    
    # 2. Grid Configuration (Global Config se uthaya)
    # GRID_SIZE agar app.py me define hai toh wahi uthayega
    # Default fallback 50x50 rakha hai security ke liye
    grid_size = globals().get('GRID_SIZE', 50) 
    
    # 3. Render Template
    # User info aur Grid size render ho raha hai taaki frontend Canvas load ho sake
    return render_template('pixelwar.html', 
                           user=user, 
                           grid_size=grid_size)


# --- API: GET GAME STATE ---
from flask import jsonify

@app.route('/api/pixelwar/state')
def get_pixel_state():
    # 1. Memory Safety Check
    # Agar kisi wajah se grid initialize nahi hui toh error ke bajaye empty structure bhejo
    current_grid = globals().get('pixel_grid', [])
    current_history = globals().get('pixel_history', [])

    # 2. History Slicing (Optimization)
    # Sirf last 10 events bhejne ka tumhara logic 100% barkarar hai
    # Taki payload size chota rahe aur mobile users ko lag na ho
    recent_history = current_history[-10:] if current_history else []

    # 3. Response Structure (100% Same)
    return jsonify({
        "grid": current_grid,
        "history": recent_history
    })


# --- GLOBAL COOLDOWN TRACKER ---
import time
user_cooldowns = {} # Stores {user_id: last_action_timestamp}

# --- API: PLACE PIXEL (SECURE & ATOMIC) ---
import asyncio
import time
from flask import session, request, jsonify

@app.route('/api/pixelwar/place', methods=['POST'])
def place_pixel():
    if 'user_info' not in session: 
        return jsonify({"status":"error", "msg":"Login First"})
    
    user_id = session['user_info']['id']
    user_name = session['user_info']['username']
    
    # ğŸ”’ 1. SERVER-SIDE COOLDOWN CHECK (Titan-Grade Security)
    current_time = time.time()
    # globals() se user_cooldowns dictionary uthayi
    cooldown_dict = globals().get('user_cooldowns', {})
    last_time = cooldown_dict.get(user_id, 0)
    
    # 5 sec ka cooldown (4.8 buffer logic intact)
    if current_time - last_time < 4.8: 
        return jsonify({"status":"error", "msg":"Cooling down! Please wait."}) 
    
    # Update Cooldown Immediately
    cooldown_dict[user_id] = current_time

    # Data Fetch
    data = request.json
    try:
        x, y = int(data.get('x')), int(data.get('y'))
        team = data.get('team')
        grid_limit = globals().get('GRID_SIZE', 50)
    except (ValueError, TypeError):
        return jsonify({"status":"error", "msg":"Invalid coordinates"})
    
    # Validation: Out of bounds check
    if not (0 <= x < grid_limit and 0 <= y < grid_limit):
        return jsonify({"status":"error", "msg":"Out of bounds"})
    
    # Update Grid Memory
    teams_config = globals().get('TEAMS', {})
    color = teams_config.get(team, {}).get('color', '#ffffff')
    
    # Memory update (y-axis first structure)
    grid = globals().get('pixel_grid')
    if grid:
        grid[y][x] = color
    
    # ğŸ”’ 2. ATOMIC BALANCE UPDATE (Safe & Non-Blocking)
    REWARD = 500
    try:
        def execute_pixel_reward():
            # Reward add karna aur naya balance lena
            db.update_balance(user_id, REWARD)
            return db.get_user_balance(user_id)

        # Asyncio se DB call ko safe kiya
        new_bal = asyncio.run(db_call(lambda: execute_pixel_reward()))
        
    except Exception as e:
        print(f"Pixel War DB Error for UID {user_id}: {e}")
        return jsonify({"status":"error", "msg":"Mining failed - DB busy"})

    # 3. History Log (100% Same Logic)
    log = f"<b style='color:{color}'>{user_name}</b> mined <b>${REWARD}</b> at ({x},{y})"
    history = globals().get('pixel_history', [])
    history.append(log)
    
    # Keep history manageable (Optional optimization)
    if len(history) > 100: history.pop(0)
    
    return jsonify({
        "status": "success", 
        "reward": REWARD, 
        "new_balance": new_bal
    })


# --- API: FETCH ALL MEMBERS ---
from flask import jsonify

@app.route('/api/business/members') # pixelwar members list
def get_discord_members():
    # 1. Config Check
    if not globals().get('GUILD_ID'): 
        return jsonify([])

    try:
        # Bot instance se guild fetch karo
        guild = bot.get_guild(int(GUILD_ID))
        
        if not guild: 
            print("âŒ Error: Bot server mein nahi hai ya GUILD_ID galat hai.")
            return jsonify([])
        
        # 2. Member Sync Logic (Logic Intact)
        members_list = []
        
        # Optimization: Discord cache se members uthao
        # Note: Bot settings mein 'Server Members Intent' ON hona chahiye
        for m in guild.members:
            if m.bot: continue # Bots ko list me mat dikhao
                
            # Online/Offline logic (100% Same)
            status = 'online' if str(m.status) != 'offline' else 'offline'
            
            # Avatar check (Premium UI support)
            avatar_url = m.display_avatar.url if m.display_avatar else "https://cdn.discordapp.com/embed/avatars/0.png"
            
            members_list.append({
                "id": str(m.id),
                "name": m.display_name, # display_name zyada accurate hota hai
                "avatar": avatar_url,
                "status": status
            })
            
            # Limit (100 players)
            if len(members_list) >= 100: 
                break 
        
        # 3. Alphabetical Sort (Bonus: Taki list organized dikhe)
        members_list = sorted(members_list, key=lambda x: x['status'] == 'offline')
                
        return jsonify(members_list)

    except Exception as e:
        print(f"Discord Member Sync Error: {e}")
        return jsonify([])


# --- API: INVITE PLAYER ---
import asyncio
from flask import session, request, jsonify
import discord

@app.route('/api/pixelwar/invite', methods=['POST'])
def invite_player():
    if 'user_info' not in session: 
        return jsonify({"status":"error", "msg": "Login Required"})
    
    data = request.json
    try:
        target_id = int(data.get('target_id'))
    except (ValueError, TypeError):
        return jsonify({"status":"error", "msg": "Invalid Target ID"})
        
    sender_name = session['user_info']['username']
    
    # Run async bot task safely in bot's loop
    try:
        if bot.is_ready():
            asyncio.run_coroutine_threadsafe(
                send_invite_msg(target_id, sender_name), 
                bot.loop
            )
            return jsonify({"status":"success", "msg": "Invite Sent to Discord!"})
        else:
            return jsonify({"status":"error", "msg": "Bot is not connected!"})
    except Exception as e:
        print(f"Invite Error: {e}")
        return jsonify({"status":"error", "msg": "Failed to send invite."})

# --- CONFIG ---
# Ye ID tumne jo di hai wahi rakhi hai
PIXEL_WAR_CHANNEL_ID = 1474247298576814134 

# --- BOT TASK: SEND INVITE (FIXED & SECURE) ---
async def send_invite_msg(target_id, sender_name):
    # Specific Channel fetch
    channel = bot.get_channel(PIXEL_WAR_CHANNEL_ID)
    
    if not channel:
        print(f"âŒ Error: Pixel War Channel ID ({PIXEL_WAR_CHANNEL_ID}) galat hai ya bot ko permission nahi hai.")
        return

    # Create Premium Embed (Logic Intact)
    embed = discord.Embed(
        title="âš”ï¸ PIXEL WAR RECRUITMENT", 
        description=f"**{sender_name}** needs backup on the grid! <@{target_id}>, you have been summoned.", 
        color=0x00f3ff
    )
    # Thumbnail logic
    embed.set_thumbnail(url="https://media.giphy.com/media/26tn33aiTi1jkl6H6/giphy.gif")
    embed.add_field(name="Mission Objective", value="Paint the map & dominate the server.", inline=False)
    embed.set_footer(text="Join the battle via the button below")
    
    # Button View (Logic Intact)
    view = discord.ui.View()
    # Your Website Link
    join_btn = discord.ui.Button(
        label="ğŸš€ JOIN WAR NOW", 
        url="https://testingbot-z0y6.onrender.com/games/pixelwar", 
        style=discord.ButtonStyle.link
    )
    view.add_item(join_btn)
    
    # Message Send with Ping
    try:
        await channel.send(
            content=f"<@{target_id}> ğŸš¨ **INCOMING TRANSMISSION!**", 
            embed=embed, 
            view=view
        )
    except Exception as e:
        print(f"âŒ Failed to send Discord Message: {e}")


# ==========================================
# ğŸ¦‘ DALGONA GAME PRO (REMASTERED)
# ================================
# PRICES & PRIZES REDUCED (Balanced)
DALGONA_LEVELS = {
    1: {"name": "Circle",    "fee": 500,     "prize": 1000,      "time": 60, "shape": "circle",    "width": 15},
    2: {"name": "Triangle",  "fee": 1000,    "prize": 2500,      "time": 55, "shape": "triangle",  "width": 14},
    3: {"name": "Square",    "fee": 2000,    "prize": 5000,      "time": 50, "shape": "square",    "width": 13},
    4: {"name": "Star",      "fee": 5000,    "prize": 12000,     "time": 45, "shape": "star",      "width": 12},
    5: {"name": "Umbrella",  "fee": 10000,   "prize": 25000,     "time": 40, "shape": "umbrella",  "width": 10},
    10:{"name": "NIGHTMARE", "fee": 50000,   "prize": 100000,   "time": 120,"shape": "nightmare", "width": 6} # â˜ ï¸ GOD LEVEL
}

import asyncio
from flask import session, redirect, render_template

@app.route('/games/dalgona')
def dalgona_page():
    # 1. Auth Check
    if 'user_info' not in session: 
        return redirect('/')
        
    user_id = session['user_info']['id']
    
    # 2. Titan-Grade Non-Blocking Fetch
    try:
        def fetch_dalgona_data():
            # Balance fetch logic
            return db.get_user_balance(user_id)
            
        balance = asyncio.run(db_call(lambda: fetch_dalgona_data()))
        
        # Safe fallback
        if balance is None:
            balance = 0
            
    except Exception as e:
        print(f"Dalgona Page Error (UID: {user_id}): {e}")
        balance = 0

    # 3. Render Template (100% Same Logic)
    # DALGONA_LEVELS config se uthayega (à¤œà¥ˆà¤¸à¥‡: Star, Circle, Umbrella, Triangle)
    levels = globals().get('DALGONA_LEVELS', {})
    
    return render_template('dalgona.html', 
                           user=session['user_info'], 
                           balance=balance, 
                           levels=levels)

import asyncio
import time
from flask import session, request, jsonify

@app.route('/api/dalgona/start', methods=['POST'])
def start_dalgona():
    if 'user_info' not in session: 
        return jsonify({"status":"error", "msg":"Login First"})
    
    user_id = session['user_info']['id']
    
    # 1. Level Validation (Logic Intact)
    try: 
        level = int(request.json.get('level'))
    except (ValueError, TypeError): 
        return jsonify({"status":"error", "msg":"Invalid Level selection"})

    # DALGONA_LEVELS config se level ka data uthao
    config = globals().get('DALGONA_LEVELS', {}).get(level)
    if not config: 
        return jsonify({"status":"error", "msg":"Level configuration not found"})
    
    # 2. Balance Check & Fee Deduction (Titan-Grade Non-Blocking)
    try:
        def execute_dalgona_start():
            # Current Balance Fetch
            bal = db.get_user_balance(user_id)
            if bal < config['fee']:
                return None, bal
            
            # Entry Fee Kato
            db.update_balance(user_id, -config['fee'])
            return True, bal - config['fee']

        success, new_bal = asyncio.run(db_call(lambda: execute_dalgona_start()))
        
        if success is None:
            return jsonify({"status":"error", "msg": f"Insufficient Funds! Need ${config['fee']:,}"})

    except Exception as e:
        print(f"Dalgona Start DB Error for UID {user_id}: {e}")
        return jsonify({"status":"error", "msg":"Bank is busy. Try again!"})
    
    # 3. âœ… NEW SESSION START (Overwrite Logic)
    # Purana session check hata diya gaya hai, ye sidha naya state set karega
    session['dalgona_active'] = True
    session['dalgona_level'] = level
    session['dalgona_start_time'] = time.time()
    
    # 4. Response (100% Same Logic)
    return jsonify({
        "status": "success",
        "time": config['time'],
        "shape": config['shape'],
        "width": config['width'],
        "new_balance": new_bal
    })



import asyncio
import time
from flask import session, request, jsonify

@app.route('/api/dalgona/finish', methods=['POST'])
async def finish_dalgona():
    if 'user_info' not in session: 
        return jsonify({"status":"error", "msg":"Login First"})
    
    user_id = session['user_info']['id']

    # 1. Security Check (100% Same Logic)
    if not session.get('dalgona_active'):
        return jsonify({"status":"error", "msg":"Cheating Detected! No active session."})
    
    level = session.get('dalgona_level')
    config = globals().get('DALGONA_LEVELS', {}).get(level)
    
    if not config:
        return jsonify({"status":"error", "msg":"Level data mismatch!"})
    
    # 2. Time Check (Bot Protection - Logic Intact)
    duration = time.time() - session.get('dalgona_start_time', 0)
    if duration < 3: # Insaan ko kam se kam 3 sec to lagenge
        session.pop('dalgona_active', None)
        return jsonify({"status":"error", "msg":"Too Fast! System detected bot behavior."})

    # 3. Give Prize & Sync Balance (Titan-Grade Non-Blocking)
    try:
        prize_amt = config['prize']
        
        def execute_dalgona_win():
            # Update balance with prize
            db.update_balance(user_id, prize_amt)
            # Fetch final updated balance
            return db.get_user_balance(user_id)

        new_bal = await db_call(lambda: execute_dalgona_win())
        
        # Game Khatam, Clear Session
        session.pop('dalgona_active', None)
        session.pop('dalgona_level', None)
        session.pop('dalgona_start_time', None)
        
        return jsonify({
            "status": "win",
            "prize": prize_amt,
            "new_balance": new_bal
        })

    except Exception as e:
        print(f"Dalgona Win Sync Error for UID {user_id}: {e}")
        return jsonify({"status":"error", "msg":"Prize sync failed. Admin will be notified."})

@app.route('/api/dalgona/fail', methods=['POST'])
def fail_dalgona():
    # Sirf session clear karne ke liye (Paise start me kat chuke hain - 100% Same Logic)
    session.pop('dalgona_active', None)
    session.pop('dalgona_level', None)
    session.pop('dalgona_start_time', None)
    
    return jsonify({"status":"ok", "msg": "Eliminated! Better luck next time."})

# ==========================================
# ğŸš€ CRASH GAME LOGIC & ROUTE (No Folders)
# ==========================================

# --- A. GAME VARIABLES ---

import random
import time
from threading import Thread
from flask import session, request, render_template, redirect, jsonify

# --- A. INITIAL STATE ---
crash_state = { 'status': 'WAITING', 'multiplier': 1.00, 'time_left': 8.0 }
crash_bets = {} 
crash_thread = None

# --- B. ENGINE (Optimized Logic) ---
def crash_engine():
    global crash_state, crash_bets
    while True:
        # 1. WAITING (8 Seconds)
        crash_state['status'] = 'WAITING'
        crash_state['multiplier'] = 1.00
        for i in range(80, 0, -1): 
            crash_state['time_left'] = i / 10
            socketio.emit('crash_update', crash_state)
            socketio.sleep(0.1)

        # 2. FLYING (Calculate Crash Point)
        crash_state['status'] = 'RUNNING'
        chance = random.random() * 100
        
        # --- âš–ï¸ REBALANCED ODDS (Fixing "Too Hard" Issue) ---
        if chance < 15: 
            limit = round(random.uniform(1.01, 1.20), 2)  # Instant Crash (Lekn kam baar hoga)
        elif chance < 60: 
            limit = round(random.uniform(1.21, 2.50), 2)  # Fair Game
        elif chance < 90: 
            limit = round(random.uniform(2.51, 5.00), 2)  # Good Win
        else: 
            limit = round(min(random.expovariate(0.3) + 5.0, 100.00), 2) # Jackpot
        
        start_time = time.time()
        while crash_state['multiplier'] < limit:
            elapsed = time.time() - start_time
            # ğŸ”¥ Smooth Curve Logic
            crash_state['multiplier'] = round(1.0 + (elapsed**2 / 10), 2)
            
            if crash_state['multiplier'] >= limit:
                crash_state['multiplier'] = limit
                socketio.emit('crash_update', crash_state)
                break
                
            socketio.emit('crash_update', crash_state)
            socketio.sleep(0.1)

        # 3. CRASHED (ğŸ’€ 10x Penalty Logic Intact)
        crash_state['status'] = 'CRASHED'
        socketio.emit('crash_update', crash_state)
        
        for sid, bet in list(crash_bets.items()):
            if not bet['cashed_out']:
                uid = bet['user_id']
                # 10 Guna nuksaan (Risk is Real!)
                penalty = bet['amount'] * 10 
                
                try:
                    def apply_crash_penalty():
                        curr = db.supabase.table("economy").select("balance").eq("user_id", str(uid)).execute().data[0]['balance']
                        new_bal = curr - penalty
                        db.supabase.table("economy").update({"balance": new_bal}).eq("user_id", str(uid)).execute()
                        return new_bal

                    # Titan-Grade DB Call
                    final_bal = asyncio.run(db_call(lambda: apply_crash_penalty()))
                    socketio.emit('balance_update', {'balance': final_bal}, to=sid)
                except Exception as e:
                    print(f"Crash Penalty Error: {e}")
        
        crash_bets = {} # Reset Bets
        socketio.sleep(4)

# --- C. ROUTE ---
@app.route('/games/crash')
def crash_game_page():
    if 'user_info' not in session: return redirect('/')
    
    global crash_thread
    if crash_thread is None or not crash_thread.is_alive():
        crash_thread = Thread(target=crash_engine)
        crash_thread.daemon = True
        crash_thread.start()

    user_id = session['user_info']['id']
    try:
        def fetch_crash_bal():
            return db.supabase.table("economy").select("balance").eq("user_id", str(user_id)).execute().data
        
        data = asyncio.run(db_call(lambda: fetch_crash_bal()))
        balance = data[0]['balance'] if data else 0
    except: balance = 0
    
    return render_template('crash.html', user=session['user_info'], balance=balance)

# --- D. SOCKET EVENTS (Secure Transactions) ---
@socketio.on('crash_bet')
def on_crash_bet(data):
    if crash_state['status'] != 'WAITING': 
        return socketio.emit('error', {'msg': 'Round already started!'}, to=request.sid)
    
    uid = session['user_info']['id']
    try:
        amt = int(data['amount'])
        if amt <= 0: return
    except: return
    
    def process_bet():
        curr_data = db.supabase.table("economy").select("balance").eq("user_id", str(uid)).execute().data
        if not curr_data or curr_data[0]['balance'] < amt: return None
        
        new_bal = curr_data[0]['balance'] - amt
        db.supabase.table("economy").update({"balance": new_bal}).eq("user_id", str(uid)).execute()
        return new_bal

    updated_bal = asyncio.run(db_call(lambda: process_bet()))
    
    if updated_bal is not None:
        crash_bets[request.sid] = {'user_id': uid, 'amount': amt, 'cashed_out': False}
        socketio.emit('bet_ok', {'amount': amt}, to=request.sid)
        socketio.emit('balance_update', {'balance': updated_bal}, to=request.sid)

@socketio.on('crash_cashout')
def on_crash_cashout():
    if crash_state['status'] == 'RUNNING' and request.sid in crash_bets:
        bet = crash_bets[request.sid]
        if not bet['cashed_out']:
            current_mult = crash_state['multiplier']
            win_amt = int(bet['amount'] * current_mult)
            
            def process_cashout():
                curr = db.supabase.table("economy").select("balance").eq("user_id", str(bet['user_id'])).execute().data[0]['balance']
                new_bal = curr + win_amt
                db.supabase.table("economy").update({"balance": new_bal}).eq("user_id", str(bet['user_id'])).execute()
                return new_bal

            final_bal = asyncio.run(db_call(lambda: process_cashout()))
            
            bet['cashed_out'] = True
            socketio.emit('cashout_ok', {'win': win_amt, 'multiplier': current_mult}, to=request.sid)
            socketio.emit('balance_update', {'balance': final_bal}, to=request.sid)


# ==========================================
# ğŸ° VIP ROULETTE (Fixed & Updated Route)
# ==========================================

# âœ… PAGE ROUTE
import asyncio
from flask import session, redirect, render_template

@app.route('/games/roulette')
def roulette_page():
    # 1. Auth Check (Same Logic)
    if 'user_info' not in session: 
        return redirect('/')
    
    uid = session['user_info']['id']
    
    # 2. Titan-Grade Non-Blocking Balance Fetch
    try:
        def fetch_roulette_bal():
            # Supabase call logic inside a safe function
            res = db.supabase.table("economy").select("balance").eq("user_id", uid).execute()
            return res.data[0]['balance'] if res.data else 0
            
        # Async execution to prevent thread blocking
        current_balance = asyncio.run(db_call(lambda: fetch_roulette_bal()))
        
        # Session update for UI consistency
        session['user_info']['balance'] = current_balance
        
    except Exception as e:
        print(f"Roulette Page Balance Error (UID: {uid}): {e}")
        current_balance = 0

    # 3. Render Template (100% Same Logic)
    return render_template('roulette.html', 
                           user=session['user_info'], 
                           balance=current_balance)



# ==========================================
# ğŸ° VIP ROULETTE API (Fixed Bet Costs)
# ==========================================

import asyncio
import random
from flask import request, jsonify

@app.route('/api/spin_roulette', methods=['POST'])
async def spin_roulette_api():
    try:
        data = request.json
        uid = str(data.get('uid'))
        bet_type = data.get('type')     # 'number' or 'color'
        bet_value = data.get('value')   # '14', 'red', 'black'
        
        # User input amount (Used for 'number' bets)
        try:
            input_amount = int(data.get('amount', 0))
        except:
            input_amount = 0

        # --- 1. CONFIGURATION (100% Same) ---
        RED_NUMS = [1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, 36]
        BLACK_NUMS = [2, 4, 6, 8, 10, 11, 13, 15, 17, 20, 22, 24, 26, 28, 29, 31, 33, 35]

        # --- 2. DETERMINE BET COST (Logic Intact) ---
        bet_cost = 0

        if bet_type == "color":
            if bet_value == "red":
                bet_cost = 500000  # ğŸ”¥ RED = 500k Fixed Cost
            elif bet_value == "black":
                bet_cost = 50000   # â™ ï¸ BLACK = 50k Fixed Cost
            else:
                return jsonify({"status": "error", "msg": "Invalid Color!"})
        
        elif bet_type == "number":
            bet_cost = input_amount
            if bet_cost <= 0:
                return jsonify({"status": "error", "msg": "Amount must be positive for number bets!"})
        else:
            return jsonify({"status": "error", "msg": "Invalid Bet Type!"})

        # --- 3. BALANCE CHECK & DEDUCTION (Titan-Grade Non-Blocking) ---
        try:
            def process_roulette_bet():
                # Fetch balance
                res = db.supabase.table("economy").select("balance").eq("user_id", uid).execute()
                if not res.data: return None
                
                bal = int(res.data[0]['balance'])
                if bal < bet_cost: return -1 # Insufficient
                
                # Deduct immediately
                new_b = bal - bet_cost
                db.supabase.table("economy").update({"balance": new_b}).eq("user_id", uid).execute()
                return new_b

            current_bal_after_deduction = await db_call(lambda: process_roulette_bet())
            
            if current_bal_after_deduction is None:
                return jsonify({"status": "error", "msg": "Account not found!"})
            if current_bal_after_deduction == -1:
                return jsonify({"status": "error", "msg": f"Garib! Need ${bet_cost:,} for this bet!"})

        except Exception as e:
            print(f"Roulette DB Error (Deduction): {e}")
            return jsonify({"status": "error", "msg": "Transaction Error. Try again!"})

        # --- 4. SPIN LOGIC ---
        landed_number = random.randint(0, 36)
        
        landed_color = "green"
        if landed_number in RED_NUMS: landed_color = "red"
        elif landed_number in BLACK_NUMS: landed_color = "black"

        # --- 5. WIN CALCULATION (100% Same Logic) ---
        win_amount = 0
        is_win = False
        message = f"Rolled {landed_number} ({landed_color.title()}). Better luck next time!"

        if bet_type == "number":
            try:
                if int(bet_value) == landed_number:
                    win_amount = bet_cost * 36
                    is_win = True
                    message = f"ğŸ¯ JACKPOT! Number {landed_number} Hit! Won ${win_amount:,}"
            except: pass

        elif bet_type == "color":
            if bet_value == "red" and landed_color == "red":
                win_amount = 1000000 # Win 1 Million
                is_win = True
                message = "ğŸ”¥ RED HIT! WON $1,000,000!"
            
            elif bet_value == "black" and landed_color == "black":
                win_amount = 100000 # Win 100k
                is_win = True
                message = "â™ ï¸ BLACK HIT! WON $100,000!"

        # --- 6. ADD WINNINGS & FINAL SYNC ---
        final_balance = current_bal_after_deduction
        
        if is_win:
            try:
                def add_roulette_winnings():
                    # Balance already deducted, just add the prize
                    new_b = current_bal_after_deduction + win_amount
                    db.supabase.table("economy").update({"balance": new_b}).eq("user_id", uid).execute()
                    return new_b

                final_balance = await db_call(lambda: add_roulette_winnings())
            except Exception as e:
                print(f"Roulette Win Add Error: {e}")
                return jsonify({"status": "error", "msg": "Win payout failed. Admin notified!"})

        return jsonify({
            "status": "success",
            "landed_number": landed_number,
            "landed_color": landed_color,
            "win_amount": win_amount,
            "new_balance": final_balance,
            "message": message,
            "is_win": is_win
        })

    except Exception as e:
        print(f"Global Roulette Error: {e}")
        return jsonify({"status": "error", "msg": "Server Error"})


# ================= ğŸ¦ ROBLOX BANKING ROUTE (ADDED TO EXISTING SERVER) =================
import asyncio
from flask import request, jsonify

@app.route('/roblox_pay', methods=['POST'])
def roblox_pay():
    try:
        # Flask se data lo
        data = request.json
        roblox_id = str(data.get("roblox_id"))
        
        print(f"ğŸ’° Roblox Transaction Request | Roblox ID: {roblox_id}")

        # 1. LINK CHECK (Bridge Logic: Roblox ID -> Discord ID)
        # Non-blocking fetch using asyncio and db_call
        def fetch_link_data():
            return db.supabase.table("access_users").select("discord_id").eq("user_id", roblox_id).execute().data
            
        user_res = asyncio.run(db_call(lambda: fetch_link_data()))
        
        if not user_res:
            return jsonify({"status": "error", "message": "User not linked! Please link your account on Discord first."}), 403
            
        discord_id = user_res[0]['discord_id']

        # 2. BALANCE & DEDUCTION LOGIC (Titan-Grade Execution)
        def execute_roblox_payment():
            # Balance check karo
            econ_res = db.supabase.table("economy").select("balance, bank").eq("user_id", discord_id).execute().data
            
            if not econ_res:
                return "no_account", None

            wallet = econ_res[0].get('balance', 0)
            bank = econ_res[0].get('bank', 0)
            net_worth = wallet + bank
            price = 1000000 # 1 Million Cost (Logic Intact)

            if net_worth >= price:
                # 3. DEDUCT MONEY LOGIC (100% Same Logic)
                if wallet >= price:
                    wallet -= price
                else:
                    remaining = price - wallet
                    wallet = 0
                    bank -= remaining

                # Database Update
                db.supabase.table("economy").update({
                    "balance": wallet, 
                    "bank": bank
                }).eq("user_id", discord_id).execute()
                
                return "success", {"wallet": wallet, "bank": bank}
            else:
                return "insufficient", net_worth

        # Execute Transaction
        status, result = asyncio.run(db_call(lambda: execute_roblox_payment()))

        if status == "success":
            print(f"âœ… 1M Deducted from {discord_id} (Linked to Roblox: {roblox_id})")
            return jsonify({"status": "success", "message": "Payment Approved", "new_stats": result}), 200
        elif status == "insufficient":
            print(f"âŒ Insufficient Funds for {discord_id}: Net Worth ${result:,}")
            return jsonify({"status": "fail", "message": "Insufficient Balance in Wallet & Bank"}), 200
        else:
            return jsonify({"status": "fail", "message": "No bank account found"}), 200

    except Exception as e:
        print(f"API Error in Roblox Bridge: {e}")
        return jsonify({"status": "error", "message": "Internal Server Error"}), 500


# -----------------------------------------------------------
# ğŸ‘‡ ISKE NICHE TUMHARA PURANA 'def run_server():' HOGA ğŸ‘‡


# --- 17. LOGOUT & RUN ---
@app.route('/logout')
def logout():
    session.clear()
    return redirect('/')


@app.route('/ping')
def ping_check():
    return jsonify({"status": "Alive"})

import asyncio
import random
import datetime as dt
from datetime import datetime, timedelta
from flask import request, jsonify
import discord

# âœ… PAGE ROUTE (Titan-Grade Optimized)
@app.route('/buy', methods=['POST'])
def buy_item():
    try:
        data = request.json
        uid = str(data.get('uid'))
        cid_from_web = data.get('cid') # Website se aayi channel ID
        item_id = data.get('item_id')

        # --- ğŸ¹ MULTI-CHANNEL SETUP (100% Same Logic) ---
        target_channels = []
        
        if cid_from_web and cid_from_web != "None" and cid_from_web != "":
            target_channels.append(cid_from_web)
            
        backup_log_id = "1474247298576814134" 
        if backup_log_id not in target_channels:
            target_channels.append(backup_log_id)
        
        # Assume SHOP_ITEMS is globally available
        item = SHOP_ITEMS.get(item_id)
        if not item: 
            return jsonify({"status": "error", "msg": "Invalid Item"})
        
        # 1. Fetch User Data (Non-Blocking)
        try:
            def fetch_buyer_data():
                return db.supabase.table("economy").select("*").eq("user_id", uid).execute().data
            
            res_data = asyncio.run(db_call(lambda: fetch_buyer_data()))
            if not res_data: 
                return jsonify({"status": "error", "msg": "Account Not Found! Use /balance first."})
            
            user_data = res_data[0]
        except Exception as e:
            print(f"Buy Fetch Error: {e}")
            return jsonify({"status": "error", "msg": "Database Lag! Try again."})

        old_bal = int(user_data.get('balance', 0))
        price = int(item['price'])
        
        # 2. Check Balance
        if old_bal < price:
            return jsonify({"status": "error", "msg": f"Garib! Need ${price - old_bal:,} more."})
        
        # 3. Process Transaction (Atomic Setup)
        new_bal = old_bal - price
        result_text = f"âœ… Bought {item['name']}"
        update_payload = {"balance": new_bal} # Ek hi baar update karenge
        
        # 4. Handle Item Logic (Lotto/Inventory/VIP)
        if item.get('type') == "lotto":
            if random.randint(1, 100) <= item.get('chance', 0):
                new_bal += item.get('win', 0)
                update_payload["balance"] = new_bal
                result_text = f"ğŸ‰ JACKPOT! Won ${item.get('win', 0):,}!"
            else:
                result_text = "ğŸ˜¢ Bad Luck! Better luck next time."
                
        elif item.get('type') == "item":
            inv = user_data.get('inventory') or {}
            inv[item_id] = inv.get(item_id, 0) + 1
            update_payload["inventory"] = inv
            
        elif item.get('type') == "vip":
            if item.get('life'): 
                expiry = "9999-12-31T23:59:59"
            else: 
                expiry = (datetime.utcnow() + timedelta(minutes=item.get('min', 0))).isoformat()
            update_payload["vip_expiry"] = expiry

        # 5. Execute DB Update Safely
        try:
            def save_purchase():
                db.supabase.table("economy").update(update_payload).eq("user_id", uid).execute()
            asyncio.run(db_call(lambda: save_purchase()))
        except Exception as e:
            print(f"Buy Save Error: {e}")
            return jsonify({"status": "error", "msg": "Transaction Failed. Funds Safe."})

        # 6. ğŸ“£ SEND LOGS TO ALL CHANNELS (Thread-safe)
        for channel_id in target_channels:
            asyncio.run_coroutine_threadsafe(
                handle_purchase_effects(uid, channel_id, item['name'], price, result_text, old_bal, new_bal), 
                bot.loop
            )
        
        return jsonify({"status": "success", "msg": result_text, "bal": new_bal})
        
    except Exception as e:
        print(f"Global Buy Error: {e}")
        return jsonify({"status": "error", "msg": "Server Error"})


# --- ğŸ› ï¸ DISCORD BACKGROUND TASK (100% SAME LOGIC, FIXED IMPORTS) ---
async def handle_purchase_effects(uid, cid, item_name, price, result_text, old_bal, new_bal):
    try:
        # 1. User & Channel Fetch
        try: 
            user = await bot.fetch_user(int(uid))
        except: 
            return

        channel = bot.get_channel(int(cid))
        if not channel: return
        guild = channel.guild
        
        # 2. Member Fetch
        try: 
            member = await guild.fetch_member(user.id)
        except: 
            await channel.send(f"âš ï¸ **Warning:** {user.name} server me nahi mila!")
            return

        # 3. ğŸ”¥ PREMIUM SHOP RECEIPT (Updated UI)
        embed = discord.Embed(title="ğŸ•µï¸ BLACK MARKET RECEIPT", color=0xFFD700) # Gold Color
        embed.set_author(name=f"Transaction: {user.name}", icon_url=user.display_avatar.url)
        embed.set_thumbnail(url="https://i.imgur.com/vHpxG5M.png") # Shop Icon
        
        embed.add_field(name="ğŸ“¦ Item Purchased", value=f"`{item_name}`", inline=True)
        embed.add_field(name="ğŸ’¸ Price Paid", value=f"`${price:,}`", inline=True)
        embed.add_field(name="ğŸ“ Status", value=f"**{result_text}**", inline=False)
        
        # Wallet Details
        embed.add_field(name="ğŸ’° Previous Balance", value=f"${old_bal:,}", inline=True)
        embed.add_field(name="ğŸ“‰ Current Balance", value=f"**${new_bal:,}**", inline=True)
        
        embed.set_footer(text=f"Buyer ID: {uid} â€¢ Verified Transaction", icon_url=guild.icon.url if guild.icon else None)
        await channel.send(embed=embed)

        # 4. Izzat Wapasi Logic
        if "Izzat" in item_name:
            try: await member.edit(nick=None)
            except: pass

        # --- ITEM DATA FETCH ---
        item_data = next((v for k, v in SHOP_ITEMS.items() if v.get("name") == item_name), None)

        # ====================================================
        # 5. ğŸ›¡ï¸ VERIFICATION SYSTEM
        # ====================================================
        if item_data and item_data.get('type') == 'verification':
            data = await get_data(uid)
            current_expiry_str = data.get('verify_expiry')
            duration = item_data.get('duration', 0)
            new_expiry = None
            expiry_msg = ""

            if duration == "perm":
                new_expiry = dt.datetime(9999, 12, 31)
                expiry_msg = "**â™¾ï¸ LIFETIME** (Amar ho gaye!)"
            else:
                if current_expiry_str and not current_expiry_str.startswith("9999"):
                    try:
                        current_dt = dt.datetime.fromisoformat(current_expiry_str)
                        if current_dt > dt.datetime.utcnow():
                            new_expiry = current_dt + dt.timedelta(seconds=duration)
                        else:
                            new_expiry = dt.datetime.utcnow() + dt.timedelta(seconds=duration)
                    except:
                        new_expiry = dt.datetime.utcnow() + dt.timedelta(seconds=duration)
                else:
                    new_expiry = dt.datetime.utcnow() + dt.timedelta(seconds=duration)
                expiry_msg = f"Valid till: `{new_expiry.strftime('%d %b %Y')}`"

            await db_call(lambda: db.supabase.table("economy").update({"verify_expiry": str(new_expiry)}).eq("user_id", str(uid)).execute())

            v_role = discord.utils.get(guild.roles, name="Verified")
            if not v_role: v_role = discord.utils.get(guild.roles, name="âœ… Verified")
            
            if v_role:
                try: await member.add_roles(v_role)
                except: pass
            await channel.send(f"âœ… **Verification Successful!**\nğŸ‘¤ {member.mention} is now Verified.\nğŸ“… {expiry_msg}")

        # ====================================================
        # 6. PREMIUM ROLES
        # ====================================================
        if item_data and item_data.get('type') == 'role':
            clean_name = item_name.split(" ", 1)[1].strip() if " " in item_name else item_name
            role_config = {
                "Hitman":         {"name": "ğŸ—¡ï¸ Hitman",         "color": 0x8B0000},
                "Hacker":         {"name": "ğŸ’» Hacker",         "color": 0x00FF00},
                "Gambler":        {"name": "ğŸ² Gambler",        "color": 0x9B59B6},
                "Peaky Blinders": {"name": "ğŸš¬ Peaky Blinders", "color": 0x2C3E50},
                "Yakuza":         {"name": "ğŸ‘¹ Yakuza",         "color": 0xFF0000},
                "Mafia Boss":     {"name": "ğŸ•¶ï¸ Mafia Boss",     "color": 0x010101},
                "Kingpin":        {"name": "ğŸ¦ Kingpin",        "color": 0xE67E22},
                "Oil Prince":     {"name": "ğŸ›¢ï¸ Oil Prince",     "color": 0xDAA520},
                "Server God":     {"name": "âš¡ Server God",     "color": 0xFFD700},
                "Immortal":       {"name": "ğŸ”® Immortal",       "color": 0x00FFFF},
            }

            if clean_name in role_config:
                target_role_name = role_config[clean_name]["name"]
                target_color_code = role_config[clean_name]["color"]
            else:
                target_role_name = item_name 
                target_color_code = random.randint(0, 0xFFFFFF)

            role = discord.utils.get(guild.roles, name=target_role_name)
            if not role:
                try:
                    role_color = discord.Color(target_color_code)
                    role = await guild.create_role(name=target_role_name, color=role_color, hoist=True, reason="Shop Premium Role")
                    await channel.send(f"ğŸ› ï¸ **Premium Role Created:** `{target_role_name}`")
                except: pass

            if role:
                try:
                    if role not in member.roles:
                        await member.add_roles(role)
                        await channel.send(f"ğŸ‰ **Role Equipped:** {member.mention} is now `{target_role_name}`!")
                except: pass

    except Exception as e:
        print(f"Effect Logic Error: {e}")

# ================== ğŸ® DISCORD COMMANDS ==================

# ==========================================
# ğŸ•µï¸ SUPER CHECK COMMAND (PREMIUM PROFILE)
# ==========================================
import discord
from discord.ext import commands
from discord import app_commands

@bot.tree.command(name="check", description="ğŸ•µï¸ View advanced empire stats, black money & heat level")
async def check(interaction: discord.Interaction, member: discord.Member = None):
    # 1. Defer the response (Titan-Grade Reliability)
    # Isse "Application did not respond" ka error kabhi nahi aayega
    await interaction.response.defer()

    # 2. Target Set Karo (Khud ka ya kisi aur ka)
    target = member or interaction.user
    user_id = str(target.id)

    # 3. Database Fetch (Non-Blocking / Atomic)
    try:
        def fetch_empire_data():
            return db.supabase.table("economy").select("*").eq("user_id", user_id).execute().data
            
        data = await db_call(lambda: fetch_empire_data())
    except Exception as e:
        print(f"Check Command Error: {e}")
        error_embed = discord.Embed(title="ğŸ”Œ System Glitch", description="Database connection unstable. Try again.", color=discord.Color.red())
        return await interaction.followup.send(embed=error_embed)

    if not data:
        embed = discord.Embed(
            title="ğŸ“‚ FILE NOT FOUND", 
            description=f"**{target.mention}** is a ghost. No empire records found in the Underworld database.", 
            color=0x2C3E50
        )
        return await interaction.followup.send(embed=embed)

    user_data = data[0]

    # 4. Data Parsing & Calculations (100% Same Logic)
    balance = user_data.get('balance', 0)
    dirty_money = user_data.get('dirty_money', 0)
    heat = user_data.get('heat', 0)
    bounty = user_data.get('head_bounty', 0)
    businesses = user_data.get('businesses') or {}
    
    # Global config se BUSINESSES uthao safe tareeke se
    biz_config = globals().get('BUSINESSES', {})
    
    # Empire Valuation Logic
    total_biz_stock = 0
    total_income_hr = 0
    biz_count = len(businesses)
    biz_names_list = []
    my_investors_count = 0

    for bid, bdata in businesses.items():
        total_biz_stock += bdata.get('stock', 0)
        
        # Income rate fetch from config
        if bid in biz_config:
            total_income_hr += biz_config[bid].get('income_per_hr', 0)
            biz_names_list.append(biz_config[bid].get('name', bid.title()))
        
        # Count my investors
        if 'investors' in bdata:
            my_investors_count += len(bdata['investors'])

    net_worth = balance + total_biz_stock + dirty_money

    # 5. ğŸ¨ ULTRA PREMIUM EMBED DESIGN
    embed = discord.Embed(
        title=f"ğŸ•´ï¸ ğš‚ğš„ğ™¿ğ™´ğš ğ™¿ğšğ™¾ğ™µğ™¸ğ™»ğ™´: {target.display_name.upper()}", 
        color=0xFFD700 # Premium Gold Color
    )
    
    # Avatar setup
    avatar_url = target.avatar.url if target.avatar else target.default_avatar.url
    embed.set_thumbnail(url=avatar_url)
    embed.set_author(name="Underworld Database Sync", icon_url="https://i.imgur.com/AfFp7pu.png")
    
    # --- A. FINANCIALS (Sleek YAML block) ---
    embed.add_field(
        name="ğŸ’³ __**FINANCIAL ASSETS**__",
        value=f"```yaml\nğŸ’° Clean Cash:   ${balance:,}\nğŸ§¼ Black Money:  ${dirty_money:,}\nğŸ¦ Biz Stock:    ${total_biz_stock:,}\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nğŸ’ NET WORTH:    ${net_worth:,}```",
        inline=False
    )

    # --- B. UNDERWORLD STATUS (Dynamic Heat Bar) ---
    heat_blocks = int(heat / 10)
    # Using slicker block emojis for a premium feel
    heat_bar = "ğŸŸ¥" * heat_blocks + "â¬›" * (10 - heat_blocks) 
    status_emoji = "ğŸŸ¢ SAFE" if heat < 30 else "ğŸŸ¡ WATCHED" if heat < 70 else "ğŸ”´ WANTED"
    
    embed.add_field(
        name="ğŸš¨ __**CRIMINAL RECORD**__",
        value=f"**Heat Level:** `{heat}%`\n{heat_bar}\n**Status:** {status_emoji}\n**ğŸ’€ Bounty:** `${bounty:,}`",
        inline=True
    )

    # --- C. EMPIRE STATS ---
    top_biz = biz_names_list[:3] 
    biz_display = ", ".join(top_biz) + ("..." if len(biz_names_list) > 3 else "") if biz_names_list else "No Assets"
    
    embed.add_field(
        name="ğŸ­ __**BUSINESS EMPIRE**__",
        value=f"**ğŸ¢ Facilities:** `{biz_count}`\n**ğŸ’¸ Income:** `${total_income_hr:,}/hr`\n**ğŸ‘¥ Investors:** `{my_investors_count} Active`\n**ğŸ—ï¸ Portfolio:** *{biz_display}*",
        inline=True
    )

    # Footer
    embed.set_footer(text="Quantum Economy Network â€¢ Restricted Access", icon_url=avatar_url)
    embed.timestamp = discord.utils.utcnow()

    # Send the final polished profile
    await interaction.followup.send(embed=embed)

# --- BUSINESS COMMAND ---
@bot.tree.command(name="business", description="Manage your GTA Empire (Passive Income)")
@check_seized()
async def business(interaction: discord.Interaction):
    biz_url = WEBSITE_URL + "/business"
    
    embed = discord.Embed(
        title="ğŸ­ Business Empire",
        description="Buy Weed Farms, Meth Labs, and more to earn Passive Income!",
        color=0x00ff00
    )
    
    view = discord.ui.View()
    button = discord.ui.Button(label="Manage Empire", style=discord.ButtonStyle.link, url=biz_url, emoji="ğŸ’¼")
    view.add_item(button)
    
    await interaction.response.send_message(embed=embed, view=view)

@bot.tree.command(name="menu", description="ğŸ›’ Open the Underground Black Market")
@check_seized()
async def menu_cmd(i: discord.Interaction):
    # ğŸ”— Configuration (As per your details)
    CLIENT_ID = "1451451135813746700" 
    REDIRECT_URI = "https://testingbot-8pb1.onrender.com/callback"
    
    # URL Encoding
    import urllib.parse
    encoded_redirect = urllib.parse.quote(REDIRECT_URI)
    
    # âœ¨ FIX: Added '&state={i.channel_id}' to track where the command was used
    # Isse login ke baad website ko pata chalega ki receipt kahan bhejni hai
    secure_url = f"https://discord.com/api/oauth2/authorize?client_id={CLIENT_ID}&redirect_uri={encoded_redirect}&response_type=code&scope=identify&state={i.channel_id}"
    
    # ğŸ¨ Detailed Premium Embed
    embed = discord.Embed(
        title="ğŸ•µï¸ GLOBAL BLACK MARKET ACCESS",
        description=(
            "Welcome to the high-security underground vault. "
            "Our market is now **OAuth2 Protected** for your account's safety.\n\n"
            "**â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”**"
        ),
        color=0xFFD700 # Gold Color
    )

    # Adding Details to make it look bigger/better
    embed.add_field(name="ğŸ“¦ Available Categories", value="â€¢ Special Items\nâ€¢ VIP Access\nâ€¢ Verification Badges\nâ€¢ Custom Roles\nâ€¢ Mega Lottery", inline=True)
    embed.add_field(name="ğŸ›¡ï¸ Security Level", value="**Level 4 Encrypted**\nAnonymous Trading\nInstant Delivery", inline=True)
    
    embed.add_field(name="âš ï¸ How to enter?", value="Click the button below and authorize your account to view your balance and start trading.", inline=False)
    
    embed.set_footer(text="Verified Underground Merchant â€¢ 2026", icon_url=i.user.display_avatar.url)
    embed.set_thumbnail(url="https://i.pinimg.com/originals/34/00/27/340027170a4877716f9f0945d8b7b25a.png") 
    
    # UI Button
    view = discord.ui.View()
    view.add_item(discord.ui.Button(
        label="ENTER THE MARKET", 
        url=secure_url, 
        style=discord.ButtonStyle.link, 
        emoji="ğŸ’³"
    ))
    
    # âœ… ephemeral=False (Ab sabko dikhega)
    await i.response.send_message(embed=embed, view=view, ephemeral=False)


import discord
from discord.ext import commands
from discord import app_commands
from datetime import datetime

@bot.tree.command(name="balance", description="ğŸ’° View Wallet, Bank & Inventory")
@check_seized() # Tumhara custom decorator safe hai
async def balance(interaction: discord.Interaction, user: discord.Member = None):
    # 1. Timeout Fix (Pehle hi response defer kar do)
    await interaction.response.defer() 

    try:
        target = user or interaction.user
        target_id = str(target.id)
        
        # 2. Fetch Data (Titan-Grade Non-Blocking & Auto-Create)
        def fetch_or_create_user():
            res = db.supabase.table("economy").select("*").eq("user_id", target_id).execute()
            
            if not res.data:
                # Naya account banao agar nahi hai
                new_user = {
                    "user_id": target_id, 
                    "balance": 0, 
                    "bank": 0, 
                    "inventory": {}
                }
                db.supabase.table("economy").insert(new_user).execute()
                return new_user
            return res.data[0]

        # Safe Async Database Call
        user_data = await db_call(lambda: fetch_or_create_user())
        
        # 3. Balance Calculation
        wallet = user_data.get('balance', 0)
        bank = user_data.get('bank', 0)
        net_worth = wallet + bank
        
        # 4. ğŸ¨ ULTRA PREMIUM EMBED SETUP
        embed = discord.Embed(
            title=f"ğŸ¦ ğš†ğ™´ğ™°ğ™»ğšƒğ™· ğšğ™´ğ™¶ğ™¸ğš‚ğšƒğšğšˆ: {target.display_name.upper()}", 
            color=0x2ECC71 # Default: Emerald Green (Money)
        )
        embed.set_thumbnail(url=target.avatar.url if target.avatar else target.default_avatar.url)
        
        # Sleek Financial Block
        finances = f"```yaml\nğŸ’³ Wallet:     ${wallet:,}\nğŸ¦ Bank:       ${bank:,}\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nğŸ’ NET WORTH:  ${net_worth:,}```"
        embed.add_field(name="ğŸ’° __**FINANCIAL SUMMARY**__", value=finances, inline=False)
        
        # 5. Inventory Logic (Protected & Polished)
        try:
            inv = user_data.get('inventory') or {}
            if not isinstance(inv, dict): inv = {} # Crash protection
            
            inv_text = ""
            global_shop = globals().get('SHOP_ITEMS', {})
            
            for k, v in inv.items():
                if v > 0:
                    # Naam dhoondne ki koshish, premium look ke sath
                    item_info = global_shop.get(k, {})
                    item_name = item_info.get('name', k.title())
                    inv_text += f"ğŸ”¸ **{item_name}** `x{v}`\n"
            
            if inv_text: 
                # Limit check (Discord max 1024 chars per field)
                if len(inv_text) > 1000:
                    inv_text = inv_text[:1000] + "...\n*And more...*"
                embed.add_field(name="ğŸ’ __**INVENTORY**__", value=inv_text, inline=False)
            else:
                embed.add_field(name="ğŸ’ __**INVENTORY**__", value="*Dust and cobwebs... (Empty)*", inline=False)
                
        except Exception as e:
            print(f"Inventory Error for {target.name}: {e}")
            embed.add_field(name="ğŸ’ __**INVENTORY**__", value="âš ï¸ *Encrypted or Corrupted*", inline=False)

        # 6. VIP Check (Premium Dynamic Color)
        try:
            vip_end = user_data.get('vip_expiry')
            # ISO format string comparison (Fast & Native)
            if vip_end and vip_end > datetime.utcnow().isoformat():
                embed.set_author(name="ğŸŒŸ VIP MEMBER", icon_url="https://i.imgur.com/vHpxG5M.png") # Gold Star Icon
                embed.color = 0xFFD700 # Color changes to Gold for VIPs!
        except Exception as e:
            print(f"VIP Error for {target.name}: {e}")

        # Final Touch: Footer
        embed.set_footer(text="Swiss Bank Server â€¢ Quantum Economy", icon_url="https://i.imgur.com/AfFp7pu.png")
        embed.timestamp = discord.utils.utcnow()

        await interaction.followup.send(embed=embed)

    except Exception as e:
        # YAHAN ASLI ERROR DIKHEGA (Safe Error Logging)
        print(f"âŒ CRITICAL BALANCE ERROR: {e}")
        await interaction.followup.send(f"âŒ **System Glitch Detected:**\n`{str(e)}`\n\n*(Take a screenshot and send it to the Developer)*", ephemeral=True)



import discord
from discord.ext import commands
from discord import app_commands

@bot.tree.command(name="deposit", description="ğŸ¦ Deposit money to your secure bank account")
@app_commands.describe(amount="Enter amount or type 'all' to deposit everything")
@check_seized() # Custom decorator safe hai
async def deposit(interaction: discord.Interaction, amount: str):
    # 1. Prevent Timeout (Titan-Grade)
    await interaction.response.defer()
    
    uid = str(interaction.user.id)
    
    try:
        # 2. Fetch Data Safely (Non-Blocking)
        def fetch_wallet():
            return db.supabase.table("economy").select("*").eq("user_id", uid).execute().data
            
        res_data = await db_call(lambda: fetch_wallet())
        
        if not res_data: 
            return await interaction.followup.send("âŒ **Ghost Account:** You don't have an account yet. Use `/balance` to create one.", ephemeral=True)
            
        d = res_data[0]
        current_wallet = int(d.get('balance', 0))
        current_bank = int(d.get('bank', 0))
        
        # 3. Smart Parsing Logic (100% Same but improved)
        if amount.lower() == "all": 
            amt = current_wallet
        else: 
            try: 
                # Remove commas if user typed like "5,000"
                amt = int(amount.replace(',', ''))
            except ValueError: 
                return await interaction.followup.send("âŒ **Invalid Input:** Please enter a valid number or type `all`.", ephemeral=True)
            
        # 4. Security Validations
        if amt <= 0: 
            return await interaction.followup.send("âŒ **Error:** You cannot deposit zero or negative amounts.", ephemeral=True)
        if current_wallet < amt: 
            return await interaction.followup.send(f"âŒ **Garib Detected!** You only have **${current_wallet:,}** in your wallet.", ephemeral=True)
        
        # 5. Atomic Math
        new_wallet = current_wallet - amt
        new_bank = current_bank + amt
        
        # 6. Execute DB Update Safely
        def save_deposit():
            db.supabase.table("economy").update({
                "balance": new_wallet, 
                "bank": new_bank
            }).eq("user_id", uid).execute()
            
        await db_call(lambda: save_deposit())
        
        # 7. ğŸ¨ ULTRA PREMIUM RECEIPT EMBED
        embed = discord.Embed(
            title="ğŸ¦ ğ™±ğ™°ğ™½ğ™º ğ™³ğ™´ğ™¿ğ™¾ğš‚ğ™¸ğšƒ ğš‚ğ™´ğ™²ğš„ğšğ™´ğ™³", 
            color=0x2ECC71 # Emerald Green for success
        )
        embed.set_author(name=f"Client: {interaction.user.display_name}", icon_url=interaction.user.display_avatar.url)
        embed.set_thumbnail(url="https://i.imgur.com/vHpxG5M.png") # Optional: Bank/Safe icon
        
        # YAML block for a highly professional look
        receipt = f"```yaml\nğŸ“¥ Amount Deposited: +${amt:,}\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nğŸ’³ New Wallet Bal:   ${new_wallet:,}\nğŸ¦ New Bank Bal:     ${new_bank:,}```"
        embed.add_field(name="ğŸ§¾ __**TRANSACTION RECEIPT**__", value=receipt, inline=False)
        
        embed.set_footer(text="Swiss Bank Server â€¢ Quantum Security", icon_url="https://i.imgur.com/AfFp7pu.png")
        embed.timestamp = discord.utils.utcnow()
        
        await interaction.followup.send(embed=embed)

    except Exception as e:
        print(f"Deposit Error for UID {uid}: {e}")
        await interaction.followup.send("âŒ **System Glitch:** Transaction failed. Your funds are safe in your wallet.", ephemeral=True)

import discord
from discord.ext import commands
from discord import app_commands

@bot.tree.command(name="withdraw", description="ğŸ§ Withdraw money from your secure bank account")
@app_commands.describe(amount="Enter amount or type 'all' to withdraw everything")
@check_seized() # Custom decorator safe hai
async def withdraw(interaction: discord.Interaction, amount: str):
    # 1. Prevent Timeout (Titan-Grade)
    await interaction.response.defer()
    
    uid = str(interaction.user.id)
    
    try:
        # 2. Fetch Data Safely (Non-Blocking)
        def fetch_bank_data():
            return db.supabase.table("economy").select("*").eq("user_id", uid).execute().data
            
        res_data = await db_call(lambda: fetch_bank_data())
        
        # Crash Fix: Account existence check
        if not res_data: 
            return await interaction.followup.send("âŒ **Ghost Account:** You don't have an account yet. Use `/balance` to create one.", ephemeral=True)
            
        d = res_data[0]
        current_wallet = int(d.get('balance', 0))
        current_bank = int(d.get('bank', 0))
        
        # 3. Smart Parsing Logic (Supports commas like "10,000")
        if amount.lower() == "all": 
            amt = current_bank
        else: 
            try: 
                amt = int(amount.replace(',', ''))
            except ValueError: 
                return await interaction.followup.send("âŒ **Invalid Input:** Please enter a valid number or type `all`.", ephemeral=True)
            
        # 4. Security Validations
        if amt <= 0: 
            return await interaction.followup.send("âŒ **Error:** You cannot withdraw zero or negative amounts.", ephemeral=True)
        if current_bank < amt: 
            return await interaction.followup.send(f"âŒ **Insufficient Funds!** You only have **${current_bank:,}** in your bank vault.", ephemeral=True)
        
        # 5. Atomic Math
        new_wallet = current_wallet + amt
        new_bank = current_bank - amt
        
        # 6. Execute DB Update Safely
        def save_withdrawal():
            db.supabase.table("economy").update({
                "balance": new_wallet, 
                "bank": new_bank
            }).eq("user_id", uid).execute()
            
        await db_call(lambda: save_withdrawal())
        
        # 7. ğŸ¨ ULTRA PREMIUM RECEIPT EMBED
        embed = discord.Embed(
            title="ğŸ§ ğ™±ğ™°ğ™½ğ™º ğš†ğ™¸ğšƒğ™·ğ™³ğšğ™°ğš†ğ™°ğ™» ğ™°ğ™¿ğ™¿ğšğ™¾ğš…ğ™´ğ™³", 
            color=0xF1C40F # Premium Gold color for cash out
        )
        embed.set_author(name=f"Client: {interaction.user.display_name}", icon_url=interaction.user.display_avatar.url)
        embed.set_thumbnail(url="https://i.imgur.com/vHpxG5M.png") # Optional: Bank/Safe icon
        
        # YAML block for a highly professional look
        receipt = f"```yaml\nğŸ“¤ Amount Withdrawn: -${amt:,}\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nğŸ’³ New Wallet Bal:   ${new_wallet:,}\nğŸ¦ New Bank Bal:     ${new_bank:,}```"
        embed.add_field(name="ğŸ§¾ __**TRANSACTION RECEIPT**__", value=receipt, inline=False)
        
        embed.set_footer(text="Swiss Bank Server â€¢ Quantum Security", icon_url="https://i.imgur.com/AfFp7pu.png")
        embed.timestamp = discord.utils.utcnow()
        
        await interaction.followup.send(embed=embed)

    except Exception as e:
        print(f"Withdraw Error for UID {uid}: {e}")
        await interaction.followup.send("âŒ **System Glitch:** Transaction failed. Your funds are safe in your vault.", ephemeral=True)


import discord
from discord.ext import commands
from discord import app_commands
import random

@bot.tree.command(name="rob", description="ğŸ”« Rob a rich user (Risky! Needs strategy)")
@check_seized()
@app_commands.checks.cooldown(1, 3600) # 1 Hour Cooldown
async def rob(interaction: discord.Interaction, victim: discord.Member):
    # 1. Basic Checks (Fast & Ephemeral)
    if interaction.user.id == victim.id or victim.bot: 
        return await interaction.response.send_message("âŒ **Error:** Khud ko ya Bots ko nahi loot sakte! Dimag lagao.", ephemeral=True)
    
    # 2. Prevent Timeout (Titan-Grade Defer)
    await interaction.response.defer()
    
    robber_id = str(interaction.user.id)
    victim_id = str(victim.id)

    try:
        # 3. Fetch Data Safely (Non-Blocking)
        def fetch_robbery_data():
            vic_res = db.supabase.table("economy").select("*").eq("user_id", victim_id).execute().data
            rob_res = db.supabase.table("economy").select("*").eq("user_id", robber_id).execute().data
            return vic_res, rob_res
            
        vic_data, rob_data = await db_call(lambda: fetch_robbery_data())
        
        # Check Account Existence
        if not vic_data: 
            return await interaction.followup.send(f"âŒ **Ghost Target:** {victim.mention} ke paas bank account hi nahi hai.")
        if not rob_data:
            return await interaction.followup.send(f"âŒ **Error:** Pehle apna underworld account banao (`/balance`).")

        vic = vic_data[0]
        robber = rob_data[0]
        vic_inv = vic.get('inventory') or {} 
        
        # 4. Strength & Minimum Balance Logic (100% Same)
        if robber.get('balance', 0) < 5000:
            return await interaction.followup.send(f"âš ï¸ **Too Poor:** {interaction.user.mention}, rob karne ke liye jeb mein kam se kam **$5,000** hone chahiye (Bail/Fine bharne ke liye)!")

        if vic.get('balance', 0) < 100000:
            return await interaction.followup.send(f"ğŸ›¡ï¸ **Safe Target:** {victim.name} ke paas $100k se kam hain. Itne chillar ke liye Police risk lena bekar hai.")

        # ==========================================
        # ğŸ’£ TRAP 1: LANDMINE (High Damage)
        # ==========================================
        if vic_inv.get('landmine', 0) > 0:
            fine = int(robber['balance'] * 0.3) # 30% Loss Logic
            
            def trigger_landmine():
                vic_inv['landmine'] -= 1
                db.supabase.table("economy").update({"inventory": vic_inv, "balance": vic['balance'] + fine}).eq("user_id", victim_id).execute()
                db.supabase.table("economy").update({"balance": robber['balance'] - fine}).eq("user_id", robber_id).execute()
                
            await db_call(lambda: trigger_landmine())
            
            # ğŸ’¥ PREMIUM EMBED: LANDMINE
            embed = discord.Embed(title="ğŸ’¥ ğ™ºğ™°ğ™±ğ™¾ğ™¾ğ™¼! ğ™»ğ™°ğ™½ğ™³ğ™¼ğ™¸ğ™½ğ™´ ğšƒğšğ™¸ğ™¶ğ™¶ğ™´ğšğ™´ğ™³", color=0xFF0000)
            embed.description = (
                f"ğŸ’€ **{interaction.user.mention}** ne chupke se ghar mein ghusne ki koshish ki aur **Landmine** uda diya!\n\n"
                f"```yaml\nğŸ¥ Hospital Bill: -${fine:,} (Paid to Target)\nğŸ›¡ï¸ Defense Used:  1x Landmine Destroyed```"
            )
            embed.set_thumbnail(url="https://cdn-icons-png.flaticon.com/512/4980/4980064.png")
            embed.set_image(url="https://media.tenor.com/2sEnpXg4w0QAAAAC/explosion-boom.gif")
            return await interaction.followup.send(embed=embed)

        # ==========================================
        # ğŸ“¹ TRAP 2: CCTV CAMERA (Caught & Exposed)
        # ==========================================
        if vic_inv.get('cctv', 0) > 0:
            fine = 10000 # Fixed 10k fine Logic
            new_bal = max(0, robber['balance'] - fine)
            
            def trigger_cctv():
                db.supabase.table("economy").update({"balance": new_bal}).eq("user_id", robber_id).execute()
                
            await db_call(lambda: trigger_cctv())
            
            # ğŸ“¸ PREMIUM EMBED: CCTV CAUGHT
            embed = discord.Embed(title="ğŸ“¹ ğ™²ğ™°ğš„ğ™¶ğ™·ğšƒ ğ™¸ğ™½ ğŸºğ™º!", color=0xFFA500)
            embed.description = (
                f"ğŸ‘® **Security Alert Tripped!**\n"
                f"**{interaction.user.mention}** ko **CCTV** ne high-res mein record kar liya!\n\n"
                f"```yaml\nğŸ“¸ Identity:   Exposed to Victim\nğŸ’¸ Police Fine: -$10,000```"
            )
            embed.set_thumbnail(url="https://cdn-icons-png.flaticon.com/512/3686/3686918.png")
            await interaction.followup.send(embed=embed)
            
            # ğŸ“© DM LOGIC (Send Proof to Victim safely)
            try:
                dm_embed = discord.Embed(title="ğŸš¨ HOME SECURITY ALERT", color=0xFF0000)
                dm_embed.description = (
                    f"âš ï¸ **Intruder Detected at your property!**\n\n"
                    f"ğŸ‘¤ **Robber:** {interaction.user.name} (ID: {interaction.user.id})\n"
                    f"ğŸ•’ **Time:** Just now\n"
                    f"âœ… **Status:** Robbery Prevented by your CCTV."
                )
                dm_embed.set_thumbnail(url="https://cdn-icons-png.flaticon.com/512/1166/1166469.png")
                await victim.send(embed=dm_embed)
            except:
                pass # Victim's DMs are closed, ignore gracefully
            return

        # ==========================================
        # ğŸ² ROBBERY ATTEMPT (RNG)
        # ==========================================
        success_chance = random.randint(1, 100)
        
        # 5. Success Logic (45% Chance - Harder Logic)
        if success_chance <= 45:
            loot = int(vic['balance'] * random.uniform(0.2, 0.5)) # 20-50% Loot Logic
            
            def process_success():
                db.supabase.table("economy").update({"balance": vic['balance'] - loot}).eq("user_id", victim_id).execute()
                db.supabase.table("economy").update({"balance": robber['balance'] + loot}).eq("user_id", robber_id).execute()
                
            await db_call(lambda: process_success())
            
            # ğŸ’° PREMIUM EMBED: SUCCESS
            embed = discord.Embed(title="ğŸ’° ğ™·ğ™´ğ™¸ğš‚ğšƒ ğš‚ğš„ğ™²ğ™²ğ™´ğš‚ğš‚ğ™µğš„ğ™»!", color=0xFFD700) # Gold
            embed.description = (
                f"ğŸ˜ˆ **Mission Passed!**\n"
                f"{interaction.user.mention} bypassed the security, looted **{victim.name}**, and escaped into the shadows!\n\n"
                f"```yaml\nğŸ’µ Stolen Amount: +${loot:,}\nğŸ”¥ Status:        Untraceable Ghost```"
            )
            embed.set_thumbnail(url="https://cdn-icons-png.flaticon.com/512/2953/2953363.png")
            embed.set_image(url="https://media.tenor.com/O6aTqJkK3hQAAAAC/robber-running.gif")
            await interaction.followup.send(embed=embed)
        
        # 6. Failed Logic (Police Catch - 55% Chance)
        else:
            fine = 5000
            
            def process_fail():
                db.supabase.table("economy").update({"balance": robber['balance'] - fine}).eq("user_id", robber_id).execute()
                
            await db_call(lambda: process_fail())
            
            # ğŸš” PREMIUM EMBED: FAILED
            embed = discord.Embed(title="ğŸš” ğ™±ğš„ğš‚ğšƒğ™´ğ™³! ğ™¿ğ™¾ğ™»ğ™¸ğ™²ğ™´ ğ™°ğšğšğ™´ğš‚ğšƒ", color=0x2f3136) # Dark Grey
            embed.description = (
                f"ğŸ‘® **Hands in the air!**\n"
                f"{interaction.user.mention} tripped the silent alarm while robbing **{victim.name}**.\n\n"
                f"```yaml\nâš–ï¸ Sentence:  Jail Time\nğŸ’¸ Bail Paid: -$5,000```"
            )
            embed.set_thumbnail(url="https://cdn-icons-png.flaticon.com/512/2504/2504660.png")
            await interaction.followup.send(embed=embed)

    except Exception as e:
        print(f"Robbery Error for UID {robber_id}: {e}")
        await interaction.followup.send("âŒ **System Glitch:** The matrix broke during your heist. Try again.")

# --- ERROR HANDLER (Titan-Grade Cooldown Look) ---
@rob.error
async def rob_error(interaction: discord.Interaction, error):
    if isinstance(error, app_commands.CommandOnCooldown):
        min_left = int(error.retry_after // 60)
        embed = discord.Embed(
            title="â³ ğ™¿ğ™¾ğ™»ğ™¸ğ™²ğ™´ ğ™·ğ™´ğ™°ğšƒ ğ™¸ğš‚ ğ™·ğ™¸ğ™¶ğ™·", 
            description=f"ğŸš¨ Cops are actively patrolling the area!\nLay low for **{min_left} minutes** before attempting another heist.", 
            color=0xE74C3C
        )
        embed.set_thumbnail(url="https://cdn-icons-png.flaticon.com/512/2504/2504660.png")
        await interaction.response.send_message(embed=embed, ephemeral=True)

import discord
from discord.ext import commands
from discord import app_commands

@bot.tree.command(name="add_money", description="ğŸ’¸ (Owner) Inject or Override funds in a user's account.")
@app_commands.describe(
    target="Kisko paise dene hain?", 
    amount="Kitna amount process karna hai?",
    action="Paise jodney (Add) hain ya exact set karne (Set) hain?",
    account="Paise Wallet mein daalne hain ya Bank mein?"
)
@app_commands.choices(action=[
    app_commands.Choice(name="â• Add Funds (Jodna)", value="add"),
    app_commands.Choice(name="ğŸ¯ Set Exact Balance (Override)", value="set")
])
@app_commands.choices(account=[
    app_commands.Choice(name="ğŸ’³ Wallet (Cash)", value="balance"),
    app_commands.Choice(name="ğŸ¦ Bank (Vault)", value="bank")
])
async def add_money(
    interaction: discord.Interaction, 
    target: discord.Member, 
    amount: int, 
    action: app_commands.Choice[str], 
    account: app_commands.Choice[str]
):
    
    # 1. OWNER CHECK (God Mode Security)
    if interaction.user.id != OWNER_ID:
        return await interaction.response.send_message("âŒ **Access Denied:** You do not have Central Bank clearance.", ephemeral=True)

    # Set command ke liye negative amount allow mat karo (Add me deduction ke liye -500 allowed hai)
    if amount < 0 and action.value == "set":
         return await interaction.response.send_message("âŒ **Error:** 'Set' action ke liye amount 0 ya positive hona chahiye!", ephemeral=True)

    # 2. Prevent Timeout
    await interaction.response.defer()

    try:
        target_id = str(target.id)
        acc_type = account.value     # 'balance' ya 'bank'
        act_type = action.value      # 'add' ya 'set'

        # 3. DATABASE OPERATION (Atomic & Non-Blocking)
        def process_admin_funds():
            # Fetch current balance
            res = db.supabase.table("economy").select("*").eq("user_id", target_id).execute().data
            
            if not res:
                # Naya account banao agar nahi hai
                new_bal = amount if act_type == "set" else amount
                new_data = {
                    "user_id": target_id, 
                    "balance": new_bal if acc_type == "balance" else 0, 
                    "bank": new_bal if acc_type == "bank" else 0,
                    "inventory": {}
                }
                db.supabase.table("economy").insert(new_data).execute()
                return 0, new_bal
            else:
                # Update existing account
                current_data = res[0]
                current_val = current_data.get(acc_type, 0)
                
                if act_type == "set":
                    new_val = amount
                else:
                    new_val = current_val + amount
                    
                db.supabase.table("economy").update({acc_type: new_val}).eq("user_id", target_id).execute()
                return current_val, new_val

        old_balance, new_balance = await db_call(lambda: process_admin_funds())

        # 4. ğŸ¨ ULTRA PREMIUM UI CONSTRUCTION
        embed = discord.Embed(
            title="ğŸ›ï¸ ğ™¶ğ™¾ğš…ğ™´ğšğ™½ğ™¼ğ™´ğ™½ğšƒ ğ™¾ğš…ğ™´ğšğšğ™¸ğ™³ğ™´ ğ™°ğ™¿ğ™¿ğšğ™¾ğš…ğ™´ğ™³", 
            color=0x00FF00 if act_type == "add" and amount > 0 else 0x3498DB, # Green for Add, Blue for Set
            timestamp=discord.utils.utcnow()
        )

        embed.set_author(name="CENTRAL BANK EXECUTIVE COMMAND", icon_url="https://cdn-icons-png.flaticon.com/512/2583/2583319.png")
        embed.set_thumbnail(url="https://media.tenor.com/Y81k5aaI_c8AAAAC/rich-money.gif")

        # Configuration Details
        embed.description = (
            f"**Authority:** {interaction.user.mention} *(Supreme Commander)*\n"
            f"**Target:** {target.mention}\n"
            f"**Destination:** {'ğŸ’³ Wallet' if acc_type == 'balance' else 'ğŸ¦ Bank'}\n"
            f"**Operation:** {'Injection (Add)' if act_type == 'add' else 'Override (Set)'}\n\n"
            "Official action ke tehat inke account mein funds modify kar diye gaye hain."
        )

        # Money Fields (YAML & Diff combo for max premium feel)
        sign = "+" if act_type == 'add' and amount >= 0 else ""
        action_text = f"Amount Added/Deducted" if act_type == 'add' else "Amount Forced To"
        
        embed.add_field(
            name=f"âš™ï¸ {action_text}",
            value=f"```diff\n{sign} ${amount:,}\n```",
            inline=False
        )

        embed.add_field(
            name="ğŸ’° Final Account Status",
            value=f"```yaml\nPrevious Balance: ${old_balance:,}\nUpdated Balance:  ${new_balance:,}```",
            inline=False
        )

        embed.set_footer(text="Secure Banking System | Audit Logged")

        await interaction.followup.send(embed=embed)

    except Exception as e:
        print(f"Error in Admin Funds: {e}")
        await interaction.followup.send(f"âŒ **Database Glitch:** `[Error Code: DB_SYNC_FAIL]`", ephemeral=True)

@bot.command()
@commands.is_owner() # Sirf aap hi ise use kar payenge
async def sync(ctx):
    try:
        # Global commands ko is server (guild) ke liye copy karega
        bot.tree.copy_global_to(guild=ctx.guild)
        synced = await bot.tree.sync(guild=ctx.guild)
        await ctx.send(f"âœ… Synced {len(synced)} commands instantly for this server!")
        print(f"Commands synced for: {ctx.guild.name}")
    except Exception as e:
        await ctx.send(f"âŒ Error: {e}")
        print(f"Sync error: {e}")

# ==========================================
# ğŸš€ FINAL STARTUP (File ka bilkul aakhri hissa)
# =========================================

# 1. Pinger (Bot ko sone nahi dega)
def self_ping():
    while True:
        try:
            # Apni khud ki site ko ping karega
            requests.get(f"{os.getenv('RENDER_URL', 'http://127.0.0.1:5000')}/", timeout=10)
        except:
            pass
        
        # ğŸ”¥ FIX: Yahan 'asyncio.sleep' ki jagah 'time.sleep' lagaya hai.
        # Ye thread ko 10 min rokega taaki CPU full na ho.
        time.sleep(600) 

# 2. Server Start (Port Fix ke saath)
def run_server():
    port = int(os.environ.get("PORT", 10000))
    # Threading mode me 'allow_unsafe_werkzeug=True' zaroori hai
    socketio.run(app, host='0.0.0.0', port=port, allow_unsafe_werkzeug=True)

# --- IMPORTANT: ADD GROUP TO BOT ---
# Ye line zarur add karna 'bot.run' se pehle!
try:
    bot.tree.add_command(titan_group)
except:
    pass

try:
    bot.tree.add_command(server_group) 
except:
    pass

try:
    bot.tree.add_command(games_group) 
except:
    pass

try:
    bot.tree.add_command(game_group) 
except:
    pass

try:
    bot.tree.add_command(roblox_group) 
except:
    pass
    

if __name__ == "__main__":
    # A. Website Start (Background Thread)
    t1 = threading.Thread(target=run_server, daemon=True)
    t1.start()
    
    # B. Pinger Start (Background Thread)
    t2 = threading.Thread(target=self_ping, daemon=True)
    t2.start()

    # C. Bot Start (Main Process)
    TOKEN = os.getenv("DISCORD_TOKEN")
    if not TOKEN:
        print("âŒ Error: DISCORD_TOKEN nahi mila environment me!")
    else:
        bot.run(TOKEN)